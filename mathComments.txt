文件路径: ./isl_ast_graft.c
注释行数: 3
注释内容:
/* Insert an if node around a copy of "data->node" testing the condition
 * encoded in guard "bset" and add the result to data->list.
 */
================================================================================

文件路径: ./isl_ast_graft.c
注释行数: 3
注释内容:
/* Insert an if node around graft->node testing the condition encoded
 * in guard "guard", assuming guard involves any conditions.
 */
================================================================================

文件路径: ./isl_ast_graft.c
注释行数: 3
注释内容:
/* Insert an if node around graft->node testing the condition encoded
 * in graft->guard, assuming graft->guard involves any conditions.
 */
================================================================================

文件路径: ./isl_ast_graft.c
注释行数: 2
注释内容:
/* Replace graft->enforced by "enforced".
 */
================================================================================

文件路径: ./isl_ast_graft.c
注释行数: 7
注释内容:
/* Merge "graft" into the last graft of "list".
 * body points to the then or else branch of an if node in that last graft.
 *
 * We attach graft->node to this branch and update the enforced
 * set of the last graft of "list" to take into account the enforced
 * set of "graft".
 */
================================================================================

文件路径: ./isl_ast_graft.c
注释行数: 3
注释内容:
/* Merge "graft" into the last graft of "list", attaching graft->node
 * to the then branch of "last_if".
 */
================================================================================

文件路径: ./isl_ast_graft.c
注释行数: 3
注释内容:
/* Merge "graft" into the last graft of "list", attaching graft->node
 * to the else branch of "last_if".
 */
================================================================================

文件路径: ./isl_ast_graft.c
注释行数: 16
注释内容:
/* For each graft in "list",
 * insert an if node around graft->node testing the condition encoded
 * in graft->guard, assuming graft->guard involves any conditions.
 *
 * We keep track of a list of generated if nodes that can be extended
 * without changing the order of the elements in "list".
 * If the guard of a graft is a subset of either the guard or its complement
 * of one of those if nodes, then the node
 * of the new graft is inserted into the then or else branch of the last graft
 * and the current graft is discarded.
 * The guard of the node is then simplified based on the conditions
 * enforced at that then or else branch.
 * Otherwise, the current graft is appended to the list.
 *
 * We only construct else branches if allowed by the user.
 */
================================================================================

文件路径: ./isl_ast_graft.c
注释行数: 5
注释内容:
/* For each graft in "list",
 * insert an if node around graft->node testing the condition encoded
 * in graft->guard, assuming graft->guard involves any conditions.
 * Subsequently remove the guards from the grafts.
 */
================================================================================

文件路径: ./isl_ast_graft.c
注释行数: 2
注释内容:
/* Insert a for node enclosing the current graft->node.
 */
================================================================================

文件路径: ./isl_ast_graft.c
注释行数: 2
注释内容:
/* Insert a mark governing the current graft->node.
 */
================================================================================

文件路径: ./isl_ast_graft.c
注释行数: 3
注释内容:
/* Record that the grafted tree enforces
 * "enforced" by intersecting graft->enforced with "enforced".
 */
================================================================================

文件路径: ./isl_ast_graft.c
注释行数: 14
注释内容:
/* Reformulate the "graft", which was generated in the context
 * of an inner code generation, in terms of the outer code generation
 * AST build.
 *
 * If "product" is set, then the domain of the inner code generation build is
 *
 *	[O -> S]
 *
 * with O the domain of the outer code generation build.
 * We essentially need to project out S.
 *
 * If "product" is not set, then we need to project the domains onto
 * their parameter spaces.
 */
================================================================================

文件路径: ./isl_local_space.c
注释行数: 11
注释内容:
/* Does the linear part of "constraint" correspond to
 * integer division "div" in "ls"?
 *
 * That is, given div = floor((c + f)/m), is the constraint of the form
 *
 *		f - m d + c' >= 0		[sign = 1]
 * or
 *		-f + m d + c'' >= 0		[sign = -1]
 * ?
 * If so, set *sign to the corresponding value.
 */
================================================================================

文件路径: ./isl_local_space.c
注释行数: 12
注释内容:
/* Check if the constraints pointed to by "constraint" is a div
 * constraint corresponding to div "div" in "ls".
 *
 * That is, if div = floor(f/m), then check if the constraint is
 *
 *		f - m d >= 0
 * or
 *		-(f-(m-1)) + m d >= 0
 *
 * First check if the linear part is of the right form and
 * then check the constant term.
 */
================================================================================

文件路径: ./isl_local_space.c
注释行数: 15
注释内容:
/* Is the constraint pointed to by "constraint" one
 * of an equality that corresponds to integer division "div" in "ls"?
 *
 * That is, given an integer division of the form
 *
 *	a = floor((f + c)/m)
 *
 * is the equality of the form
 *
 *		-f + m d + c' = 0
 * ?
 * Note that the constant term is not checked explicitly, but given
 * that this is a valid equality constraint, the constant c' necessarily
 * has a value close to -c.
 */
================================================================================

文件路径: ./isl_local_space.c
注释行数: 5
注释内容:
/* Given a local space "ls" of a set, create a local space
 * for the lift of the set.  In particular, the result
 * is of the form [dim -> local[..]], with ls->div->n_row variables in the
 * range of the wrapped map.
 */
================================================================================

文件路径: ./isl_local_space.c
注释行数: 19
注释内容:
/* Compute the preimage of "ls" under the function represented by "ma".
 * In other words, plug in "ma" in "ls".  The result is a local space
 * that is part of the domain space of "ma".
 *
 * If the divs in "ls" are represented as
 *
 *	floor((a_i(p) + b_i x + c_i(divs))/n_i)
 *
 * and ma is represented by
 *
 *	x = D(p) + F(y) + G(divs')
 *
 * then the resulting divs are
 *
 *	floor((a_i(p) + b_i D(p) + b_i F(y) + B_i G(divs') + c_i(divs))/n_i)
 *
 * We first copy over the divs from "ma" and then
 * we add the modified divs from "ls".
 */
================================================================================

文件路径: ./isl_ilp.c
注释行数: 3
注释内容:
/* Update the optimum in data->res with respect to the affine function
 * "aff" defined over "set".
 */
================================================================================

文件路径: ./isl_ilp.c
注释行数: 2
注释内容:
/* Update the optimum in data->res with the optimum of "pa".
 */
================================================================================

文件路径: ./isl_test.c
注释行数: 3
注释内容:
/*
	assert(bset && bset->n_div == 1);
	*/
================================================================================

文件路径: ./isl_test.c
注释行数: 3
注释内容:
/*
	assert(bset && bset->n_div == 1);
	*/
================================================================================

文件路径: ./isl_test.c
注释行数: 7
注释内容:
/* Check that isl_set_is_subset is not confused by identical
 * integer divisions.
 * The call to isl_set_normalize ensures that the equality constraints
 * a = b = 0 are discovered, turning e0 and e1 into identical
 * integer divisions.  Any further simplification would remove
 * the duplicate integer divisions.
 */
================================================================================

文件路径: ./isl_test.c
注释行数: 7
注释内容:
/* Check that conditional validity constraints are also taken into
 * account across bands.
 * In particular, try to make sure that live ranges D[1,0]->C[2,1] and
 * D[2,0]->C[3,0] are not local in the outer band of the generated schedule
 * and then check that the adjacent order constraint C[2,1]->D[2,0]
 * is enforced by the rest of the schedule.
 */
================================================================================

文件路径: ./isl_test.c
注释行数: 8
注释内容:
/* Check that the scheduler does not perform any needless
 * compound skewing.  Earlier versions of isl would compute
 * schedules in terms of transformed schedule coefficients and
 * would not accurately keep track of the sum of the original
 * schedule coefficients.  It could then produce the schedule
 * S[t,i,j,k] -> [t, 2t + i, 2t + i + j, 2t + i + j + k]
 * for the input below instead of the schedule below.
 */
================================================================================

文件路径: ./isl_test.c
注释行数: 2
注释内容:
/* Check that "vertex" corresponds to one of the vertices in data->vertex.
 */
================================================================================

文件路径: ./isl_test.c
注释行数: 11
注释内容:
/* Check that the expression
 *
 *	[n] -> { [n/2] : n <= 0 and n % 2 = 0; [0] : n > 0 }
 *
 * is not combined into
 *
 *	min(n/2, 0)
 *
 * as this would result in n/2 being evaluated in parts of
 * the definition domain where n is not a multiple of 2.
 */
================================================================================

文件路径: ./isl_schedule_constraints.c
注释行数: 21
注释内容:
/* The constraints that need to be satisfied by a schedule on "domain".
 *
 * "context" specifies extra constraints on the parameters.
 *
 * "validity" constraints map domain elements i to domain elements
 * that should be scheduled after i.  (Hard constraint)
 * "proximity" constraints map domain elements i to domains elements
 * that should be scheduled as early as possible after i (or before i).
 * (Soft constraint)
 *
 * "condition" and "conditional_validity" constraints map possibly "tagged"
 * domain elements i -> s to "tagged" domain elements j -> t.
 * The elements of the "conditional_validity" constraints, but without the
 * tags (i.e., the elements i -> j) are treated as validity constraints,
 * except that during the construction of a tilable band,
 * the elements of the "conditional_validity" constraints may be violated
 * provided that all adjacent elements of the "condition" constraints
 * are local within the band.
 * A dependence is local within a band if domain and range are mapped
 * to the same schedule point by the band.
 */
================================================================================

文件路径: ./isl_schedule_constraints.c
注释行数: 15
注释内容:
/* Apply "umap" to the domains of the wrapped relations
 * inside the domain and range of "c".
 *
 * That is, for each map of the form
 *
 *	[D -> S] -> [E -> T]
 *
 * in "c", apply "umap" to D and E.
 *
 * D is exposed by currying the relation to
 *
 *	D -> [S -> [E -> T]]
 *
 * E is exposed by doing the same to the inverse of "c".
 */
================================================================================

文件路径: ./isl_bind_domain_templ.c
注释行数: 10
注释内容:
/* Given a function living in a space of the form [A -> B] -> C and
 * a tuple of identifiers in A, bind the domain dimensions of the relation
 * wrapped in the domain of "obj" with identifiers specified by "tuple",
 * returning a function in the space B -> C.
 *
 * If no parameters with these identifiers appear in "obj" already,
 * then the domain dimensions are simply reinterpreted as parameters.
 * Otherwise, the parameters are first equated to the corresponding
 * domain dimensions.
 */
================================================================================

文件路径: ./isl_test_int.c
注释行数: 3
注释内容:
/* Use a triple that satisfies 'product = factor1 * factor2' to check the
 * operations mul, divexact, tdiv, fdiv and cdiv.
 */
================================================================================

文件路径: ./isl_test_int.c
注释行数: 3
注释内容:
/* Use a triple that satisfies 'sum = term1 + term2' to check the operations add
 * and sub.
 */
================================================================================

文件路径: ./isl_ast.c
注释行数: 2
注释内容:
/* Replace node->annotation by "annotation".
 */
================================================================================

文件路径: ./isl_ast.c
注释行数: 18
注释内容:
/* Do we need/want parentheses around "expr" as a subexpression of
 * an "op" operation?  If "left" is set, then "expr" is the left-most
 * operand.
 *
 * We only need parentheses if "expr" represents an operation.
 *
 * If op has a higher precedence than expr->u.op.op, then we need
 * parentheses.
 * If op and expr->u.op.op have the same precedence, but the operations
 * are performed in an order that is different from the associativity,
 * then we need parentheses.
 *
 * An and inside an or technically does not require parentheses,
 * but some compilers complain about that, so we add them anyway.
 *
 * Computations such as "a / b * c" and "a % b + c" can be somewhat
 * difficult to read, so we add parentheses for those as well.
 */
================================================================================

文件路径: ./isl_ast.c
注释行数: 20
注释内容:
/* Print the body "node" of a for or if node.
 * If "else_node" is set, then it is printed as well.
 * If "force_block" is set, then print out the body as a block.
 *
 * We first check if we need to print out a block.
 * We always print out a block if there is an else node to make
 * sure that the else node is matched to the correct if node.
 * For consistency, the corresponding else node is also printed as a block.
 *
 * If the else node is itself an if, then we print it as
 *
 *	} else if (..) {
 *	}
 *
 * Otherwise the else node is printed as
 *
 *	} else {
 *	  node
 *	}
 */
================================================================================

文件路径: ./isl_ast.c
注释行数: 19
注释内容:
/* Print the for node "node".
 *
 * If the for node is degenerate, it is printed as
 *
 *	type iterator = init;
 *	body
 *
 * Otherwise, it is printed as
 *
 *	for (type iterator = init; cond; iterator += inc)
 *		body
 *
 * "in_block" is set if we are currently inside a block.
 * "in_list" is set if the current node is not alone in the block.
 * If we are not in a block or if the current not is not alone in the block
 * then we print a block around a degenerate for loop such that the variable
 * declaration will not conflict with any potential other declaration
 * of the same variable.
 */
================================================================================

文件路径: ./isl_ast_build.c
注释行数: 2
注释内容:
/* Replace build->options by "options".
 */
================================================================================

文件路径: ./isl_ast_build.c
注释行数: 6
注释内容:
/* Clear build->schedule_map.
 * This function should be called whenever anything that might affect
 * the result of isl_ast_build_get_schedule_map_multi_aff changes.
 * In particular, it should be called when the depth is changed or
 * when an iterator is determined to have a fixed value.
 */
================================================================================

文件路径: ./isl_ast_build.c
注释行数: 5
注释内容:
/* Initialize "build" for AST construction in schedule space "space"
 * in the case that build->domain is a parameter set.
 *
 * build->iterators is assumed to have been updated already.
 */
================================================================================

文件路径: ./isl_ast_build.c
注释行数: 31
注释内容:
/* Update the AST build based on the given loop bounds for
 * the current dimension and the stride information available in the build.
 *
 * We first make sure that the bounds do not refer to any iterators
 * that have already been eliminated.
 * Then, we check if the bounds imply that the current iterator
 * has a fixed value.
 * If they do and if this fixed value can be expressed as a single
 * affine expression, we eliminate the iterators from the bounds.
 * Note that we cannot simply plug in this single value using
 * isl_basic_set_preimage_multi_aff as the single value may only
 * be defined on a subset of the domain.  Plugging in the value
 * would restrict the build domain to this subset, while this
 * restriction may not be reflected in the generated code.
 * Finally, we intersect build->domain with the updated bounds.
 * We also add the stride constraint unless we have been able
 * to find a fixed value expressed as a single affine expression.
 *
 * Note that the check for a fixed value in update_values requires
 * us to intersect the bounds with the current build domain.
 * When we intersect build->domain with the updated bounds in
 * the final step, we make sure that these updated bounds have
 * not been intersected with the old build->domain.
 * Otherwise, we would indirectly intersect the build domain with itself,
 * which can lead to inefficiencies, in particular if the build domain
 * contains any unknown divs.
 *
 * The pending and generated sets are not updated by this function to
 * match the updated domain.
 * The caller still needs to call isl_ast_build_set_pending_generated.
 */
================================================================================

文件路径: ./isl_ast_build.c
注释行数: 3
注释内容:
/* Intersect build->domain with "set", where "set" is specified
 * in terms of the internal schedule domain.
 */
================================================================================

文件路径: ./isl_ast_build.c
注释行数: 3
注释内容:
/* Intersect build->generated and build->domain with "set",
 * where "set" is specified in terms of the internal schedule domain.
 */
================================================================================

文件路径: ./isl_ast_build.c
注释行数: 3
注释内容:
/* Intersect build->domain with "set", where "set" is specified
 * in terms of the external schedule domain.
 */
================================================================================

文件路径: ./isl_ast_build.c
注释行数: 2
注释内容:
/* Replace build->executed by "executed".
 */
================================================================================

文件路径: ./isl_ast_build.c
注释行数: 3
注释内容:
/* Extract the loop AST generation types for the members of build->node
 * and store them in build->loop_type.
 */
================================================================================

文件路径: ./isl_ast_build.c
注释行数: 3
注释内容:
/* Add constraints corresponding to any previously detected
 * stride on the current dimension to build->domain.
 */
================================================================================

文件路径: ./isl_ast_build.c
注释行数: 2
注释内容:
/* Does "map" not involve the input dimension data->depth?
 */
================================================================================

文件路径: ./isl_ast_build.c
注释行数: 6
注释内容:
/* Construct the map
 *
 *	{ [i] -> [i] : i < pos; [i] -> [i + 1] : i >= pos }
 *
 * with "space" the parameter space of the constructed map.
 */
================================================================================

文件路径: ./isl_ast_build.c
注释行数: 21
注释内容:
/* Update the "options" to reflect the insertion of a dimension
 * at position "pos" in the schedule domain space.
 * "space" is the original domain space before the insertion and
 * may be named and/or structured.
 *
 * The (relevant) input options all have "space" as domain, which
 * has to be mapped to the extended space.
 * The values of the ranges also refer to the schedule domain positions
 * and they therefore also need to be adjusted.  In particular, values
 * smaller than pos do not need to change, while values greater than or
 * equal to pos need to be incremented.
 * That is, we need to apply the following map.
 *
 *	{ atomic[i] -> atomic[i] : i < pos; [i] -> [i + 1] : i >= pos;
 *	  unroll[i] -> unroll[i] : i < pos; [i] -> [i + 1] : i >= pos;
 *	  separate[i] -> separate[i] : i < pos; [i] -> [i + 1] : i >= pos;
 *	  separation_class[[i] -> [c]]
 *		-> separation_class[[i] -> [c]] : i < pos;
 *	  separation_class[[i] -> [c]]
 *		-> separation_class[[i + 1] -> [c]] : i >= pos }
 */
================================================================================

文件路径: ./isl_ast_build.c
注释行数: 7
注释内容:
/* If we are generating an AST from a schedule tree (build->node is set),
 * then update the loop AST generation types
 * to reflect the insertion of a dimension at (global) position "pos"
 * in the schedule domain space.
 * We do not need to adjust any isolate option since we would not be inserting
 * any dimensions if there were any isolate option.
 */
================================================================================

文件路径: ./isl_ast_build.c
注释行数: 18
注释内容:
/* Insert a single dimension in the schedule domain at position "pos".
 * The new dimension is given an isl_id with the empty string as name.
 *
 * The main difficulty is updating build->options to reflect the
 * extra dimension.  This is handled in options_insert_dim.
 *
 * Note that because of the dimension manipulations, the resulting
 * schedule domain space will always be unnamed and unstructured.
 * However, the original schedule domain space may be named and/or
 * structured, so we have to take this possibility into account
 * while performing the transformations.
 *
 * Since the inserted schedule dimension is used by the caller
 * to differentiate between different domain spaces, there is
 * no longer a uniform mapping from the internal schedule space
 * to the input schedule space.  The internal2input mapping is
 * therefore removed.
 */
================================================================================

文件路径: ./isl_ast_build.c
注释行数: 15
注释内容:
/* Scale down the current dimension by a factor of "m".
 * "umap" is an isl_union_map that implements the scaling down.
 * That is, it is of the form
 *
 *	{ [.... i ....] -> [.... i' ....] : i = m i' }
 *
 * This function is called right after the strides have been
 * detected, but before any constraints on the current dimension
 * have been included in build->domain.
 * We therefore only need to update stride, offset, the options and
 * the mapping from internal schedule space to the original schedule
 * space, if we are still keeping track of such a mapping.
 * The latter mapping is updated by plugging in
 * { [... i ...] -> [... m i ... ] }.
 */
================================================================================

文件路径: ./isl_ast_build.c
注释行数: 24
注释内容:
/* Embed "options" into the given isl_ast_build space.
 *
 * This function is called from within a nested call to
 * isl_ast_build_node_from_schedule_map.
 * "options" refers to the additional schedule,
 * while space refers to both the space of the outer isl_ast_build and
 * that of the additional schedule.
 * Specifically, space is of the form
 *
 *	[I -> S]
 *
 * while options lives in the space(s)
 *
 *	S -> *
 *
 * We compute
 *
 *	[I -> S] -> S
 *
 * and compose this with options, to obtain the new options
 * living in the space(s)
 *
 *	[I -> S] -> *
 */
================================================================================

文件路径: ./isl_ast_build.c
注释行数: 3
注释内容:
/* Does "aff" only attain non-negative values over build->domain?
 * That is, does it not attain any negative values?
 */
================================================================================

文件路径: ./isl_ast_build.c
注释行数: 9
注释内容:
/* Is the dimension at position "pos" known to attain only a single
 * value that, moreover, can be described by a single affine expression
 * in terms of the outer dimensions and parameters?
 *
 * If not, then the corresponding affine expression in build->values
 * is set to be equal to the same input dimension.
 * Otherwise, it is set to the requested expression in terms of
 * outer dimensions and parameters.
 */
================================================================================

文件路径: ./isl_ast_build.c
注释行数: 6
注释内容:
/* Plug in the known values (fixed affine expressions in terms of
 * parameters and outer loop iterators) of all loop iterators
 * in the domain of "umap".
 *
 * We simply precompose "umap" with build->values.
 */
================================================================================

文件路径: ./isl_ast_build.c
注释行数: 8
注释内容:
/* Include information about what we know about the iterators of
 * already generated loops to "set".
 *
 * We currently only plug in the known affine values of outer loop
 * iterators.
 * In principle we could also introduce equalities or even other
 * constraints implied by the intersection of "set" and build->domain.
 */
================================================================================

文件路径: ./isl_ast_build.c
注释行数: 17
注释内容:
/* Extract the isolated set from the isolate option, if any,
 * and store in the build.
 * If there is no isolate option, then the isolated set is
 * set to the empty set.
 *
 * The isolate option is of the form
 *
 *	isolate[[outer bands] -> current_band]
 *
 * We flatten this set and then map it back to the internal
 * schedule space.
 *
 * If we have already extracted the isolated set
 * or if internal2input is no longer set, then we do not
 * need to do anything.  In the latter case, we know
 * that the current band cannot have any isolate option.
 */
================================================================================

文件路径: ./isl_ast_build.c
注释行数: 2
注释内容:
/* Replace build->single_valued by "sv".
 */
================================================================================

文件路径: ./isl_ast_build_expr.c
注释行数: 20
注释内容:
/* Given the numerator "aff" of the argument of an integer division
 * with denominator "d", check if it can be made non-negative over
 * data->build->domain by stealing part of the constant term of
 * the expression in which the integer division appears.
 *
 * In particular, the outer expression is of the form
 *
 *	v * floor(aff/d) + cst
 *
 * We already know that "aff" itself may attain negative values.
 * Here we check if aff + d*floor(cst/v) is non-negative, such
 * that we could rewrite the expression to
 *
 *	v * floor((aff + d*floor(cst/v))/d) + cst - v*floor(cst/v)
 *
 * Note that aff + d*floor(cst/v) can only possibly be non-negative
 * if data->cst and data->v have the same sign.
 * Similarly, if floor(cst/v) is zero, then there is no point in
 * checking again.
 */
================================================================================

文件路径: ./isl_ast_build_expr.c
注释行数: 26
注释内容:
/* Given the numerator "aff' of the argument of an integer division
 * with denominator "d", steal part of the constant term of
 * the expression in which the integer division appears to make it
 * non-negative over data->build->domain.
 *
 * In particular, the outer expression is of the form
 *
 *	v * floor(aff/d) + cst
 *
 * We know that "aff" itself may attain negative values,
 * but that aff + d*floor(cst/v) is non-negative.
 * Find the minimal positive value that we need to add to "aff"
 * to make it positive and adjust data->cst accordingly.
 * That is, compute the minimal value "m" of "aff" over
 * data->build->domain and take
 *
 *	s = ceil(m/d)
 *
 * such that
 *
 *	aff + d * s >= 0
 *
 * and rewrite the expression to
 *
 *	v * floor((aff + s*d)/d) + (cst - v*s)
 */
================================================================================

文件路径: ./isl_ast_build_expr.c
注释行数: 34
注释内容:
/* Create an isl_ast_expr evaluating the div at position "pos" in "ls".
 * The result is simplified in terms of data->build->domain.
 * This function may change (the sign of) data->v.
 *
 * "ls" is known to be non-NULL.
 *
 * Let the div be of the form floor(e/d).
 * If the ast_build_prefer_pdiv option is set then we check if "e"
 * is non-negative, so that we can generate
 *
 *	(pdiv_q, expr(e), expr(d))
 *
 * instead of
 *
 *	(fdiv_q, expr(e), expr(d))
 *
 * If the ast_build_prefer_pdiv option is set and
 * if "e" is not non-negative, then we check if "-e + d - 1" is non-negative.
 * If so, we can rewrite
 *
 *	floor(e/d) = -ceil(-e/d) = -floor((-e + d - 1)/d)
 *
 * and still use pdiv_q, while changing the sign of data->v.
 *
 * Otherwise, we check if
 *
 *	e + d*floor(cst/v)
 *
 * is non-negative and if so, replace floor(e/d) by
 *
 *	floor((e + s*d)/d) - s
 *
 * with s the minimal shift that makes the argument non-negative.
 */
================================================================================

文件路径: ./isl_ast_build_expr.c
注释行数: 9
注释内容:
/* Create an isl_ast_expr evaluating the specified dimension of "ls".
 * The result is simplified in terms of data->build->domain.
 * This function may change (the sign of) data->v.
 *
 * The isl_ast_expr is constructed based on the type of the dimension.
 * - divs are constructed by var_div
 * - set variables are constructed from the iterator isl_ids in data->build
 * - parameters are constructed from the isl_ids in "ls"
 */
================================================================================

文件路径: ./isl_ast_build_expr.c
注释行数: 23
注释内容:
/* Add an expression for "*v" times the specified dimension of "ls"
 * to expr.
 * If the dimension is an integer division, then this function
 * may modify data->cst in order to make the numerator non-negative.
 * The result is simplified in terms of data->build->domain.
 *
 * Let e be the expression for the specified dimension,
 * multiplied by the absolute value of "*v".
 * If "*v" is negative, we create
 *
 *	(isl_ast_expr_op_sub, expr, e)
 *
 * except when expr is trivially zero, in which case we create
 *
 *	(isl_ast_expr_op_minus, e)
 *
 * instead.
 *
 * If "*v" is positive, we simply create
 *
 *	(isl_ast_expr_op_add, expr, e)
 *
 */
================================================================================

文件路径: ./isl_ast_build_expr.c
注释行数: 13
注释内容:
/* Does
 *
 *	arg mod data->d
 *
 * represent (a special case of) a test for some linear expression
 * being even?
 *
 * In particular, is it of the form
 *
 *	(lin - 1) mod 2
 *
 * ?
 */
================================================================================

文件路径: ./isl_ast_build_expr.c
注释行数: 29
注释内容:
/* Given that data->v * div_i in data->aff is equal to
 *
 *	f * (term - (arg mod d))
 *
 * with data->d * f = data->v and "arg" non-negative on data->build, add
 *
 *	f * term
 *
 * to data->add and
 *
 *	abs(f) * (arg mod d)
 *
 * to data->neg or data->pos depending on the sign of -f.
 *
 * In the special case that "arg mod d" is of the form "(lin - 1) mod 2",
 * with "lin" some linear expression, first replace
 *
 *	f * (term - ((lin - 1) mod 2))
 *
 * by
 *
 *	-f * (1 - term - (lin mod 2))
 *
 * These two are equal because
 *
 *	((lin - 1) mod 2) + (lin mod 2) = 1
 *
 * Also, if "lin - 1" is non-negative, then "lin" is non-negative too.
 */
================================================================================

文件路径: ./isl_ast_build_expr.c
注释行数: 18
注释内容:
/* Given that data->v * div_i in data->aff is of the form
 *
 *	f * d * floor(div/d)
 *
 * with div nonnegative on data->build, rewrite it as
 *
 *	f * (div - (div mod d)) = f * div - f * (div mod d)
 *
 * and add
 *
 *	f * div
 *
 * to data->add and
 *
 *	abs(f) * (div mod d)
 *
 * to data->neg or data->pos depending on the sign of -f.
 */
================================================================================

文件路径: ./isl_ast_build_expr.c
注释行数: 18
注释内容:
/* Given that data->v * div_i in data->aff is of the form
 *
 *	f * d * floor(div/d)					(1)
 *
 * check if div is non-negative on data->build and, if so,
 * extract the corresponding modulo from data->aff.
 * If not, then check if
 *
 *	-div + d - 1
 *
 * is non-negative on data->build.  If so, replace (1) by
 *
 *	-f * d * floor((-div + d - 1)/d)
 *
 * and extract the corresponding modulo from data->aff.
 *
 * This function may modify data->div.
 */
================================================================================

文件路径: ./isl_ast_build_expr.c
注释行数: 11
注释内容:
/* Is the affine expression of constraint "c" "simpler" than data->nonneg
 * for use in extracting a modulo expression?
 *
 * We currently only consider the constant term of the affine expression.
 * In particular, we prefer the affine expression with the smallest constant
 * term.
 * This means that if there are two constraints, say x >= 0 and -x + 10 >= 0,
 * then we would pick x >= 0
 *
 * More detailed heuristics could be used if it turns out that there is a need.
 */
================================================================================

文件路径: ./isl_ast_build_expr.c
注释行数: 79
注释内容:
/* Given that data->v * div_i in data->aff is of the form
 *
 *	f * d * floor(div/d)					(1)
 *
 * see if we can find an expression div' that is non-negative over data->build
 * and that is related to div through
 *
 *	div' = div + d * e
 *
 * or
 *
 *	div' = -div + d - 1 + d * e
 *
 * with e some affine expression.
 * If so, we write (1) as
 *
 *	f * div + f * (div' mod d)
 *
 * or
 *
 *	-f * (-div + d - 1) - f * (div' mod d)
 *
 * exploiting (in the second case) the fact that
 *
 *	f * d * floor(div/d) =	-f * d * floor((-div + d - 1)/d)
 *
 *
 * We first try to find an appropriate expression for div'
 * from the constraints of data->build->domain (which is therefore
 * guaranteed to be non-negative on data->build), where we remove
 * any integer divisions from the constraints and skip this step
 * if "div" itself involves any integer divisions.
 * If we cannot find an appropriate expression this way, then
 * we pass control to extract_nonneg_mod where check
 * if div or "-div + d -1" themselves happen to be
 * non-negative on data->build.
 *
 * While looking for an appropriate constraint in data->build->domain,
 * we ignore the constant term, so after finding such a constraint,
 * we still need to fix up the constant term.
 * In particular, if a is the constant term of "div"
 * (or d - 1 - the constant term of "div" if data->sign < 0)
 * and b is the constant term of the constraint, then we need to find
 * a non-negative constant c such that
 *
 *	b + c \equiv a	mod d
 *
 * We therefore take
 *
 *	c = (a - b) mod d
 *
 * and add it to b to obtain the constant term of div'.
 * If this constant term is "too negative", then we add an appropriate
 * multiple of d to make it positive.
 *
 *
 * Note that the above is a only a very simple heuristic for finding an
 * appropriate expression.  We could try a bit harder by also considering
 * sums of constraints that involve disjoint sets of variables or
 * we could consider arbitrary linear combinations of constraints,
 * although that could potentially be much more expensive as it involves
 * the solution of an LP problem.
 *
 * In particular, if v_i is a column vector representing constraint i,
 * w represents div and e_i is the i-th unit vector, then we are looking
 * for a solution of the constraints
 *
 *	\sum_i lambda_i v_i = w + \sum_i alpha_i d e_i
 *
 * with \lambda_i >= 0 and alpha_i of unrestricted sign.
 * If we are not just interested in a non-negative expression, but
 * also in one with a minimal range, then we don't just want
 * c = \sum_i lambda_i v_i to be non-negative over the domain,
 * but also beta - c = \sum_i mu_i v_i, where beta is a scalar
 * that we want to minimize and we now also have to take into account
 * the constant terms of the constraints.
 * Alternatively, we could first compute the dual of the domain
 * and plug in the constraints on the coefficients.
 */
================================================================================

文件路径: ./isl_ast_build_expr.c
注释行数: 31
注释内容:
/* Check if "data->aff" involves any (implicit) modulo computations based
 * on div "data->i".
 * If so, remove them from aff and add expressions corresponding
 * to those modulo computations to data->pos and/or data->neg.
 *
 * "aff" is assumed to be an integer affine expression.
 *
 * In particular, check if (v * div_j) is of the form
 *
 *	f * m * floor(a / m)
 *
 * and, if so, rewrite it as
 *
 *	f * (a - (a mod m)) = f * a - f * (a mod m)
 *
 * and extract out -f * (a mod m).
 * In particular, if f > 0, we add (f * (a mod m)) to *neg.
 * If f < 0, we add ((-f) * (a mod m)) to *pos.
 *
 * Note that in order to represent "a mod m" as
 *
 *	(isl_ast_expr_op_pdiv_r, a, m)
 *
 * we need to make sure that a is non-negative.
 * If not, we check if "-a + m - 1" is non-negative.
 * If so, we can rewrite
 *
 *	floor(a/m) = -ceil(-a/m) = -floor((-a + m - 1)/m)
 *
 * and still extract a modulo.
 */
================================================================================

文件路径: ./isl_ast_build_expr.c
注释行数: 23
注释内容:
/* Check if "aff" involves any (implicit) modulo computations.
 * If so, remove them from aff and add expressions corresponding
 * to those modulo computations to *pos and/or *neg.
 * We only do this if the option ast_build_prefer_pdiv is set.
 *
 * "aff" is assumed to be an integer affine expression.
 *
 * A modulo expression is of the form
 *
 *	a mod m = a - m * floor(a / m)
 *
 * To detect them in aff, we look for terms of the form
 *
 *	f * m * floor(a / m)
 *
 * rewrite them as
 *
 *	f * (a - (a mod m)) = f * a - f * (a mod m)
 *
 * and extract out -f * (a mod m).
 * In particular, if f > 0, we add (f * (a mod m)) to *neg.
 * If f < 0, we add ((-f) * (a mod m)) to *pos.
 */
================================================================================

文件路径: ./isl_ast_build_expr.c
注释行数: 8
注释内容:
/* Construct an isl_ast_expr that evaluates the affine expression "aff",
 * The result is simplified in terms of build->domain.
 *
 * We first extract hidden modulo computations from the affine expression
 * and then add terms for each variable with a non-zero coefficient.
 * Finally, if the affine expression has a non-trivial denominator,
 * we divide the resulting isl_ast_expr by this denominator.
 */
================================================================================

文件路径: ./isl_ast_build_expr.c
注释行数: 4
注释内容:
/* Add terms to "expr" for each variable in "aff" with a coefficient
 * with sign equal to "sign".
 * The result is simplified in terms of data->build->domain.
 */
================================================================================

文件路径: ./isl_ast_build_expr.c
注释行数: 21
注释内容:
/* Give an equality of the form
 *
 *	aff = e - d floor(e/d) = 0
 *
 * or
 *
 *	aff = -e + d floor(e/d) = 0
 *
 * with the integer division "pos" equal to floor(e/d),
 * construct the AST expression
 *
 *	(isl_ast_expr_op_eq,
 *		(isl_ast_expr_op_zdiv_r, expr(e), expr(d)), expr(0))
 *
 * If e only has negative coefficients, then construct
 *
 *	(isl_ast_expr_op_eq,
 *		(isl_ast_expr_op_zdiv_r, expr(-e), expr(d)), expr(0))
 *
 * instead.
 */
================================================================================

文件路径: ./isl_ast_build_expr.c
注释行数: 37
注释内容:
/* Construct an isl_ast_expr that evaluates the condition "constraint",
 * The result is simplified in terms of build->domain.
 *
 * We first check if the constraint is an equality of the form
 *
 *	e - d floor(e/d) = 0
 *
 * i.e.,
 *
 *	e mod d = 0
 *
 * If so, we convert it to
 *
 *	(isl_ast_expr_op_eq,
 *		(isl_ast_expr_op_zdiv_r, expr(e), expr(d)), expr(0))
 *
 * Otherwise, let the constraint by either "a >= 0" or "a == 0".
 * We first extract hidden modulo computations from "a"
 * and then collect all the terms with a positive coefficient in cons_pos
 * and the terms with a negative coefficient in cons_neg.
 *
 * The result is then of the form
 *
 *	(isl_ast_expr_op_ge, expr(pos), expr(-neg)))
 *
 * or
 *
 *	(isl_ast_expr_op_eq, expr(pos), expr(-neg)))
 *
 * However, if the first expression is an integer constant (and the second
 * is not), then we swap the two expressions.  This ensures that we construct,
 * e.g., "i <= 5" rather than "5 >= i".
 *
 * Furthermore, is there are no terms with positive coefficients (or no terms
 * with negative coefficients), then the constant term is added to "pos"
 * (or "neg"), ignoring the sign of the constant term.
 */
================================================================================

文件路径: ./isl_ast_build_expr.c
注释行数: 20
注释内容:
/* Construct an isl_ast_expr that evaluates the conditions defining "bset".
 * The result is simplified in terms of build->domain.
 *
 * If "bset" is not bounded by any constraint, then we construct
 * the expression "1", i.e., "true".
 *
 * Otherwise, we sort the constraints, putting constraints that involve
 * integer divisions after those that do not, and construct an "and"
 * of the ast expressions of the individual constraints.
 *
 * Each constraint is added to the generated constraints of the build
 * after it has been converted to an AST expression so that it can be used
 * to simplify the following constraints.  This may change the truth value
 * of subsequent constraints that do not satisfy the earlier constraints,
 * but this does not affect the outcome of the conjunction as it is
 * only true if all the conjuncts are true (no matter in what order
 * they are evaluated).  In particular, the constraints that do not
 * involve integer divisions may serve to simplify some constraints
 * that do involve integer divisions.
 */
================================================================================

文件路径: ./isl_ast_build_expr.c
注释行数: 8
注释内容:
/* State of data about previous pieces in
 * isl_ast_build_expr_from_pw_aff_internal.
 *
 * isl_state_none: no data about previous pieces
 * isl_state_single: data about a single previous piece
 * isl_state_min: data represents minimum of several pieces
 * isl_state_max: data represents maximum of several pieces
 */
================================================================================

文件路径: ./isl_ast_build_expr.c
注释行数: 5
注释内容:
/* Construct an isl_ast_expr that evaluates "pa".
 * The result is simplified in terms of build->domain.
 *
 * The domain of "pa" lives in the internal schedule space.
 */
================================================================================

文件路径: ./isl_ast_build_expr.c
注释行数: 5
注释内容:
/* Construct an isl_ast_expr that evaluates "pa".
 * The result is simplified in terms of build->domain.
 *
 * The domain of "pa" lives in the external schedule space.
 */
================================================================================

文件路径: ./isl_tarjan.c
注释行数: 3
注释内容:
/* Perform Tarjan's algorithm for computing the strongly connected components
 * in the graph with g->len nodes and with edges defined by "follows".
 */
================================================================================

文件路径: ./isl_tarjan.c
注释行数: 9
注释内容:
/* Decompose the graph with "len" nodes and edges defined by "follows"
 * into the strongly connected component (SCC) that contains "node"
 * as well as all SCCs that are followed by this SCC.
 * follows(i, j, user) should return 1 if "i" follows "j" and 0 otherwise.
 * It should return -1 on error.
 *
 * The SCC containing "node" will appear as the last component
 * in g->order.
 */
================================================================================

文件路径: ./basis_reduction_templ.c
注释行数: 21
注释内容:
/* Compute a reduced basis for the set represented by the tableau "tab".
 * tab->basis, which must be initialized by the calling function to an affine
 * unimodular basis, is updated to reflect the reduced basis.
 * The first tab->n_zero rows of the basis (ignoring the constant row)
 * are assumed to correspond to equalities and are left untouched.
 * tab->n_zero is updated to reflect any additional equalities that
 * have been detected in the first rows of the new basis.
 * The final tab->n_unbounded rows of the basis are assumed to correspond
 * to unbounded directions and are also left untouched.
 * In particular this means that the remaining rows are assumed to
 * correspond to bounded directions.
 *
 * This function implements the algorithm described in
 * "An Implementation of the Generalized Basis Reduction Algorithm
 *  for Integer Programming" of Cook el al. to compute a reduced basis.
 * We use \epsilon = 1/4.
 *
 * If ctx->opt->gbr_only_first is set, the user is only interested
 * in the first direction.  In this case we stop the basis reduction when
 * the width in the first direction becomes smaller than 2.
 */
================================================================================

文件路径: ./isl_sample.c
注释行数: 23
注释内容:
/* Perform a greedy search for an integer point in the set represented
 * by "tab", given that the minimal rational value (rounded up to the
 * nearest integer) at "level" is smaller than the maximal rational
 * value (rounded down to the nearest integer).
 *
 * Return 1 if we have found an integer point (if tab->n_unbounded > 0
 * then we may have only found integer values for the bounded dimensions
 * and it is the responsibility of the caller to extend this solution
 * to the unbounded dimensions).
 * Return 0 if greedy search did not result in a solution.
 * Return -1 if some error occurred.
 *
 * We assign a value half-way between the minimum and the maximum
 * to the current dimension and check if the minimal value of the
 * next dimension is still smaller than (or equal) to the maximal value.
 * We continue this process until either
 * - the minimal value (rounded up) is greater than the maximal value
 *	(rounded down).  In this case, greedy search has failed.
 * - we have exhausted all bounded dimensions, meaning that we have
 *	found a solution.
 * - the sample value of the tableau is integral.
 * - some error has occurred.
 */
================================================================================

文件路径: ./isl_sample.c
注释行数: 6
注释内容:
/* isl_factorizer_every_factor_basic_set callback that extends
 * the sample in data->sample with the contribution
 * of the factor "bset".
 * If "bset" turns out to be empty, then the product is empty too and
 * no further factors need to be considered.
 */
================================================================================

文件路径: ./isl_sample.c
注释行数: 17
注释内容:
/* Given a tableau "tab", a tableau "tab_cone" that corresponds
 * to the recession cone and the inverse of a new basis U = inv(B),
 * with the unbounded directions in B last,
 * add constraints to "tab" that ensure any rational value
 * in the unbounded directions can be rounded up to an integer value.
 *
 * The new basis is given by x' = B x, i.e., x = U x'.
 * For any rational value of the last tab->n_unbounded coordinates
 * in the update tableau, the value that is obtained by rounding
 * up this value should be contained in the original tableau.
 * For any constraint "a x + c >= 0", we therefore need to add
 * a constraint "a x + c + s >= 0", with s the sum of all negative
 * entries in the last elements of "a U".
 *
 * Since we are not interested in the first entries of any of the "a U",
 * we first drop the columns of U that correpond to bounded directions.
 */
================================================================================

文件路径: ./isl_val.c
注释行数: 2
注释内容:
/* Compute x, y and g such that g = gcd(a,b) and a*x+b*y = g.
 */
================================================================================

文件路径: ./isl_list_templ.c
注释行数: 4
注释内容:
/* Does element i of data->list follow element j?
 *
 * Use the user provided callback to find out.
 */
================================================================================

文件路径: ./isl_equalities.c
注释行数: 46
注释内容:
/* Given a set of modulo constraints
 *
 *		c + A y = 0 mod d
 *
 * this function computes a particular solution y_0
 *
 * The input is given as a matrix B = [ c A ] and a vector d.
 *
 * The output is matrix containing the solution y_0 or
 * a zero-column matrix if the constraints admit no integer solution.
 *
 * The given set of constrains is equivalent to
 *
 *		c + A y = -D x
 *
 * with D = diag d and x a fresh set of variables.
 * Reducing both c and A modulo d does not change the
 * value of y in the solution and may lead to smaller coefficients.
 * Let M = [ D A ] and [ H 0 ] = M U, the Hermite normal form of M.
 * Then
 *		  [ x ]
 *		M [ y ] = - c
 * and so
 *		               [ x ]
 *		[ H 0 ] U^{-1} [ y ] = - c
 * Let
 *		[ A ]          [ x ]
 *		[ B ] = U^{-1} [ y ]
 * then
 *		H A + 0 B = -c
 *
 * so B may be chosen arbitrarily, e.g., B = 0, and then
 *
 *		       [ x ] = [ -c ]
 *		U^{-1} [ y ] = [  0 ]
 * or
 *		[ x ]     [ -c ]
 *		[ y ] = U [  0 ]
 * specifically,
 *
 *		y = U_{2,1} (-c)
 *
 * If any of the coordinates of this y are non-integer
 * then the constraints admit no integer solution and
 * a zero-column matrix is returned.
 */
================================================================================

文件路径: ./isl_equalities.c
注释行数: 13
注释内容:
/* Compute a common lattice of solutions to the linear modulo
 * constraints specified by B and d.
 * See also the documentation of isl_mat_parameter_compression.
 * We put the matrix
 * 
 *		A = [ L_1^{-T} L_2^{-T} ... L_k^{-T} ]
 *
 * on a common denominator.  This denominator D is the lcm of modulos d.
 * Since L_i = U_i^{-1} diag(d_i, 1, ... 1), we have
 * L_i^{-T} = U_i^T diag(d_i, 1, ... 1)^{-T} = U_i^T diag(1/d_i, 1, ..., 1).
 * Putting this on the common denominator, we have
 * D * L_i^{-T} = U_i^T diag(D/d_i, D, ..., D).
 */
================================================================================

文件路径: ./isl_equalities.c
注释行数: 47
注释内容:
/* Given a set of equalities
 *
 *		-C(y) + M x = 0
 *
 * this function computes a unimodular transformation from a lower-dimensional
 * space to the original space that bijectively maps the integer points x'
 * in the lower-dimensional space to the integer points x in the original
 * space that satisfy the equalities.
 *
 * The input is given as a matrix B = [ -C M ] and the output is a
 * matrix that maps [1 x'] to [1 x].
 * The number of equality constraints in B is assumed to be smaller than
 * or equal to the number of variables x.
 * "first" is the position of the first x variable.
 * The preceding variables are considered to be y-variables.
 * If T2 is not NULL, then *T2 is set to a matrix mapping [1 x] to [1 x'].
 *
 * First compute the (left) Hermite normal form of M,
 *
 *		M [U1 U2] = M U = H = [H1 0]
 * or
 *		              M = H Q = [H1 0] [Q1]
 *                                             [Q2]
 *
 * with U, Q unimodular, Q = U^{-1} (and H lower triangular).
 * Define the transformed variables as
 *
 *		x = [U1 U2] [ x1' ] = [U1 U2] [Q1] x
 *		            [ x2' ]           [Q2]
 *
 * The equalities then become
 *
 *		-C(y) + H1 x1' = 0   or   x1' = H1^{-1} C(y) = C'(y)
 *
 * If the denominator of the constant term does not divide the
 * the common denominator of the coefficients of y, then every
 * integer point is mapped to a non-integer point and then the original set
 * has no integer solutions (since the x' are a unimodular transformation
 * of the x).  In this case, a zero-column matrix is returned.
 * Otherwise, the transformation is given by
 *
 *		x = U1 H1^{-1} C(y) + U2 x2'
 *
 * The inverse transformation is simply
 *
 *		x2' = Q2 x
 */
================================================================================

文件路径: ./isl_transitive_closure.c
注释行数: 17
注释内容:
/* Check whether the overapproximation of the power of "map" is exactly
 * the power of "map".  Let R be "map" and A_k the overapproximation.
 * The approximation is exact if
 *
 *	A_1 = R
 *	A_k = A_{k-1} \circ R			k >= 2
 *
 * Since A_k is known to be an overapproximation, we only need to check
 *
 *	A_1 \subset R
 *	A_k \subset A_{k-1} \circ R		k >= 2
 *
 * In practice, "app" has an extra input and output coordinate
 * to encode the length of the path.  So, we first need to add
 * this coordinate to "map" and set the length of the path to
 * one.
 */
================================================================================

文件路径: ./isl_transitive_closure.c
注释行数: 21
注释内容:
/* Check whether the overapproximation of the power of "map" is exactly
 * the power of "map", possibly after projecting out the power (if "project"
 * is set).
 *
 * If "project" is set and if "steps" can only result in acyclic paths,
 * then we check
 *
 *	A = R \cup (A \circ R)
 *
 * where A is the overapproximation with the power projected out, i.e.,
 * an overapproximation of the transitive closure.
 * More specifically, since A is known to be an overapproximation, we check
 *
 *	A \subset R \cup (A \circ R)
 *
 * Otherwise, we check if the power is exact.
 *
 * Note that "app" has an extra input and output coordinate to encode
 * the length of the part.  If we are only interested in the transitive
 * closure, then we can simply project out these coordinates first.
 */
================================================================================

文件路径: ./isl_transitive_closure.c
注释行数: 12
注释内容:
/* Given a set of n offsets v_i (the rows of "steps"), construct a relation
 * of the given dimension specification (Z^{n+1} -> Z^{n+1})
 * that maps an element x to any element that can be reached
 * by taking a non-negative number of steps along any of
 * the extended offsets v'_i = [v_i 1].
 * That is, construct
 *
 * { [x] -> [y] : exists k_i >= 0, y = x + \sum_i k_i v'_i }
 *
 * For any element in this relation, the number of steps taken
 * is equal to the difference in the final coordinates.
 */
================================================================================

文件路径: ./isl_transitive_closure.c
注释行数: 55
注释内容:
/* Given a set of offsets "delta", construct a relation of the
 * given dimension specification (Z^{n+1} -> Z^{n+1}) that
 * is an overapproximation of the relations that
 * maps an element x to any element that can be reached
 * by taking a non-negative number of steps along any of
 * the elements in "delta".
 * That is, construct an approximation of
 *
 *	{ [x] -> [y] : exists f \in \delta, k \in Z :
 *					y = x + k [f, 1] and k >= 0 }
 *
 * For any element in this relation, the number of steps taken
 * is equal to the difference in the final coordinates.
 *
 * In particular, let delta be defined as
 *
 *	\delta = [p] -> { [x] : A x + a >= 0 and B p + b >= 0 and
 *				C x + C'p + c >= 0 and
 *				D x + D'p + d >= 0 }
 *
 * where the constraints C x + C'p + c >= 0 are such that the parametric
 * constant term of each constraint j, "C_j x + C'_j p + c_j",
 * can never attain positive values, then the relation is constructed as
 *
 *	{ [x] -> [y] : exists [f, k] \in Z^{n+1} : y = x + f and
 *			A f + k a >= 0 and B p + b >= 0 and
 *			C f + C'p + c >= 0 and k >= 1 }
 *	union { [x] -> [x] }
 *
 * If the zero-length paths happen to correspond exactly to the identity
 * mapping, then we return
 *
 *	{ [x] -> [y] : exists [f, k] \in Z^{n+1} : y = x + f and
 *			A f + k a >= 0 and B p + b >= 0 and
 *			C f + C'p + c >= 0 and k >= 0 }
 *
 * instead.
 *
 * Existentially quantified variables in \delta are handled by
 * classifying them as independent of the parameters, purely
 * parameter dependent and others.  Constraints containing
 * any of the other existentially quantified variables are removed.
 * This is safe, but leads to an additional overapproximation.
 *
 * If there are any impure constraints, then we also eliminate
 * the parameters from \delta, resulting in a set
 *
 *	\delta' = { [x] : E x + e >= 0 }
 *
 * and add the constraints
 *
 *			E f + k e >= 0
 *
 * to the constructed relation.
 */
================================================================================

文件路径: ./isl_transitive_closure.c
注释行数: 7
注释内容:
/* Given a dimension specification Z^{n+1} -> Z^{n+1} and a parameter "param",
 * construct a map that equates the parameter to the difference
 * in the final coordinates and imposes that this difference is positive.
 * That is, construct
 *
 *	{ [x,x_s] -> [y,y_s] : k = y_s - x_s > 0 }
 */
================================================================================

文件路径: ./isl_transitive_closure.c
注释行数: 9
注释内容:
/* Check whether "path" is acyclic, where the last coordinates of domain
 * and range of path encode the number of steps taken.
 * That is, check whether
 *
 *	{ d | d = y - x and (x,y) in path }
 *
 * does not contain any element with positive last coordinate (positive length)
 * and zero remaining coordinates (cycle).
 */
================================================================================

文件路径: ./isl_transitive_closure.c
注释行数: 2
注释内容:
/* Construct a map [x] -> [x+1], with parameters prescribed by "space".
 */
================================================================================

文件路径: ./isl_transitive_closure.c
注释行数: 3
注释内容:
/* Replace each entry in the n by n grid of maps by the cross product
 * with the relation { [i] -> [i + 1] }.
 */
================================================================================

文件路径: ./isl_transitive_closure.c
注释行数: 19
注释内容:
/* Given a partition of the domains and ranges of the basic maps in "map",
 * apply the Floyd-Warshall algorithm with the elements in the partition
 * as vertices.
 *
 * In particular, there are "n" elements in the partition and "group" is
 * an array of length 2 * map->n with entries in [0,n-1].
 *
 * We first construct a matrix of relations based on the partition information,
 * apply Floyd-Warshall on this matrix of relations and then take the
 * union of all entries in the matrix as the final result.
 *
 * If we are actually computing the power instead of the transitive closure,
 * i.e., when "project" is not set, then the result should have the
 * path lengths encoded as the difference between an extra pair of
 * coordinates.  We therefore apply the nested transitive closures
 * to relations that include these lengths.  In particular, we replace
 * the input relation by the cross product with the unit length relation
 * { [i] -> [i + 1] }.
 */
================================================================================

文件路径: ./isl_transitive_closure.c
注释行数: 33
注释内容:
/* Given a union of basic maps R = \cup_i R_i \subseteq D \times D
 * and a dimension specification (Z^{n+1} -> Z^{n+1}),
 * construct a map that is an overapproximation of the map
 * that takes an element from the dom R \times Z to an
 * element from ran R \times Z, such that the first n coordinates of the
 * difference between them is a sum of differences between images
 * and pre-images in one of the R_i and such that the last coordinate
 * is equal to the number of steps taken.
 * If "project" is set, then these final coordinates are not included,
 * i.e., a relation of type Z^n -> Z^n is returned.
 * That is, let
 *
 *	\Delta_i = { y - x | (x, y) in R_i }
 *
 * then the constructed map is an overapproximation of
 *
 *	{ (x) -> (x + d) | \exists k_i >= 0, \delta_i \in \Delta_i :
 *				d = (\sum_i k_i \delta_i, \sum_i k_i) and
 *				x in dom R and x + d in ran R }
 *
 * or
 *
 *	{ (x) -> (x + d) | \exists k_i >= 0, \delta_i \in \Delta_i :
 *				d = (\sum_i k_i \delta_i) and
 *				x in dom R and x + d in ran R }
 *
 * if "project" is set.
 *
 * We first split the map into strongly connected components, perform
 * the above on each component and then join the results in the correct
 * order, at each join also taking in the union of both arguments
 * to allow for paths that do not go through one of the two arguments.
 */
================================================================================

文件路径: ./isl_transitive_closure.c
注释行数: 29
注释内容:
/* Given a map, compute the smallest superset of this map that is of the form
 *
 *	{ i -> j : L <= j - i <= U and exists a_p: j_p - i_p = M_p a_p }
 *
 * (where p ranges over the (non-parametric) dimensions),
 * compute the transitive closure of this map, i.e.,
 *
 *	{ i -> j : exists k > 0:
 *		k L <= j - i <= k U and exists a: j_p - i_p = M_p a_p }
 *
 * and intersect domain and range of this transitive closure with
 * the given domain and range.
 *
 * If with_id is set, then try to include as much of the identity mapping
 * as possible, by computing
 *
 *	{ i -> j : exists k >= 0:
 *		k L <= j - i <= k U and exists a: j_p - i_p = M_p a_p }
 *
 * instead (i.e., allow k = 0).
 *
 * In practice, we compute the difference set
 *
 *	delta  = { j - i | i -> j in map },
 *
 * look for stride constraint on the individual dimensions and compute
 * (constant) lower and upper bounds for each individual dimension,
 * adding a constraint for each bound not equal to infinity.
 */
================================================================================

文件路径: ./isl_transitive_closure.c
注释行数: 13
注释内容:
/* Given a map, compute the smallest superset of this map that is of the form
 *
 *	{ i -> j : L <= j - i <= U and exists a_p: j_p - i_p = M_p a_p }
 *
 * (where p ranges over the (non-parametric) dimensions),
 * compute the transitive closure of this map, i.e.,
 *
 *	{ i -> j : exists k > 0:
 *		k L <= j - i <= k U and exists a: j_p - i_p = M_p a_p }
 *
 * and intersect domain and range of this transitive closure with
 * domain and range of the original map.
 */
================================================================================

文件路径: ./isl_transitive_closure.c
注释行数: 13
注释内容:
/* Given a map, compute the smallest superset of this map that is of the form
 *
 *	{ i -> j : L <= j - i <= U and exists a_p: j_p - i_p = M_p a_p }
 *
 * (where p ranges over the (non-parametric) dimensions),
 * compute the transitive and partially reflexive closure of this map, i.e.,
 *
 *	{ i -> j : exists k >= 0:
 *		k L <= j - i <= k U and exists a: j_p - i_p = M_p a_p }
 *
 * and intersect domain and range of this transitive closure with
 * the given domain.
 */
================================================================================

文件路径: ./isl_transitive_closure.c
注释行数: 28
注释内容:
/* Check if basic map M_i can be combined with all the other
 * basic maps such that
 *
 *	(\cup_j M_j)^+
 *
 * can be computed as
 *
 *	M_i \cup (\cup_{j \ne i} M_i^* \circ M_j \circ M_i^*)^+
 *
 * In particular, check if we can compute a compact representation
 * of
 *
 *		M_i^* \circ M_j \circ M_i^*
 *
 * for each j != i.
 * Let M_i^? be an extension of M_i^+ that allows paths
 * of length zero, i.e., the result of box_closure(., 1).
 * The criterion, as proposed by Kelly et al., is that
 * id = M_i^? - M_i^+ can be represented as a basic map
 * and that
 *
 *	id \circ M_j \circ id = M_j
 *
 * for each j != i.
 *
 * If this function returns 1, then tc and qc are set to
 * M_i^+ and M_i^?, respectively.
 */
================================================================================

文件路径: ./isl_transitive_closure.c
注释行数: 2
注释内容:
/* Construct a map [[x]->[y]] -> [y-x], with parameters prescribed by "space".
 */
================================================================================

文件路径: ./isl_tab.c
注释行数: 5
注释内容:
/*
 * The implementation of tableaus in this file was inspired by Section 8
 * of David Detlefs, Greg Nelson and James B. Saxe, "Simplify: a theorem
 * prover for program checking".
 */
================================================================================

文件路径: ./isl_tab.c
注释行数: 16
注释内容:
/* Find a pivot (row and col) that will increase (sgn > 0) or decrease
 * (sgn < 0) the value of row variable var.
 * If not NULL, then skip_var is a row variable that should be ignored
 * while looking for a pivot row.  It is usually equal to var.
 *
 * As the given row in the tableau is of the form
 *
 *	x_r = a_r0 + \sum_i a_ri x_i
 *
 * we need to find a column such that the sign of a_ri is equal to "sgn"
 * (such that an increase in x_i will have the desired effect) or a
 * column with a variable that may attain negative values.
 * If a_ri is positive, then we need to move x_i in the same direction
 * to obtain the desired effect.  Otherwise, x_i has to move in the
 * opposite direction.
 */
================================================================================

文件路径: ./isl_tab.c
注释行数: 50
注释内容:
/* Given a row number "row" and a column number "col", pivot the tableau
 * such that the associated variables are interchanged.
 * The given row in the tableau expresses
 *
 *	x_r = a_r0 + \sum_i a_ri x_i
 *
 * or
 *
 *	x_c = 1/a_rc x_r - a_r0/a_rc + sum_{i \ne r} -a_ri/a_rc
 *
 * Substituting this equality into the other rows
 *
 *	x_j = a_j0 + \sum_i a_ji x_i
 *
 * with a_jc \ne 0, we obtain
 *
 *	x_j = a_jc/a_rc x_r + a_j0 - a_jc a_r0/a_rc + sum a_ji - a_jc a_ri/a_rc 
 *
 * The tableau
 *
 *	n_rc/d_r		n_ri/d_r
 *	n_jc/d_j		n_ji/d_j
 *
 * where i is any other column and j is any other row,
 * is therefore transformed into
 *
 * s(n_rc)d_r/|n_rc|		-s(n_rc)n_ri/|n_rc|
 * s(n_rc)d_r n_jc/(|n_rc| d_j)	(n_ji |n_rc| - s(n_rc)n_jc n_ri)/(|n_rc| d_j)
 *
 * The transformation is performed along the following steps
 *
 *	d_r/n_rc		n_ri/n_rc
 *	n_jc/d_j		n_ji/d_j
 *
 *	s(n_rc)d_r/|n_rc|	-s(n_rc)n_ri/|n_rc|
 *	n_jc/d_j		n_ji/d_j
 *
 *	s(n_rc)d_r/|n_rc|	-s(n_rc)n_ri/|n_rc|
 *	n_jc/(|n_rc| d_j)	n_ji/(|n_rc| d_j)
 *
 *	s(n_rc)d_r/|n_rc|	-s(n_rc)n_ri/|n_rc|
 *	n_jc/(|n_rc| d_j)	(n_ji |n_rc|)/(|n_rc| d_j)
 *
 *	s(n_rc)d_r/|n_rc|	-s(n_rc)n_ri/|n_rc|
 *	n_jc/(|n_rc| d_j)	(n_ji |n_rc| - s(n_rc)n_jc n_ri)/(|n_rc| d_j)
 *
 * s(n_rc)d_r/|n_rc|		-s(n_rc)n_ri/|n_rc|
 * s(n_rc)d_r n_jc/(|n_rc| d_j)	(n_ji |n_rc| - s(n_rc)n_jc n_ri)/(|n_rc| d_j)
 *
 */
================================================================================

文件路径: ./isl_tab.c
注释行数: 5
注释内容:
/* Move the entries in tab->var up one position, starting at "first",
 * creating room for an extra entry at position "first".
 * Since some of the entries of tab->row_var and tab->col_var contain
 * indices into this array, they have to be updated accordingly.
 */
================================================================================

文件路径: ./isl_tab.c
注释行数: 5
注释内容:
/* Drop the entry at position "first" in tab->var, moving all
 * subsequent entries down.
 * Since some of the entries of tab->row_var and tab->col_var contain
 * indices into this array, they have to be updated accordingly.
 */
================================================================================

文件路径: ./isl_tab.c
注释行数: 22
注释内容:
/* Add a row to the tableau.  The row is given as an affine combination
 * of the original variables and needs to be expressed in terms of the
 * column variables.
 *
 * This function assumes that at least one more row and at least
 * one more element in the constraint array are available in the tableau.
 *
 * We add each term in turn.
 * If r = n/d_r is the current sum and we need to add k x, then
 * 	if x is a column variable, we increase the numerator of
 *		this column by k d_r
 *	if x = f/d_x is a row variable, then the new representation of r is
 *
 *		 n    k f   d_x/g n + d_r/g k f   m/d_r n + m/d_g k f
 *		--- + --- = ------------------- = -------------------
 *		d_r   d_r        d_r d_x/g                m
 *
 *	with g the gcd of d_r and d_x and m the lcm of d_r and d_x.
 *
 * If tab->M is set, then, internally, each variable x is represented
 * as x' - M.  We then also need no subtract k d_r from the coefficient of M.
 */
================================================================================

文件路径: ./isl_tab.c
注释行数: 7
注释内容:
/* Add equality "eq" and check if it conflicts with the
 * previously added constraints or if it is obviously redundant.
 *
 * This function assumes that at least one more row and at least
 * one more element in the constraint array are available in the tableau.
 * If tab->bmap is set, then two rows are needed instead of one.
 */
================================================================================

文件路径: ./isl_tab.c
注释行数: 15
注释内容:
/* For a div d = floor(f/m), add the constraints
 *
 *		f - m d >= 0
 *		-(f-(m-1)) + m d >= 0
 *
 * Note that the second constraint is the negation of
 *
 *		f - m d >= m
 *
 * If add_ineq is not NULL, then this function is used
 * instead of isl_tab_add_ineq to effectively add the inequalities.
 *
 * This function assumes that at least two more rows and at least
 * two more elements in the constraint array are available in the tableau.
 */
================================================================================

文件路径: ./isl_tab.c
注释行数: 10
注释内容:
/* Given a non-negative variable "var", temporarily add a new non-negative
 * variable that is the opposite of "var", ensuring that "var" can only attain
 * the value zero.  The new variable is removed again before this function
 * returns.  However, the effect of forcing "var" to be zero remains.
 * If var = n/d is a row variable, then the new variable = -n/d.
 * If var is a column variables, then the new variable = -var.
 * If the new variable cannot attain non-negative values, then
 * the resulting tableau is empty.
 * Otherwise, we know the value will be zero and we close the row.
 */
================================================================================

文件路径: ./isl_tab.c
注释行数: 17
注释内容:
/* Given a tableau "tab" and an inequality constraint "con" of the tableau,
 * relax the inequality by one.  That is, the inequality r >= 0 is replaced
 * by r' = r + 1 >= 0.
 * If r is a row variable, we simply increase the constant term by one
 * (taking into account the denominator).
 * If r is a column variable, then we need to modify each row that
 * refers to r = r' - 1 by substituting this equality, effectively
 * subtracting the coefficient of the column from the constant.
 * We should only do this if the minimum is manifestly unbounded,
 * however.  Otherwise, we may end up with negative sample values
 * for non-negative variables.
 * So, if r is a column variable with a minimum that is not
 * manifestly unbounded, then we need to move it to a row.
 * However, the sample value of this row may be negative,
 * even after the relaxation, so we need to restore it.
 * We therefore prefer to pivot a column up to a row, if possible.
 */
================================================================================

文件路径: ./isl_tab.c
注释行数: 17
注释内容:
/* Replace the variable v at position "pos" in the tableau "tab"
 * by v' = v + shift.
 *
 * If the variable is in a column, then we first check if we can
 * simply plug in v = v' - shift.  The effect on a row with
 * coefficient f/d for variable v is that the constant term c/d
 * is replaced by (c - f * shift)/d.  If shift is positive and
 * f is negative for each row that needs to remain non-negative,
 * then this is clearly safe.  In other words, if the minimum of v
 * is manifestly unbounded, then we can keep v in a column position.
 * Otherwise, we can pivot it down to a row.
 * Similarly, if shift is negative, we need to check if the maximum
 * of is manifestly unbounded.
 *
 * If the variable is in a row (from the start or after pivoting),
 * then the constant term c/d is replaced by (c + d * shift)/d.
 */
================================================================================

文件路径: ./isl_tab.c
注释行数: 3
注释内容:
/* Update the element of row_var or col_var that corresponds to
 * constraint tab->con[i] to a move from position "old" to position "i".
 */
================================================================================

文件路径: ./isl_tab.c
注释行数: 5
注释内容:
/* Interchange constraints "con1" and "con2" in "tab".
 * In particular, interchange the contents of these entries in tab->con.
 * Since tab->col_var and tab->row_var point back into this array,
 * they need to be updated accordingly.
 */
================================================================================

文件路径: ./isl_tab.c
注释行数: 5
注释内容:
/* Drop the "n" entries starting at position "first" in tab->con, moving all
 * subsequent entries down.
 * Since some of the entries of tab->row_var and tab->col_var contain
 * indices into this array, they have to be updated accordingly.
 */
================================================================================

文件路径: ./isl_tab.c
注释行数: 8
注释内容:
/* Is the constraint at position "con" marked as being redundant?
 * If it is marked as representing an equality, then it is not
 * considered to be redundant.
 * Note that isl_tab_mark_redundant marks both the isl_tab_var as
 * redundant and moves the corresponding row into the first
 * tab->n_redundant positions (or removes the row, assigning it index -1),
 * so the final test is actually redundant itself.
 */
================================================================================

文件路径: ./isl_tab.c
注释行数: 10
注释内容:
/* The given row "row" represents an inequality violated by all
 * points in the tableau.  Check for some special cases of such
 * separating constraints.
 * In particular, if the row has been reduced to the constant -1,
 * then we know the inequality is adjacent (but opposite) to
 * an equality in the tableau.
 * If the row has been reduced to r = c*(-1 -r'), with r' an inequality
 * of the tableau and c a positive constant, then the inequality
 * is adjacent (but opposite) to the inequality r'.
 */
================================================================================

文件路径: ./isl_tab.c
注释行数: 8
注释内容:
/* Check the effect of inequality "ineq" on the tableau "tab".
 * The result may be
 *	isl_ineq_redundant:	satisfied by all points in the tableau
 *	isl_ineq_separate:	satisfied by no point in the tableau
 *	isl_ineq_cut:		satisfied by some by not all points
 *	isl_ineq_adj_eq:	adjacent to an equality
 *	isl_ineq_adj_ineq:	adjacent to an inequality.
 */
================================================================================

文件路径: ./isl_polynomial.c
注释行数: 4
注释内容:
/* Create a slice of the domain "set" such that integer division "div"
 * has the fixed value "v" and add the results to data->res,
 * replacing the integer division by "v" in "qp".
 */
================================================================================

文件路径: ./isl_polynomial.c
注释行数: 4
注释内容:
/* Split the domain "set" such that integer division "div"
 * has a fixed value (ranging from "min" to "max") on each slice
 * and add the results to data->res.
 */
================================================================================

文件路径: ./isl_polynomial.c
注释行数: 6
注释内容:
/* If "qp" refers to any integer division
 * that can only attain "max_periods" distinct values on "set"
 * then split the domain along those distinct values.
 * Add the results (or the original if no splitting occurs)
 * to data->res.
 */
================================================================================

文件路径: ./isl_polynomial.c
注释行数: 4
注释内容:
/* isl_factorizer_every_factor_basic_set callback that applies
 * data->fn to the factor "bset" and multiplies in the result
 * in data->pwqp.
 */
================================================================================

文件路径: ./isl_polynomial.c
注释行数: 8
注释内容:
/* Appoximate data->qp by a polynomial on the orthant identified by "signs".
 * We first make all integer divisions positive and then split the
 * quasipolynomials into terms with sign data->sign (the direction
 * of the requested approximation) and terms with the opposite sign.
 * In the first set of terms, each integer division [a/m] is
 * overapproximated by a/m, while in the second it is underapproximated
 * by (a-(m-1))/m.
 */
================================================================================

文件路径: ./isl_bound.c
注释行数: 11
注释内容:
/* Compute a bound on the polynomial defined over the parametric polytope
 * using either range propagation or bernstein expansion and
 * store the result in bound->pwf and bound->pwf_tight.
 * Since bernstein expansion requires bounded domains, we apply
 * range propagation on unbounded domains.  Otherwise, we respect the choice
 * of the user.
 *
 * If the polynomial does not depend on the set variables
 * then the bound is equal to the polynomial and
 * it can be added to "bound" directly.
 */
================================================================================

文件路径: ./isl_ast_build_private.h
注释行数: 134
注释内容:
/* An isl_ast_build represents the context in which AST is being
 * generated.  That is, it (mostly) contains information about outer
 * loops that can be used to simplify inner loops.
 *
 * "domain" represents constraints on the internal schedule domain,
 * corresponding to the context of the AST generation and the constraints
 * implied by the loops that have already been generated.
 * When an isl_ast_build is first created, outside any AST generation,
 * the domain is typically a parameter set.  It is only when a AST
 * generation phase is initiated that the domain of the isl_ast_build
 * is changed to refer to the internal schedule domain.
 * The domain then lives in a space of the form
 *
 *	S
 *
 *  or
 *
 *	[O -> S]
 *
 * O represents the loops generated in outer AST generations.
 * S represents the loops (both generated and to be generated)
 * of the current AST generation.
 * Both include eliminated loops.
 * "domain" is expected not to have any unknown divs because
 * it is used as the context argument in a call to isl_basic_set_gist
 * in isl_ast_build_compute_gist_basic_set.
 *
 * "depth" is equal to the number of loops that have already
 * been generated (including those in outer AST generations).
 * "outer_pos" is equal to the number of loops in outer AST generations.
 *
 * "generated" is a superset of "domain" corresponding to those
 * constraints that were either given by the user or that have
 * effectively been generated (as bounds on a for loop).
 *
 * "pending" is a superset of "domain" corresponding to the constraints
 * that still need to be generated (as guards), but that may end up
 * not getting generated if they are implied by any constraints
 * enforced by inner loops.
 *
 * "strides" contains the stride of each loop.  The number of elements
 * is equal to the number of dimensions in "domain".
 * "offsets" contains the offsets of strided loops.  If s is the stride
 * for a given dimension and f is the corresponding offset, then the
 * dimension takes on values
 *
 *	f + s a
 *
 * with a an integer.  For non-strided loops, the offset is zero.
 *
 * "iterators" contains the loop iterators of both generated and
 * to be generated loops.  The number of elements is at least as
 * large as the dimension of the internal schedule domain.  The
 * number may be larger, in which case the additional ids can be
 * used in a nested AST generation should the schedule be non-injective.
 *
 * "values" lives in the space
 *
 *	[O -> S] -> [O -> S]		(or S -> S)
 *
 * and expresses (if possible) loop iterators in terms of parameters
 * and outer loop iterators.  If the value of a given loop iterator
 * cannot be expressed as an affine expression (either because the iterator
 * attains multiple values or because the single value is a piecewise
 * affine expression), then it is expressed in "values" as being equal
 * to itself.
 *
 * "value" is the value of the loop iterator at the current depth.
 * It is NULL if it has not been computed yet or if the value of the
 * given loop iterator cannot be expressed as a piecewise affine expression
 * (because the iterator attains multiple values).
 *
 * "schedule_map" maps the internal schedule domain to the external schedule
 * domain.  It may be NULL if it hasn't been computed yet.
 * See isl_ast_build_get_schedule_map_multi_aff.
 *
 * "internal2input" maps the internal schedule domain to the original
 * input schedule domain.  In case of a schedule tree input, the original
 * input schedule domain consist of the flat product of all outer
 * band node spaces, including the current band node.
 * It may be NULL if there no longer is such a uniform mapping
 * (because different iterations have been rescheduled differently).
 *
 * "options" contains the AST build options in case we are generating
 * an AST from a flat schedule map.  When creating an AST from a schedule
 * tree, this field is ignored.
 *
 * The "create_leaf" callback is called for every leaf in the generated AST.
 * The callback is responsible for creating the node to be placed at those
 * leaves.  If this callback is not set, then isl will generated user
 * nodes with call expressions corresponding to an element of the domain.
 *
 * The "at_each_domain" callback is called on every node created to represent
 * an element of the domain.  Each of these nodes is a user node
 * with as expression a call expression.
 *
 * The "before_each_for" callback is called on each for node before
 * its children have been created.
 *
 * The "after_each_for" callback is called on each for node after
 * its children have been created.
 *
 * The "before_each_mark" callback is called before we handle the subtree
 * of an isl_schedule_node_mark node.
 *
 * The "after_each_mark" callback is called after we have handled the subtree
 * of an isl_schedule_node_mark node.
 *
 * "executed" contains the inverse schedule at this point
 * of the AST generation.
 * It is currently only used in isl_ast_build_get_schedule, which is
 * in turn only used by user code from within a callback.
 * The value is set right before we may be calling such a callback.
 *
 * "single_valued" is set if the current inverse schedule (which may or may
 * not be stored in "executed") is known to be single valued, specifically
 * an inverse schedule that was not (appeared not to be) single valued
 * is extended to a single valued inverse schedule.  This is mainly used
 * to avoid an infinite recursion when we fail to detect later on that
 * the extended inverse schedule is single valued.
 *
 * "node" points to the current band node in case we are generating
 * an AST from a schedule tree.  It may be NULL if we are not generating
 * an AST from a schedule tree or if we are not inside a band node.
 *
 * "loop_type" originally contains loop AST generation types for
 * the "n" members of "node" and it is updated (along with "n") when
 * a schedule dimension is inserted.
 * It is NULL if "node" is NULL.
 *
 * "isolated" is the piece of the schedule domain isolated by the isolate
 * option on the current band.  This set may be NULL if we have not checked
 * for the isolate option yet.
 */
================================================================================

文件路径: ./isl_ast_codegen.c
注释行数: 19
注释内容:
/* Generate an AST for a single domain based on
 * the (non single valued) inverse schedule "executed".
 *
 * We extend the schedule with the iteration domain
 * and continue generating through a call to generate_code.
 *
 * In particular, if executed has the form
 *
 *	S -> D
 *
 * then we continue generating code on
 *
 *	[S -> D] -> D
 *
 * The extended inverse schedule is clearly single valued
 * ensuring that the nested generate_code will not reach this function,
 * but will instead create calls to all elements of D that need
 * to be executed from the current schedule domain.
 */
================================================================================

文件路径: ./isl_ast_codegen.c
注释行数: 35
注释内容:
/* Generate an AST for a single domain based on
 * the inverse schedule "executed" and add it to data->list.
 *
 * If there is more than one domain element associated to the current
 * schedule "time", then we need to continue the generation process
 * in generate_non_single_valued.
 * Note that the inverse schedule being single-valued may depend
 * on constraints that are only available in the original context
 * domain specified by the user.  We therefore first introduce
 * some of the constraints of data->build->domain.  In particular,
 * we intersect with a single-disjunct approximation of this set.
 * We perform this approximation to avoid further splitting up
 * the executed relation, possibly introducing a disjunctive guard
 * on the statement.
 *
 * On the other hand, we only perform the test after having taken the gist
 * of the domain as the resulting map is the one from which the call
 * expression is constructed.  Using this map to construct the call
 * expression usually yields simpler results in cases where the original
 * map is not obviously single-valued.
 * If the original map is obviously single-valued, then the gist
 * operation is skipped.
 *
 * Because we perform the single-valuedness test on the gisted map,
 * we may in rare cases fail to recognize that the inverse schedule
 * is single-valued.  This becomes problematic if this happens
 * from the recursive call through generate_non_single_valued
 * as we would then end up in an infinite recursion.
 * We therefore check if we are inside a call to generate_non_single_valued
 * and revert to the ungisted map if the gisted map turns out not to be
 * single-valued.
 *
 * Otherwise, call add_domain to generate a call expression (with guard) and
 * to call the at_each_domain callback, if any.
 */
================================================================================

文件路径: ./isl_ast_codegen.c
注释行数: 20
注释内容:
/* Extract a lower bound on dimension "pos" from constraint "c".
 *
 * If the constraint is of the form
 *
 *	a x + f(...) >= 0
 *
 * then we essentially return
 *
 *	l = ceil(-f(...)/a)
 *
 * However, if the current dimension is strided, then we need to make
 * sure that the lower bound we construct is of the form
 *
 *	f + s a
 *
 * with f the offset and s the stride.
 * We therefore compute
 *
 *	f + s * ceil((l - f)/s)
 */
================================================================================

文件路径: ./isl_ast_codegen.c
注释行数: 11
注释内容:
/* Update "graft" based on "sub_build" for the degenerate case.
 *
 * "build" is the build in which graft->node was created
 * "sub_build" contains information about the current level itself,
 * including the single value attained.
 *
 * We set the initialization part of the for loop to the single
 * value attained by the current dimension.
 * The increment and condition are not strictly needed as the are known
 * to be "1" and "iterator <= value" respectively.
 */
================================================================================

文件路径: ./isl_ast_codegen.c
注释行数: 28
注释内容:
/* Compute the constraints on the outer dimensions enforced by
 * graft->node and add those constraints to graft->enforced,
 * in case the upper bound is expressed as a set "upper".
 *
 * In particular, if l(...) is a lower bound in "lower", and
 *
 *	-a i + f(...) >= 0		or	a i <= f(...)
 *
 * is an upper bound ocnstraint on the current dimension i,
 * then the for loop enforces the constraint
 *
 *	-a l(...) + f(...) >= 0		or	a l(...) <= f(...)
 *
 * We therefore simply take each lower bound in turn, plug it into
 * the upper bounds and compute the intersection over all lower bounds.
 *
 * If a lower bound is a rational expression, then
 * isl_basic_set_preimage_multi_aff will force this rational
 * expression to have only integer values.  However, the loop
 * itself does not enforce this integrality constraint.  We therefore
 * use the ceil of the lower bounds instead of the lower bounds themselves.
 * Other constraints will make sure that the for loop is only executed
 * when each of the lower bounds attains an integral value.
 * In particular, potentially rational values only occur in
 * lower_bound if the offset is a (seemingly) rational expression,
 * but then outer conditions will make sure that this rational expression
 * only attains integer values.
 */
================================================================================

文件路径: ./isl_ast_codegen.c
注释行数: 8
注释内容:
/* Compute the constraints on the outer dimensions enforced by
 * graft->node and add those constraints to graft->enforced,
 * in case the upper bound is expressed as
 * a list of affine expressions "upper".
 *
 * The enforced condition is that each lower bound expression is less
 * than or equal to each upper bound expression.
 */
================================================================================

文件路径: ./isl_ast_codegen.c
注释行数: 13
注释内容:
/* Set the condition part of the for node graft->node in case
 * the upper bound is represented as a list of piecewise affine expressions.
 *
 * In particular, set the condition to
 *
 *	iterator <= min(list of upper bounds)
 *
 * If each of the upper bounds has a negative constant term, then
 * set the condition to
 *
 *	iterator < min(list of (upper bound + 1)s)
 *
 */
================================================================================

文件路径: ./isl_ast_codegen.c
注释行数: 3
注释内容:
/* Set the condition part of the for node graft->node in case
 * the upper bound is represented as a set.
 */
================================================================================

文件路径: ./isl_ast_codegen.c
注释行数: 8
注释内容:
/* Fill in the expressions of the for node in graft->node.
 *
 * In particular,
 * - set the initialization part of the loop to the maximum of the lower bounds
 * - extract the increment from the stride of the current dimension
 * - construct the for condition either based on a list of upper bounds
 *	or on a set of upper bound constraints.
 */
================================================================================

文件路径: ./isl_ast_codegen.c
注释行数: 4
注释内容:
/* Increment data->n_indep, data->lower or data->upper depending
 * on whether "c" is independenct of dimensions data->pos,
 * a lower bound or an upper bound.
 */
================================================================================

文件路径: ./isl_ast_codegen.c
注释行数: 16
注释内容:
/* Update "graft" based on "bounds" and "domain" for the generic,
 * non-degenerate, case.
 *
 * "list" respresent the list of bounds that need to be encoded by
 * the for loop.  Only the constraints that involve the iterator
 * are relevant here.  The other constraints are taken care of by
 * the caller and are included in the generated constraints of "build".
 * "domain" is the subset of the intersection of the constraints
 * for which some code is executed.
 * "build" is the build in which graft->node was created.
 *
 * We separate lower bounds, upper bounds and constraints that
 * are independent of the loop iterator.
 *
 * The actual for loop bounds are generated in refine_generic_bounds.
 */
================================================================================

文件路径: ./isl_ast_codegen.c
注释行数: 11
注释内容:
/* Update "graft" based on "bounds" and "domain" for the generic,
 * non-degenerate, case.
 *
 * "bounds" respresent the bounds that need to be encoded by
 * the for loop (or a guard around the for loop).
 * "domain" is the subset of "bounds" for which some code is executed.
 * "build" is the build in which graft->node was created.
 *
 * We break up "bounds" into a list of constraints and continue with
 * refine_generic_split.
 */
================================================================================

文件路径: ./isl_ast_codegen.c
注释行数: 5
注释内容:
/* If constraint "c" involves the input dimension data->depth,
 * then make sure that all the other coefficients are multiples of data->m,
 * reducing data->m if needed.
 * Break out of the iteration if data->m has become equal to "1".
 */
================================================================================

文件路径: ./isl_ast_codegen.c
注释行数: 5
注释内容:
/* For each constraint of "bmap" that involves the input dimension data->depth,
 * make sure that all the other coefficients are multiples of data->m,
 * reducing data->m if needed.
 * Break out of the iteration if data->m has become equal to "1".
 */
================================================================================

文件路径: ./isl_ast_codegen.c
注释行数: 5
注释内容:
/* For each constraint of "map" that involves the input dimension data->depth,
 * make sure that all the other coefficients are multiples of data->m,
 * reducing data->m if needed.
 * Break out of the iteration if data->m has become equal to "1".
 */
================================================================================

文件路径: ./isl_ast_codegen.c
注释行数: 9
注释内容:
/* Call generate_sorted_domains on "scc", fuse the result into a list
 * with either zero or one graft and collect the these single element
 * lists into data->list.
 *
 * If there is only one component, i.e., if the number of basic sets
 * in the current component is equal to the total number of basic sets,
 * then data->single is set to 1 and the result of generate_sorted_domains
 * is not fused.
 */
================================================================================

文件路径: ./isl_ast_codegen.c
注释行数: 5
注释内容:
/* Split data->domain into pieces that intersect with the range of "map"
 * and pieces that do not intersect with the range of "map"
 * and then add that part of the range of "map" that does not intersect
 * with data->domain.
 */
================================================================================

文件路径: ./isl_ast_codegen.c
注释行数: 14
注释内容:
/* Is the lower bound "lower" with corresponding iteration count "n"
 * better than the one stored in "data"?
 * If there is no upper bound on the iteration count ("n" is infinity) or
 * if the count is too large, then we cannot use this lower bound.
 * Otherwise, if there was no previous lower bound or
 * if the iteration count of the new lower bound is smaller than
 * the iteration count of the previous lower bound, then we consider
 * the new lower bound to be better.
 * If the iteration count is the same, then compare the number
 * of integer divisions that would be needed to express
 * the iterator value at the first slice in the unrolling
 * according to the lower bound.  If we end up computing this
 * number, then store the lowest value in data->n_div.
 */
================================================================================

文件路径: ./isl_ast_codegen.c
注释行数: 33
注释内容:
/* Call "fn" on each iteration of the current dimension of "domain".
 * If "init" is not NULL, then it is called with the number of
 * iterations before any call to "fn".
 * Return -1 on failure.
 *
 * Since we are going to be iterating over the individual values,
 * we first check if there are any strides on the current dimension.
 * If there is, we rewrite the current dimension i as
 *
 *		i = stride i' + offset
 *
 * and then iterate over individual values of i' instead.
 *
 * We then look for a lower bound on i' and a size such that the domain
 * is a subset of
 *
 *	{ [j,i'] : l(j) <= i' < l(j) + n }
 *
 * and then take slices of the domain at values of i'
 * between l(j) and l(j) + n - 1.
 *
 * We compute the unshifted simple hull of each slice to ensure that
 * we have a single basic set per offset.  The slicing constraint
 * may get simplified away before the unshifted simple hull is taken
 * and may therefore in some rare cases disappear from the result.
 * We therefore explicitly add the constraint back after computing
 * the unshifted simple hull to ensure that the basic sets
 * remain disjoint.  The constraints that are dropped by taking the hull
 * will be taken into account at the next level, as in the case of the
 * atomic option.
 *
 * Finally, we map i' back to i and call "fn".
 */
================================================================================

文件路径: ./isl_ast_codegen.c
注释行数: 6
注释内容:
/* Given an iteration of an unrolled domain represented by "bset",
 * add it to data->domains->list.
 * Since we may have dropped some constraints, we intersect with
 * the class domain again to ensure that each element in the list
 * is disjoint from the other class domains.
 */
================================================================================

文件路径: ./isl_ast_codegen.c
注释行数: 12
注释内容:
/* Split up the schedule domain into uniform basic sets,
 * in the sense that each element in a basic set is associated to
 * elements of the same domains, and add the result to domains->list.
 * Do this for that part of the schedule domain that lies in the
 * intersection of "class_domain" and the separate option domain.
 *
 * "class_domain" may or may not include the constraints
 * of the schedule domain, but this does not make a difference
 * since we are going to intersect it with the domain of the inverse schedule.
 * If it includes schedule domain constraints, then they may involve
 * inner dimensions, but we will eliminate them in separation_domain.
 */
================================================================================

文件路径: ./isl_ast_codegen.c
注释行数: 37
注释内容:
/* Split up the domain at the current depth into disjoint
 * basic sets for which code should be generated separately
 * for the given separation class domain.
 *
 * If any separation classes have been defined, then "class_domain"
 * is the domain of the current class and does not refer to inner dimensions.
 * Otherwise, "class_domain" is the universe domain.
 *
 * We first make sure that the class domain is disjoint from
 * previously considered class domains.
 *
 * The separate domains can be computed directly from the "class_domain".
 *
 * The unroll, atomic and remainder domains need the constraints
 * from the schedule domain.
 *
 * For unrolling, the actual schedule domain is needed (with divs that
 * may refer to the current dimension) so that stride detection can be
 * performed.
 *
 * For atomic and remainder domains, inner dimensions and divs involving
 * the current dimensions should be eliminated.
 * In case we are working within a separation class, we need to intersect
 * the result with the current "class_domain" to ensure that the domains
 * are disjoint from those generated from other class domains.
 *
 * The domain that has been made atomic may be larger than specified
 * by the user since it needs to be representable as a single basic set.
 * This possibly larger domain is removed from class_domain by
 * compute_atomic_domain.  It is computed first so that the extended domain
 * would not overlap with any domains computed before.
 * Similary, the unrolled domains may have some constraints removed and
 * may therefore also be larger than specified by the user.
 *
 * If anything is left after handling separate, unroll and atomic,
 * we split it up into basic sets and append the basic sets to domains->list.
 */
================================================================================

文件路径: ./isl_ast_codegen.c
注释行数: 7
注释内容:
/* Split up the domain at the current depth into disjoint
 * basic sets for which code should be generated separately
 * for the separation class identified by "pnt".
 *
 * We extract the corresponding class domain from domains->sep_class,
 * eliminate inner dimensions and pass control to compute_partial_domains.
 */
================================================================================

文件路径: ./isl_ast_codegen.c
注释行数: 3
注释内容:
/* Given an iteration of an unrolled domain represented by "bset",
 * generate the corresponding AST and add the result to data->list.
 */
================================================================================

文件路径: ./isl_ast_codegen.c
注释行数: 79
注释内容:
/* Construct a shifted inverse schedule based on the original inverse schedule,
 * the stride and the offset.
 *
 * The original inverse schedule is specified as the "map" fields
 * of the elements of "domain" indexed by the first "n" elements of "order".
 *
 * "stride" and "offset" are such that the difference
 * between the values of the current dimension of domain "i"
 * and the values of the current dimension for some reference domain are
 * equal to
 *
 *	stride * integer + offset[i]
 *
 * Moreover, 0 <= offset[i] < stride.
 *
 * For each domain, we create a map
 *
 *	{ [..., j, ...] -> [..., j - offset[i], offset[i], ....] }
 *
 * where j refers to the current dimension and the other dimensions are
 * unchanged, and apply this map to the original schedule domain.
 *
 * For example, for the original schedule
 *
 *	{ A[i] -> [2i]: 0 <= i < 10; B[i] -> [2i+1] : 0 <= i < 10 }
 *
 * and assuming the offset is 0 for the A domain and 1 for the B domain,
 * we apply the mapping
 *
 *	{ [j] -> [j, 0] }
 *
 * to the schedule of the "A" domain and the mapping
 *
 *	{ [j - 1] -> [j, 1] }
 *
 * to the schedule of the "B" domain.
 *
 *
 * Note that after the transformation, the differences between pairs
 * of values of the current dimension over all domains are multiples
 * of stride and that we have therefore exposed the stride.
 *
 *
 * To see that the mapping preserves the lexicographic order,
 * first note that each of the individual maps above preserves the order.
 * If the value of the current iterator is j1 in one domain and j2 in another,
 * then if j1 = j2, we know that the same map is applied to both domains
 * and the order is preserved.
 * Otherwise, let us assume, without loss of generality, that j1 < j2.
 * If c1 >= c2 (with c1 and c2 the corresponding offsets), then
 *
 *	j1 - c1 < j2 - c2
 *
 * and the order is preserved.
 * If c1 < c2, then we know
 *
 *	0 <= c2 - c1 < s
 *
 * We also have
 *
 *	j2 - j1 = n * s + r
 *
 * with n >= 0 and 0 <= r < s.
 * In other words, r = c2 - c1.
 * If n > 0, then
 *
 *	j1 - c1 < j2 - c2
 *
 * If n = 0, then
 *
 *	j1 - c1 = j2 - c2
 *
 * and so
 *
 *	(j1 - c1, c1) << (j2 - c2, c2)
 *
 * with "<<" the lexicographic order, proving that the order is preserved
 * in all cases.
 */
================================================================================

文件路径: ./isl_ast_codegen.c
注释行数: 70
注释内容:
/* Generate code for a single component.
 *
 * The component inverse schedule is specified as the "map" fields
 * of the elements of "domain" indexed by the first "n" elements of "order".
 *
 * This function may modify the "set" fields of "domain".
 *
 * Before proceeding with the actual code generation for the component,
 * we first check if there are any "shifted" strides, meaning that
 * the schedule domains of the individual domains are all strided,
 * but that they have different offsets, resulting in the union
 * of schedule domains not being strided anymore.
 *
 * The simplest example is the schedule
 *
 *	{ A[i] -> [2i]: 0 <= i < 10; B[i] -> [2i+1] : 0 <= i < 10 }
 *
 * Both schedule domains are strided, but their union is not.
 * This function detects such cases and then rewrites the schedule to
 *
 *	{ A[i] -> [2i, 0]: 0 <= i < 10; B[i] -> [2i, 1] : 0 <= i < 10 }
 *
 * In the new schedule, the schedule domains have the same offset (modulo
 * the stride), ensuring that the union of schedule domains is also strided.
 *
 *
 * If there is only a single domain in the component, then there is
 * nothing to do.   Similarly, if the current schedule dimension has
 * a fixed value for almost all domains then there is nothing to be done.
 * In particular, we need at least two domains where the current schedule
 * dimension does not have a fixed value.
 * Finally, in case of a schedule map input,
 * if any of the options refer to the current schedule dimension,
 * then we bail out as well.  It would be possible to reformulate the options
 * in terms of the new schedule domain, but that would introduce constraints
 * that separate the domains in the options and that is something we would
 * like to avoid.
 * In the case of a schedule tree input, we bail out if any of
 * the descendants of the current schedule node refer to outer
 * schedule nodes in any way.
 *
 *
 * To see if there is any shifted stride, we look at the differences
 * between the values of the current dimension in pairs of domains
 * for equal values of outer dimensions.  These differences should be
 * of the form
 *
 *	m x + r
 *
 * with "m" the stride and "r" a constant.  Note that we cannot perform
 * this analysis on individual domains as the lower bound in each domain
 * may depend on parameters or outer dimensions and so the current dimension
 * itself may not have a fixed remainder on division by the stride.
 *
 * In particular, we compare the first domain that does not have an
 * obviously fixed value for the current dimension to itself and all
 * other domains and collect the offsets and the gcd of the strides.
 * If the gcd becomes one, then we failed to find shifted strides.
 * If the gcd is zero, then the differences were all fixed, meaning
 * that some domains had non-obviously fixed values for the current dimension.
 * If all the offsets are the same (for those domains that do not have
 * an obviously fixed value for the current dimension), then we do not
 * apply the transformation.
 * If none of the domains were skipped, then there is nothing to do.
 * If some of them were skipped, then if we apply separation, the schedule
 * domain should get split in pieces with a (non-shifted) stride.
 *
 * Otherwise, we apply a shift to expose the stride in
 * generate_shift_component.
 */
================================================================================

文件路径: ./isl_ast_codegen.c
注释行数: 9
注释内容:
/* Internal data for any_scheduled_after.
 *
 * "build" is the build in which the AST is constructed.
 * "depth" is the number of loops that have already been generated
 * "group_coscheduled" is a local copy of options->ast_build_group_coscheduled
 * "domain" is an array of set-map pairs corresponding to the different
 * iteration domains.  The set is the schedule domain, i.e., the domain
 * of the inverse schedule, while the map is the inverse schedule itself.
 */
================================================================================

文件路径: ./isl_ast_codegen.c
注释行数: 14
注释内容:
/* Is any element of domain "i" scheduled after any element of domain "j"
 * (for a common iteration of the first data->depth loops)?
 *
 * data->domain[i].set contains the domain of the inverse schedule
 * for domain "i", i.e., elements in the schedule domain.
 *
 * If we are inside a band of a schedule tree and there is a pair
 * of elements in the two domains that is schedule together by
 * the current band, then we check if any element of "i" may be schedule
 * after element of "j" by the descendants of the band node.
 *
 * If data->group_coscheduled is set, then we also return 1 if there
 * is any pair of elements in the two domains that are scheduled together.
 */
================================================================================

文件路径: ./isl_ast_codegen.c
注释行数: 20
注释内容:
/* Given an inverse schedule in terms of the external build schedule, i.e.,
 *
 *	[E -> S] -> D
 *
 * with E the external build schedule and S the additional schedule "space",
 * reformulate the inverse schedule in terms of the internal schedule domain,
 * i.e., return
 *
 *	[I -> S] -> D
 *
 * We first obtain a mapping
 *
 *	I -> E
 *
 * take the inverse and the product with S -> S, resulting in
 *
 *	[I -> S] -> [E -> S]
 *
 * Applying the map to the input produces the desired result.
 */
================================================================================

文件路径: ./isl_ast_codegen.c
注释行数: 37
注释内容:
/* Generate an AST that visits the elements in the range of data->executed
 * in the relative order specified by the corresponding domain element(s)
 * for those domain elements that belong to "set".
 * Add the result to data->list.
 *
 * The caller ensures that "set" is a universe domain.
 * "space" is the space of the additional part of the schedule.
 * It is equal to the space of "set" if build->domain is parametric.
 * Otherwise, it is equal to the range of the wrapped space of "set".
 *
 * If the build space is not parametric and
 * if isl_ast_build_node_from_schedule_map
 * was called from an outside user (data->internal not set), then
 * the (inverse) schedule refers to the external build domain and needs to
 * be transformed to refer to the internal build domain.
 *
 * If the build space is parametric, then we add some of the parameter
 * constraints to the executed relation.  Adding these constraints
 * allows for an earlier detection of conflicts in some cases.
 * However, we do not want to divide the executed relation into
 * more disjuncts than necessary.  We therefore approximate
 * the constraints on the parameters by a single disjunct set.
 *
 * The build is extended to include the additional part of the schedule.
 * If the original build space was not parametric, then the options
 * in data->build refer only to the additional part of the schedule
 * and they need to be adjusted to refer to the complete AST build
 * domain.
 *
 * After having adjusted inverse schedule and build, we start generating
 * code with the outer loop of the current code generation
 * in generate_next_level.
 *
 * If the original build space was not parametric, we undo the embedding
 * on the resulting isl_ast_node_list so that it can be used within
 * the outer AST build.
 */
================================================================================

文件路径: ./isl_ast_codegen.c
注释行数: 17
注释内容:
/* Generate an AST that visits the elements in the range of data->executed
 * in the relative order specified by the corresponding domain element(s)
 * for those domain elements that belong to "set".
 * Add the result to data->list.
 *
 * The caller ensures that "set" is a universe domain.
 *
 * If the build space S is not parametric, then the space of "set"
 * need to be a wrapped relation with S as domain.  That is, it needs
 * to be of the form
 *
 *	[S -> T]
 *
 * Check this property and pass control to generate_code_in_space
 * passing along T.
 * If the build space is not parametric, then T is the space of "set".
 */
================================================================================

文件路径: ./isl_bernstein.c
注释行数: 10
注释内容:
/* Extract the coefficients of the Bernstein base polynomials and store
 * them in data->fold and data->fold_tight.
 *
 * In particular, the coefficient of each monomial
 * of multi-degree (k[0], k[1], ..., k[n-1]) is divided by the corresponding
 * multinomial coefficient d!/k[0]! k[1]! ... k[n-1]!
 *
 * c[i] contains the coefficient of the selected powers of the first i+1 vars.
 * multinom[i] contains the partial multinomial coefficient.
 */
================================================================================

文件路径: ./isl_bernstein.c
注释行数: 12
注释内容:
/* Perform bernstein expansion on the parametric vertices that are active
 * on "cell".
 *
 * data->poly has been homogenized in the calling function.
 *
 * We plug in the barycentric coordinates for the set variables
 *
 *		\vec x = \sum_i \alpha_i v_i(\vec p)
 *
 * and the constant "1 = \sum_i \alpha_i" for the homogeneous dimension.
 * Next, we extract the coefficients of the Bernstein base polynomials.
 */
================================================================================

文件路径: ./isl_bernstein.c
注释行数: 11
注释内容:
/* Compute a bound on the polynomial defined over the parametric polytope
 * using bernstein expansion and store the result
 * in bound->pwf and bound->pwf_tight.
 *
 * If bernstein_recurse is set to ISL_BERNSTEIN_FACTORS, we check if
 * the polytope can be factorized and apply bernstein expansion recursively
 * on the factors.
 * If bernstein_recurse is set to ISL_BERNSTEIN_INTERVALS, we apply
 * bernstein expansion recursively on each dimension.
 * Otherwise, we apply bernstein expansion on the entire polytope.
 */
================================================================================

文件路径: ./isl_scheduler.c
注释行数: 39
注释内容:
/* An edge in the dependence graph.  An edge may be used to
 * ensure validity of the generated schedule, to minimize the dependence
 * distance or both
 *
 * map is the dependence relation, with i -> j in the map if j depends on i
 * tagged_condition and tagged_validity contain the union of all tagged
 *	condition or conditional validity dependence relations that
 *	specialize the dependence relation "map"; that is,
 *	if (i -> a) -> (j -> b) is an element of "tagged_condition"
 *	or "tagged_validity", then i -> j is an element of "map".
 *	If these fields are NULL, then they represent the empty relation.
 * src is the source node
 * dst is the sink node
 *
 * types is a bit vector containing the types of this edge.
 * validity is set if the edge is used to ensure correctness
 * coincidence is used to enforce zero dependence distances
 * proximity is set if the edge is used to minimize dependence distances
 * condition is set if the edge represents a condition
 *	for a conditional validity schedule constraint
 * local can only be set for condition edges and indicates that
 *	the dependence distance over the edge should be zero
 * conditional_validity is set if the edge is used to conditionally
 *	ensure correctness
 *
 * For validity edges, start and end mark the sequence of inequality
 * constraints in the LP problem that encode the validity constraint
 * corresponding to this edge.
 *
 * During clustering, an edge may be marked "no_merge" if it should
 * not be used to merge clusters.
 * The weight is also only used during clustering and it is
 * an indication of how many schedule dimensions on either side
 * of the schedule constraints can be aligned.
 * If the weight is negative, then this means that this edge was postponed
 * by has_bounded_distances or any_no_merge.  The original weight can
 * be retrieved by adding 1 + graph->max_weight, with "graph"
 * the graph containing this edge.
 */
================================================================================

文件路径: ./isl_scheduler.c
注释行数: 2
注释内容:
/* Add the given edge to graph->edge_table[type].
 */
================================================================================

文件路径: ./isl_scheduler.c
注释行数: 3
注释内容:
/* Set the entries of node->max to the value of the schedule_max_coefficient
 * option, if set.
 */
================================================================================

文件路径: ./isl_scheduler.c
注释行数: 15
注释内容:
/* Set the entries of node->max to the minimum of the schedule_max_coefficient
 * option (if set) and half of the minimum of the sizes in the other
 * dimensions.  Round up when computing the half such that
 * if the minimum of the sizes is one, half of the size is taken to be one
 * rather than zero.
 * If the global minimum is unbounded (i.e., if both
 * the schedule_max_coefficient is not set and the sizes in the other
 * dimensions are unbounded), then store a negative value.
 * If the schedule coefficient is close to the size of the instance set
 * in another dimension, then the schedule may represent a loop
 * coalescing transformation (especially if the coefficient
 * in that other dimension is one).  Forcing the coefficient to be
 * smaller than or equal to half the minimal size should avoid this
 * situation.
 */
================================================================================

文件路径: ./isl_scheduler.c
注释行数: 6
注释内容:
/* Construct a map that isolates the variable in position "pos" in "set".
 *
 * That is, construct
 *
 *	[i_0, ..., i_pos-1, i_pos+1, ...] -> [i_pos]
 */
================================================================================

文件路径: ./isl_scheduler.c
注释行数: 16
注释内容:
/* Compute the size of the compressed domain in each dimension and
 * store the results in node->sizes.
 * "uncompressed" is the original domain (without compression).
 *
 * First compress the domain if needed and then compute the size
 * in each direction.
 * If the domain is not convex, then the sizes are computed
 * on a convex superset in order to avoid picking up sizes
 * that are valid for the individual disjuncts, but not for
 * the domain as a whole.
 *
 * If any of the sizes turns out to be zero, then this means
 * that this dimension has a fixed value in terms of
 * the other dimensions.  Perform an (extra) compression
 * to remove this dimensions.
 */
================================================================================

文件路径: ./isl_scheduler.c
注释行数: 14
注释内容:
/* Compute the size of the instance set "set" of "node", after compression,
 * as well as bounds on the corresponding coefficients, if needed.
 *
 * The sizes are needed when the schedule_treat_coalescing option is set.
 * The bounds are needed when the schedule_treat_coalescing option or
 * the schedule_max_coefficient option is set.
 *
 * If the schedule_treat_coalescing option is not set, then at most
 * the bounds need to be set and this is done in set_max_coefficient.
 * Otherwise, compute the size of the compressed domain
 * in each direction and store the results in node->size.
 * Finally, set the bounds on the coefficients based on the sizes
 * and the schedule_max_coefficient option in compute_max_coefficient.
 */
================================================================================

文件路径: ./isl_scheduler.c
注释行数: 13
注释内容:
/* Insert dummy tags in domain and range of "map".
 *
 * In particular, if "map" is of the form
 *
 *	A -> B
 *
 * then return
 *
 *	[A -> dummy_tag] -> [B -> dummy_tag]
 *
 * where the dummy_tags are identical and equal to any dummy tags
 * introduced by any other call to this function.
 */
================================================================================

文件路径: ./isl_scheduler.c
注释行数: 23
注释内容:
/* Add a new edge to the graph based on the given map
 * and add it to data->graph->edge_table[data->type].
 * If a dependence relation of a given type happens to be identical
 * to one of the dependence relations of a type that was added before,
 * then we don't create a new edge, but instead mark the original edge
 * as also representing a dependence of the current type.
 *
 * Edges of type isl_edge_condition or isl_edge_conditional_validity
 * may be specified as "tagged" dependence relations.  That is, "map"
 * may contain elements (i -> a) -> (j -> b), where i -> j denotes
 * the dependence on iterations and a and b are tags.
 * edge->map is set to the relation containing the elements i -> j,
 * while edge->tagged_condition and edge->tagged_validity contain
 * the union of all the "map" relations
 * for which extract_edge is called that result in the same edge->map.
 *
 * If the source or the destination node is compressed, then
 * intersect both "map" and "tagged" with the constraints that
 * were used to construct the compression.
 * This ensures that there are no schedule constraints defined
 * outside of these domains, while the scheduler no longer has
 * any control over those outside parts.
 */
================================================================================

文件路径: ./isl_scheduler.c
注释行数: 2
注释内容:
/* Sort the elements of graph->sorted according to the corresponding SCCs.
 */
================================================================================

文件路径: ./isl_scheduler.c
注释行数: 20
注释内容:
/* Construct an isl_dim_map for mapping constraints on coefficients
 * for "node" to the corresponding positions in graph->lp.
 * "offset" is the offset of the coefficients for the variables
 * in the input constraints.
 * "s" is the sign of the mapping.
 *
 * The input constraints are given in terms of the coefficients
 * (c_0, c_x) or (c_0, c_n, c_x).
 * The mapping produced by this function essentially plugs in
 * (0, c_i_x^+ - c_i_x^-) if s = 1 and
 * (0, -c_i_x^+ + c_i_x^-) if s = -1 or
 * (0, 0, c_i_x^+ - c_i_x^-) if s = 1 and
 * (0, 0, -c_i_x^+ + c_i_x^-) if s = -1.
 * In graph->lp, the c_i_x^- appear before their c_i_x^+ counterpart.
 * Furthermore, the order of these pairs is the opposite of that
 * of the corresponding coefficients.
 *
 * The caller can extend the mapping to also map the other coefficients
 * (and therefore not plug in 0).
 */
================================================================================

文件路径: ./isl_scheduler.c
注释行数: 20
注释内容:
/* Construct an isl_dim_map for mapping constraints on coefficients
 * for "src" (node i) and "dst" (node j) to the corresponding positions
 * in graph->lp.
 * "offset" is the offset of the coefficients for the variables of "src"
 * in the input constraints.
 * "s" is the sign of the mapping.
 *
 * The input constraints are given in terms of the coefficients
 * (c_0, c_n, c_x, c_y).
 * The mapping produced by this function essentially plugs in
 * (c_j_0 - c_i_0, c_j_n - c_i_n,
 *  -(c_i_x^+ - c_i_x^-), c_j_x^+ - c_j_x^-) if s = 1 and
 * (-c_j_0 + c_i_0, -c_j_n + c_i_n,
 *  c_i_x^+ - c_i_x^-, -(c_j_x^+ - c_j_x^-)) if s = -1.
 * In graph->lp, the c_*^- appear before their c_*^+ counterpart.
 * Furthermore, the order of these pairs is the opposite of that
 * of the corresponding coefficients.
 *
 * The caller can further extend the mapping.
 */
================================================================================

文件路径: ./isl_scheduler.c
注释行数: 15
注释内容:
/* Add constraints to graph->lp that force validity for the given
 * dependence from a node i to itself.
 * That is, add constraints that enforce
 *
 *	(c_i_0 + c_i_n n + c_i_x y) - (c_i_0 + c_i_n n + c_i_x x)
 *	= c_i_x (y - x) >= 0
 *
 * for each (x,y) in R.
 * We obtain general constraints on coefficients (c_0, c_x)
 * of valid constraints for (y - x) and then plug in (0, c_i_x^+ - c_i_x^-),
 * where c_i_x = c_i_x^+ - c_i_x^-, with c_i_x^+ and c_i_x^- non-negative.
 * In graph->lp, the c_i_x^- appear before their c_i_x^+ counterpart.
 * Note that the result of intra_coefficients may also contain
 * parameter coefficients c_n, in which case 0 is plugged in for them as well.
 */
================================================================================

文件路径: ./isl_scheduler.c
注释行数: 13
注释内容:
/* Add constraints to graph->lp that force validity for the given
 * dependence from node i to node j.
 * That is, add constraints that enforce
 *
 *	(c_j_0 + c_j_n n + c_j_x y) - (c_i_0 + c_i_n n + c_i_x x) >= 0
 *
 * for each (x,y) in R.
 * We obtain general constraints on coefficients (c_0, c_n, c_x, c_y)
 * of valid constraints for R and then plug in
 * (c_j_0 - c_i_0, c_j_n - c_i_n, -(c_i_x^+ - c_i_x^-), c_j_x^+ - c_j_x^-),
 * where c_* = c_*^+ - c_*^-, with c_*^+ and c_*^- non-negative.
 * In graph->lp, the c_*^- appear before their c_*^+ counterpart.
 */
================================================================================

文件路径: ./isl_scheduler.c
注释行数: 42
注释内容:
/* Add constraints to graph->lp that bound the dependence distance for the given
 * dependence from a node i to itself.
 * If s = 1, we add the constraint
 *
 *	c_i_x (y - x) <= m_0 + m_n n
 *
 * or
 *
 *	-c_i_x (y - x) + m_0 + m_n n >= 0
 *
 * for each (x,y) in R.
 * If s = -1, we add the constraint
 *
 *	-c_i_x (y - x) <= m_0 + m_n n
 *
 * or
 *
 *	c_i_x (y - x) + m_0 + m_n n >= 0
 *
 * for each (x,y) in R.
 * We obtain general constraints on coefficients (c_0, c_n, c_x)
 * of valid constraints for (y - x) and then plug in (m_0, m_n, -s * c_i_x),
 * with each coefficient (except m_0) represented as a pair of non-negative
 * coefficients.
 *
 *
 * If "local" is set, then we add constraints
 *
 *	c_i_x (y - x) <= 0
 *
 * or
 *
 *	-c_i_x (y - x) <= 0
 *
 * instead, forcing the dependence distance to be (less than or) equal to 0.
 * That is, we plug in (0, 0, -s * c_i_x),
 * intra_coefficients is not required to have c_n in its result when
 * "local" is set.  If they are missing, then (0, -s * c_i_x) is plugged in.
 * Note that dependences marked local are treated as validity constraints
 * by add_all_validity_constraints and therefore also have
 * their distances bounded by 0 from below.
 */
================================================================================

文件路径: ./isl_scheduler.c
注释行数: 47
注释内容:
/* Add constraints to graph->lp that bound the dependence distance for the given
 * dependence from node i to node j.
 * If s = 1, we add the constraint
 *
 *	(c_j_0 + c_j_n n + c_j_x y) - (c_i_0 + c_i_n n + c_i_x x)
 *		<= m_0 + m_n n
 *
 * or
 *
 *	-(c_j_0 + c_j_n n + c_j_x y) + (c_i_0 + c_i_n n + c_i_x x) +
 *		m_0 + m_n n >= 0
 *
 * for each (x,y) in R.
 * If s = -1, we add the constraint
 *
 *	-((c_j_0 + c_j_n n + c_j_x y) - (c_i_0 + c_i_n n + c_i_x x))
 *		<= m_0 + m_n n
 *
 * or
 *
 *	(c_j_0 + c_j_n n + c_j_x y) - (c_i_0 + c_i_n n + c_i_x x) +
 *		m_0 + m_n n >= 0
 *
 * for each (x,y) in R.
 * We obtain general constraints on coefficients (c_0, c_n, c_x, c_y)
 * of valid constraints for R and then plug in
 * (m_0 - s*c_j_0 + s*c_i_0, m_n - s*c_j_n + s*c_i_n,
 *  s*c_i_x, -s*c_j_x)
 * with each coefficient (except m_0, c_*_0 and c_*_n)
 * represented as a pair of non-negative coefficients.
 *
 *
 * If "local" is set (and s = 1), then we add constraints
 *
 *	(c_j_0 + c_j_n n + c_j_x y) - (c_i_0 + c_i_n n + c_i_x x) <= 0
 *
 * or
 *
 *	-((c_j_0 + c_j_n n + c_j_x y) + (c_i_0 + c_i_n n + c_i_x x)) >= 0
 *
 * instead, forcing the dependence distance to be (less than or) equal to 0.
 * That is, we plug in
 * (-s*c_j_0 + s*c_i_0, -s*c_j_n + s*c_i_n, s*c_i_x, -s*c_j_x).
 * Note that dependences marked local are treated as validity constraints
 * by add_all_validity_constraints and therefore also have
 * their distances bounded by 0 from below.
 */
================================================================================

文件路径: ./isl_scheduler.c
注释行数: 10
注释内容:
/* Add all validity constraints to graph->lp.
 *
 * An edge that is forced to be local needs to have its dependence
 * distances equal to zero.  We take care of bounding them by 0 from below
 * here.  add_all_proximity_constraints takes care of bounding them by 0
 * from above.
 *
 * If "use_coincidence" is set, then we treat coincidence edges as local edges.
 * Otherwise, we ignore them.
 */
================================================================================

文件路径: ./isl_scheduler.c
注释行数: 12
注释内容:
/* Add constraints to graph->lp that bound the dependence distance
 * for all dependence relations.
 * If a given proximity dependence is identical to a validity
 * dependence, then the dependence distance is already bounded
 * from below (by zero), so we only need to bound the distance
 * from above.  (This includes the case of "local" dependences
 * which are treated as validity dependence by add_all_validity_constraints.)
 * Otherwise, we need to bound the distance both from above and from below.
 *
 * If "use_coincidence" is set, then we treat coincidence edges as local edges.
 * Otherwise, we ignore them.
 */
================================================================================

文件路径: ./isl_scheduler.c
注释行数: 28
注释内容:
/* Compute a basis for the rows in the linear part of the schedule
 * and extend this basis to a full basis.  The remaining rows
 * can then be used to force linear independence from the rows
 * in the schedule.
 *
 * In particular, given the schedule rows S, we compute
 *
 *	S   = H Q
 *	S U = H
 *
 * with H the Hermite normal form of S.  That is, all but the
 * first rank columns of H are zero and so each row in S is
 * a linear combination of the first rank rows of Q.
 * The matrix Q can be used as a variable transformation
 * that isolates the directions of S in the first rank rows.
 * Transposing S U = H yields
 *
 *	U^T S^T = H^T
 *
 * with all but the first rank rows of H^T zero.
 * The last rows of U^T are therefore linear combinations
 * of schedule coefficients that are all zero on schedule
 * coefficients that are linearly dependent on the rows of S.
 * At least one of these combinations is non-zero on
 * linearly independent schedule coefficients.
 * The rows are normalized to involve as few of the last
 * coefficients as possible and to have a positive initial value.
 */
================================================================================

文件路径: ./isl_scheduler.c
注释行数: 30
注释内容:
/* Add constraints to graph->lp that bound the values of
 * the parameter schedule coefficients of "node" to "max" and
 * the variable schedule coefficients to the corresponding entry
 * in node->max.
 * In either case, a negative value means that no bound needs to be imposed.
 *
 * For parameter coefficients, this amounts to adding a constraint
 *
 *	c_n <= max
 *
 * i.e.,
 *
 *	-c_n + max >= 0
 *
 * The variables coefficients are, however, not represented directly.
 * Instead, the variable coefficients c_x are written as differences
 * c_x = c_x^+ - c_x^-.
 * That is,
 *
 *	-max_i <= c_x_i <= max_i
 *
 * is encoded as
 *
 *	-max_i <= c_x_i^+ - c_x_i^- <= max_i
 *
 * or
 *
 *	-(c_x_i^+ - c_x_i^-) + max_i >= 0
 *	c_x_i^+ - c_x_i^- + max_i >= 0
 */
================================================================================

文件路径: ./isl_scheduler.c
注释行数: 8
注释内容:
/* Add constraints that bound the values of the variable and parameter
 * coefficients of the schedule.
 *
 * The maximal value of the coefficients is defined by the option
 * 'schedule_max_coefficient' and the entries in node->max.
 * These latter entries are only set if either the schedule_max_coefficient
 * option or the schedule_treat_coalescing option is set.
 */
================================================================================

文件路径: ./isl_scheduler.c
注释行数: 3
注释内容:
/* Add a constraint to graph->lp that equates the value at position
 * "sum_pos" to the sum of the "n" values starting at "first".
 */
================================================================================

文件路径: ./isl_scheduler.c
注释行数: 3
注释内容:
/* Add a constraint to graph->lp that equates the value at position
 * "sum_pos" to the sum of the parameter coefficients of all nodes.
 */
================================================================================

文件路径: ./isl_scheduler.c
注释行数: 3
注释内容:
/* Add a constraint to graph->lp that equates the value at position
 * "sum_pos" to the sum of the variable coefficients of all nodes.
 */
================================================================================

文件路径: ./isl_scheduler.c
注释行数: 30
注释内容:
/* Construct an ILP problem for finding schedule coefficients
 * that result in non-negative, but small dependence distances
 * over all dependences.
 * In particular, the dependence distances over proximity edges
 * are bounded by m_0 + m_n n and we compute schedule coefficients
 * with small values (preferably zero) of m_n and m_0.
 *
 * All variables of the ILP are non-negative.  The actual coefficients
 * may be negative, so each coefficient is represented as the difference
 * of two non-negative variables.  The negative part always appears
 * immediately before the positive part.
 * Other than that, the variables have the following order
 *
 *	- sum of positive and negative parts of m_n coefficients
 *	- m_0
 *	- sum of all c_n coefficients
 *		(unconstrained when computing non-parametric schedules)
 *	- sum of positive and negative parts of all c_x coefficients
 *	- positive and negative parts of m_n coefficients
 *	- for each node
 *		- positive and negative parts of c_i_x, in opposite order
 *		- c_i_n (if parametric)
 *		- c_i_0
 *
 * The constraints are those from the edges plus two or three equalities
 * to express the sums.
 *
 * If "use_coincidence" is set, then we treat coincidence edges as local edges.
 * Otherwise, we ignore them.
 */
================================================================================

文件路径: ./isl_scheduler.c
注释行数: 7
注释内容:
/* Solve the ILP problem constructed in setup_lp.
 * For each node such that all the remaining rows of its schedule
 * need to be non-trivial, we construct a non-triviality region.
 * This region imposes that the next row is independent of previous rows.
 * In particular, the non-triviality region enforces that at least
 * one of the linear combinations in the rows of node->indep is non-zero.
 */
================================================================================

文件路径: ./isl_scheduler.c
注释行数: 16
注释内容:
/* Add the constraints "coef" derived from an edge from "node" to itself
 * to graph->lp in order to respect the dependences and to try and carry them.
 * "pos" is the sequence number of the edge that needs to be carried.
 * "coef" represents general constraints on coefficients (c_0, c_x)
 * of valid constraints for (y - x) with x and y instances of the node.
 *
 * The constraints added to graph->lp need to enforce
 *
 *	(c_j_0 + c_j_x y) - (c_j_0 + c_j_x x)
 *	= c_j_x (y - x) >= e_i
 *
 * for each (x,y) in the dependence relation of the edge.
 * That is, (-e_i, c_j_x) needs to be plugged in for (c_0, c_x),
 * taking into account that each coefficient in c_j_x is represented
 * as a pair of non-negative coefficients.
 */
================================================================================

文件路径: ./isl_scheduler.c
注释行数: 24
注释内容:
/* Add the constraints "coef" derived from an edge from "src" to "dst"
 * to graph->lp in order to respect the dependences and to try and carry them.
 * "pos" is the sequence number of the edge that needs to be carried or
 * -1 if no attempt should be made to carry the dependences.
 * "coef" represents general constraints on coefficients (c_0, c_n, c_x, c_y)
 * of valid constraints for (x, y) with x and y instances of "src" and "dst".
 *
 * The constraints added to graph->lp need to enforce
 *
 *	(c_k_0 + c_k_n n + c_k_x y) - (c_j_0 + c_j_n n + c_j_x x) >= e_i
 *
 * for each (x,y) in the dependence relation of the edge or
 *
 *	(c_k_0 + c_k_n n + c_k_x y) - (c_j_0 + c_j_n n + c_j_x x) >= 0
 *
 * if pos is -1.
 * That is,
 * (-e_i + c_k_0 - c_j_0, c_k_n - c_j_n, -c_j_x, c_k_x)
 * or
 * (c_k_0 - c_j_0, c_k_n - c_j_n, -c_j_x, c_k_x)
 * needs to be plugged in for (c_0, c_n, c_x, c_y),
 * taking into account that each coefficient in c_j_x and c_k_x is represented
 * as a pair of non-negative coefficients.
 */
================================================================================

文件路径: ./isl_scheduler.c
注释行数: 11
注释内容:
/* Add the constraints "coef" derived from an edge from a node to itself
 * to data->graph->lp in order to respect the dependences and
 * to try and carry them.
 *
 * The space of "coef" is of the form
 *
 *	coefficients[[c_cst] -> S[c_x]]
 *
 * with S[c_x] the (compressed) space of the node.
 * Extract the node from the space and call add_intra_constraints.
 */
================================================================================

文件路径: ./isl_scheduler.c
注释行数: 11
注释内容:
/* Add the constraints "coef" derived from an edge from a node j
 * to a node k to data->graph->lp in order to respect the dependences and
 * to try and carry them (provided data->carry_inter is set).
 *
 * The space of "coef" is of the form
 *
 *	coefficients[[c_cst, c_n] -> [S_j[c_x] -> S_k[c_y]]]
 *
 * with S_j[c_x] and S_k[c_y] the (compressed) spaces of the nodes.
 * Extract the nodes from the space and call add_inter_constraints.
 */
================================================================================

文件路径: ./isl_scheduler.c
注释行数: 7
注释内容:
/* Add constraints to graph->lp that force all (conditional) validity
 * dependences to be respected and attempt to carry them.
 * "intra" is the sequence of coefficient constraints for intra-node edges.
 * "inter" is the sequence of coefficient constraints for inter-node edges.
 * "carry_inter" indicates whether inter-node edges should be carried or
 * only respected.
 */
================================================================================

文件路径: ./isl_scheduler.c
注释行数: 3
注释内容:
/* Add the number of equality and inequality constraints of "bset"
 * to data->n_eq and data->n_ineq.
 */
================================================================================

文件路径: ./isl_scheduler.c
注释行数: 33
注释内容:
/* Construct an LP problem for finding schedule coefficients
 * such that the schedule carries as many validity dependences as possible.
 * In particular, for each dependence i, we bound the dependence distance
 * from below by e_i, with 0 <= e_i <= 1 and then maximize the sum
 * of all e_i's.  Dependences with e_i = 0 in the solution are simply
 * respected, while those with e_i > 0 (in practice e_i = 1) are carried.
 * "intra" is the sequence of coefficient constraints for intra-node edges.
 * "inter" is the sequence of coefficient constraints for inter-node edges.
 * "n_edge" is the total number of edges.
 * "carry_inter" indicates whether inter-node edges should be carried or
 * only respected.  That is, if "carry_inter" is not set, then
 * no e_i variables are introduced for the inter-node edges.
 *
 * All variables of the LP are non-negative.  The actual coefficients
 * may be negative, so each coefficient is represented as the difference
 * of two non-negative variables.  The negative part always appears
 * immediately before the positive part.
 * Other than that, the variables have the following order
 *
 *	- sum of (1 - e_i) over all edges
 *	- sum of all c_n coefficients
 *		(unconstrained when computing non-parametric schedules)
 *	- sum of positive and negative parts of all c_x coefficients
 *	- for each edge
 *		- e_i
 *	- for each node
 *		- positive and negative parts of c_i_x, in opposite order
 *		- c_i_n (if parametric)
 *		- c_i_0
 *
 * The constraints are those from the (validity) edges plus three equalities
 * to express the sums and n_edge inequalities to express e_i <= 1.
 */
================================================================================

文件路径: ./isl_scheduler.c
注释行数: 21
注释内容:
/* Does the solution "sol" of the LP problem constructed by setup_carry_lp
 * carry any of the "n_edge" groups of dependences?
 * The value in the first position is the sum of (1 - e_i) over all "n_edge"
 * edges, with 0 <= e_i <= 1 equal to 1 when the dependences represented
 * by the edge are carried by the solution.
 * If the sum of the (1 - e_i) is smaller than "n_edge" then at least
 * one of those is carried.
 *
 * Note that despite the fact that the problem is solved using a rational
 * solver, the solution is guaranteed to be integral.
 * Specifically, the dependence distance lower bounds e_i (and therefore
 * also their sum) are integers.  See Lemma 5 of [1].
 *
 * Any potential denominator of the sum is cleared by this function.
 * The denominator is not relevant for any of the other elements
 * in the solution.
 *
 * [1] P. Feautrier, Some Efficient Solutions to the Affine Scheduling
 *     Problem, Part II: Multi-Dimensional Time.
 *     In Intl. Journal of Parallel Programming, 1992.
 */
================================================================================

文件路径: ./isl_scheduler.c
注释行数: 3
注释内容:
/* Add the size bounds for the node with instance deltas in "set"
 * to data->bounds.
 */
================================================================================

文件路径: ./isl_scheduler.c
注释行数: 8
注释内容:
/* Check if the lineality space "set" is non-trivial (i.e., is not just
 * the origin or, in other words, satisfies a number of equality constraints
 * that is smaller than the dimension of the set).
 * If so, extend data->mask and data->equivalent accordingly.
 *
 * The input should not have any local variables already, but
 * isl_set_remove_divs is called to make sure it does not.
 */
================================================================================

文件路径: ./isl_scheduler.c
注释行数: 19
注释内容:
/* Check if the difference set on intra-node schedule constraints "intra"
 * has any non-trivial lineality space.
 * If so, then extend the difference set to a difference set
 * on equivalent elements.  That is, if "intra" is
 *
 *	{ y - x : (x,y) \in V }
 *
 * and elements are equivalent if they have the same image under f,
 * then return
 *
 *	{ y' - x' : (x,y) \in V and f(x) = f(x') and f(y) = f(y') }
 *
 * or, since f is linear,
 *
 *	{ y' - x' : (x,y) \in V and f(y - x) = f(y' - x') }
 *
 * The results of the search for non-trivial lineality spaces is stored
 * in "data".
 */
================================================================================

文件路径: ./isl_scheduler.c
注释行数: 9
注释内容:
/* If the difference set on intra-node schedule constraints was found to have
 * any non-trivial lineality space by exploit_intra_lineality,
 * as recorded in "data", then extend the inter-node
 * schedule constraints "inter" to schedule constraints on equivalent elements.
 * That is, if "inter" is V and
 * elements are equivalent if they have the same image under f, then return
 *
 *	{ (x', y') : (x,y) \in V and f(x) = f(x') and f(y) = f(y') }
 */
================================================================================

文件路径: ./isl_scheduler.c
注释行数: 31
注释内容:
/* Construct a schedule row for each node such that as many validity dependences
 * as possible are carried and then continue with the next band.
 * If "fallback" is set, then the carrying is performed as a fallback
 * for the Pluto-like scheduler.
 * If "coincidence" is set, then try and carry coincidence edges as well.
 *
 * If there are no validity dependences, then no dependence can be carried and
 * the procedure is guaranteed to fail.  If there is more than one component,
 * then try computing a schedule on each component separately
 * to prevent or at least postpone this failure.
 *
 * If a schedule row is computed, then check that dependences are carried
 * for at least one of the edges.
 *
 * If the computed schedule row turns out to be trivial on one or
 * more nodes where it should not be trivial, then we throw it away
 * and try again on each component separately.
 *
 * If there is only one component, then we accept the schedule row anyway,
 * but we do not consider it as a complete row and therefore do not
 * increment graph->n_row.  Note that the ranks of the nodes that
 * do get a non-trivial schedule part will get updated regardless and
 * graph->maxvar is computed based on these ranks.  The test for
 * whether more schedule rows are required in compute_schedule_wcc
 * is therefore not affected.
 *
 * Insert a band corresponding to the schedule row at position "node"
 * of the schedule tree and continue with the construction of the schedule.
 * This insertion and the continued construction is performed by split_scaled
 * after optionally checking for non-trivial common divisors.
 */
================================================================================

文件路径: ./isl_scheduler.c
注释行数: 5
注释内容:
/* Is the conditional validity dependence in the edge with index "edge_index"
 * violated by the latest (i.e., final) row of the schedule?
 * That is, is i scheduled after j
 * for any conditional validity dependence i -> j?
 */
================================================================================

文件路径: ./isl_scheduler.c
注释行数: 32
注释内容:
/* Examine the current band (the rows between graph->band_start and
 * graph->n_total_row), deciding whether to drop it or add it to "node"
 * and then continue with the computation of the next band, if any.
 * If "initialized" is set, then it may be assumed that compute_maxvar
 * has been called on the current band.  Otherwise, call
 * compute_maxvar if and before carry_dependences gets called.
 *
 * The caller keeps looking for a new row as long as
 * graph->n_row < graph->maxvar.  If the latest attempt to find
 * such a row failed (i.e., we still have graph->n_row < graph->maxvar),
 * then we either
 * - split between SCCs and start over (assuming we found an interesting
 *	pair of SCCs between which to split)
 * - continue with the next band (assuming the current band has at least
 *	one row)
 * - if there is more than one SCC left, then split along all SCCs
 * - if outer coincidence needs to be enforced, then try to carry as many
 *	validity or coincidence dependences as possible and
 *	continue with the next band
 * - try to carry as many validity dependences as possible and
 *	continue with the next band
 * In each case, we first insert a band node in the schedule tree
 * if any rows have been computed.
 *
 * If the caller managed to complete the schedule and the current band
 * is empty, then finish off by topologically
 * sorting the statements based on the remaining dependences.
 * If, on the other hand, the current band has at least one row,
 * then continue with the next band.  Note that this next band
 * will necessarily be empty, but the graph may still be split up
 * into weakly connected components before arriving back here.
 */
================================================================================

文件路径: ./isl_scheduler.c
注释行数: 32
注释内容:
/* Construct a band of schedule rows for a connected dependence graph.
 * The caller is responsible for determining the strongly connected
 * components and calling compute_maxvar first.
 *
 * We try to find a sequence of as many schedule rows as possible that result
 * in non-negative dependence distances (independent of the previous rows
 * in the sequence, i.e., such that the sequence is tilable), with as
 * many of the initial rows as possible satisfying the coincidence constraints.
 * The computation stops if we can't find any more rows or if we have found
 * all the rows we wanted to find.
 *
 * If ctx->opt->schedule_outer_coincidence is set, then we force the
 * outermost dimension to satisfy the coincidence constraints.  If this
 * turns out to be impossible, we fall back on the general scheme above
 * and try to carry as many dependences as possible.
 *
 * If "graph" contains both condition and conditional validity dependences,
 * then we need to check that that the conditional schedule constraint
 * is satisfied, i.e., there are no violated conditional validity dependences
 * that are adjacent to any non-local condition dependences.
 * If there are, then we mark all those adjacent condition dependences
 * as local and recompute the current band.  Those dependences that
 * are marked local will then be forced to be local.
 * The initial computation is performed with no dependences marked as local.
 * If we are lucky, then there will be no violated conditional validity
 * dependences adjacent to any non-local condition dependences.
 * Otherwise, we mark some additional condition dependences as local and
 * recompute.  We continue this process until there are no violations left or
 * until we are no longer able to compute a schedule.
 * Since there are only a finite number of dependences,
 * there will only be a finite number of iterations.
 */
================================================================================

文件路径: ./isl_scheduler.c
注释行数: 22
注释内容:
/* Mark all SCCs that belong to either of the two clusters in "c"
 * connected by the edge in "graph" with index "edge", or to any
 * of the intermediate clusters.
 * The marking is recorded in c->scc_in_merge.
 *
 * The given edge has been selected for merging two clusters,
 * meaning that there is at least a proximity edge between the two nodes.
 * However, there may also be (indirect) validity dependences
 * between the two nodes.  When merging the two clusters, all clusters
 * containing one or more of the intermediate nodes along the
 * indirect validity dependences need to be merged in as well.
 *
 * First collect all such nodes by computing the strongly connected
 * component (SCC) containing the two nodes connected by the edge, where
 * the two nodes are considered to depend on each other to make
 * sure they end up in the same SCC.  Similarly, each node is considered
 * to depend on every other node in the same cluster to ensure
 * that the SCC consists of complete clusters.
 *
 * Then the original SCCs that contain any of these nodes are marked
 * in c->scc_in_merge.
 */
================================================================================

文件路径: ./isl_scheduler.c
注释行数: 13
注释内容:
/* Given a mapping "cluster_map" from the original instances to
 * the cluster instances, add schedule constraints on the clusters
 * to "sc" corresponding to the original constraints represented by "edge".
 *
 * For non-tagged dependence constraints, the cluster constraints
 * are obtained by applying "cluster_map" to the edge->map.
 *
 * For tagged dependence constraints, "cluster_map" needs to be applied
 * to the domains of the wrapped relations in domain and range
 * of the tagged dependence constraints.  Pick out the mappings
 * from these domains from "cluster_map" and construct their product.
 * This mapping can then be applied to the pair of domains.
 */
================================================================================

文件路径: ./isl_scheduler.c
注释行数: 16
注释内容:
/* Compute weights on the proximity edges of "graph" that can
 * be used by find_proximity to find the most appropriate
 * proximity edge to use to merge two clusters in "c".
 * The weights are also used by has_bounded_distances to determine
 * whether the merge should be allowed.
 * Store the maximum of the computed weights in graph->max_weight.
 *
 * The computed weight is a measure for the number of remaining schedule
 * dimensions that can still be completely aligned.
 * In particular, compute the number of equalities between
 * input dimensions and output dimensions in the proximity constraints.
 * The directions that are already handled by outer schedule bands
 * are projected out prior to determining this number.
 *
 * Edges that will never be considered by find_proximity are ignored.
 */
================================================================================

文件路径: ./isl_scheduler.c
注释行数: 15
注释内容:
/* Compute a schedule on sc->domain that respects the given schedule
 * constraints.
 *
 * In particular, the schedule respects all the validity dependences.
 * If the default isl scheduling algorithm is used, it tries to minimize
 * the dependence distances over the proximity dependences.
 * If Feautrier's scheduling algorithm is used, the proximity dependence
 * distances are only minimized during the extension to a full-dimensional
 * schedule.
 *
 * If there are any condition and conditional validity dependences,
 * then the conditional validity dependences may be violated inside
 * a tilable band, provided they have no adjacent non-local
 * condition dependences.
 */
================================================================================

文件路径: ./isl_union_eval.c
注释行数: 7
注释内容:
/* Update the evaluation in data->v based on the evaluation of "part".
 *
 * Only (at most) a single part on which this function is called
 * is assumed to evaluate to anything other than zero.
 * Since the value is initialized to zero, the evaluation of "part"
 * can simply be added.
 */
================================================================================

文件路径: ./isl_tab_pip.c
注释行数: 3
注释内容:
/* Pop one partial solution from the partial solution stack and
 * pass it on to sol->add or sol->add_empty.
 */
================================================================================

文件路径: ./isl_tab_pip.c
注释行数: 10
注释内容:
/* Swap the initial two partial solutions in "sol".
 *
 * That is, go from
 *
 *	sol->partial = p1; p1->next = p2; p2->next = p3
 *
 * to
 *
 *	sol->partial = p2; p2->next = p1; p1->next = p3
 */
================================================================================

文件路径: ./isl_tab_pip.c
注释行数: 49
注释内容:
/* Add the solution identified by the tableau and the context tableau.
 *
 * The layout of the variables is as follows.
 *	tab->n_var is equal to the total number of variables in the input
 *			map (including divs that were copied from the context)
 *			+ the number of extra divs constructed
 *      Of these, the first tab->n_param and the last tab->n_div variables
 *	correspond to the variables in the context, i.e.,
 *		tab->n_param + tab->n_div = context_tab->n_var
 *	tab->n_param is equal to the number of parameters and input
 *			dimensions in the input map
 *	tab->n_div is equal to the number of divs in the context
 *
 * If there is no solution, then call add_empty with a basic set
 * that corresponds to the context tableau.  (If add_empty is NULL,
 * then do nothing).
 *
 * If there is a solution, then first construct a matrix that maps
 * all dimensions of the context to the output variables, i.e.,
 * the output dimensions in the input map.
 * The divs in the input map (if any) that do not correspond to any
 * div in the context do not appear in the solution.
 * The algorithm will make sure that they have an integer value,
 * but these values themselves are of no interest.
 * We have to be careful not to drop or rearrange any divs in the
 * context because that would change the meaning of the matrix.
 *
 * To extract the value of the output variables, it should be noted
 * that we always use a big parameter M in the main tableau and so
 * the variable stored in this tableau is not an output variable x itself, but
 *	x' = M + x (in case of minimization)
 * or
 *	x' = M - x (in case of maximization)
 * If x' appears in a column, then its optimal value is zero,
 * which means that the optimal value of x is an unbounded number
 * (-M for minimization and M for maximization).
 * We currently assume that the output dimensions in the original map
 * are bounded, so this cannot occur.
 * Similarly, when x' appears in a row, then the coefficient of M in that
 * row is necessarily 1.
 * If the row in the tableau represents
 *	d x' = c + d M + e(y)
 * then, in case of minimization, the corresponding row in the matrix
 * will be
 *	a c + a e(y)
 * with a d = m, the (updated) common denominator of the matrix.
 * In case of maximization, the row will be
 *	-a c - a e(y)
 */
================================================================================

文件路径: ./isl_tab_pip.c
注释行数: 13
注释内容:
/* Given a row in the tableau and a div that was created
 * using get_row_split_div and that has been constrained to equality, i.e.,
 *
 *		d = floor(\sum_i {a_i} y_i) = \sum_i {a_i} y_i
 *
 * replace the expression "\sum_i {a_i} y_i" in the row by d,
 * i.e., we subtract "\sum_i {a_i} y_i" and add 1 d.
 * The coefficients of the non-parameters in the tableau have been
 * verified to be integral.  We can therefore simply replace coefficient b
 * by floor(b).  For the coefficients of the parameters we have
 * floor(a_i) = a_i - {a_i}, while for the other coefficients, we have
 * floor(b) = b.
 */
================================================================================

文件路径: ./isl_tab_pip.c
注释行数: 6
注释内容:
/* Does the index into the tab->var or tab->con array "index"
 * correspond to a variable in the context tableau?
 * In particular, it needs to be an index into the tab->var array and
 * it needs to refer to either one of the first tab->n_param variables or
 * one of the last tab->n_div variables.
 */
================================================================================

文件路径: ./isl_tab_pip.c
注释行数: 9
注释内容:
/* Add the equality described by "eq" to the context.
 * If "check" is set, then we check if the context is empty after
 * adding the equality.
 * If "update" is set, then we check if the samples are still valid.
 *
 * We do not explicitly add shifted copies of the equality to
 * cgbr->shifted since they would conflict with each other.
 * Instead, we directly mark cgbr->shifted empty.
 */
================================================================================

文件路径: ./isl_tab_pip.c
注释行数: 56
注释内容:
/* Determine the sign of the given row of the main tableau.
 * The result is one of
 *	isl_tab_row_pos: always non-negative; no pivot needed
 *	isl_tab_row_neg: always non-positive; pivot
 *	isl_tab_row_any: can be both positive and negative; split
 *
 * We first handle some simple cases
 *	- the row sign may be known already
 *	- the row may be obviously non-negative
 *	- the parametric constant may be equal to that of another row
 *	  for which we know the sign.  This sign will be either "pos" or
 *	  "any".  If it had been "neg" then we would have pivoted before.
 *
 * If none of these cases hold, we check the value of the row for each
 * of the currently active samples.  Based on the signs of these values
 * we make an initial determination of the sign of the row.
 *
 *	all zero			->	unk(nown)
 *	all non-negative		->	pos
 *	all non-positive		->	neg
 *	both negative and positive	->	all
 *
 * If we end up with "all", we are done.
 * Otherwise, we perform a check for positive and/or negative
 * values as follows.
 *
 *	samples	       neg	       unk	       pos
 *	<0 ?			    Y        N	    Y        N
 *					    pos    any      pos
 *	>0 ?	     Y      N	 Y     N
 *		    any    neg  any   neg
 *
 * There is no special sign for "zero", because we can usually treat zero
 * as either non-negative or non-positive, whatever works out best.
 * However, if the row is "critical", meaning that pivoting is impossible
 * then we don't want to limp zero with the non-positive case, because
 * then we we would lose the solution for those values of the parameters
 * where the value of the row is zero.  Instead, we treat 0 as non-negative
 * ensuring a split if the row can attain both zero and negative values.
 * The same happens when the original constraint was one that could not
 * be satisfied with equality by any integer values of the parameters.
 * In this case, we normalize the constraint, but then a value of zero
 * for the normalized constraint is actually a positive value for the
 * original constraint, so again we need to treat zero as non-negative.
 * In both these cases, we have the following decision tree instead:
 *
 *	all non-negative		->	pos
 *	all negative			->	neg
 *	both negative and non-negative	->	all
 *
 *	samples	       neg	          	       pos
 *	<0 ?			             	    Y        N
 *					           any      pos
 *	>=0 ?	     Y      N
 *		    any    neg
 */
================================================================================

文件路径: ./isl_tab_pip.c
注释行数: 94
注释内容:
/* Compute the lexicographic minimum of the set represented by the main
 * tableau "tab" within the context "sol->context_tab".
 * On entry the sample value of the main tableau is lexicographically
 * less than or equal to this lexicographic minimum.
 * Pivots are performed until a feasible point is found, which is then
 * necessarily equal to the minimum, or until the tableau is found to
 * be infeasible.  Some pivots may need to be performed for only some
 * feasible values of the context tableau.  If so, the context tableau
 * is split into a part where the pivot is needed and a part where it is not.
 *
 * Whenever we enter the main loop, the main tableau is such that no
 * "obvious" pivots need to be performed on it, where "obvious" means
 * that the given row can be seen to be negative without looking at
 * the context tableau.  In particular, for non-parametric problems,
 * no pivots need to be performed on the main tableau.
 * The caller of find_solutions is responsible for making this property
 * hold prior to the first iteration of the loop, while restore_lexmin
 * is called before every other iteration.
 *
 * Inside the main loop, we first examine the signs of the rows of
 * the main tableau within the context of the context tableau.
 * If we find a row that is always non-positive for all values of
 * the parameters satisfying the context tableau and negative for at
 * least one value of the parameters, we perform the appropriate pivot
 * and start over.  An exception is the case where no pivot can be
 * performed on the row.  In this case, we require that the sign of
 * the row is negative for all values of the parameters (rather than just
 * non-positive).  This special case is handled inside row_sign, which
 * will say that the row can have any sign if it determines that it can
 * attain both negative and zero values.
 *
 * If we can't find a row that always requires a pivot, but we can find
 * one or more rows that require a pivot for some values of the parameters
 * (i.e., the row can attain both positive and negative signs), then we split
 * the context tableau into two parts, one where we force the sign to be
 * non-negative and one where we force is to be negative.
 * The non-negative part is handled by a recursive call (through find_in_pos).
 * Upon returning from this call, we continue with the negative part and
 * perform the required pivot.
 *
 * If no such rows can be found, all rows are non-negative and we have
 * found a (rational) feasible point.  If we only wanted a rational point
 * then we are done.
 * Otherwise, we check if all values of the sample point of the tableau
 * are integral for the variables.  If so, we have found the minimal
 * integral point and we are done.
 * If the sample point is not integral, then we need to make a distinction
 * based on whether the constant term is non-integral or the coefficients
 * of the parameters.  Furthermore, in order to decide how to handle
 * the non-integrality, we also need to know whether the coefficients
 * of the other columns in the tableau are integral.  This leads
 * to the following table.  The first two rows do not correspond
 * to a non-integral sample point and are only mentioned for completeness.
 *
 *	constant	parameters	other
 *
 *	int		int		int	|
 *	int		int		rat	| -> no problem
 *
 *	rat		int		int	  -> fail
 *
 *	rat		int		rat	  -> cut
 *
 *	int		rat		rat	|
 *	rat		rat		rat	| -> parametric cut
 *
 *	int		rat		int	|
 *	rat		rat		int	| -> split context
 *
 * If the parametric constant is completely integral, then there is nothing
 * to be done.  If the constant term is non-integral, but all the other
 * coefficient are integral, then there is nothing that can be done
 * and the tableau has no integral solution.
 * If, on the other hand, one or more of the other columns have rational
 * coefficients, but the parameter coefficients are all integral, then
 * we can perform a regular (non-parametric) cut.
 * Finally, if there is any parameter coefficient that is non-integral,
 * then we need to involve the context tableau.  There are two cases here.
 * If at least one other column has a rational coefficient, then we
 * can perform a parametric cut in the main tableau by adding a new
 * integer division in the context tableau.
 * If all other columns have integral coefficients, then we need to
 * enforce that the rational combination of parameters (c + \sum a_i y_i)/m
 * is always integral.  We do this by introducing an integer division
 * q = floor((c + \sum a_i y_i)/m) and stipulating that its argument should
 * always be integral in the context tableau, i.e., m q = c + \sum a_i y_i.
 * Since q is expressed in the tableau as
 *	c + \sum a_i y_i - m q >= 0
 *	-c - \sum a_i y_i + m q + m - 1 >= 0
 * it is sufficient to add the inequality
 *	-c - \sum a_i y_i + m q >= 0
 * In the part of the context where this inequality does not hold, the
 * main tableau is marked as being empty.
 */
================================================================================

文件路径: ./isl_tab_pip.c
注释行数: 20
注释内容:
/* Compute the lexicographic minimum of the set represented by the main
 * tableau "tab" within the context "sol->context_tab".
 *
 * As a preprocessing step, we first transfer all the purely parametric
 * equalities from the main tableau to the context tableau, i.e.,
 * parameters that have been pivoted to a row.
 * These equalities are ignored by the main algorithm, because the
 * corresponding rows may not be marked as being non-negative.
 * In parts of the context where the added equality does not hold,
 * the main tableau is marked as being empty.
 *
 * Before we embark on the actual computation, we save a copy
 * of the context.  When we return, we check if there are any
 * partial solutions that can potentially be merged.  If so,
 * we perform a rollback to the initial state of the context.
 * The merging of partial solutions happens inside calls to
 * sol_dec_level that are pushed onto the undo stack of the context.
 * If there are no partial solutions that can potentially be merged
 * then the rollback is skipped as it would just be wasted effort.
 */
================================================================================

文件路径: ./isl_tab_pip.c
注释行数: 5
注释内容:
/* Structure used during detection of parallel constraints.
 * n_in: number of "input" variables: isl_dim_param + isl_dim_in
 * n_out: number of "output" variables: isl_dim_out + isl_dim_div
 * val: the coefficients of the output variables
 */
================================================================================

文件路径: ./isl_tab_pip.c
注释行数: 3
注释内容:
/* Check whether the coefficients of the output variables
 * of the constraint in "entry" are equal to info->val.
 */
================================================================================

文件路径: ./isl_tab_pip.c
注释行数: 13
注释内容:
/* Given a set of upper bounds on the last "input" variable m,
 * construct a set that assigns the minimal upper bound to m, i.e.,
 * construct a set that divides the space into cells where one
 * of the upper bounds is smaller than all the others and assign
 * this upper bound to m.
 *
 * In particular, if there are n bounds b_i, then the result
 * consists of n basic sets, each one of the form
 *
 *	m = b_i
 *	b_i <= b_j	for j > i
 *	b_i <  b_j	for j < i
 */
================================================================================

文件路径: ./isl_tab_pip.c
注释行数: 13
注释内容:
/* Given a map of which the last input variable is the minimum
 * of the bounds in "cst", split each basic set in the set
 * in pieces where one of the bounds is (strictly) smaller than the others.
 * This subdivision is given in "min_expr".
 * The variable is subsequently projected out.
 *
 * We only do the split when it is needed.
 * For example if the last input variable m = min(a,b) and the only
 * constraints in the given basic set are lower bounds on m,
 * i.e., l <= m = min(a,b), then we can simply project out m
 * to obtain l <= a and l <= b, without having to split on whether
 * m is equal to a or b.
 */
================================================================================

文件路径: ./isl_tab_pip.c
注释行数: 8
注释内容:
/* What to do next after entering a level of the backtracking procedure.
 *
 * error: some error has occurred; abort
 * done: an optimal solution has been found; stop search
 * backtrack: backtrack to the previous level
 * handle: add the constraints for the current level and
 * 	move to the next level
 */
================================================================================

文件路径: ./isl_tab_pip.c
注释行数: 7
注释内容:
/* If a solution has been found in the previous case at this level
 * (marked by local->update being set), then add constraints
 * that enforce a better solution in the present and all following cases.
 * The constraints only need to be imposed once because they are
 * included in the snapshot (taken in pick_side) that will be used in
 * subsequent cases.
 */
================================================================================

文件路径: ./isl_tab_pip.c
注释行数: 17
注释内容:
/* Add constraints to data->tab that select the current case (local->side)
 * at the current level.
 *
 * If the linear combinations v should not be zero, then the cases are
 *	v_0 >= 1
 *	v_0 <= -1
 *	v_0 = 0 and v_1 >= 1
 *	v_0 = 0 and v_1 <= -1
 *	v_0 = 0 and v_1 = 0 and v_2 >= 1
 *	v_0 = 0 and v_1 = 0 and v_2 <= -1
 *	...
 * in this order.
 *
 * A snapshot is taken after the equality constraint (if any) has been added
 * such that the next case can start off from this position.
 * The rollback to this position is performed in enter_level.
 */
================================================================================

文件路径: ./isl_convex_hull.c
注释行数: 39
注释内容:
/* Given the bounding constraint "c" of a facet of the convex hull of "set",
 * compute a hyperplane description of the facet, i.e., compute the facets
 * of the facet.
 *
 * We compute an affine transformation that transforms the constraint
 *
 *			  [ 1 ]
 *			c [ x ] = 0
 *
 * to the constraint
 *
 *			   z_1  = 0
 *
 * by computing the right inverse U of a matrix that starts with the rows
 *
 *			[ 1 0 ]
 *			[  c  ]
 *
 * Then
 *			[ 1 ]     [ 1 ]
 *			[ x ] = U [ z ]
 * and
 *			[ 1 ]     [ 1 ]
 *			[ z ] = Q [ x ]
 *
 * with Q = U^{-1}
 * Since z_1 is zero, we can drop this variable as well as the corresponding
 * column of U to obtain
 *
 *			[ 1 ]      [ 1  ]
 *			[ x ] = U' [ z' ]
 * and
 *			[ 1  ]      [ 1 ]
 *			[ z' ] = Q' [ x ]
 *
 * with Q' equal to Q, but without the corresponding row.
 * After computing the facets of the facet in the z' space,
 * we convert them back to the x space through Q.
 */
================================================================================

文件路径: ./isl_convex_hull.c
注释行数: 20
注释内容:
/* Given a set and a linear space "lin" of dimension n > 0,
 * project the linear space from the set, compute the convex hull
 * and then map the set back to the original space.
 *
 * Let
 *
 *	M x = 0
 *
 * describe the linear space.  We first compute the Hermite normal
 * form H = M U of M = H Q, to obtain
 *
 *	H Q x = 0
 *
 * The last n rows of H will be zero, so the last n variables of x' = Q x
 * are the one we want to project out.  We do this by transforming each
 * basic set A x >= b to A U x' >= b and then removing the last n dimensions.
 * After computing the convex hull in x'_1, i.e., A' x'_1 >= b',
 * we transform the hull back to the original space as A' Q_1 x >= b',
 * with Q_1 all but the last n rows of Q.
 */
================================================================================

文件路径: ./isl_convex_hull.c
注释行数: 9
注释内容:
/* Given two polyhedra with as constraints h_{ij} x >= 0 in homegeneous space,
 * set up an LP for solving
 *
 *	\sum_j \alpha_{1j} h_{1j} = \sum_j \alpha_{2j} h_{2j}
 *
 * \alpha{i0} corresponds to the (implicit) positivity constraint 1 >= 0
 * The next \alpha{ij} correspond to the equalities and come in pairs.
 * The final \alpha{ij} correspond to the inequalities.
 */
================================================================================

文件路径: ./isl_convex_hull.c
注释行数: 20
注释内容:
/* Compute a vector s in the homogeneous space such that <s, r> > 0
 * for all rays in the homogeneous space of the two cones that correspond
 * to the input polyhedra bset1 and bset2.
 *
 * We compute s as a vector that satisfies
 *
 *	s = \sum_j \alpha_{ij} h_{ij}	for i = 1,2			(*)
 *
 * with h_{ij} the normals of the facets of polyhedron i
 * (including the "positivity constraint" 1 >= 0) and \alpha_{ij}
 * strictly positive numbers.  For simplicity we impose \alpha_{ij} >= 1.
 * We first set up an LP with as variables the \alpha{ij}.
 * In this formulation, for each polyhedron i,
 * the first constraint is the positivity constraint, followed by pairs
 * of variables for the equalities, followed by variables for the inequalities.
 * We then simply pick a feasible solution and compute s using (*).
 *
 * Note that we simply pick any valid direction and make no attempt
 * to pick a "good" or even the "best" valid direction.
 */
================================================================================

文件路径: ./isl_convex_hull.c
注释行数: 9
注释内容:
/* Given a polyhedron b_i + A_i x >= 0 and a map T = S^{-1},
 * compute b_i' + A_i' x' >= 0, with
 *
 *	[ b_i A_i ]        [ y' ]		              [ y' ]
 *	[  1   0  ] S^{-1} [ x' ] >= 0	or	[ b_i' A_i' ] [ x' ] >= 0
 *
 * In particular, add the "positivity constraint" and then perform
 * the mapping.
 */
================================================================================

文件路径: ./isl_convex_hull.c
注释行数: 13
注释内容:
/* Set the constant term of "ineq" to the maximum of those of the constraints
 * in the basic sets of "set" following "i" that are parallel to "ineq".
 * That is, if any of the basic sets of "set" following "i" have a more
 * relaxed copy of "ineq", then replace "ineq" by the most relaxed copy.
 * "c_hash" is the hash value of the linear part of "ineq".
 * "v" has been set up for use by has_ineq.
 *
 * Note that the two inequality constraints corresponding to an equality are
 * represented by the same inequality constraint in data->p[j].table
 * (but with different hash values).  This means the constraint (or at
 * least its constant term) may need to be temporarily negated to get
 * the actually hashed constraint.
 */
================================================================================

文件路径: ./isl_convex_hull.c
注释行数: 19
注释内容:
/* Compute a superset of the convex hull of map that is described
 * by only (translates of) the constraints in the constituents of map.
 * Translation is only allowed if "shift" is set.
 *
 * The constraints are sorted while removing redundant constraints
 * in order to indicate a preference of which constraints should
 * be preserved.  In particular, pairs of constraints that are
 * sorted together are preferred to either both be preserved
 * or both be removed.  The sorting is performed inside
 * isl_basic_map_remove_redundancies.
 *
 * The result of the computation is stored in map->cached_simple_hull[shift]
 * such that it can be reused in subsequent calls.  The cache is cleared
 * whenever the map is modified (in isl_map_cow).
 * Note that the results need to be stored in the input map for there
 * to be any chance that they may get reused.  In particular, they
 * are stored in a copy of the input map that is saved before
 * the integer division alignment.
 */
================================================================================

文件路径: ./isl_map.c
注释行数: 7
注释内容:
/* For each known div d = floor(f/m), add the constraints
 *
 *		f - m d >= 0
 *		-(f-(m-1)) + m d >= 0
 *
 * Do not finalize the result.
 */
================================================================================

文件路径: ./isl_map.c
注释行数: 7
注释内容:
/* Check whether equality i of bset is a pure stride constraint
 * on a single dimension, i.e., of the form
 *
 *	v = k e
 *
 * with k a constant and e an existentially quantified variable.
 */
================================================================================

文件路径: ./isl_map.c
注释行数: 48
注释内容:
/* Try and add a lower and/or upper bound on "div" to "bmap"
 * based on inequality "i".
 * "total" is the total number of variables (excluding the divs).
 * "v" is a temporary object that can be used during the calculations.
 * If "lb" is set, then a lower bound should be constructed.
 * If "ub" is set, then an upper bound should be constructed.
 *
 * The calling function has already checked that the inequality does not
 * reference "div", but we still need to check that the inequality is
 * of the right form.  We'll consider the case where we want to construct
 * a lower bound.  The construction of upper bounds is similar.
 *
 * Let "div" be of the form
 *
 *	q = floor((a + f(x))/d)
 *
 * We essentially check if constraint "i" is of the form
 *
 *	b + f(x) >= 0
 *
 * so that we can use it to derive a lower bound on "div".
 * However, we allow a slightly more general form
 *
 *	b + g(x) >= 0
 *
 * with the condition that the coefficients of g(x) - f(x) are all
 * divisible by d.
 * Rewriting this constraint as
 *
 *	0 >= -b - g(x)
 *
 * adding a + f(x) to both sides and dividing by d, we obtain
 *
 *	(a + f(x))/d >= (a-b)/d + (f(x)-g(x))/d
 *
 * Taking the floor on both sides, we obtain
 *
 *	q >= floor((a-b)/d) + (f(x)-g(x))/d
 *
 * or
 *
 *	(g(x)-f(x))/d + ceil((b-a)/d) + q >= 0
 *
 * In the case of an upper bound, we construct the constraint
 *
 *	(g(x)+f(x))/d + floor((b+a)/d) - q >= 0
 *
 */
================================================================================

文件路径: ./isl_map.c
注释行数: 3
注释内容:
/* Given two basic maps A -> f(A) and B -> g(B), construct a basic map
 * A \cap B -> f(A) + f(B)
 */
================================================================================

文件路径: ./isl_map.c
注释行数: 3
注释内容:
/* Given two maps A -> f(A) and B -> g(B), construct a map
 * A \cap B -> f(A) + f(B)
 */
================================================================================

文件路径: ./isl_map.c
注释行数: 2
注释内容:
/* Given a basic map A -> f(A), construct A -> -f(A).
 */
================================================================================

文件路径: ./isl_map.c
注释行数: 2
注释内容:
/* Given a map A -> f(A), construct A -> -f(A).
 */
================================================================================

文件路径: ./isl_map.c
注释行数: 3
注释内容:
/* Given a basic map A -> f(A) and an integer d, construct a basic map
 * A -> floor(f(A)/d).
 */
================================================================================

文件路径: ./isl_map.c
注释行数: 3
注释内容:
/* Given a map A -> f(A) and an integer d, construct a map
 * A -> floor(f(A)/d).
 */
================================================================================

文件路径: ./isl_map.c
注释行数: 3
注释内容:
/* Given a map A -> f(A) and an integer d, construct a map
 * A -> floor(f(A)/d).
 */
================================================================================

文件路径: ./isl_map.c
注释行数: 4
注释内容:
/* For the div d = floor(f/m) at position "div", add the constraint
 *
 *		f - m d >= 0
 */
================================================================================

文件路径: ./isl_map.c
注释行数: 4
注释内容:
/* For the div d = floor(f/m) at position "div", add the constraint
 *
 *		-(f-(m-1)) + m d >= 0
 */
================================================================================

文件路径: ./isl_map.c
注释行数: 9
注释内容:
/* For the div d = floor(f/m) at position "pos", add the constraints
 *
 *		f - m d >= 0
 *		-(f-(m-1)) + m d >= 0
 *
 * Note that the second constraint is the negation of
 *
 *		f - m d >= m
 */
================================================================================

文件路径: ./isl_map.c
注释行数: 8
注释内容:
/* For each known div d = floor(f/m), add the constraints
 *
 *		f - m d >= 0
 *		-(f-(m-1)) + m d >= 0
 *
 * Remove duplicate constraints in case of some these div constraints
 * already appear in "bmap".
 */
================================================================================

文件路径: ./isl_map.c
注释行数: 13
注释内容:
/* Add the div constraint of sign "sign" for div "div" of "bmap".
 *
 * In particular, if this div is of the form d = floor(f/m),
 * then add the constraint
 *
 *		f - m d >= 0
 *
 * if sign < 0 or the constraint
 *
 *		-(f-(m-1)) + m d >= 0
 *
 * if sign > 0.
 */
================================================================================

文件路径: ./isl_map.c
注释行数: 3
注释内容:
/*
 * returns [domain -> range] -> range - domain
 */
================================================================================

文件路径: ./isl_map.c
注释行数: 3
注释内容:
/*
 * returns [domain -> range] -> range - domain
 */
================================================================================

文件路径: ./isl_map.c
注释行数: 17
注释内容:
/* Align the divs of "dst" to those of "src", adding divs from "src"
 * if needed.  That is, make sure that the first src->n_div divs
 * of the result are equal to those of src.
 * The integer division of "src" are assumed to be ordered.
 *
 * The integer divisions are swapped into the right position
 * (possibly after adding them first).  This may result
 * in the remaining integer divisions appearing in the wrong order,
 * i.e., with some integer division appearing before
 * some other integer division on which it depends.
 * The integer divisions therefore need to be ordered.
 * This will not affect the integer divisions aligned to those of "src",
 * since "src" is assumed to have ordered integer divisions.
 *
 * The result is not finalized as by design it will have redundant
 * divs if any divs from "src" were copied.
 */
================================================================================

文件路径: ./isl_map.c
注释行数: 2
注释内容:
/* Given two maps A -> B and C -> D, construct a map [A -> C] -> [B -> D]
 */
================================================================================

文件路径: ./isl_map.c
注释行数: 2
注释内容:
/* Given two maps A -> B and C -> D, construct a map (A, C) -> (B, D)
 */
================================================================================

文件路径: ./isl_map.c
注释行数: 2
注释内容:
/* Given two maps A -> B and C -> D, construct a map [A -> C] -> (B * D)
 */
================================================================================

文件路径: ./isl_map.c
注释行数: 2
注释内容:
/* Given two maps A -> B and C -> D, construct a map (A * C) -> [B -> D]
 */
================================================================================

文件路径: ./isl_map.c
注释行数: 2
注释内容:
/* Given a map A -> [B -> C], extract the map A -> B.
 */
================================================================================

文件路径: ./isl_map.c
注释行数: 2
注释内容:
/* Given a map A -> [B -> C], extract the map A -> C.
 */
================================================================================

文件路径: ./isl_map.c
注释行数: 2
注释内容:
/* Given two maps A -> B and C -> D, construct a map (A, C) -> (B * D)
 */
================================================================================

文件路径: ./isl_map.c
注释行数: 2
注释内容:
/* Given two maps A -> B and C -> D, construct a map (A * C) -> (B, D)
 */
================================================================================

文件路径: ./isl_map.c
注释行数: 18
注释内容:
/* For each affine expression in ma of the form
 *
 *	x_i = (f_i y + h_i)/m_i
 *
 * with m_i different from one, add a constraint to "bmap"
 * of the form
 *
 *	f_i y + h_i = m_i alpha_i
 *
 * with alpha_i an additional existentially quantified variable.
 *
 * The input variables of "ma" correspond to a subset of the variables
 * of "bmap".  There are "n_before" variables in "bmap" before this
 * subset and "n_after" variables after this subset.
 * The integer divisions of the affine expressions in "ma" are assumed
 * to have been aligned.  There are "n_div_ma" of them and
 * they appear first in "bmap", straight after the "n_after" variables.
 */
================================================================================

文件路径: ./isl_map.c
注释行数: 46
注释内容:
/* Compute the preimage of the domain or range (depending on "type")
 * of "bmap" under the function represented by "ma".
 * In other words, plug in "ma" in the domain or range of "bmap".
 * The result is a basic map that lives in the same space as "bmap"
 * except that the domain or range has been replaced by
 * the domain space of "ma".
 *
 * If bmap is represented by
 *
 *	A(p) + S u + B x + T v + C(divs) >= 0,
 *
 * where u and x are input and output dimensions if type == isl_dim_out
 * while x and v are input and output dimensions if type == isl_dim_in,
 * and ma is represented by
 *
 *	x = D(p) + F(y) + G(divs')
 *
 * then the result is
 *
 *	A(p) + B D(p) + S u + B F(y) + T v + B G(divs') + C(divs) >= 0
 *
 * The divs in the input set are similarly adjusted.
 * In particular
 *
 *	floor((a_i(p) + s u + b_i x + t v + c_i(divs))/n_i)
 *
 * becomes
 *
 *	floor((a_i(p) + b_i D(p) + s u + b_i F(y) + t v +
 *		B_i G(divs') + c_i(divs))/n_i)
 *
 * If bmap is not a rational map and if F(y) involves any denominators
 *
 *	x_i = (f_i y + h_i)/m_i
 *
 * then additional constraints are added to ensure that we only
 * map back integer points.  That is we enforce
 *
 *	f_i y + h_i = m_i alpha_i
 *
 * with alpha_i an additional existentially quantified variable.
 *
 * We first copy over the divs from "ma".
 * Then we add the modified constraints and divs from "bmap".
 * Finally, we add the stride constraints, if needed.
 */
================================================================================

文件路径: ./isl_map.c
注释行数: 6
注释内容:
/* Replace the variables x of type "type" starting at "first" in "bmap"
 * by x' with x = M x' with M the matrix trans.
 * That is, replace the corresponding coefficients c by c M.
 *
 * The transformation matrix should be a square matrix.
 */
================================================================================

文件路径: ./isl_map.c
注释行数: 6
注释内容:
/* Replace the variables x of type "type" starting at "first" in "bset"
 * by x' with x = M x' with M the matrix trans.
 * That is, replace the corresponding coefficients c by c M.
 *
 * The transformation matrix should be a square matrix.
 */
================================================================================

文件路径: ./isl_affine_hull.c
注释行数: 9
注释内容:
/* Make first row entries in column col of bset1 identical to
 * those of bset2, using the fact that entry bset1->eq[row][col]=a
 * is non-zero.  Initially, these elements of bset1 are all zero.
 * For each row i < row, we set
 *		A[i] = a * A[i] + B[i][col] * A[row]
 *		B[i] = a * B[i]
 * so that
 *		A[i][col] = B[i][col] = a * old(B[i][col])
 */
================================================================================

文件路径: ./isl_affine_hull.c
注释行数: 15
注释内容:
/* Find an integer point in the set represented by "tab"
 * that lies outside of the equality "eq" e(x) = 0.
 * If "up" is true, look for a point satisfying e(x) - 1 >= 0.
 * Otherwise, look for a point satisfying -e(x) - 1 >= 0 (i.e., e(x) <= -1).
 * The point, if found, is returned.
 * If no point can be found, a zero-length vector is returned.
 *
 * Before solving an ILP problem, we first check if simply
 * adding the normal of the constraint to one of the known
 * integer points in the basic set represented by "tab"
 * yields another point inside the basic set.
 *
 * The caller of this function ensures that the tableau is bounded or
 * that tab->basis and tab->n_unbounded have been set appropriately.
 */
================================================================================

文件路径: ./isl_affine_hull.c
注释行数: 13
注释内容:
/* Extend an initial (under-)approximation of the affine hull of basic
 * set represented by the tableau "tab"
 * by looking for points that do not satisfy one of the equalities
 * in the current approximation and adding them to that approximation
 * until no such points can be found any more.
 *
 * The caller of this function ensures that "tab" is bounded or
 * that tab->basis and tab->n_unbounded have been set appropriately.
 *
 * "bset" may be either NULL or the basic set represented by "tab".
 * If "bset" is not NULL, we check for any point we find if any
 * of its adjacent points also belong to "bset".
 */
================================================================================

文件路径: ./isl_affine_hull.c
注释行数: 31
注释内容:
/* Compute the affine hull of "bset", where "cone" is the recession cone
 * of "bset".
 *
 * We first compute a unimodular transformation that puts the unbounded
 * directions in the last dimensions.  In particular, we take a transformation
 * that maps all equalities to equalities (in HNF) on the first dimensions.
 * Let x be the original dimensions and y the transformed, with y_1 bounded
 * and y_2 unbounded.
 *
 *	       [ y_1 ]			[ y_1 ]   [ Q_1 ]
 *	x = U  [ y_2 ]			[ y_2 ] = [ Q_2 ] x
 *
 * Let's call the input basic set S.  We compute S' = preimage(S, U)
 * and drop the final dimensions including any constraints involving them.
 * This results in set S''.
 * Then we compute the affine hull A'' of S''.
 * Let F y_1 >= g be the constraint system of A''.  In the transformed
 * space the y_2 are unbounded, so we can add them back without any constraints,
 * resulting in
 *
 *		        [ y_1 ]
 *		[ F 0 ] [ y_2 ] >= g
 * or
 *		        [ Q_1 ]
 *		[ F 0 ] [ Q_2 ] x >= g
 * or
 *		F Q_1 x >= g
 *
 * The affine hull in the original space is then obtained as
 * A = preimage(A'', Q_1).
 */
================================================================================

文件路径: ./isl_affine_hull.c
注释行数: 18
注释内容:
/* Given a rational affine matrix "M", add stride constraints to "bmap"
 * that ensure that
 *
 *		M(x)
 *
 * is an integer vector.  The variables x include all the variables
 * of "bmap" except the unknown divs.
 *
 * If d is the common denominator of M, then we need to impose that
 *
 *		d M(x) = 0 	mod d
 *
 * or
 *
 *		exists alpha : d M(x) = d alpha
 *
 * This function is similar to add_strides in isl_morph.c
 */
================================================================================

文件路径: ./isl_union_templ.c
注释行数: 4
注释内容:
/* Internal data structure for isl_union_*_transform_space.
 * "control" specifies how the base expressions should be modified.
 * "res" collects the results (if control->inplace is not set).
 */
================================================================================

文件路径: ./isl_union_templ.c
注释行数: 3
注释内容:
/* Apply control->fn to "part" and add the result to data->res or
 * place it back into the input union if control->inplace is set.
 */
================================================================================

文件路径: ./isl_union_templ.c
注释行数: 4
注释内容:
/* Check if data->u2 has an element living in the same space as "part".
 * If so, call data->fn on the two elements and add the result to
 * data->res.
 */
================================================================================

文件路径: ./isl_union_templ.c
注释行数: 4
注释内容:
/* Find the set in data->uset that lives in the same space as the domain
 * of "part" (ignoring parameters), apply data->fn to *entry and this set
 * (if any), and add the result to data->res.
 */
================================================================================

文件路径: ./isl_union_templ.c
注释行数: 4
注释内容:
/* Call data->test on the piecewise expression at *entry,
 * updating the result in data->res.
 * Abort if this result is no longer isl_bool_true.
 */
================================================================================

文件路径: ./isl_sort.c
注释行数: 19
注释内容:
/* The code here is an optimized merge sort. Starting from a generic merge sort
 * the following optimizations were applied:
 *
 * o Batching of memcpy() calls: Instead of calling memcpy() to copy each and
 *   every element into a temporary buffer, blocks of elements are copied
 *   at a time.
 *
 * o To reduce the number of memcpy() calls further, copying leading
 *   and trailing elements into our temporary buffer is avoided, in case it is
 *   not necessary to merge them.
 *
 * A further optimization could be to specialize memcpy calls based on the
 * size of the types we compare. For now, this code does not include the
 * relevant optimization, as clang e.g. inlines a very efficient memcpy()
 * implementation. It is not clear, that the specialized version as provided in
 * the blog post, is really superior to the one that will be inlined by
 * default. So we decided to keep the code simple until this optimization was
 * proven to be beneficial.
 */
================================================================================

文件路径: ./isl_morph.c
注释行数: 25
注释内容:
/* Given a basic set, exploit the equalities in the basic set to construct
 * a morphism that maps the basic set to a lower-dimensional space.
 * Specifically, the morphism reduces the number of dimensions of type "type".
 *
 * We first select the equalities of interest, that is those that involve
 * variables of type "type" and no later variables.
 * Denote those equalities as
 *
 *		-C(p) + M x = 0
 *
 * where C(p) depends on the parameters if type == isl_dim_set and
 * is a constant if type == isl_dim_param.
 *
 * Use isl_mat_final_variable_compression to construct a compression
 *
 *	x = T x'
 *
 *	x' = Q x
 *
 * If T is a zero-column matrix, then the set of equality constraints
 * do not admit a solution.  In this case, an empty morphism is returned.
 *
 * Both matrices are extended to map the full original space to the full
 * compressed space.
 */
================================================================================

文件路径: ./isl_morph.c
注释行数: 16
注释内容:
/* Construct a parameter compression for "bset".
 * We basically just call isl_mat_parameter_compression with the right input
 * and then extend the resulting matrix to include the variables.
 *
 * The implementation assumes that "bset" does not have any equalities
 * that only involve the parameters and that isl_basic_set_gauss has
 * been applied to "bset".
 *
 * Let the equalities be given as
 *
 *	B(p) + A x = 0.
 *
 * We use isl_mat_parameter_compression_ext to compute the compression
 *
 *	p = T p'.
 */
================================================================================

文件路径: ./isl_farkas.c
注释行数: 47
注释内容:
/*
 * Let C be a cone and define
 *
 *	C' := { y | forall x in C : y x >= 0 }
 *
 * C' contains the coefficients of all linear constraints
 * that are valid for C.
 * Furthermore, C'' = C.
 *
 * If C is defined as { x | A x >= 0 }
 * then any element in C' must be a non-negative combination
 * of the rows of A, i.e., y = t A with t >= 0.  That is,
 *
 *	C' = { y | exists t >= 0 : y = t A }
 *
 * If any of the rows in A actually represents an equality, then
 * also negative combinations of this row are allowed and so the
 * non-negativity constraint on the corresponding element of t
 * can be dropped.
 *
 * A polyhedron P = { x | b + A x >= 0 } can be represented
 * in homogeneous coordinates by the cone
 * C = { [z,x] | b z + A x >= and z >= 0 }
 * The valid linear constraints on C correspond to the valid affine
 * constraints on P.
 * This is essentially Farkas' lemma.
 *
 * Since
 *				  [ 1 0 ]
 *		[ w y ] = [t_0 t] [ b A ]
 *
 * we have
 *
 *	C' = { w, y | exists t_0, t >= 0 : y = t A and w = t_0 + t b }
 * or
 *
 *	C' = { w, y | exists t >= 0 : y = t A and w - t b >= 0 }
 *
 * In practice, we introduce an extra variable (w), shifting all
 * other variables to the right, and an extra inequality
 * (w - t b >= 0) corresponding to the positivity constraint on
 * the homogeneous coordinate.
 *
 * When going back from coefficients to solutions, we immediately
 * plug in 1 for z, which corresponds to shifting all variables
 * to the left, with the leftmost ending up in the constant position.
 */
================================================================================

文件路径: ./isl_farkas.c
注释行数: 13
注释内容:
/* Given a dimension specification of the solutions space, construct
 * a dimension specification for the space of coefficients.
 *
 * In particular transform
 *
 *	[params] -> { S }
 *
 * to
 *
 *	{ coefficients[[cst, params] -> S] }
 *
 * and prefix each dimension name with "c_".
 */
================================================================================

文件路径: ./isl_farkas.c
注释行数: 13
注释内容:
/* Given a dimension specification of the space of coefficients, construct
 * a dimension specification for the space of solutions.
 *
 * In particular transform
 *
 *	{ coefficients[[cst, params] -> S] }
 *
 * to
 *
 *	[params] -> { S }
 *
 * and drop the "c_" prefix from the dimension names.
 */
================================================================================

文件路径: ./isl_farkas.c
注释行数: 4
注释内容:
/* Move to the first vertex of the given factor starting
 * at inequality constraint "start", setting factor->pos and
 * returning 1 if a vertex is found.
 */
================================================================================

文件路径: ./isl_farkas.c
注释行数: 15
注释内容:
/* Given a factorization "f" of a basic set,
 * construct a basic set containing the tuples of coefficients of all
 * valid affine constraints on the basic set, ignoring
 * the space of input and output.
 *
 * The factorization may involve a linear transformation of the basic set.
 * In particular, the transformed basic set is formulated
 * in terms of x' = U x, i.e., x = V x', with V = U^{-1}.
 * The dual is then computed in terms of y' with y'^t [z; x'] >= 0.
 * Plugging in y' = [1 0; 0 V^t] y yields
 * y^t [1 0; 0 V] [z; x'] >= 0, i.e., y^t [z; x] >= 0, which is
 * the desired set of coefficients y.
 * Note that this transformation to y' only needs to be applied
 * if U is not the identity matrix.
 */
================================================================================

文件路径: ./isl_range.c
注释行数: 5
注释内容:
/* Add term "term" to data->poly if it has sign data->sign.
 * The sign is determined based on the signs of the parameters
 * and variables in data->signs.  The integer divisions, if
 * any, are assumed to be non-negative.
 */
================================================================================

文件路径: ./isl_range.c
注释行数: 15
注释内容:
/* Given a lower and upper bound on the final variable and constraints
 * on the remaining variables where these bounds are active,
 * eliminate the variable from data->poly based on these bounds.
 * If the polynomial has been determined to be monotonic
 * in the variable, then simply plug in the appropriate bound.
 * If the current polynomial is tight and if this bound is integer,
 * then the result is still tight.  In all other cases, the results
 * may not be tight.
 * Otherwise, plug in the largest bound (in absolute value) in
 * the positive terms (if an upper bound is wanted) or the negative terms
 * (if a lower bounded is wanted) and the other bound in the other terms.
 *
 * If all variables have been eliminated, then record the result.
 * Ohterwise, recurse on the next variable.
 */
================================================================================

文件路径: ./isl_map_subtract.c
注释行数: 29
注释内容:
/* Compute the set difference between bmap and map and call
 * dc->add on each of the piece until this function returns
 * a negative value.
 * Return 0 on success and -1 on error.  dc->add returning
 * a negative value is treated as an error, but the calling
 * function can interpret the results based on the state of dc.
 *
 * Assumes that map has known divs.
 *
 * The difference is computed by a backtracking algorithm.
 * Each level corresponds to a basic map in "map".
 * When a node in entered for the first time, we check
 * if the corresonding basic map intersects the current piece
 * of "bmap".  If not, we move to the next level.
 * Otherwise, we split the current piece into as many
 * pieces as there are non-redundant constraints of the current
 * basic map in the intersection.  Each of these pieces is
 * handled by a child of the current node.
 * In particular, if there are n non-redundant constraints,
 * then for each 0 <= i < n, a piece is cut off by adding
 * constraints 0 <= j < i and adding the opposite of constraint i.
 * If there are no non-redundant constraints, meaning that the current
 * piece is a subset of the current basic map, then we simply backtrack.
 *
 * In the leaves, we check if the remaining piece has any integer points
 * and if so, pass it along to dc->add.  As a special case, if nothing
 * has been removed when we end up in a leaf, we simply pass along
 * the original basic map.
 */
================================================================================

文件路径: ./isl_seq.c
注释行数: 7
注释内容:
/* Eliminate element "pos" from "dst" using "src".
 * In particular, let d = dst[pos] and s = src[pos], then
 * dst is replaced by (|s| dst - sgn(s)d src)/gcd(s,d),
 * such that dst[pos] is zero after the elimination.
 * If "m" is not NULL, then *m is multiplied by |s|/gcd(s,d).
 * That is, it is multiplied by the same factor as "dst".
 */
================================================================================

文件路径: ./isl_input.c
注释行数: 12
注释内容:
/* Read an isl_val from "s".
 *
 * The following token sequences are recognized
 *
 *	"infty"		->	infty
 *	"-" "infty"	->	-infty
 *	"NaN"		->	NaN
 *	n "/" d		->	n/d
 *	v		->	v
 *
 * where n, d and v are integer constants.
 */
================================================================================

文件路径: ./isl_input.c
注释行数: 3
注释内容:
/* Construct an isl_pw_aff defined on a "space" (with v->n variables)
 * that is equal to the last of those variables.
 */
================================================================================

文件路径: ./isl_input.c
注释行数: 12
注释内容:
/* Construct a piecewise affine expression corresponding
 * to the last variable in "v" that is greater than or equal to "pa".
 *
 * In particular, if D is the domain space of "pa",
 * then construct the expression
 *
 *	D[..., i] -> i,
 *
 * impose lower bound "pa" and return
 *
 *	D[..., i] -> i : i >= pa
 */
================================================================================

文件路径: ./isl_input.c
注释行数: 12
注释内容:
/* Construct a piecewise affine expression corresponding
 * to the last variable in "v" that is smaller than or equal to "pa".
 *
 * In particular, if D is the domain space of "pa",
 * then construct the expression
 *
 *	D[..., i] -> i,
 *
 * impose lower bound "pa" and return
 *
 *	D[..., i] -> i : i <= pa
 */
================================================================================

文件路径: ./isl_input.c
注释行数: 12
注释内容:
/* Construct a piecewise affine expression corresponding
 * to the last variable in "v" that ranges between "pa" and "pa2".
 *
 * In particular, if D is the domain space of "pa" (and "pa2"),
 * then construct the expression
 *
 *	D[..., i] -> i,
 *
 * impose lower bound "pa" and upper bound "pa2" and return
 *
 *	D[..., i] -> i : pa <= i <= pa2
 */
================================================================================

文件路径: ./isl_input.c
注释行数: 3
注释内容:
/* Construct an isl_pw_aff defined on a space with v->n variables
 * that is equal to the last of those variables.
 */
================================================================================

文件路径: ./isl_input.c
注释行数: 15
注释内容:
/* Given two equal-length lists of piecewise affine expression with the space
 * of "set" as domain, construct a set in the same space that expresses
 * that "left" and "right" satisfy the comparison "type".
 *
 * A space is constructed of the same dimension as the number of elements
 * in the two lists.  The comparison is then expressed in a map from
 * this space to itself and wrapped into a set.  Finally the two lists
 * of piecewise affine expressions are plugged into this set.
 *
 * Let S be the space of "set" and T the constructed space.
 * The lists are first changed into two isl_multi_pw_affs in S -> T and
 * then combined into an isl_multi_pw_aff in S -> [T -> T],
 * while the comparison is first expressed in T -> T, then [T -> T]
 * and finally in S.
 */
================================================================================

文件路径: ./isl_input.c
注释行数: 15
注释内容:
/* Extract an isl_multi_pw_aff with domain space "dom_space"
 * from a tuple "tuple" read by read_tuple.
 *
 * Note that the function read_tuple accepts tuples where some output or
 * set dimensions are defined in terms of other output or set dimensions
 * since this function is also used to read maps.  As a special case,
 * read_tuple also accept dimensions that are defined in terms of themselves
 * (i.e., that are not defined).
 * These cases are not allowed when extracting an isl_multi_pw_aff so check
 * that the definitions of the output/set dimensions do not involve any
 * output/set dimensions.
 * Finally, drop the output dimensions from the domain of the result
 * of read_tuple (which is of the form [input, output] -> [output],
 * with anonymous domain) and reset the space.
 */
================================================================================

文件路径: ./isl_input.c
注释行数: 25
注释内容:
/* Read an isl_multi_union_pw_aff from "s".
 *
 * The input has the form
 *
 *	[{ [..] : ... ; [..] : ... }, { [..] : ... ; [..] : ... }]
 *
 * or
 *
 *	[..] -> [{ [..] : ... ; [..] : ... }, { [..] : ... ; [..] : ... }]
 *
 * Additionally, a shared domain may be specified as
 *
 *	([..] : ...)
 *
 * or
 *
 *	[..] -> ([..] : ...)
 *
 * The first case is handled by the caller, the second case
 * is handled by read_multi_union_pw_aff_body.
 *
 * We first check for the special case of an empty tuple "[]".
 * Then we check if there are any parameters.
 * Finally, read the tuple and construct the result.
 */
================================================================================

文件路径: ./isl_mat.c
注释行数: 12
注释内容:
/* Given matrix M, compute
 *
 *		M U = H
 *		M   = H Q
 *
 * with U and Q unimodular matrices and H a matrix in column echelon form
 * such that on each echelon row the entries in the non-echelon column
 * are non-negative (if neg == 0) or non-positive (if neg == 1)
 * and strictly smaller (in absolute value) than the entries in the echelon
 * column.
 * If U or Q are NULL, then these matrices are not computed.
 */
================================================================================

文件路径: ./isl_mat.c
注释行数: 11
注释内容:
/* Replace the variables x in the rows q by x' given by x = M x',
 * with M the matrix mat.
 *
 * If the number of new variables is greater than the original
 * number of variables, then the rows q have already been
 * preextended.  If the new number is smaller, then the coefficients
 * of the divs, which are not changed, need to be shifted down.
 * The row q may be the equalities, the inequalities or the
 * div expressions.  In the latter case, has_div is true and
 * we need to take into account the extra denominator column.
 */
================================================================================

文件路径: ./isl_mat.c
注释行数: 10
注释内容:
/* Replace the variables x in bset by x' given by x = M x', with
 * M the matrix mat.
 *
 * If there are fewer variables x' then there are x, then we perform
 * the transformation in place, which means that, in principle,
 * this frees up some extra variables as the number
 * of columns remains constant, but we would have to extend
 * the div array too as the number of rows in this array is assumed
 * to be equal to extra.
 */
================================================================================

文件路径: ./isl_mat.c
注释行数: 4
注释内容:
/* Replace the variables x starting at "first_col" in the rows "rows"
 * of some coefficient matrix by x' with x = M x' with M the matrix mat.
 * That is, replace the corresponding coefficients c by c M.
 */
================================================================================

文件路径: ./isl_space.c
注释行数: 4
注释内容:
/* Given two map spaces { A -> C } and { B -> D }, construct the space
 * { [A -> B] -> [C -> D] }.
 * Given two set spaces { A } and { B }, construct the space { [A -> B] }.
 */
================================================================================

文件路径: ./isl_space.c
注释行数: 3
注释内容:
/* Given two spaces { A -> C } and { B -> C }, construct the space
 * { [A -> B] -> C }
 */
================================================================================

文件路径: ./isl_space.c
注释行数: 7
注释内容:
/* Internal function that, given a space of the form [A -> B] -> C and
 * a tuple of identifiers in A, returns a space B -> C with
 * the identifiers in "tuple" added as fresh parameters.
 * In other words, the domain dimensions of the wrapped relation
 * in the domain of "space" are reinterpreted
 * as parameters, but stay in the same global positions.
 */
================================================================================

文件路径: ./isl_space.c
注释行数: 5
注释内容:
/* Given a space "space" of a set, create a space
 * for the lift of the set.  In particular, the result
 * is of the form lifted[space -> local[..]], with n_local variables in the
 * range of the wrapped map.
 */
================================================================================

文件路径: ./isl_output.c
注释行数: 2
注释内容:
/* offset is the offset of local_space inside data->type of data->space.
 */
================================================================================

文件路径: ./isl_output.c
注释行数: 8
注释内容:
/* Print dimension "pos" of data->space to "p".
 *
 * data->user is assumed to be an isl_basic_map keeping track of equalities.
 *
 * If the current dimension is defined by these equalities, then print
 * the corresponding expression, assigned to the name of the dimension
 * if there is any.  Otherwise, print the name of the dimension.
 */
================================================================================

文件路径: ./isl_output.c
注释行数: 9
注释内容:
/* Print dimension "pos" of data->space to "p".
 *
 * data->user is assumed to be an isl_multi_aff.
 *
 * If the current dimension is an output dimension, then print
 * the corresponding expression.  Otherwise, print the name of the dimension.
 * Make sure to use the domain space for printing names as
 * that is the space that will be used for printing constraints (if any).
 */
================================================================================

文件路径: ./isl_output.c
注释行数: 11
注释内容:
/* Print dimension "pos" of data->space to "p".
 *
 * data->user is assumed to be an isl_multi_pw_aff.
 *
 * If the current dimension is an output dimension, then print
 * the corresponding piecewise affine expression.
 * Otherwise, print the name of the dimension.
 * Make sure to use the same space in both cases.
 * In particular, use the domain space for printing names as
 * that is the space that is used for printing constraints.
 */
================================================================================

文件路径: ./isl_output.c
注释行数: 7
注释内容:
/* Print dimension "pos" of data->space to "p".
 *
 * data->user is assumed to be an isl_multi_val.
 *
 * If the current dimension is an output dimension, then print
 * the corresponding value.  Otherwise, print the name of the dimension.
 */
================================================================================

文件路径: ./isl_output.c
注释行数: 7
注释内容:
/* Print dimension "pos" of data->space to "p".
 *
 * data->user is assumed to be an isl_multi_id.
 *
 * If the current dimension is an output dimension, then print
 * the corresponding identifier.  Otherwise, print the name of the dimension.
 */
================================================================================

文件路径: ./isl_output.c
注释行数: 8
注释内容:
/* Print dimension "pos" of data->space to "p".
 *
 * data->user is assumed to be an isl_multi_union_pw_aff.
 *
 * The current dimension is necessarily a set dimension, so
 * we print the corresponding isl_union_pw_aff, including
 * the braces.
 */
================================================================================

文件路径: ./isl_scan.c
注释行数: 2
注释内容:
/* Call callback->add with the current sample value of the tableau "tab".
 */
================================================================================

文件路径: ./isl_scan.c
注释行数: 18
注释内容:
/* Look for all integer points in "bset", which is assumed to be bounded,
 * and call callback->add on each of them.
 *
 * We first compute a reduced basis for the set and then scan
 * the set in the directions of this basis.
 * We basically perform a depth first search, where in each level i
 * we compute the range in the i-th basis vector direction, given
 * fixed values in the directions of the previous basis vector.
 * We then add an equality to the tableau fixing the value in the
 * direction of the current basis vector to each value in the range
 * in turn and then continue to the next level.
 *
 * The search is implemented iteratively.  "level" identifies the current
 * basis vector.  "init" is true if we want the first value at the current
 * level and false if we want the next value.
 * Solutions are added in the leaves of the search tree, i.e., after
 * we have fixed a value in each direction of the basis.
 */
================================================================================

文件路径: ./isl_factorization.c
注释行数: 1
注释内容:
/* for each column: row position of pivot */
================================================================================

文件路径: ./isl_int_sioimath.h
注释行数: 11
注释内容:
/* The negation of the smallest possible number in int32_t, INT32_MIN
 * (0x80000000u, -2147483648), cannot be represented in an int32_t, therefore
 * every operation that may produce this value needs to special-case it.
 * The operations are:
 * abs(INT32_MIN)
 * -INT32_MIN   (negation)
 * -1 * INT32_MIN (multiplication)
 * INT32_MIN/-1 (any division: divexact, fdiv, cdiv, tdiv)
 * To avoid checking these cases, we exclude INT32_MIN from small
 * representation.
 */
================================================================================

文件路径: ./isl_int_sioimath.h
注释行数: 9
注释内容:
/* Get the IMath representation of an isl_int without modifying it.
 * For the case it is not in big representation yet, pass some scratch space we
 * can use to store the big representation in.
 * In order to avoid requiring init and free on the scratch space, we directly
 * modify the internal representation.
 *
 * The name derives from its indented use: getting the big representation of an
 * input (src) argument.
 */
================================================================================

文件路径: ./isl_int_sioimath.h
注释行数: 3
注释内容:
/* Get the remainder of: lhs divided by rhs rounded towards negative infinite
 * (Floor).
 */
================================================================================

文件路径: ./isl_int_sioimath.h
注释行数: 5
注释内容:
/* Return:
 *   +1 if lhs > rhs
 *   -1 if lhs < rhs
 *    0 if lhs = rhs
 */
================================================================================

文件路径: ./isl_schedule_node.c
注释行数: 8
注释内容:
/* Update the filter information in "data" based on the first "n"
 * elements in "list" and the extension tree root "tree", in case
 * data->universe_domain is set and data->collect_prefix is not.
 *
 * We collect the universe domain of the elements in "list" and
 * add it to the universe range of the extension (intersected
 * with the already collected filter, if any).
 */
================================================================================

文件路径: ./isl_schedule_node.c
注释行数: 14
注释内容:
/* Update "data" based on the tree node "tree" in case "data" has
 * already been initialized.
 *
 * Return 0 on success and -1 on error.
 *
 * If "tree" is a domain and data->universe_domain is not set, then
 * intersect data->filter with the domain.
 * If "tree" is a filter, then we intersect data->filter with this filter
 * (or its universe).
 * If "tree" is a band with at least one member and data->collect_prefix
 * is set, then we extend data->prefix with the band schedule.
 * If "tree" is an extension, then we make sure that we are not collecting
 * information on any extended domain elements.
 */
================================================================================

文件路径: ./isl_schedule_node.c
注释行数: 26
注释内容:
/* Collect filter and/or prefix information from the first "n"
 * elements in "list" (which represent the ancestors of a node).
 * Store the results in "data".
 *
 * Extension nodes are only supported if they do not affect the outcome,
 * i.e., if we are collecting information on non-extended domain elements,
 * or if we are collecting the universe domain (without prefix).
 *
 * Return 0 on success and -1 on error.
 *
 * We traverse the list from innermost ancestor (last element)
 * to outermost ancestor (first element), calling collect_filter_prefix_init
 * on each node as long as we have not been able to extract any information
 * yet and collect_filter_prefix_update afterwards.
 * If we come across an expansion node, then we interrupt the traversal
 * and call collect_filter_prefix_expansion to restart the traversal
 * over the remaining ancestors and to combine the results with those
 * that have already been collected.
 * If we come across an extension node and we are only computing
 * the universe domain, then we interrupt the traversal and call
 * collect_universe_domain_extension to restart the traversal
 * over the remaining ancestors and to combine the results with those
 * that have already been collected.
 * On successful return, data->initialized will be set since the outermost
 * ancestor is a domain node, which always results in an initialization.
 */
================================================================================

文件路径: ./isl_schedule_node.c
注释行数: 4
注释内容:
/* isl_schedule_node_foreach_descendant_top_down callback
 * that sets data->failed if data->test returns false and
 * subsequently aborts the traversal.
 */
================================================================================

文件路径: ./isl_schedule_node.c
注释行数: 15
注释内容:
/* Update the ancestors of "node" to point to the tree that "node"
 * now points to.
 * That is, replace the child in the original parent that corresponds
 * to the current tree position by node->tree and continue updating
 * the ancestors in the same way until the root is reached.
 *
 * If "fn" is not NULL, then it is called on each ancestor as we move up
 * the tree so that it can modify the ancestor before it is added
 * to the list of ancestors of the modified node.
 * The additional "pos" argument records the position
 * of the "tree" argument in the original schedule tree.
 *
 * If "node" originally points to a leaf of the schedule tree, then make sure
 * that in the end it points to a leaf in the updated schedule tree.
 */
================================================================================

文件路径: ./isl_schedule_node.c
注释行数: 2
注释内容:
/* Is domain covered by data->domain within data->domain_universe?
 */
================================================================================

文件路径: ./isl_schedule_node.c
注释行数: 12
注释内容:
/* Update the band tree root "tree" to refer to the group instances
 * in data->group rather than the original domain elements in data->domain.
 * "pos" is the position in the original schedule tree where the modified
 * "tree" will be attached.
 *
 * Add the part of the identity schedule on the group instances data->sched
 * that corresponds to this band node to the band schedule.
 * If the domain elements that reach the node and that are part
 * of data->domain_universe are all elements of data->domain (and therefore
 * replaced by the group instances) then this data->domain_universe
 * is removed from the domain of the band schedule.
 */
================================================================================

文件路径: ./isl_schedule_node.c
注释行数: 9
注释内容:
/* Update the context tree root "tree" to refer to the group instances
 * in data->group rather than the original domain elements in data->domain.
 * "pos" is the position in the original schedule tree where the modified
 * "tree" will be attached.
 *
 * We do not actually need to update "tree" since a context node only
 * refers to the schedule space.  However, we may need to update "data"
 * to not refer to any parameters introduced by the context node.
 */
================================================================================

文件路径: ./isl_schedule_node.c
注释行数: 9
注释内容:
/* Update the domain tree root "tree" to refer to the group instances
 * in data->group rather than the original domain elements in data->domain.
 * "pos" is the position in the original schedule tree where the modified
 * "tree" will be attached.
 *
 * We first double-check that all grouped domain elements are actually
 * part of the root domain and then replace those elements by the group
 * instances.
 */
================================================================================

文件路径: ./isl_schedule_node.c
注释行数: 14
注释内容:
/* Update the expansion tree root "tree" to refer to the group instances
 * in data->group rather than the original domain elements in data->domain.
 * "pos" is the position in the original schedule tree where the modified
 * "tree" will be attached.
 *
 * Let G_1 -> D_1 be the expansion of "tree" and G_2 -> D_2 the newly
 * introduced expansion in a descendant of "tree".
 * We first double-check that D_2 is a subset of D_1.
 * Then we remove D_2 from the range of G_1 -> D_1 and add the mapping
 * G_1 -> D_1 . D_2 -> G_2.
 * Simmilarly, we restrict the domain of the contraction to the universe
 * of the range of the updated expansion and add G_2 -> D_2 . D_1 -> G_1,
 * attempting to remove the domain constraints of this additional part.
 */
================================================================================

文件路径: ./isl_schedule_node.c
注释行数: 15
注释内容:
/* Update the tree root "tree" to refer to the group instances
 * in data->group rather than the original domain elements in data->domain.
 * "pos" is the position in the original schedule tree where the modified
 * "tree" will be attached.
 *
 * If we have come across a domain or expansion node before (data->finished
 * is set), then we no longer need perform any modifications.
 *
 * If "tree" is a filter, then we add data->group_universe to the filter.
 * We also remove data->domain_universe from the filter if all the domain
 * elements in this universe that reach the filter node are part of
 * the elements that are being grouped by data->expansion.
 * If "tree" is a band, domain or expansion, then it is handled
 * in a separate function.
 */
================================================================================

文件路径: ./isl_schedule_node.c
注释行数: 7
注释内容:
/* Enter the expansion node "node" during a isl_schedule_node_gist traversal.
 *
 * In particular, add an extra element to data->filters containing
 * the expansion of the previous element and replace the expansion
 * and contraction on "node" by the gist with respect to these filters.
 * Also keep track of the fact that we have entered another expansion.
 */
================================================================================

文件路径: ./isl_schedule_node.c
注释行数: 9
注释内容:
/* Leave the expansion node "node" during a isl_schedule_node_gist traversal.
 *
 * In particular, remove the element in data->filters that was added by
 * gist_enter_expansion and decrement the number of outer expansions.
 *
 * The expansion has already been simplified in gist_enter_expansion.
 * If this simplification results in an identity expansion, then
 * it is removed here.
 */
================================================================================

文件路径: ./isl_schedule_node.c
注释行数: 6
注释内容:
/* Enter the extension node "node" during a isl_schedule_node_gist traversal.
 *
 * In particular, add an extra element to data->filters containing
 * the union of the previous element with the additional domain elements
 * introduced by the extension.
 */
================================================================================

文件路径: ./isl_schedule_node.c
注释行数: 26
注释内容:
/* Callback for "traverse" to leave a node for isl_schedule_node_gist.
 *
 * In particular, if the current node is a filter node, then we remove
 * the element on the "filters" list that was added when we entered
 * the node.  There is no need to compute any gist here, since we
 * already did that when we entered the node.
 *
 * Expansion nodes are handled by gist_leave_expansion.
 *
 * If the current node is an extension, then remove the element
 * in data->filters that was added by gist_enter_extension.
 *
 * If the current node is a band node, then we compute the gist of
 * the band node with respect to the intersection of the original context
 * and the intermediate filters.
 *
 * If the current node is a sequence or set node, then some of
 * the filter children may have become empty and so they are removed.
 * If only one child is left, then the set or sequence node along with
 * the single remaining child filter is removed.  The filter can be
 * removed because the filters on a sequence or set node are supposed
 * to partition the incoming domain instances.
 * In principle, it should then be impossible for there to be zero
 * remaining children, but should this happen, we replace the entire
 * subtree with an empty filter.
 */
================================================================================

文件路径: ./isl_schedule_node.c
注释行数: 14
注释内容:
/* Callback for "traverse" to enter a node and to move
 * to the deepest initial subtree that should be traversed
 * by isl_schedule_node_get_subtree_expansion.
 *
 * Whenever we come across an expansion node, the last element
 * of data->expansions is combined with the expansion
 * on the expansion node.
 *
 * Whenever we come across a filter node that is the child
 * of a set or sequence node, data->expansions is extended
 * with a new element that restricts the previous element
 * to the elements selected by the filter.
 * The previous element can then be reused while backtracking.
 */
================================================================================

文件路径: ./isl_schedule_node.c
注释行数: 10
注释内容:
/* Callback for "traverse" to leave a node for
 * isl_schedule_node_get_subtree_expansion.
 *
 * If we come across a filter node that is the child
 * of a set or sequence node, then we remove the element
 * of data->expansions that was added in subtree_expansion_enter.
 *
 * If we reach a leaf node, then the accumulated expansion is
 * added to data->res.
 */
================================================================================

文件路径: ./isl_schedule_node.c
注释行数: 14
注释内容:
/* Callback for "traverse" to enter a node and to move
 * to the deepest initial subtree that should be traversed
 * by isl_schedule_node_get_subtree_contraction.
 *
 * Whenever we come across an expansion node, the last element
 * of data->contractions is combined with the contraction
 * on the expansion node.
 *
 * Whenever we come across a filter node that is the child
 * of a set or sequence node, data->contractions is extended
 * with a new element that restricts the previous element
 * to the elements selected by the filter.
 * The previous element can then be reused while backtracking.
 */
================================================================================

文件路径: ./isl_schedule_node.c
注释行数: 10
注释内容:
/* Callback for "traverse" to leave a node for
 * isl_schedule_node_get_subtree_contraction.
 *
 * If we come across a filter node that is the child
 * of a set or sequence node, then we remove the element
 * of data->contractions that was added in subtree_contraction_enter.
 *
 * If we reach a leaf node, then the accumulated contraction is
 * added to data->res.
 */
================================================================================

文件路径: ./isl_schedule_node.c
注释行数: 9
注释内容:
/* If "node" is a leaf, then plug in data->tree, simplifying it
 * within its new context.
 *
 * If there are any domain elements at the leaf where the tree
 * should not be plugged in (i.e., there are elements not in data->domain)
 * then first extend the tree to only apply to the elements in data->domain
 * by constructing a set node that selects data->tree for elements
 * in data->domain and a leaf for the other elements.
 */
================================================================================

文件路径: ./isl_stream.c
注释行数: 3
注释内容:
/* Read a character from the stream and advance s->line and s->col
 * to point to the next character.
 */
================================================================================

文件路径: ./isl_union_map.c
注释行数: 3
注释内容:
/* Call data->test on "map", which is part of an isl_union_set and
 * therefore known to be an isl_set.
 */
================================================================================

文件路径: ./isl_union_map.c
注释行数: 10
注释内容:
/* Look for the map in data->umap2 that corresponds to "map", if any.
 * Return (isl_bool_true, matching map) if there is one,
 * (isl_bool_false, NULL) if there is no matching map and
 * (isl_bool_error, NULL) on error.
 *
 * If not NULL, then data->control->filter specifies whether "map"
 * can have any matching map.  If so,
 * data->control->match_space specifies which map in data->umap2
 * corresponds to "map".
 */
================================================================================

文件路径: ./isl_union_map.c
注释行数: 9
注释内容:
/* isl_hash_table_foreach callback for gen_bin_op.
 * Look for the map in data->umap2 that corresponds
 * to the map that "entry" points to, apply the binary operation and
 * add the result to data->res.
 *
 * If no corresponding map can be found, then the effect depends
 * on data->control->subtract.  If it is set, then the current map
 * is added directly to the result.  Otherwise, it is ignored.
 */
================================================================================

文件路径: ./isl_union_map.c
注释行数: 4
注释内容:
/* Intersect each map in "umap" in a space [A -> B] -> C
 * with the corresponding map in "factor" in the space A -> C and
 * collect the results.
 */
================================================================================

文件路径: ./isl_union_map.c
注释行数: 4
注释内容:
/* Intersect each map in "umap" in a space [A -> B] -> C
 * with the corresponding map in "factor" in the space B -> C and
 * collect the results.
 */
================================================================================

文件路径: ./isl_union_map.c
注释行数: 4
注释内容:
/* Intersect each map in "umap" in a space A -> [B -> C]
 * with the corresponding map in "factor" in the space A -> B and
 * collect the results.
 */
================================================================================

文件路径: ./isl_union_map.c
注释行数: 4
注释内容:
/* Intersect each map in "umap" in a space A -> [B -> C]
 * with the corresponding map in "factor" in the space A -> C and
 * collect the results.
 */
================================================================================

文件路径: ./isl_union_map.c
注释行数: 2
注释内容:
/* Given two maps A -> B and C -> D, construct a map [A -> C] -> (B * D)
 */
================================================================================

文件路径: ./isl_union_map.c
注释行数: 3
注释内容:
/* If data->map A -> B and "map2" C -> D have the same range space,
 * then add (A, C) -> (B * D) to data->res.
 */
================================================================================

文件路径: ./isl_union_map.c
注释行数: 2
注释内容:
/* Given two maps A -> B and C -> D, construct a map (A, C) -> (B * D).
 */
================================================================================

文件路径: ./isl_union_map.c
注释行数: 4
注释内容:
/* Wrapper for isl_un_op_control filters that do not require
 * a second argument.
 * Simply call data->filter without the second argument.
 */
================================================================================

文件路径: ./isl_union_map.c
注释行数: 9
注释内容:
/* isl_hash_table_foreach callback for un_op.
 * Handle the map that "entry" points to.
 *
 * If control->filter is set, then check if this map satisfies the filter.
 * If so (or if control->filter is not set), modify the map
 * by calling control->fn_map or control->fn_map2 (if set) and
 * either add the result to data->res or
 * replace the original entry by the result (if control->inplace is set).
 */
================================================================================

文件路径: ./isl_union_map.c
注释行数: 7
注释内容:
/* Modify the maps in "umap" based on "control".
 * If control->inplace is set, then modify the maps in "umap" in-place.
 * Otherwise, create a new union map to hold the results.
 * If control->total is set, then perform an inplace computation
 * if "umap" is only referenced once.  Otherwise, create a new union map
 * to store the results.
 */
================================================================================

文件路径: ./isl_union_map.c
注释行数: 3
注释内容:
/* For each map in "umap" of the form [A -> B] -> C,
 * construct the map A -> C and collect the results.
 */
================================================================================

文件路径: ./isl_union_map.c
注释行数: 3
注释内容:
/* For each map in "umap" of the form [A -> B] -> C,
 * construct the map B -> C and collect the results.
 */
================================================================================

文件路径: ./isl_union_map.c
注释行数: 3
注释内容:
/* For each map in "umap" of the form A -> [B -> C],
 * construct the map A -> B and collect the results.
 */
================================================================================

文件路径: ./isl_union_map.c
注释行数: 3
注释内容:
/* For each map in "umap" of the form A -> [B -> C],
 * construct the map A -> C and collect the results.
 */
================================================================================

文件路径: ./isl_union_map.c
注释行数: 3
注释内容:
/* For each map in "umap" of the form [A -> B] -> [C -> D],
 * construct the map A -> C and collect the results.
 */
================================================================================

文件路径: ./isl_union_map.c
注释行数: 3
注释内容:
/* For each map in "umap" of the form [A -> B] -> [C -> D],
 * construct the map B -> D and collect the results.
 */
================================================================================

文件路径: ./isl_union_map.c
注释行数: 3
注释内容:
/* Check if "map" is disjoint from data->umap2 and abort
 * the search if it is not.
 */
================================================================================

文件路径: ./isl_union_map.c
注释行数: 15
注释内容:
/* Check if the data->umap is single-valued on "set".
 *
 * If data->umap consists of a single map on "set", then test it
 * as an isl_map.
 *
 * Otherwise, compute
 *
 *	M \circ M^-1
 *
 * check if the result is a subset of the identity mapping and
 * store the result in data->sv.
 *
 * Terminate as soon as data->umap has been determined not to
 * be single-valued.
 */
================================================================================

文件路径: ./isl_union_map.c
注释行数: 5
注释内容:
/* Call data->fn to compute the preimage of the domain or range of *entry
 * under the function represented by data->pma, provided the domain/range
 * space of *entry matches the target space of data->pma
 * (as given by data->match), and add the result to data->res.
 */
================================================================================

文件路径: ./isl_union_map.c
注释行数: 5
注释内容:
/* Call data->fn to compute the preimage of the domain or range of *entry
 * under the function represented by data->mpa, provided the domain/range
 * space of *entry matches the target space of data->mpa
 * (as given by data->match), and add the result to data->res.
 */
================================================================================

文件路径: ./isl_union_map.c
注释行数: 3
注释内容:
/* Call data->fn to compute the preimage of the domain or range of data->umap
 * under the function represented by pma and add the result to data->res.
 */
================================================================================

文件路径: ./isl_union_map.c
注释行数: 3
注释内容:
/* Turn the data->n dimensions of type data->type, starting at data->first
 * into existentially quantified variables and add the result to data->res.
 */
================================================================================

文件路径: ./isl_union_map.c
注释行数: 2
注释内容:
/* Does "map" _not_ involve the data->n parameters starting at data->first?
 */
================================================================================

文件路径: ./isl_union_map.c
注释行数: 3
注释内容:
/* Replace the range space of "map" by the range space of data->range and
 * add the result to data->res.
 */
================================================================================

文件路径: ./isl_union_map.c
注释行数: 3
注释内容:
/* Replace the parameters of "map" by those of data->space and
 * add the result to data->res.
 */
================================================================================

文件路径: ./isl_union_map.c
注释行数: 4
注释内容:
/* Intersect "map" with the result of applying data->order to
 * the functions in data->mupa that apply to the domain and the range
 * of "map" and add the result to data->res.
 */
================================================================================

文件路径: ./isl_union_map.c
注释行数: 3
注释内容:
/* isl_un_op_control filter that negates the result of data->fn
 * called on "map".
 */
================================================================================

文件路径: ./isl_aff.c
注释行数: 4
注释内容:
/* Look for any divs in the aff->ls with a denominator equal to one
 * and plug them into the affine expression and any subsequent divs
 * that may reference the div.
 */
================================================================================

文件路径: ./isl_aff.c
注释行数: 5
注释内容:
/* Swap divs "a" and "b" in "aff", which is assumed to be non-NULL.
 *
 * Even though this function is only called on isl_affs with a single
 * reference, we are careful to only change aff->v and aff->ls together.
 */
================================================================================

文件路径: ./isl_aff.c
注释行数: 6
注释内容:
/* Compute
 *
 *	aff mod m = aff - m * floor(aff/m)
 *
 * with m an integer value.
 */
================================================================================

文件路径: ./isl_aff.c
注释行数: 4
注释内容:
/* Compute
 *
 *	pwaff mod m = pwaff - m * floor(pwaff/m)
 */
================================================================================

文件路径: ./isl_aff.c
注释行数: 6
注释内容:
/* Compute
 *
 *	pa mod m = pa - m * floor(pa/m)
 *
 * with m an integer value.
 */
================================================================================

文件路径: ./isl_aff.c
注释行数: 2
注释内容:
/* Given a function A -> [B -> C], extract the function A -> B.
 */
================================================================================

文件路径: ./isl_aff.c
注释行数: 2
注释内容:
/* Given a function A -> [B -> C], extract the function A -> C.
 */
================================================================================

文件路径: ./isl_aff.c
注释行数: 3
注释内容:
/* Given two piecewise multi-affine expressions A -> B and C -> D,
 * construct a piecewise multi-affine expression [A -> C] -> [B -> D].
 */
================================================================================

文件路径: ./isl_aff.c
注释行数: 67
注释内容:
/* Extract an affine expression that expresses the output dimension "pos"
 * of "bmap" in terms of the parameters and input dimensions from
 * equality "eq".
 * Note that this expression may involve integer divisions defined
 * in terms of parameters and input dimensions.
 * The equality may also involve references to earlier (but not later)
 * output dimensions.  These are replaced by the corresponding elements
 * in "ma".
 *
 * If the equality is of the form
 *
 *	f(i) + h(j) + a x + g(i) = 0,
 *
 * with f(i) a linear combinations of the parameters and input dimensions,
 * g(i) a linear combination of integer divisions defined in terms of the same
 * and h(j) a linear combinations of earlier output dimensions,
 * then the affine expression is
 *
 *	(-f(i) - g(i))/a - h(j)/a
 *
 * If the equality is of the form
 *
 *	f(i) + h(j) - a x + g(i) = 0,
 *
 * then the affine expression is
 *
 *	(f(i) + g(i))/a - h(j)/(-a)
 *
 *
 * If "div" refers to an integer division (i.e., it is smaller than
 * the number of integer divisions), then the equality constraint
 * does involve an integer division (the one at position "div") that
 * is defined in terms of output dimensions.  However, this integer
 * division can be eliminated by exploiting a pair of constraints
 * x >= l and x <= l + n, with n smaller than the coefficient of "div"
 * in the equality constraint.  "ineq" refers to inequality x >= l, i.e.,
 * -l + x >= 0.
 * In particular, let
 *
 *	x = e(i) + m floor(...)
 *
 * with e(i) the expression derived above and floor(...) the integer
 * division involving output dimensions.
 * From
 *
 *	l <= x <= l + n,
 *
 * we have
 *
 *	0 <= x - l <= n
 *
 * This means
 *
 *	e(i) + m floor(...) - l = (e(i) + m floor(...) - l) mod m
 *	                        = (e(i) - l) mod m
 *
 * Therefore,
 *
 *	x - l = (e(i) - l) mod m
 *
 * or
 *
 *	x = ((e(i) - l) mod m) + l
 *
 * The variable "shift" below contains the expression -l, which may
 * also involve a linear combination of earlier output dimensions.
 */
================================================================================

文件路径: ./isl_aff.c
注释行数: 27
注释内容:
/* Try and create an isl_pw_multi_aff that is equivalent to the given isl_map,
 * taking into account that the output dimension at position "d"
 * can be represented as
 *
 *	x = floor((e(...) + c1) / m)
 *
 * given that constraint "i" is of the form
 *
 *	e(...) + c1 - m x >= 0
 *
 *
 * Let "map" be of the form
 *
 *	A -> B
 *
 * We construct a mapping
 *
 *	A -> [A -> x = floor(...)]
 *
 * apply that to the map, obtaining
 *
 *	[A -> x = floor(...)] -> B
 *
 * and equate dimension "d" to x.
 * We then compute a isl_pw_multi_aff representation of the resulting map
 * and plug in the mapping above.
 */
================================================================================

文件路径: ./isl_aff.c
注释行数: 33
注释内容:
/* Try and create an isl_pw_multi_aff that is equivalent to the given isl_map.
 *
 * As a special case, we first check if there is any pair of constraints,
 * shared by all the basic maps in "map" that force a given dimension
 * to be equal to the floor of some affine combination of the input dimensions.
 *
 * In particular, if we can find two constraints
 *
 *	e(...) + c1 - m x >= 0		i.e.,		m x <= e(...) + c1
 *
 * and
 *
 *	-e(...) + c2 + m x >= 0		i.e.,		m x >= e(...) - c2
 *
 * where m > 1 and e only depends on parameters and input dimemnsions,
 * and such that
 *
 *	c1 + c2 < m			i.e.,		-c2 >= c1 - (m - 1)
 *
 * then we know that we can take
 *
 *	x = floor((e(...) + c1) / m)
 *
 * without having to perform any computation.
 *
 * Note that we know that
 *
 *	c1 + c2 >= 1
 *
 * If c1 + c2 were 0, then we would have detected an equality during
 * simplification.  If c1 + c2 were negative, then we would have detected
 * a contradiction.
 */
================================================================================

文件路径: ./isl_aff.c
注释行数: 21
注释内容:
/* Given an affine expression
 *
 *	[A -> B] -> f(A,B)
 *
 * construct an isl_multi_aff
 *
 *	[A -> B] -> B'
 *
 * such that dimension "d" in B' is set to "aff" and the remaining
 * dimensions are set equal to the corresponding dimensions in B.
 * "n_in" is the dimension of the space A.
 * "n_out" is the dimension of the space B.
 *
 * If "is_set" is set, then the affine expression is of the form
 *
 *	[B] -> f(B)
 *
 * and we construct an isl_multi_aff
 *
 *	B -> B'
 */
================================================================================

文件路径: ./isl_aff.c
注释行数: 56
注释内容:
/* Try and create an isl_pw_multi_aff that is equivalent to the given isl_map,
 * taking into account that the dimension at position "d" can be written as
 *
 *	x = m a + f(..)						(1)
 *
 * where m is equal to "gcd".
 * "i" is the index of the equality in "hull" that defines f(..).
 * In particular, the equality is of the form
 *
 *	f(..) - x + m g(existentials) = 0
 *
 * or
 *
 *	-f(..) + x + m g(existentials) = 0
 *
 * We basically plug (1) into "map", resulting in a map with "a"
 * in the range instead of "x".  The corresponding isl_pw_multi_aff
 * defining "a" is then plugged back into (1) to obtain a definition for "x".
 *
 * Specifically, given the input map
 *
 *	A -> B
 *
 * We first wrap it into a set
 *
 *	[A -> B]
 *
 * and define (1) on top of the corresponding space, resulting in "aff".
 * We use this to create an isl_multi_aff that maps the output position "d"
 * from "a" to "x", leaving all other (intput and output) dimensions unchanged.
 * We plug this into the wrapped map, unwrap the result and compute the
 * corresponding isl_pw_multi_aff.
 * The result is an expression
 *
 *	A -> T(A)
 *
 * We adjust that to
 *
 *	A -> [A -> T(A)]
 *
 * so that we can plug that into "aff", after extending the latter to
 * a mapping
 *
 *	[A -> B] -> B'
 *
 *
 * If "map" is actually a set, then there is no "A" space, meaning
 * that we do not need to perform any wrapping, and that the result
 * of the recursive call is of the form
 *
 *	[T]
 *
 * which is plugged into a mapping of the form
 *
 *	B -> B'
 */
================================================================================

文件路径: ./isl_aff.c
注释行数: 15
注释内容:
/* Try and create an isl_pw_multi_aff that is equivalent to the given isl_map.
 * "hull" contains the equalities valid for "map".
 *
 * Check if any of the output dimensions is "strided".
 * That is, we check if it can be written as
 *
 *	x = m a + f(..)
 *
 * with m greater than 1, a some combination of existentially quantified
 * variables and f an expression in the parameters and input dimensions.
 * If so, we remove the stride in pw_multi_aff_from_map_stride.
 *
 * Otherwise, we continue with pw_multi_aff_from_map_check_div for a further
 * special case.
 */
================================================================================

文件路径: ./isl_aff.c
注释行数: 18
注释内容:
/* Plug in "subs" for dimension "type", "pos" of "pma".
 *
 * pma is of the form
 *
 *	A_i(v) -> M_i(v)
 *
 * while subs is of the form
 *
 *	v' = B_j(v) -> S_j
 *
 * Each pair i,j such that C_ij = A_i \cap B_i is non-empty
 * has a contribution in the result, in particular
 *
 *	C_ij(S_j) -> M_i(S_j)
 *
 * Note that plugging in S_j in C_ij may also result in an empty set
 * and this contribution should simply be discarded.
 */
================================================================================

文件路径: ./isl_aff.c
注释行数: 19
注释内容:
/* Compute the pullback of "aff" by the function represented by "ma".
 * In other words, plug in "ma" in "aff".  The result is an affine expression
 * defined over the domain space of "ma".
 *
 * If "aff" is represented by
 *
 *	(a(p) + b x + c(divs))/d
 *
 * and ma is represented by
 *
 *	x = D(p) + F(y) + G(divs')
 *
 * then the result is
 *
 *	(a(p) + b D(p) + b F(y) + b G(divs') + c(divs))/d
 *
 * The divs in the local space of the input are similarly adjusted
 * through a call to isl_local_space_preimage_multi_aff.
 */
================================================================================

文件路径: ./isl_aff.c
注释行数: 3
注释内容:
/* Given an isl_pw_multi_aff from upma1, store it in data->pma
 * and call data->fn for each isl_pw_multi_aff in data->upma2.
 */
================================================================================

文件路径: ./isl_aff.c
注释行数: 5
注释内容:
/* Call "fn" on each pair of isl_pw_multi_affs in "upma1" and "upma2".
 * The isl_pw_multi_aff from upma1 is stored in data->pma (where data is
 * passed as user field) and the isl_pw_multi_aff from upma2 is available
 * as *entry.  The callback should adjust data->res if desired.
 */
================================================================================

文件路径: ./isl_aff.c
注释行数: 3
注释内容:
/* Given two isl_pw_multi_affs A -> B and C -> D,
 * construct an isl_pw_multi_aff (A * C) -> [B -> D].
 */
================================================================================

文件路径: ./isl_aff.c
注释行数: 3
注释内容:
/* Given two isl_pw_multi_affs A -> B and C -> D,
 * construct an isl_pw_multi_aff (A * C) -> (B, D).
 */
================================================================================

文件路径: ./isl_aff.c
注释行数: 3
注释内容:
/* If data->pma and "pma2" have the same domain space, then use "range_product"
 * to compute some form of range product and add the result to data->res.
 */
================================================================================

文件路径: ./isl_aff.c
注释行数: 3
注释内容:
/* If data->pma and "pma2" have the same domain space, then compute
 * their flat range product and add the result to data->res.
 */
================================================================================

文件路径: ./isl_aff.c
注释行数: 3
注释内容:
/* Given two isl_union_pw_multi_affs A -> B and C -> D,
 * construct an isl_union_pw_multi_aff (A * C) -> (B, D).
 */
================================================================================

文件路径: ./isl_aff.c
注释行数: 3
注释内容:
/* If data->pma and "pma2" have the same domain space, then compute
 * their range product and add the result to data->res.
 */
================================================================================

文件路径: ./isl_aff.c
注释行数: 3
注释内容:
/* Given two isl_union_pw_multi_affs A -> B and C -> D,
 * construct an isl_union_pw_multi_aff (A * C) -> [B -> D].
 */
================================================================================

文件路径: ./isl_aff.c
注释行数: 3
注释内容:
/* Create an isl_pw_multi_aff equal to data->mv on "domain"
 * and add it to data->res.
 */
================================================================================

文件路径: ./isl_aff.c
注释行数: 3
注释内容:
/* Compute the pullback of data->pma by the function represented by "pma2",
 * provided the spaces match, and add the results to data->res.
 */
================================================================================

文件路径: ./isl_aff.c
注释行数: 10
注释内容:
/* Given a function "pma1" of the form A[B -> C] -> D and
 * a function "pma2" of the form E -> B,
 * replace the domain of the wrapped relation inside the domain of "pma1"
 * by the preimage with respect to "pma2".
 * In other words, plug in "pma2" in this nested domain.
 * The result is of the form A[E -> C] -> D.
 *
 * In particular, extend E -> B to A[E -> C] -> A[B -> C] and
 * plug that into "pma1".
 */
================================================================================

文件路径: ./isl_aff.c
注释行数: 7
注释内容:
/* If data->pma and "pma2" are such that
 * data->pma is of the form A[B -> C] -> D and
 * "pma2" is of the form E -> B,
 * then replace the domain of the wrapped relation
 * inside the domain of data->pma by the preimage with respect to "pma2" and
 * add the result to data->res.
 */
================================================================================

文件路径: ./isl_aff.c
注释行数: 7
注释内容:
/* For each pair of functions A[B -> C] -> D in "upma1" and
 * E -> B in "upma2",
 * replace the domain of the wrapped relation inside the domain of the first
 * by the preimage with respect to the second and collect the results.
 * In other words, plug in the second function in this nested domain.
 * The results are of the form A[E -> C] -> D.
 */
================================================================================

文件路径: ./isl_aff.c
注释行数: 3
注释内容:
/* Replace the parameters of "pa" by data->space and
 * add the result to data->res.
 */
================================================================================

文件路径: ./isl_aff.c
注释行数: 6
注释内容:
/* Compute
 *
 *	upa mod m = upa - m * floor(upa/m)
 *
 * with m an integer value.
 */
================================================================================

文件路径: ./isl_aff.c
注释行数: 3
注释内容:
/* Extract an isl_pw_aff corresponding to output dimension "pos" of "pma"
 * (assuming it has such a dimension) and add it to data->res.
 */
================================================================================

文件路径: ./isl_aff.c
注释行数: 3
注释内容:
/* Construct a piecewise affine expression that is equal to data->pa
 * on "domain" and add the result to data->res.
 */
================================================================================

文件路径: ./isl_aff.c
注释行数: 3
注释内容:
/* Construct a piecewise affine expression that is equal to data->v
 * on "domain" and add the result to data->res.
 */
================================================================================

文件路径: ./isl_aff.c
注释行数: 4
注释内容:
/* Bind the piecewise affine function "pa" to the parameter data->id,
 * adding the resulting elements in the domain where the expression
 * is equal to the parameter to data->bound.
 */
================================================================================

文件路径: ./isl_aff.c
注释行数: 3
注释内容:
/* Check if "pma" can be plugged into data->pa.
 * If so, perform the pullback and add the result to data->res.
 */
================================================================================

文件路径: ./isl_aff.c
注释行数: 3
注释内容:
/* Check if any of the elements of data->upma can be plugged into pa,
 * add if so add the result to data->res.
 */
================================================================================

文件路径: ./isl_aff.c
注释行数: 3
注释内容:
/* Replace the range space of "pma" by the range space of data->range and
 * add the result to data->res.
 */
================================================================================

文件路径: ./isl_aff.c
注释行数: 5
注释内容:
/* Wrapper for isl_union_pw_multi_aff_un_op filter functions (which do not take
 * a second argument) for use as an isl_union_pw_multi_aff_transform
 * filter function (which does take a second argument).
 * Simply call control->filter without the second argument.
 */
================================================================================

文件路径: ./isl_aff.c
注释行数: 5
注释内容:
/* Wrapper for isl_union_pw_multi_aff_un_op base functions (which do not take
 * a second argument) for use as an isl_union_pw_multi_aff_transform
 * base function (which does take a second argument).
 * Simply call control->fn without the second argument.
 */
================================================================================

文件路径: ./isl_aff.c
注释行数: 3
注释内容:
/* For each function in "upma" of the form A -> [B -> C],
 * extract the function A -> B and collect the results.
 */
================================================================================

文件路径: ./isl_aff.c
注释行数: 3
注释内容:
/* For each function in "upma" of the form A -> [B -> C],
 * extract the function A -> C and collect the results.
 */
================================================================================

文件路径: ./isl_schedule_band.c
注释行数: 11
注释内容:
/* Given a parameter space "space", extend it to a set space
 *
 *	{ type[x] }
 *
 * or
 *
 *	{ [isolate[] -> type[x]] }
 *
 * depending on whether "isolate" is set.
 * These can be used to encode loop AST generation options of the given type.
 */
================================================================================

文件路径: ./isl_schedule_band.c
注释行数: 12
注释内容:
/* Add encodings of the "n" loop AST generation options "type" to "options".
 * If "isolate" is set, then these options refer to the isolated part.
 *
 * In particular, for each sequence of consecutive identical types "t",
 * different from the default, add an option
 *
 *	{ t[x] : first <= x <= last }
 *
 * or
 *
 *	{ [isolate[] -> t[x]] : first <= x <= last }
 */
================================================================================

文件路径: ./isl_schedule_band.c
注释行数: 2
注释内容:
/* Does "set" not satisfy data->is()?
 */
================================================================================

文件路径: ./isl_schedule_band.c
注释行数: 6
注释内容:
/* Does "set" live in a space of the form
 *
 *	isolate[[...] -> [...]]
 *
 * ?
 */
================================================================================

文件路径: ./isl_schedule_band.c
注释行数: 6
注释内容:
/* Does "options" include an option of the ofrm
 *
 *	isolate[[...] -> [...]]
 *
 * ?
 */
================================================================================

文件路径: ./isl_schedule_band.c
注释行数: 7
注释内容:
/* Does "set" encode a loop AST generation option for the isolated part?
 * That is, is of the form
 *
 *	{ [isolate[] -> t[x]] }
 *
 * with t equal to "atomic", "unroll" or "separate"?
 */
================================================================================

文件路径: ./isl_schedule_band.c
注释行数: 4
注释内容:
/* Extract the loop AST generation types for the members of "band"
 * from "options" and store them in band->loop_type.
 * Return -1 on error.
 */
================================================================================

文件路径: ./isl_schedule_band.c
注释行数: 5
注释内容:
/* Extract the loop AST generation types for the members of "band"
 * from "options" for the isolated part and
 * store them in band->isolate_loop_type.
 * Return -1 on error.
 */
================================================================================

文件路径: ./isl_schedule_band.c
注释行数: 10
注释内容:
/* Construct universe sets of the spaces that encode loop AST generation
 * types (for the isolated part if "isolate" is set).  That is, construct
 *
 *	{ atomic[x]; separate[x]; unroll[x] }
 *
 * or
 *
 *	{ [isolate[] -> atomic[x]]; [isolate[] -> separate[x]];
 *	  [isolate[] -> unroll[x]] }
 */
================================================================================

文件路径: ./isl_schedule_band.c
注释行数: 11
注释内容:
/* Replace the AST build options associated to "band" by "options".
 * If there are any loop AST generation type options, then they
 * are extracted and stored in band->loop_type.  Otherwise,
 * band->loop_type is removed to indicate that the default applies
 * to all members.  Similarly for the loop AST generation type options
 * for the isolated part, which are stored in band->isolate_loop_type.
 * The remaining options are stored in band->ast_build_options.
 *
 * Set anchored if the options include an isolate option since the
 * domain of the wrapped map references the outer band node schedules.
 */
================================================================================

文件路径: ./isl_multi_product_templ.c
注释行数: 6
注释内容:
/* Given two MULTI(BASE)s A -> B and C -> D,
 * construct a MULTI(BASE) [A -> C] -> [B -> D].
 *
 * If "multi1" and/or "multi2" has an explicit domain, then
 * intersect the domain of the result with these explicit domains.
 */
================================================================================

文件路径: ./isl_multi_templ.c
注释行数: 6
注释内容:
/* Given two MULTI(BASE)s A -> B and C -> D,
 * construct a MULTI(BASE) (A * C) -> [B -> D].
 *
 * If "multi1" and/or "multi2" has an explicit domain, then
 * intersect the domain of the result with these explicit domains.
 */
================================================================================

文件路径: ./isl_multi_templ.c
注释行数: 2
注释内容:
/* Given a function A -> [B -> C], extract the function A -> B.
 */
================================================================================

文件路径: ./isl_multi_templ.c
注释行数: 2
注释内容:
/* Given a function A -> [B -> C], extract the function A -> C.
 */
================================================================================

文件路径: ./isl_multi_templ.c
注释行数: 2
注释内容:
/* Given a function [B -> C], extract the function C.
 */
================================================================================

文件路径: ./isl_multi_templ.c
注释行数: 3
注释内容:
/* Given two MULTI(BASE)s A -> B and C -> D,
 * construct a MULTI(BASE) (A * C) -> (B, D).
 */
================================================================================

文件路径: ./isl_vertices.c
注释行数: 4
注释内容:
/* Create todo items for all interior facets of the chamber represented
 * by "tab" and collect them in first->next, taking care to cancel
 * opposite todo items.
 */
================================================================================

文件路径: ./isl_tab_lexopt_templ.c
注释行数: 32
注释内容:
/* Given a basic map with at least two parallel constraints (as found
 * by the function parallel_constraints), first look for more constraints
 * parallel to the two constraint and replace the found list of parallel
 * constraints by a single constraint with as "input" part the minimum
 * of the input parts of the list of constraints.  Then, recursively call
 * basic_map_partial_lexopt (possibly finding more parallel constraints)
 * and plug in the definition of the minimum in the result.
 *
 * As in parallel_constraints, only inequality constraints that only
 * involve input variables that do not occur in any other inequality
 * constraints are considered.
 *
 * More specifically, given a set of constraints
 *
 *	a x + b_i(p) >= 0
 *
 * Replace this set by a single constraint
 *
 *	a x + u >= 0
 *
 * with u a new parameter with constraints
 *
 *	u <= b_i(p)
 *
 * Any solution to the new system is also a solution for the original system
 * since
 *
 *	a x >= -u >= -b_i(p)
 *
 * Moreover, m = min_i(b_i(p)) satisfies the constraints on u and can
 * therefore be plugged into the solution.
 */
================================================================================

文件路径: ./isl_map_simplify.c
注释行数: 20
注释内容:
/* Reduce the coefficient of the variable at position "pos"
 * in integer division "div", such that it lies in the half-open
 * interval (1/2,1/2], extracting any excess value from this integer division.
 * "pos" is as determined by isl_basic_map_offset, i.e., pos == 0
 * corresponds to the constant term.
 *
 * That is, the integer division is of the form
 *
 *	floor((... + (c * d + r) * x_pos + ...)/d)
 *
 * with -d < 2 * r <= d.
 * Replace it by
 *
 *	floor((... + r * x_pos + ...)/d) + c * x_pos
 *
 * If 2 * ((c * d + r) % d) <= d, then c = floor((c * d + r)/d).
 * Otherwise, c = floor((c * d + r)/d) + 1.
 *
 * This is the same normalization that is performed by isl_aff_floor.
 */
================================================================================

文件路径: ./isl_map_simplify.c
注释行数: 48
注释内容:
/* Normalize divs that appear in equalities.
 *
 * In particular, we assume that bmap contains some equalities
 * of the form
 *
 *	a x = m * e_i
 *
 * and we want to replace the set of e_i by a minimal set and
 * such that the new e_i have a canonical representation in terms
 * of the vector x.
 * If any of the equalities involves more than one divs, then
 * we currently simply bail out.
 *
 * Let us first additionally assume that all equalities involve
 * a div.  The equalities then express modulo constraints on the
 * remaining variables and we can use "parameter compression"
 * to find a minimal set of constraints.  The result is a transformation
 *
 *	x = T(x') = x_0 + G x'
 *
 * with G a lower-triangular matrix with all elements below the diagonal
 * non-negative and smaller than the diagonal element on the same row.
 * We first normalize x_0 by making the same property hold in the affine
 * T matrix.
 * The rows i of G with a 1 on the diagonal do not impose any modulo
 * constraint and simply express x_i = x'_i.
 * For each of the remaining rows i, we introduce a div and a corresponding
 * equality.  In particular
 *
 *	g_ii e_j = x_i - g_i(x')
 *
 * where each x'_k is replaced either by x_k (if g_kk = 1) or the
 * corresponding div (if g_kk != 1).
 *
 * If there are any equalities not involving any div, then we
 * first apply a variable compression on the variables x:
 *
 *	x = C x''	x'' = C_2 x
 *
 * and perform the above parameter compression on A C instead of on A.
 * The resulting compression is then of the form
 *
 *	x'' = T(x') = x_0 + G x'
 *
 * and in constructing the new divs and the corresponding equalities,
 * we have to replace each x'', i.e., the x'_k with (g_kk = 1),
 * by the corresponding row from C_2.
 */
================================================================================

文件路径: ./isl_map_simplify.c
注释行数: 8
注释内容:
/* If the only constraints a div d=floor(f/m)
 * appears in are its two defining constraints
 *
 *	f - m d >=0
 *	-(f - (m - 1)) + m d >= 0
 *
 * then it can safely be removed.
 */
================================================================================

文件路径: ./isl_map_simplify.c
注释行数: 28
注释内容:
/* Remove the prime factors from *g that have an exponent that
 * is strictly smaller than the exponent in "c".
 * All exponents in *g are known to be smaller than or equal
 * to those in "c".
 *
 * That is, if *g is equal to
 *
 *	p_1^{e_1} p_2^{e_2} ... p_n^{e_n}
 *
 * and "c" is equal to
 *
 *	p_1^{f_1} p_2^{f_2} ... p_n^{f_n}
 *
 * then update *g to
 *
 *	p_1^{e_1 * (e_1 = f_1)} p_2^{e_2 * (e_2 = f_2)} ...
 *		p_n^{e_n * (e_n = f_n)}
 *
 * If e_i = f_i, then c / *g does not have any p_i factors and therefore
 * neither does the gcd of *g and c / *g.
 * If e_i < f_i, then the gcd of *g and c / *g has a positive
 * power min(e_i, s_i) of p_i with s_i = f_i - e_i among its factors.
 * Dividing *g by this gcd therefore strictly reduces the exponent
 * of the prime factors that need to be removed, while leaving the
 * other prime factors untouched.
 * Repeating this process until gcd(*g, c / *g) = 1 therefore
 * removes all undesired factors, without removing any others.
 */
================================================================================

文件路径: ./isl_map_simplify.c
注释行数: 49
注释内容:
/* Reduce the "n" stride constraints in "bmap" based on a copy "A"
 * of the same stride constraints in a compressed space that exploits
 * all equalities in the context and the other equalities in "bmap".
 *
 * If the stride constraints of "bmap" are of the form
 *
 *	C(x) + D(y) = 0
 *
 * then A is of the form
 *
 *	B(x') + D(y) = 0
 *
 * If any of these constraints involves only a single local variable y,
 * then the constraint appears as
 *
 *	f(x) + m y_i = 0
 *
 * in "bmap" and as
 *
 *	h(x') + m y_i = 0
 *
 * in "A".
 *
 * Let g be the gcd of m and the coefficients of h.
 * Then, in particular, g is a divisor of the coefficients of h and
 *
 *	f(x) = h(x')
 *
 * is known to be a multiple of g.
 * If some prime factor in m appears with the same exponent in g,
 * then it can be removed from m because f(x) is already known
 * to be a multiple of g and therefore in particular of this power
 * of the prime factors.
 * Prime factors that appear with a smaller exponent in g cannot
 * be removed from m.
 * Let g' be the divisor of g containing all prime factors that
 * appear with the same exponent in m and g, then
 *
 *	f(x) + m y_i = 0
 *
 * can be replaced by
 *
 *	f(x) + m/g' y_i' = 0
 *
 * Note that (if g' != 1) this changes the explicit representation
 * of y_i to that of y_i', so the integer division at position i
 * is marked unknown and later recomputed by a call to
 * isl_basic_map_gauss.
 */
================================================================================

文件路径: ./isl_map_simplify.c
注释行数: 4
注释内容:
/* Is the inequality stored in data->v satisfied by "bmap"?
 * That is, does it only attain non-negative values?
 * data->tab is a tableau corresponding to "bmap".
 */
================================================================================

文件路径: ./isl_map_simplify.c
注释行数: 52
注释内容:
/* Given a lower and an upper bound on div i, do they always allow
 * for an integer value of the given div?
 * Determine this property by constructing an inequality
 * such that the property is guaranteed when the inequality is nonnegative.
 * The lower bound is inequality l, while the upper bound is inequality u.
 * The constructed inequality is stored in data->v.
 *
 * Let the upper bound be
 *
 *	-n_u a + e_u >= 0
 *
 * and the lower bound
 *
 *	n_l a + e_l >= 0
 *
 * Let n_u = f_u g and n_l = f_l g, with g = gcd(n_u, n_l).
 * We have
 *
 *	- f_u e_l <= f_u f_l g a <= f_l e_u
 *
 * Since all variables are integer valued, this is equivalent to
 *
 *	- f_u e_l - (f_u - 1) <= f_u f_l g a <= f_l e_u + (f_l - 1)
 *
 * If this interval is at least f_u f_l g, then it contains at least
 * one integer value for a.
 * That is, the test constraint is
 *
 *	f_l e_u + f_u e_l + f_l - 1 + f_u - 1 + 1 >= f_u f_l g
 *
 * or
 *
 *	f_l e_u + f_u e_l + f_l - 1 + f_u - 1 + 1 - f_u f_l g >= 0
 *
 * If the coefficients of f_l e_u + f_u e_l have a common divisor g',
 * then the constraint can be scaled down by a factor g',
 * with the constant term replaced by
 * floor((f_l e_{u,0} + f_u e_{l,0} + f_l - 1 + f_u - 1 + 1 - f_u f_l g)/g').
 * Note that the result of applying Fourier-Motzkin to this pair
 * of constraints is
 *
 *	f_l e_u + f_u e_l >= 0
 *
 * If the constant term of the scaled down version of this constraint,
 * i.e., floor((f_l e_{u,0} + f_u e_{l,0})/g') is equal to the constant
 * term of the scaled down test constraint, then the test constraint
 * is known to hold and no explicit evaluation is required.
 * This is essentially the Omega test.
 *
 * If the test constraint consists of only a constant term, then
 * it is sufficient to look at the sign of this constant term.
 */
================================================================================

文件路径: ./isl_map_simplify.c
注释行数: 42
注释内容:
/* Remove divs that are not strictly needed based on the inequality
 * constraints.
 * In particular, if a div only occurs positively (or negatively)
 * in constraints, then it can simply be dropped.
 * Also, if a div occurs in only two constraints and if moreover
 * those two constraints are opposite to each other, except for the constant
 * term and if the sum of the constant terms is such that for any value
 * of the other values, there is always at least one integer value of the
 * div, i.e., if one plus this sum is greater than or equal to
 * the (absolute value) of the coefficient of the div in the constraints,
 * then we can also simply drop the div.
 *
 * If an existentially quantified variable does not have an explicit
 * representation, appears in only a single lower bound that does not
 * involve any other such existentially quantified variables and appears
 * in this lower bound with coefficient 1,
 * then fix the variable to the value of the lower bound.  That is,
 * turn the inequality into an equality.
 * If for any value of the other variables, there is any value
 * for the existentially quantified variable satisfying the constraints,
 * then this lower bound also satisfies the constraints.
 * It is therefore safe to pick this lower bound.
 *
 * The same reasoning holds even if the coefficient is not one.
 * However, fixing the variable to the value of the lower bound may
 * in general introduce an extra integer division, in which case
 * it may be better to pick another value.
 * If this integer division has a known constant value, then plugging
 * in this constant value removes the existentially quantified variable
 * completely.  In particular, if the lower bound is of the form
 * ceil((-f(x) - c)/n) and there are two constraints, f(x) + c0 >= 0 and
 * -f(x) + c1 >= 0 such that ceil((-c1 - c)/n) = ceil((c0 - c)/n),
 * then the existentially quantified variable can be assigned this
 * shared value.
 *
 * We skip divs that appear in equalities or in the definition of other divs.
 * Divs that appear in the definition of other divs usually occur in at least
 * 4 constraints, but the constraints may have been simplified.
 *
 * If any divs are left after these simple checks then we move on
 * to more complicated cases in drop_more_redundant_divs.
 */
================================================================================

文件路径: ./isl_pw_union_opt.c
注释行数: 29
注释内容:
/* Given (potentially) updated cells "i" of data_i->pw and "j" of data_j->pw and
 * a set "better" where the piece from data_j->pw is better
 * than the piece from data_i->pw,
 * (further) update the specified cells such that only the better elements
 * remain on the (non-empty) intersection.
 *
 * Let C be the set "better".
 * Let A be the cell data_i->cell[i] and B the cell data_j->cell[j].
 *
 * The elements in C need to be removed from A, except for those parts
 * that lie outside of B.  That is,
 *
 *	A <- (A \setminus C) \cup ((A \cap C) \setminus B')
 *
 * Conversely, the elements in B need to be restricted to C, except
 * for those parts that lie outside of A.  That is
 *
 *	B <- (B \cap C) \cup ((B \setminus C) \setminus A')
 *
 * Since all pairs of pieces are considered, the domains are updated
 * several times.  A and B refer to these updated domains
 * (kept track of in data_i->cell[i] and data_j->cell[j]), while A' and B' refer
 * to the original domains of the pieces.  It is safe to use these
 * original domains because the difference between, say, A' and A is
 * the domains of pw2-pieces that have been removed before and
 * those domains are disjoint from B.  A' is used instead of A
 * because the continued updating of A may result in this domain
 * getting broken up into more disjuncts.
 */
================================================================================

文件路径: ./isl_pw_union_opt.c
注释行数: 6
注释内容:
/* Given (potentially) updated cells "i" of data_i->pw and "j" of data_j->pw and
 * a function "cmp" that returns the set of elements where
 * "el1" is "better" than "el2",
 * (further) update the specified cells such that only the "better" elements
 * remain on the (non-empty) intersection.
 */
================================================================================

文件路径: ./isl_pw_union_opt.c
注释行数: 23
注释内容:
/* Given (potentially) updated cells "i" of data_i->pw and "j" of data_j->pw and
 * a function "cmp" that returns the set of elements where
 * "el1" is "better" than "el2",
 * (further) update the specified cells such that only the "better" elements
 * remain on the (non-empty) intersection.
 *
 * The base computation is performed by isl_pw_*_union_opt_cmp_pair,
 * which splits the cells according to the set of elements
 * where the piece from data_j->pw is better than the piece from data_i->pw.
 *
 * In some cases, there may be a subset of the intersection
 * where both pieces have the same value and can therefore
 * both be considered to be "better" than the other.
 * This can result in unnecessary splitting on this subset.
 * Avoid some of these cases by checking whether
 * data_i->pw is always better than data_j->pw on the intersection.
 * In particular, do this for the special case where this intersection
 * is equal to the cell "j" and data_i->pw is better on its entire cell.
 *
 * Similarly, if data_i->pw is never better than data_j->pw,
 * then no splitting will occur and there is no need to check
 * where data_j->pw is better than data_i->pw.
 */
================================================================================

文件路径: ./isl_pw_union_opt.c
注释行数: 16
注释内容:
/* Given two piecewise expressions data1->pw and data2->pw, replace
 * their domains
 * by the sets in data1->cell and data2->cell and combine the results into
 * a single piecewise expression.
 * The pieces of data1->pw and data2->pw are assumed to have been sorted
 * according to the function value expressions.
 * The pieces of the result are also sorted in this way.
 *
 * Run through the pieces of data1->pw and data2->pw in order until they
 * have both been exhausted, picking the piece from data1->pw or data2->pw
 * depending on which should come first, together with the corresponding
 * domain from data1->cell or data2->cell.  In cases where the next pieces
 * in both data1->pw and data2->pw have the same function value expression,
 * construct only a single piece in the result with as domain
 * the union of the domains in data1->cell and data2->cell.
 */
================================================================================

文件路径: ./isl_fold.c
注释行数: 3
注释内容:
/* For each 0 <= i < "n", replace variable "first" + i of type "type"
 * in fold->qp[k] by subs[i].
 */
================================================================================

文件路径: ./isl_stride.c
注释行数: 27
注释内容:
/* Set the stride and offset of data->pos to the given
 * value and expression.
 *
 * If we had already found a stride before, then the two strides
 * are combined into a single stride.
 *
 * In particular, if the new stride information is of the form
 *
 *	i = f + s (...)
 *
 * and the old stride information is of the form
 *
 *	i = f2 + s2 (...)
 *
 * then we compute the extended gcd of s and s2
 *
 *	a s + b s2 = g,
 *
 * with g = gcd(s,s2), multiply the first equation with t1 = b s2/g
 * and the second with t2 = a s1/g.
 * This results in
 *
 *	i = (b s2 + a s1)/g i = t1 f + t2 f2 + (s s2)/g (...)
 *
 * so that t1 f + t2 f2 is the combined offset and (s s2)/g = lcm(s,s2)
 * is the combined stride.
 */
================================================================================

文件路径: ./isl_stride.c
注释行数: 34
注释内容:
/* Check if constraint "c" imposes any stride on dimension data->pos
 * and, if so, update the stride information in "data".
 *
 * In order to impose a stride on the dimension, "c" needs to be an equality
 * and it needs to involve the dimension.  Note that "c" may also be
 * a div constraint and thus an inequality that we cannot use.
 *
 * Let c be of the form
 *
 *	h(p) + g * v * i + g * stride * f(alpha) = 0
 *
 * with h(p) an expression in terms of the parameters and other dimensions
 * and f(alpha) an expression in terms of the existentially quantified
 * variables.
 *
 * If "stride" is not zero and not one, then it represents a non-trivial stride
 * on "i".  We compute a and b such that
 *
 *	a v + b stride = 1
 *
 * We have
 *
 *	g v i = -h(p) + g stride f(alpha)
 *
 *	a g v i = -a h(p) + g stride f(alpha)
 *
 *	a g v i + b g stride i = -a h(p) + g stride * (...)
 *
 *	g i = -a h(p) + g stride * (...)
 *
 *	i = -a h(p)/g + stride * (...)
 *
 * The expression "-a h(p)/g" can therefore be used as offset.
 */
================================================================================

文件路径: ./isl_stride.c
注释行数: 8
注释内容:
/* Check if the constraints in "set" imply any stride on set dimension "pos" and
 * store the results in data->stride and data->offset.
 *
 * In particular, compute the affine hull and then check if
 * any of the constraints in the hull impose any stride on the dimension.
 * If no such constraint can be found, then the offset is taken
 * to be the zero expression and the stride is taken to be one.
 */
================================================================================

文件路径: ./isl_coalesce.c
注释行数: 4
注释内容:
/* Compute the hash of the (apparent) affine hull of info->bmap (with
 * the existentially quantified variables removed) and store it
 * in info->hash.
 */
================================================================================

文件路径: ./isl_coalesce.c
注释行数: 8
注释内容:
/* This type represents the kind of change that has been performed
 * while trying to coalesce two basic maps.
 *
 * isl_change_none: nothing was changed
 * isl_change_drop_first: the first basic map was removed
 * isl_change_drop_second: the second basic map was removed
 * isl_change_fuse: the two basic maps were replaced by a new basic map.
 */
================================================================================

文件路径: ./isl_coalesce.c
注释行数: 6
注释内容:
/* Check if info->bmap contains the basic map represented
 * by the tableau "tab".
 * For each equality, we check both the constraint itself
 * (as an inequality) and its negation.  Make sure the
 * equality is returned to its original state before returning.
 */
================================================================================

文件路径: ./isl_coalesce.c
注释行数: 51
注释内容:
/* Basic map "i" has an inequality "k" that is adjacent
 * to some inequality of basic map "j".  All the other inequalities
 * are valid for "j".
 * If not NULL, then "extra" contains extra wrapping constraints that are valid
 * for both "i" and "j".
 * Check if basic map "j" forms an extension of basic map "i",
 * taking into account the extra constraints, if any.
 *
 * Note that this function is only called if some of the equalities or
 * inequalities of basic map "j" do cut basic map "i".  The function is
 * correct even if there are no such cut constraints, but in that case
 * the additional checks performed by this function are overkill.
 *
 * In particular, we replace constraint k, say f >= 0, by constraint
 * f <= -1, add the inequalities of "j" that are valid for "i",
 * as well as the "extra" constraints, if any,
 * and check if the result is a subset of basic map "j".
 * To improve the chances of the subset relation being detected,
 * any variable that only attains a single integer value
 * in the tableau of "i" is first fixed to that value.
 * If the result is a subset, then we know that this result is exactly equal
 * to basic map "j" since all its constraints are valid for basic map "j".
 * By combining the valid constraints of "i" (all equalities and all
 * inequalities except "k"), the valid constraints of "j" and
 * the "extra" constraints, if any, we therefore
 * obtain a basic map that is equal to their union.
 * In this case, there is no need to perform a rollback of the tableau
 * since it is going to be destroyed in fuse().
 *
 *
 *	|\__			|\__
 *	|   \__			|   \__
 *	|      \_	=>	|      \__
 *	|_______| _		|_________\
 *
 *
 *	|\			|\
 *	| \			| \
 *	|  \			|  \
 *	|  |			|   \
 *	|  ||\		=>      |    \
 *	|  || \			|     \
 *	|  ||  |		|      |
 *	|__||_/			|_____/
 *
 *
 *	_______			 _______
 *     |       | __		|       \__
 *     |       ||__|	=>	|        __|
 *     |_______|		|_______/
 */
================================================================================

文件路径: ./isl_coalesce.c
注释行数: 20
注释内容:
/* Given the compressed version of inequality constraint "ineq"
 * of info->bmap in "v", check if the constraint can be tightened,
 * where the compression is based on an equality constraint valid
 * for info->tab.
 * If so, add the tightened version of the inequality constraint
 * to info->tab.  "v" may be modified by this function.
 *
 * That is, if the compressed constraint is of the form
 *
 *	m f() + c >= 0
 *
 * with 0 < c < m, then it is equivalent to
 *
 *	f() >= 0
 *
 * This means that c can also be subtracted from the original,
 * uncompressed constraint without affecting the integer points
 * in info->tab.  Add this tightened constraint as an extra row
 * to info->tab to make this information explicitly available.
 */
================================================================================

文件路径: ./isl_coalesce.c
注释行数: 37
注释内容:
/* Tighten the (non-redundant) constraints on the facet represented
 * by info->tab.
 * In particular, on input, info->tab represents the result
 * of relaxing the "n" inequality constraints of info->bmap in "relaxed"
 * by one, i.e., replacing f_i >= 0 by f_i + 1 >= 0, and then
 * replacing the one at index "l" by the corresponding equality,
 * i.e., f_k + 1 = 0, with k = relaxed[l].
 *
 * Compute a variable compression from the equality constraint f_k + 1 = 0
 * and use it to tighten the other constraints of info->bmap
 * (that is, all constraints that have not been relaxed),
 * updating info->tab (and leaving info->bmap untouched).
 * The compression handles essentially two cases, one where a variable
 * is assigned a fixed value and can therefore be eliminated, and one
 * where one variable is a shifted multiple of some other variable and
 * can therefore be replaced by that multiple.
 * Gaussian elimination would also work for the first case, but for
 * the second case, the effectiveness would depend on the order
 * of the variables.
 * After compression, some of the constraints may have coefficients
 * with a common divisor.  If this divisor does not divide the constant
 * term, then the constraint can be tightened.
 * The tightening is performed on the tableau info->tab by introducing
 * extra (temporary) constraints.
 *
 * Only constraints that are possibly affected by the compression are
 * considered.  In particular, if the constraint only involves variables
 * that are directly mapped to a distinct set of other variables, then
 * no common divisor can be introduced and no tightening can occur.
 *
 * It is important to only consider the non-redundant constraints
 * since the facet constraint has been relaxed prior to the call
 * to this function, meaning that the constraints that were redundant
 * prior to the relaxation may no longer be redundant.
 * These constraints will be ignored in the fused result, so
 * the fusion detection should not exploit them.
 */
================================================================================

文件路径: ./isl_coalesce.c
注释行数: 44
注释内容:
/* Basic map "i" has "n" inequality constraints (collected in "relax")
 * that are such that they include basic map "j" if they are relaxed
 * by one.  All the other inequalities are valid for "j".
 * Check if basic map "j" forms an extension of basic map "i".
 *
 * In particular, relax the constraints in "relax", compute the corresponding
 * facets one by one and check whether each of these is included
 * in the other basic map.
 * Before testing for inclusion, the constraints on each facet
 * are tightened to increase the chance of an inclusion being detected.
 * (Adding the valid constraints of "j" to the tableau of "i", as is done
 * in is_adj_ineq_extension, may further increase those chances, but this
 * is not currently done.)
 * If each facet is included, we know that relaxing the constraints extends
 * the basic map with exactly the other basic map (we already know that this
 * other basic map is included in the extension, because all other
 * inequality constraints are valid of "j") and we can replace the
 * two basic maps by this extension.
 *
 * If any of the relaxed constraints turn out to be redundant, then bail out.
 * isl_tab_select_facet refuses to handle such constraints.  It may be
 * possible to handle them anyway by making a distinction between
 * redundant constraints with a corresponding facet that still intersects
 * the set (allowing isl_tab_select_facet to handle them) and
 * those where the facet does not intersect the set (which can be ignored
 * because the empty facet is trivially included in the other disjunct).
 * However, relaxed constraints that turn out to be redundant should
 * be fairly rare and no such instance has been reported where
 * coalescing would be successful.
 *        ____			  _____
 *       /    || 		 /     |
 *      /     ||  		/      |
 *      \     ||   	=>	\      |
 *       \    ||		 \     |
 *        \___||		  \____|
 *
 *
 *	 \			|\
 *	|\\			| \
 *	| \\			|  \
 *	|  |		=>	|  /
 *	| /			| /
 *	|/			|/
 */
================================================================================

文件路径: ./isl_coalesce.c
注释行数: 5
注释内容:
/* Is the wrapping constraint in row "row" allowed?
 *
 * If wraps->bound is set, we check that none of the coefficients
 * is greater than wraps->max.
 */
================================================================================

文件路径: ./isl_coalesce.c
注释行数: 33
注释内容:
/* This function has two modes of operations.
 *
 * If "add_valid" is set, then all the constraints of info->bmap
 * (except the opposite of "bound") are valid for the other basic map.
 * In this case, attempts are made to wrap some of these valid constraints
 * to more tightly fit around "set".  Only successful wrappings are recorded
 * and failed wrappings are ignored.
 *
 * If "add_valid" is not set, then some of the constraints of info->bmap
 * are not valid for the other basic map, and only those are considered
 * for wrapping.  In this case all attempted wrappings need to succeed.
 * Otherwise "wraps" is marked as failed.
 * Note that the constraints that are valid for the other basic map
 * will be added to the combined basic map by default, so there is
 * no need to wrap them.
 * The caller wrap_in_facets even relies on this function not wrapping
 * any constraints that are already valid.
 *
 * Only consider constraints that are not redundant (as determined
 * by info->tab) and that are valid or invalid depending on "add_valid".
 * Wrap each constraint around "bound" such that it includes the whole
 * set "set" and append the resulting constraint to "wraps".
 * "wraps" is assumed to have been pre-allocated to the appropriate size.
 * wraps->n_row is the number of actual wrapped constraints that have
 * been added.
 * If any of the wrapping problems results in a constraint that is
 * identical to "bound", then this means that "set" is unbounded in such
 * a way that no wrapping is possible.
 * Similarly, if we want to bound the coefficients of the wrapping
 * constraints and a newly added wrapping constraint does not
 * satisfy the bound, then the wrapping is considered to have failed.
 * Note though that "wraps" is only marked failed if "add_valid" is not set.
 */
================================================================================

文件路径: ./isl_coalesce.c
注释行数: 20
注释内容:
/* For each constraint in info->bmap that is not redundant (as determined
 * by info->tab) and that is not a valid constraint for the other basic map,
 * wrap the constraint around "bound" such that it includes the whole
 * set "set" and append the resulting constraint to "wraps".
 * Note that the constraints that are valid for the other basic map
 * will be added to the combined basic map by default, so there is
 * no need to wrap them.
 * The caller wrap_in_facets even relies on this function not wrapping
 * any constraints that are already valid.
 * "wraps" is assumed to have been pre-allocated to the appropriate size.
 * wraps->n_row is the number of actual wrapped constraints that have
 * been added.
 * If any of the wrapping problems results in a constraint that is
 * identical to "bound", then this means that "set" is unbounded in such
 * a way that no wrapping is possible.  If this happens then "wraps"
 * is marked as failed.
 * Similarly, if we want to bound the coefficients of the wrapping
 * constraints and a newly added wrapping constraint does not
 * satisfy the bound, then "wraps" is also marked as failed.
 */
================================================================================

文件路径: ./isl_coalesce.c
注释行数: 25
注释内容:
/* Wrap some constraints of info->bmap that bound the facet defined
 * by inequality "k" around (the opposite of) this inequality to
 * include "set".  "bound" may be used to store the negated inequality.
 *
 * If "add_valid" is set, then all ridges are already valid and
 * the purpose is to wrap "set" more tightly.  In this case,
 * wrapping doesn't fail, although it is possible that no constraint
 * gets wrapped.
 *
 * If "add_valid" is not set, then some of the ridges are cut constraints
 * and only those are wrapped around "set".
 *
 * Since the wrapped constraints are not guaranteed to contain the whole
 * of info->bmap, we check them in check_wraps.
 * If any of the wrapped constraints turn out to be invalid, then
 * check_wraps will mark "wraps" as failed if "add_valid" is not set.
 * If "add_valid" is set, then the offending constraints are
 * simply removed.
 *
 * If any of the cut constraints of info->bmap turn out
 * to be redundant with respect to other constraints
 * then these will neither be wrapped nor added directly to the result.
 * The result may therefore not be correct.
 * Skip wrapping and mark "wraps" as failed in this case.
 */
================================================================================

文件路径: ./isl_coalesce.c
注释行数: 6
注释内容:
/* Wrap the constraints of info->bmap that bound the facet defined
 * by inequality "k" around (the opposite of) this inequality to
 * include "set".  "bound" may be used to store the negated inequality.
 * If any of the wrapped constraints turn out to be invalid for info->bmap
 * itself, then mark "wraps" as failed.
 */
================================================================================

文件路径: ./isl_coalesce.c
注释行数: 7
注释内容:
/* Wrap the (valid) constraints of info->bmap that bound the facet defined
 * by inequality "k" around (the opposite of) this inequality to
 * include "set" more tightly.
 * "bound" may be used to store the negated inequality.
 * Remove any wrapping constraints that turn out to be invalid
 * for info->bmap itself.
 */
================================================================================

文件路径: ./isl_coalesce.c
注释行数: 21
注释内容:
/* Given a cut constraint t(x) >= 0 of basic map i, stored in row "w"
 * of wrap.mat, replace it by its relaxed version t(x) + 1 >= 0, and
 * add wrapping constraints to wrap.mat for all constraints
 * of basic map j that bound the part of basic map j that sticks out
 * of the cut constraint.
 * "set_i" is the underlying set of basic map i.
 * If any wrapping fails, then wraps->mat.n_row is reset to zero.
 *
 * In particular, we first intersect basic map j with t(x) + 1 = 0.
 * If the result is empty, then t(x) >= 0 was actually a valid constraint
 * (with respect to the integer points), so we add t(x) >= 0 instead.
 * Otherwise, we wrap the constraints of basic map j that are not
 * redundant in this intersection and that are not already valid
 * for basic map i over basic map i.
 * Note that it is sufficient to wrap the constraints to include
 * basic map i, because we will only wrap the constraints that do
 * not include basic map i already.  The wrapped constraint will
 * therefore be more relaxed compared to the original constraint.
 * Since the original constraint is valid for basic map j, so is
 * the wrapped constraint.
 */
================================================================================

文件路径: ./isl_coalesce.c
注释行数: 59
注释内容:
/* Given two basic sets i and j,
 * check if relaxing all the cut constraints of i by one turns
 * them into valid constraint for j and check if we can wrap in
 * the bits that are sticking out.
 * If so, replace the pair by their union.
 *
 * We first check if all relaxed cut inequalities of i are valid for j
 * and then try to wrap in the intersections of the relaxed cut inequalities
 * with j.
 *
 * During this wrapping, we consider the points of j that lie at a distance
 * of exactly 1 from i.  In particular, we ignore the points that lie in
 * between this lower-dimensional space and the basic map i.
 * We can therefore only apply this to integer maps.
 *        ____			  _____
 *       / ___|_		 /     \
 *      / |    |  		/      |
 *      \ |    |   	=>	\      |
 *       \|____|		 \     |
 *        \___| 		  \____/
 *
 *	 _____			 ______
 *	| ____|_		|      \
 *	| |     |		|       |
 *	| |	|	=>	|       |
 *	|_|     |		|       |
 *	  |_____|		 \______|
 *
 *	 _______
 *	|       |
 *	|  |\   |
 *	|  | \  |
 *	|  |  \ |
 *	|  |   \|
 *	|  |    \
 *	|  |_____\
 *	|       |
 *	|_______|
 *
 * Wrapping can fail if the result of wrapping one of the facets
 * around its edges does not produce any new facet constraint.
 * In particular, this happens when we try to wrap in unbounded sets.
 *
 *	 _______________________________________________________________________
 *	|
 *	|  ___
 *	| |   |
 *	|_|   |_________________________________________________________________
 *	  |___|
 *
 * The following is not an acceptable result of coalescing the above two
 * sets as it includes extra integer points.
 *	 _______________________________________________________________________
 *	|
 *	|     
 *	|      
 *	|
 *	 \______________________________________________________________________
 */
================================================================================

文件路径: ./isl_coalesce.c
注释行数: 29
注释内容:
/* If the integer division at position "div" is defined by an equality,
 * i.e., a stride constraint, then change the integer division expression
 * to have a constant term equal to zero.
 *
 * Let the equality constraint be
 *
 *	c + f + m a = 0
 *
 * The integer division expression is then typically of the form
 *
 *	a = floor((-f - c')/m)
 *
 * The integer division is first shifted by t = floor(c/m),
 * turning the equality constraint into
 *
 *	c - m floor(c/m) + f + m a' = 0
 *
 * i.e.,
 *
 *	(c mod m) + f + m a' = 0
 *
 * That is,
 *
 *	a' = (-f - (c mod m))/m = floor((-f)/m)
 *
 * because a' is an integer and 0 <= (c mod m) < m.
 * The constant term of a' can therefore be zeroed out,
 * but only if the integer division expression is of the expected form.
 */
================================================================================

文件路径: ./isl_coalesce.c
注释行数: 27
注释内容:
/* For each of the "n" integer division variables "expanded",
 * if the variable has a fixed value, then add two inequality
 * constraints expressing the fixed value.
 * Otherwise, add the corresponding div constraints.
 * The caller is responsible for removing the div constraints
 * that it added for all these "n" integer divisions.
 *
 * The div constraints and the pair of inequality constraints
 * forcing the fixed value cannot both be added for a given variable
 * as the combination may render some of the original constraints redundant.
 * These would then be ignored during the coalescing detection,
 * while they could remain in the fused result.
 *
 * The two added inequality constraints are
 *
 *	-a + v >= 0
 *	a - v >= 0
 *
 * with "a" the variable and "v" its fixed value.
 * The facet corresponding to one of these two constraints is selected
 * in the tableau to ensure that the pair of inequality constraints
 * is treated as an equality constraint.
 *
 * The information in info->ineq is thrown away because it was
 * computed in terms of div constraints, while some of those
 * have now been replaced by these pairs of inequality constraints.
 */
================================================================================

文件路径: ./isl_coalesce.c
注释行数: 16
注释内容:
/* Add variables to info->bmap and info->tab corresponding to the elements
 * in "list" that are not set to NaN.
 * "extra_var" is the number of these elements.
 * "dim" is the offset in the variables of "tab" where we should
 * start considering the elements in "list".
 * When this function returns, the total number of variables in "tab"
 * is equal to "dim" plus the number of elements in "list".
 *
 * The newly added existentially quantified variables are not given
 * an explicit representation because the corresponding div constraints
 * do not appear in info->bmap.  These constraints are not added
 * to info->bmap because for internal consistency, they would need to
 * be added to info->tab as well, where they could combine with the equality
 * that is added later to result in constraints that do not hold
 * in the original input.
 */
================================================================================

文件路径: ./isl_coalesce.c
注释行数: 8
注释内容:
/* Add variables to info->tab and info->bmap corresponding to the elements
 * in "list" that are not set to NaN.  The value of the added variable
 * in info->tab is fixed to the purely affine expression defined by the element.
 * "dim" is the offset in the variables of info->tab where we should
 * start considering the elements in "list".
 * When this function returns, the total number of variables in info->tab
 * is equal to "dim" plus the number of elements in "list".
 */
================================================================================

文件路径: ./isl_pw_templ.c
注释行数: 3
注释内容:
/* Given a piecewise expression "pw" with domain in a space [A -> B] and
 * a set in the space A, intersect the domain with the set.
 */
================================================================================

文件路径: ./isl_pw_templ.c
注释行数: 3
注释内容:
/* Given a piecewise expression "pw" with domain in a space [A -> B] and
 * a set in the space B, intersect the domain with the set.
 */
================================================================================

文件路径: ./isl_union_multi.c
注释行数: 2
注释内容:
/* Call data->fn on the group stored at *entry.
 */
================================================================================

文件路径: ./isl_union_multi.c
注释行数: 2
注释内容:
/* Call data->fn on a copy of each expression in "group".
 */
================================================================================

文件路径: ./isl_union_multi.c
注释行数: 3
注释内容:
/* isl_union_*_foreach_group callback for calling data->fn on
 * each part entry in the group.
 */
================================================================================

文件路径: ./isl_constraint.c
注释行数: 14
注释内容:
/* Is "constraint" an equality that corresponds to integer division "div"?
 *
 * That is, given an integer division of the form
 *
 *	a = floor((f + c)/m)
 *
 * is the equality of the form
 *
 *		-f + m d + c' = 0
 * ?
 * Note that the constant term is not checked explicitly, but given
 * that this is a valid equality constraint, the constant c' necessarily
 * has a value close to -c.
 */
================================================================================

文件路径: ./isl_flow.c
注释行数: 35
注释内容:
/* After the dependences derived from a must-source have been computed
 * at a certain level, check if any of the sources of the must-dependences
 * may be coscheduled with other sources.
 * If they are any such sources, then there is no way of determining
 * which of the sources actually comes last and the must-dependences
 * need to be turned into may-dependences, while dependences from
 * the other sources need to be added to the may-dependences as well.
 * "acc" describes the sources and a callback for checking whether
 * two sources may be coscheduled.  If acc->coscheduled is NULL then
 * the sources are assumed not to be coscheduled.
 * "must_rel" and "may_rel" describe the must and may-dependence relations
 * computed at the current level for the must-sources.  Some of the dependences
 * may be moved from "must_rel" to "may_rel".
 * "flow" contains all dependences computed so far (apart from those
 * in "must_rel" and "may_rel") and may be updated with additional
 * dependences derived from may-sources.
 *
 * In particular, consider all the must-sources with a non-empty
 * dependence relation in "must_rel".  They are considered in reverse
 * order because that is the order in which they are considered in the caller.
 * If any of the must-sources are coscheduled, then the last one
 * is the one that will have a corresponding dependence relation.
 * For each must-source i, consider both all the previous must-sources
 * and all the may-sources.  If any of those may be coscheduled with
 * must-source i, then compute the coscheduled instances that access
 * the same memory elements.  The result is a relation [T -> S] -> K.
 * The projection onto T -> K is a subset of the must-dependence relation
 * that needs to be turned into may-dependences.
 * The projection onto S -> K needs to be added to the may-dependences
 * of source S.
 * Since a given must-source instance may be coscheduled with several
 * other source instances, the dependences that need to be turned
 * into may-dependences are first collected and only actually removed
 * from the must-dependences after all other sources have been considered.
 */
================================================================================

文件路径: ./isl_flow.c
注释行数: 7
注释内容:
/* Extract information on the constant dimensions of the schedule
 * for a given access.  The "map" is of the form
 *
 *	[S -> D] -> A
 *
 * with S the schedule domain, D the iteration domain and A the data domain.
 */
================================================================================

文件路径: ./isl_flow.c
注释行数: 22
注释内容:
/* Prepend the schedule dimensions to the iteration domains.
 *
 * That is, if the schedule is of the form
 *
 *	D -> S
 *
 * while the access relations are of the form
 *
 *	D -> A
 *
 * then the updated access relations are of the form
 *
 *	[S -> D] -> A
 *
 * The schedule map is also replaced by the map
 *
 *	[S -> D] -> D
 *
 * that is used during the internal computation.
 * Neither the original schedule map nor this updated schedule map
 * are used after the call to this function.
 */
================================================================================

文件路径: ./isl_flow.c
注释行数: 14
注释内容:
/* This structure represents the result of a dependence analysis computation.
 *
 * "must_dep" represents the full definite dependences
 * "may_dep" represents the full non-definite dependences.
 * Both are of the form
 *
 *	[Source] -> [[Sink -> Data]]
 *
 * (after the schedule dimensions have been projected out).
 * "must_no_source" represents the subset of the sink accesses for which
 * definitely no source was found.
 * "may_no_source" represents the subset of the sink accesses for which
 * possibly, but not definitely, no source was found.
 */
================================================================================

文件路径: ./isl_flow.c
注释行数: 20
注释内容:
/* Drop the schedule dimensions from the iteration domains in "flow".
 * In particular, the schedule dimensions have been prepended
 * to the iteration domains prior to the dependence analysis by
 * replacing the iteration domain D, by the wrapped map [S -> D].
 * Replace these wrapped maps by the original D.
 *
 * In particular, the dependences computed by access_info_compute_flow_core
 * are of the form
 *
 *	[S -> D] -> [[S' -> D'] -> A]
 *
 * The schedule dimensions are projected out by first currying the range,
 * resulting in
 *
 *	[S -> D] -> [S' -> [D' -> A]]
 *
 * and then computing the factor range
 *
 *	D -> [D' -> A]
 */
================================================================================

文件路径: ./isl_flow.c
注释行数: 22
注释内容:
/* Drop dependences from "flow" that purely originate from kills.
 * That is, only keep those dependences that originate from
 * the original must-sources "must" and/or the original may-sources "may".
 * In particular, "must" contains the must-sources from before
 * the kills were added and "may" contains the may-source from before
 * the kills were removed.
 *
 * The dependences are of the form
 *
 *	Source -> [Sink -> Data]
 *
 * Only those dependences are kept where the Source -> Data part
 * is a subset of the original may-sources or must-sources.
 * Of those, only the must-dependences that intersect with the must-sources
 * remain must-dependences.
 * If there is some overlap between the may-sources and the must-sources,
 * then the may-dependences and must-dependences may also overlap.
 * This should be fine since the may-dependences are only kept
 * disjoint from the must-dependences for the isl_union_map_compute_flow
 * interface.  This interface does not support kills, so it will
 * not end up calling this function.
 */
================================================================================

文件路径: ./isl_flow.c
注释行数: 19
注释内容:
/* Given a description of the "sink" accesses, the "source" accesses and
 * a schedule, compute for each instance of a sink access
 * and for each element accessed by that instance,
 * the possible or definite source accesses that last accessed the
 * element accessed by the sink access before this sink access
 * in the sense that there is no intermediate definite source access.
 *
 * The must_no_source and may_no_source elements of the result
 * are subsets of access->sink.  The elements must_dep and may_dep
 * map domain elements of access->{may,must)_source to
 * domain elements of access->sink.
 *
 * This function is used when only the schedule map representation
 * is available.
 *
 * We first prepend the schedule dimensions to the domain
 * of the accesses so that we can easily compare their relative order.
 * Then we consider each sink access individually in compute_flow.
 */
================================================================================

文件路径: ./isl_flow.c
注释行数: 7
注释内容:
/* A schedule access relation.
 *
 * The access relation "access" is of the form [S -> D] -> A,
 * where S corresponds to the prefix schedule at "node".
 * "must" is only relevant for source accesses and indicates
 * whether the access is a must source or a may source.
 */
================================================================================

文件路径: ./isl_flow.c
注释行数: 9
注释内容:
/* isl_schedule_foreach_schedule_node_top_down callback for counting
 * (an upper bound on) the number of sinks and sources.
 *
 * Sinks and sources are only extracted at leaves of the tree,
 * so we skip the node if it is not a leaf.
 * Otherwise we increment data->n_sink and data->n_source with
 * the number of spaces in the sink and source access domains
 * that reach this node.
 */
================================================================================

文件路径: ./isl_flow.c
注释行数: 4
注释内容:
/* Add a single scheduled sink or source (depending on data->set_sink)
 * with scheduled access relation "map", must property data->must and
 * schedule node data->node to the list of sinks or sources.
 */
================================================================================

文件路径: ./isl_flow.c
注释行数: 24
注释内容:
/* isl_schedule_foreach_schedule_node_top_down callback for collecting
 * individual scheduled source and sink accesses (taking into account
 * the domain of the schedule).
 *
 * We only collect accesses at the leaves of the schedule tree.
 * We prepend the schedule dimensions at the leaf to the iteration
 * domains of the source and sink accesses and then extract
 * the individual accesses (per space).
 *
 * In particular, if the prefix schedule at the node is of the form
 *
 *	D -> S
 *
 * while the access relations are of the form
 *
 *	D -> A
 *
 * then the updated access relations are of the form
 *
 *	[S -> D] -> A
 *
 * Note that S consists of a single space such that introducing S
 * in the access relations does not increase the number of spaces.
 */
================================================================================

文件路径: ./isl_flow.c
注释行数: 17
注释内容:
/* Given a scheduled sink access relation "sink", compute the corresponding
 * dependences on the sources in "data" and add the computed dependences
 * to "uf".
 *
 * The dependences computed by access_info_compute_flow_core are of the form
 *
 *	[S -> I] -> [[S' -> I'] -> A]
 *
 * The schedule dimensions are projected out by first currying the range,
 * resulting in
 *
 *	[S -> I] -> [S' -> [I' -> A]]
 *
 * and then computing the factor range
 *
 *	I -> [I' -> A]
 */
================================================================================

文件路径: ./isl_flow.c
注释行数: 21
注释内容:
/* Given a description of the "sink" accesses, the "source" accesses and
 * a schedule, compute for each instance of a sink access
 * and for each element accessed by that instance,
 * the possible or definite source accesses that last accessed the
 * element accessed by the sink access before this sink access
 * in the sense that there is no intermediate definite source access.
 * Only consider dependences between statement instances that belong
 * to the domain of the schedule.
 *
 * The must_no_source and may_no_source elements of the result
 * are subsets of access->sink.  The elements must_dep and may_dep
 * map domain elements of access->{may,must)_source to
 * domain elements of access->sink.
 *
 * This function is used when a schedule tree representation
 * is available.
 *
 * We extract the individual scheduled source and sink access relations
 * (taking into account the domain of the schedule) and
 * then compute dependences for each scheduled sink individually.
 */
================================================================================

文件路径: ./isl_flow.c
注释行数: 20
注释内容:
/* Given a description of the "sink" accesses, the "source" accesses and
 * a schedule, compute for each instance of a sink access
 * and for each element accessed by that instance,
 * the possible or definite source accesses that last accessed the
 * element accessed by the sink access before this sink access
 * in the sense that there is no intermediate definite source access.
 *
 * The must_no_source and may_no_source elements of the result
 * are subsets of access->sink.  The elements must_dep and may_dep
 * map domain elements of access->{may,must)_source to
 * domain elements of access->sink.
 *
 * If any kills have been specified, then they are treated as
 * must-sources internally.  Any dependence that purely derives
 * from an original kill is removed from the output.
 *
 * We check whether the schedule is available as a schedule tree
 * or a schedule map and call the corresponding function to perform
 * the analysis.
 */
================================================================================

文件路径: ./interface/generator.cc
注释行数: 6
注释内容:
/* Extract information about all automatic conversion functions
 * for the given class, storing the results in this->conversions.
 *
 * In particular, look through all exported constructors for the class and
 * check if any of them is explicitly marked as a conversion function.
 */
================================================================================

文件路径: ./interface/generator.cc
注释行数: 3
注释内容:
/* Extract information about all automatic conversion functions,
 * storing the results in this->conversions.
 */
================================================================================

文件路径: ./interface/generator.cc
注释行数: 7
注释内容:
/* Add information about the enum values in "decl", set by "fd",
 * to c->set_enums. "prefix" is the prefix of the generated method names.
 * In particular, it has the name of the enum type removed.
 *
 * In particular, for each non-negative enum value, keep track of
 * the value, the name and the corresponding method name.
 */
================================================================================

文件路径: ./interface/generator.cc
注释行数: 8
注释内容:
/* Check if "fd" sets an enum value and, if so, add information
 * about the enum values to c->set_enums.
 *
 * A function is considered to set an enum value if:
 * - the function returns an object of the same type
 * - the last argument is of type enum
 * - the name of the function ends with the name of the enum
 */
================================================================================

文件路径: ./interface/template_cpp.cc
注释行数: 10
注释内容:
/* If a method with signature "sig" requires additional template parameters
 * compared to those of the class, then print a declaration for them.
 * If this->declarations is set, then this will be part of a method declaration,
 * requiring extra indentation.
 *
 * Construct the sequence of all required template parameters
 * with those of the template class appearing first.
 * If this sequence has any parameters not induced by the template class itself,
 * then print a declaration for these extra parameters.
 */
================================================================================

文件路径: ./interface/plain_cpp.cc
注释行数: 7
注释内容:
/* Print declarations of copy assignment operator.
 *
 * Each class has one assignment operator.
 *
 * 	isl:set &set::operator=(set obj)
 *
 */
================================================================================

文件路径: ./include/isl/hmap_templ.c
注释行数: 2
注释内容:
/* Call data->fn on a copy of the key and value in *entry.
 */
================================================================================

文件路径: ./include/isl/hmap_templ.c
注释行数: 2
注释内容:
/* Print the given key-value pair to data->p.
 */
================================================================================

文件路径: ./include/isl/root_headfile/isl_ast_build_private.h
注释行数: 134
注释内容:
/* An isl_ast_build represents the context in which AST is being
 * generated.  That is, it (mostly) contains information about outer
 * loops that can be used to simplify inner loops.
 *
 * "domain" represents constraints on the internal schedule domain,
 * corresponding to the context of the AST generation and the constraints
 * implied by the loops that have already been generated.
 * When an isl_ast_build is first created, outside any AST generation,
 * the domain is typically a parameter set.  It is only when a AST
 * generation phase is initiated that the domain of the isl_ast_build
 * is changed to refer to the internal schedule domain.
 * The domain then lives in a space of the form
 *
 *	S
 *
 *  or
 *
 *	[O -> S]
 *
 * O represents the loops generated in outer AST generations.
 * S represents the loops (both generated and to be generated)
 * of the current AST generation.
 * Both include eliminated loops.
 * "domain" is expected not to have any unknown divs because
 * it is used as the context argument in a call to isl_basic_set_gist
 * in isl_ast_build_compute_gist_basic_set.
 *
 * "depth" is equal to the number of loops that have already
 * been generated (including those in outer AST generations).
 * "outer_pos" is equal to the number of loops in outer AST generations.
 *
 * "generated" is a superset of "domain" corresponding to those
 * constraints that were either given by the user or that have
 * effectively been generated (as bounds on a for loop).
 *
 * "pending" is a superset of "domain" corresponding to the constraints
 * that still need to be generated (as guards), but that may end up
 * not getting generated if they are implied by any constraints
 * enforced by inner loops.
 *
 * "strides" contains the stride of each loop.  The number of elements
 * is equal to the number of dimensions in "domain".
 * "offsets" contains the offsets of strided loops.  If s is the stride
 * for a given dimension and f is the corresponding offset, then the
 * dimension takes on values
 *
 *	f + s a
 *
 * with a an integer.  For non-strided loops, the offset is zero.
 *
 * "iterators" contains the loop iterators of both generated and
 * to be generated loops.  The number of elements is at least as
 * large as the dimension of the internal schedule domain.  The
 * number may be larger, in which case the additional ids can be
 * used in a nested AST generation should the schedule be non-injective.
 *
 * "values" lives in the space
 *
 *	[O -> S] -> [O -> S]		(or S -> S)
 *
 * and expresses (if possible) loop iterators in terms of parameters
 * and outer loop iterators.  If the value of a given loop iterator
 * cannot be expressed as an affine expression (either because the iterator
 * attains multiple values or because the single value is a piecewise
 * affine expression), then it is expressed in "values" as being equal
 * to itself.
 *
 * "value" is the value of the loop iterator at the current depth.
 * It is NULL if it has not been computed yet or if the value of the
 * given loop iterator cannot be expressed as a piecewise affine expression
 * (because the iterator attains multiple values).
 *
 * "schedule_map" maps the internal schedule domain to the external schedule
 * domain.  It may be NULL if it hasn't been computed yet.
 * See isl_ast_build_get_schedule_map_multi_aff.
 *
 * "internal2input" maps the internal schedule domain to the original
 * input schedule domain.  In case of a schedule tree input, the original
 * input schedule domain consist of the flat product of all outer
 * band node spaces, including the current band node.
 * It may be NULL if there no longer is such a uniform mapping
 * (because different iterations have been rescheduled differently).
 *
 * "options" contains the AST build options in case we are generating
 * an AST from a flat schedule map.  When creating an AST from a schedule
 * tree, this field is ignored.
 *
 * The "create_leaf" callback is called for every leaf in the generated AST.
 * The callback is responsible for creating the node to be placed at those
 * leaves.  If this callback is not set, then isl will generated user
 * nodes with call expressions corresponding to an element of the domain.
 *
 * The "at_each_domain" callback is called on every node created to represent
 * an element of the domain.  Each of these nodes is a user node
 * with as expression a call expression.
 *
 * The "before_each_for" callback is called on each for node before
 * its children have been created.
 *
 * The "after_each_for" callback is called on each for node after
 * its children have been created.
 *
 * The "before_each_mark" callback is called before we handle the subtree
 * of an isl_schedule_node_mark node.
 *
 * The "after_each_mark" callback is called after we have handled the subtree
 * of an isl_schedule_node_mark node.
 *
 * "executed" contains the inverse schedule at this point
 * of the AST generation.
 * It is currently only used in isl_ast_build_get_schedule, which is
 * in turn only used by user code from within a callback.
 * The value is set right before we may be calling such a callback.
 *
 * "single_valued" is set if the current inverse schedule (which may or may
 * not be stored in "executed") is known to be single valued, specifically
 * an inverse schedule that was not (appeared not to be) single valued
 * is extended to a single valued inverse schedule.  This is mainly used
 * to avoid an infinite recursion when we fail to detect later on that
 * the extended inverse schedule is single valued.
 *
 * "node" points to the current band node in case we are generating
 * an AST from a schedule tree.  It may be NULL if we are not generating
 * an AST from a schedule tree or if we are not inside a band node.
 *
 * "loop_type" originally contains loop AST generation types for
 * the "n" members of "node" and it is updated (along with "n") when
 * a schedule dimension is inserted.
 * It is NULL if "node" is NULL.
 *
 * "isolated" is the piece of the schedule domain isolated by the isolate
 * option on the current band.  This set may be NULL if we have not checked
 * for the isolate option yet.
 */
================================================================================

文件路径: ./include/isl/root_headfile/isl_int_sioimath.h
注释行数: 11
注释内容:
/* The negation of the smallest possible number in int32_t, INT32_MIN
 * (0x80000000u, -2147483648), cannot be represented in an int32_t, therefore
 * every operation that may produce this value needs to special-case it.
 * The operations are:
 * abs(INT32_MIN)
 * -INT32_MIN   (negation)
 * -1 * INT32_MIN (multiplication)
 * INT32_MIN/-1 (any division: divexact, fdiv, cdiv, tdiv)
 * To avoid checking these cases, we exclude INT32_MIN from small
 * representation.
 */
================================================================================

文件路径: ./include/isl/root_headfile/isl_int_sioimath.h
注释行数: 9
注释内容:
/* Get the IMath representation of an isl_int without modifying it.
 * For the case it is not in big representation yet, pass some scratch space we
 * can use to store the big representation in.
 * In order to avoid requiring init and free on the scratch space, we directly
 * modify the internal representation.
 *
 * The name derives from its indented use: getting the big representation of an
 * input (src) argument.
 */
================================================================================

文件路径: ./include/isl/root_headfile/isl_int_sioimath.h
注释行数: 3
注释内容:
/* Get the remainder of: lhs divided by rhs rounded towards negative infinite
 * (Floor).
 */
================================================================================

文件路径: ./include/isl/root_headfile/isl_int_sioimath.h
注释行数: 5
注释内容:
/* Return:
 *   +1 if lhs > rhs
 *   -1 if lhs < rhs
 *    0 if lhs = rhs
 */
================================================================================
