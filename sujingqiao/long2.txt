
文件路径: ./isl_map.c
注释行数: 22
注释内容:
/*
 * Copyright 2008-2009 Katholieke Universiteit Leuven
 * Copyright 2010      INRIA Saclay
 * Copyright 2012-2014 Ecole Normale Superieure
 * Copyright 2014      INRIA Rocquencourt
 * Copyright 2016      INRIA Paris
 * Copyright 2016      Sven Verdoolaege
 * Copyright 2018-2019 Cerebras Systems
 *
 * Use of this software is governed by the MIT license
 *
 * Written by Sven Verdoolaege, K.U.Leuven, Departement
 * Computerwetenschappen, Celestijnenlaan 200A, B-3001 Leuven, Belgium
 * and INRIA Saclay - Ile-de-France, Parc Club Orsay Universite,
 * ZAC des vignes, 4 rue Jacques Monod, 91893 Orsay, France 
 * and Ecole Normale Superieure, 45 rue d’Ulm, 75230 Paris, France
 * and Inria Paris - Rocquencourt, Domaine de Voluceau - Rocquencourt,
 * B.P. 105 - 78153 Le Chesnay, France
 * and Centre de Recherche Inria de Paris, 2 rue Simone Iff - Voie DQ12,
 * CS 42112, 75589 Paris Cedex 12, France
 * and Cerebras Systems, 175 S San Antonio Rd, Los Altos, CA, USA
 */
================================================================================

文件路径: ./isl_map.c
注释行数: 10
注释内容:
/* Return an isl_map that is equal to "map" and that has only
 * a single reference.
 *
 * If the original input already has only one reference, then
 * simply return it, but clear all cached information, since
 * it may be rendered invalid by the operations that will be
 * performed on the result.
 *
 * Otherwise, create a duplicate (without any cached information).
 */
================================================================================

文件路径: ./isl_map.c
注释行数: 48
注释内容:
/* Try and add a lower and/or upper bound on "div" to "bmap"
 * based on inequality "i".
 * "total" is the total number of variables (excluding the divs).
 * "v" is a temporary object that can be used during the calculations.
 * If "lb" is set, then a lower bound should be constructed.
 * If "ub" is set, then an upper bound should be constructed.
 *
 * The calling function has already checked that the inequality does not
 * reference "div", but we still need to check that the inequality is
 * of the right form.  We'll consider the case where we want to construct
 * a lower bound.  The construction of upper bounds is similar.
 *
 * Let "div" be of the form
 *
 *	q = floor((a + f(x))/d)
 *
 * We essentially check if constraint "i" is of the form
 *
 *	b + f(x) >= 0
 *
 * so that we can use it to derive a lower bound on "div".
 * However, we allow a slightly more general form
 *
 *	b + g(x) >= 0
 *
 * with the condition that the coefficients of g(x) - f(x) are all
 * divisible by d.
 * Rewriting this constraint as
 *
 *	0 >= -b - g(x)
 *
 * adding a + f(x) to both sides and dividing by d, we obtain
 *
 *	(a + f(x))/d >= (a-b)/d + (f(x)-g(x))/d
 *
 * Taking the floor on both sides, we obtain
 *
 *	q >= floor((a-b)/d) + (f(x)-g(x))/d
 *
 * or
 *
 *	(g(x)-f(x))/d + ceil((b-a)/d) + q >= 0
 *
 * In the case of an upper bound, we construct the constraint
 *
 *	(g(x)+f(x))/d + floor((b+a)/d) - q >= 0
 *
 */
================================================================================

文件路径: ./isl_map.c
注释行数: 45
注释内容:
/* This function is called right before "div" is eliminated from "bmap"
 * using Fourier-Motzkin.
 * Look through the constraints of "bmap" for constraints on the argument
 * of the integer division and use them to construct constraints on the
 * integer division itself.  These constraints can then be combined
 * during the Fourier-Motzkin elimination.
 * Note that it is only useful to introduce lower bounds on "div"
 * if "bmap" already contains upper bounds on "div" as the newly
 * introduce lower bounds can then be combined with the pre-existing
 * upper bounds.  Similarly for upper bounds.
 * We therefore first check if "bmap" contains any lower and/or upper bounds
 * on "div".
 *
 * It is interesting to note that the introduction of these constraints
 * can indeed lead to more accurate results, even when compared to
 * deriving constraints on the argument of "div" from constraints on "div".
 * Consider, for example, the set
 *
 *	{ [i,j,k] : 3 + i + 2j >= 0 and 2 * [(i+2j)/4] <= k }
 *
 * The second constraint can be rewritten as
 *
 *	2 * [(-i-2j+3)/4] + k >= 0
 *
 * from which we can derive
 *
 *	-i - 2j + 3 >= -2k
 *
 * or
 *
 *	i + 2j <= 3 + 2k
 *
 * Combined with the first constraint, we obtain
 *
 *	-3 <= 3 + 2k	or	k >= -3
 *
 * If, on the other hand we derive a constraint on [(i+2j)/4] from
 * the first constraint, we obtain
 *
 *	[(i + 2j)/4] >= [-3/4] = -1
 *
 * Combining this constraint with the second constraint, we obtain
 *
 *	k >= -2
 */
================================================================================

文件路径: ./isl_map.c
注释行数: 13
注释内容:
/* Add the div constraint of sign "sign" for div "div" of "bmap".
 *
 * In particular, if this div is of the form d = floor(f/m),
 * then add the constraint
 *
 *		f - m d >= 0
 *
 * if sign < 0 or the constraint
 *
 *		-(f-(m-1)) + m d >= 0
 *
 * if sign > 0.
 */
================================================================================

文件路径: ./isl_map.c
注释行数: 10
注释内容:
/* Force the symbolic constant expression "bound"
 * to satisfy the relation "order" with respect to
 * the output variable at position "pos" of "map".
 *
 * Create an affine expression representing the output variable
 * in terms of the range and
 * compare it using "order" to "bound" (defined on the domain).
 * The result is a relation between elements in domain and range that
 * can be intersected with "map".
 */
================================================================================

文件路径: ./isl_map.c
注释行数: 17
注释内容:
/* Given a map "map", compute the lexicographically minimal
 * (or maximal) image element for each domain element in dom,
 * in the form of an isl_pw_multi_aff.
 * If "empty" is not NULL, then set *empty to those elements in dom that
 * do not have an image element.
 * If "flags" includes ISL_OPT_FULL, then "dom" is NULL and the optimum
 * should be computed over the domain of "map".  "empty" is also NULL
 * in this case.
 *
 * We first compute the lexicographically minimal or maximal element
 * in the first basic map.  This results in a partial solution "res"
 * and a subset "todo" of dom that still need to be handled.
 * We then consider each of the remaining maps in "map" and successively
 * update both "res" and "todo".
 * If "empty" is NULL, then the todo sets are not needed and therefore
 * also not computed.
 */
================================================================================

文件路径: ./isl_map.c
注释行数: 23
注释内容:
/* Given a map "map", compute the lexicographically minimal
 * (or maximal) image element for each domain element in "dom",
 * in the form of an isl_map.
 * If "empty" is not NULL, then set *empty to those elements in "dom" that
 * do not have an image element.
 * If "flags" includes ISL_OPT_FULL, then "dom" is NULL and the optimum
 * should be computed over the domain of "map".  "empty" is also NULL
 * in this case.
 *
 * If the input consists of more than one disjunct, then first
 * compute the desired result in the form of an isl_pw_multi_aff and
 * then convert that into an isl_map.
 *
 * This function used to have an explicit implementation in terms
 * of isl_maps, but it would continually intersect the domains of
 * partial results with the complement of the domain of the next
 * partial solution, potentially leading to an explosion in the number
 * of disjuncts if there are several disjuncts in the input.
 * An even earlier implementation of this function would look for
 * better results in the domain of the partial result and for extra
 * results in the complement of this domain, which would lead to
 * even more splintering.
 */
================================================================================

文件路径: ./isl_map.c
注释行数: 14
注释内容:
/* Compute an explicit representation for the existentially quantified
 * variables in "bset" by computing the "minimal value" of the set
 * variables.  Since there are no set variables, the computation of
 * the minimal value essentially computes an explicit representation
 * of the non-empty part(s) of "bset".
 *
 * The input only involves parameters and existentially quantified variables.
 * All equalities among parameters have been removed.
 *
 * Since the existentially quantified variables in the result are in general
 * going to be different from those in the input, we first replace
 * them by the minimal number of variables based on their equalities.
 * This should simplify the parametric integer programming.
 */
================================================================================

文件路径: ./isl_map.c
注释行数: 18
注释内容:
/* Project the given basic set onto its parameter domain, possibly introducing
 * new, explicit, existential variables in the constraints.
 * The input has parameters and (possibly implicit) existential variables.
 * The output has the same parameters, but only
 * explicit existentially quantified variables.
 *
 * The actual projection is performed by pip, but pip doesn't seem
 * to like equalities very much, so we first remove the equalities
 * among the parameters by performing a variable compression on
 * the parameters.  Afterward, an inverse transformation is performed
 * and the equalities among the parameters are inserted back in.
 *
 * The variable compression on the parameters may uncover additional
 * equalities that were only implicit before.  We therefore check
 * if there are any new parameter equalities in the result and
 * if so recurse.  The removal of parameter equalities is required
 * for the parameter compression performed by base_compute_divs.
 */
================================================================================

文件路径: ./isl_map.c
注释行数: 14
注释内容:
/* Compute an explicit representation for the existentially
 * quantified variables for which do not know any explicit representation yet.
 *
 * We first sort the existentially quantified variables so that the
 * existentially quantified variables for which we already have an explicit
 * representation are placed before those for which we do not.
 * The input dimensions, the output dimensions and the existentially
 * quantified variables for which we already have an explicit
 * representation are then turned into parameters.
 * compute_divs returns a map with the same parameters and
 * no input or output dimensions and the dimension specification
 * is reset to that of the input, including the existentially quantified
 * variables for which we already had an explicit representation.
 */
================================================================================

文件路径: ./isl_map.c
注释行数: 10
注释内容:
/* Return the union of "map1" and "map2", where we assume for now that
 * "map1" and "map2" are disjoint.  Note that the basic maps inside
 * "map1" or "map2" may not be disjoint from each other.
 * Also note that this function is also called from isl_map_union,
 * which takes care of handling the situation where "map1" and "map2"
 * may not be disjoint.
 *
 * If one of the inputs is empty, we can simply return the other input.
 * Similarly, if one of the inputs is universal, then it is equal to the union.
 */
================================================================================

文件路径: ./isl_map.c
注释行数: 12
注释内容:
/* Return the union of "map1" and "map2", where "map1" and "map2" may
 * not be disjoint.
 *
 * We currently simply call map_union_disjoint, the internal operation
 * of which does not really depend on the inputs being disjoint.
 * If the result contains more than one basic map, then we clear
 * the disjoint flag since the result may contain basic maps from
 * both inputs and these are not guaranteed to be disjoint.
 *
 * As a special case, if "map1" and "map2" are obviously equal,
 * then we simply return "map1".
 */
================================================================================

文件路径: ./isl_map.c
注释行数: 12
注释内容:
/* Data structure that specifies how isl_map_intersect_factor
 * should operate.
 *
 * "preserve_type" is the tuple where the factor differs from
 * the input map and of which the identifiers needs
 * to be preserved explicitly.
 * "other_factor" is used to extract the space of the other factor
 * from the space of the product ("map").
 * "product" is used to combine the given factor and a universe map
 * in the space returned by "other_factor" to produce a map
 * that lives in the same space as the input map.
 */
================================================================================

文件路径: ./isl_map.c
注释行数: 12
注释内容:
/* Given a map "map" in some product space and a map "factor"
 * living in some factor space, return the intersection.
 *
 * After aligning the parameters,
 * the map "factor" is first extended to a map living in the same space
 * as "map" and then a regular intersection is computed.
 *
 * Note that the extension is computed as a product, which is anonymous
 * by default.  If "map" has an identifier on the corresponding tuple,
 * then this identifier needs to be set on the product
 * before the intersection is computed.
 */
================================================================================

文件路径: ./isl_map.c
注释行数: 10
注释内容:
/* Apply the expansion computed by isl_merge_divs.
 * The expansion itself is given by "exp" while the resulting
 * list of divs is given by "div".
 *
 * Move the integer divisions of "bmap" into the right position
 * according to "exp" and then introduce the additional integer
 * divisions, adding div constraints.
 * The moving should be done first to avoid moving coefficients
 * in the definitions of the extra integer divisions.
 */
================================================================================

文件路径: ./isl_map.c
注释行数: 17
注释内容:
/* Align the divs of "dst" to those of "src", adding divs from "src"
 * if needed.  That is, make sure that the first src->n_div divs
 * of the result are equal to those of src.
 * The integer division of "src" are assumed to be ordered.
 *
 * The integer divisions are swapped into the right position
 * (possibly after adding them first).  This may result
 * in the remaining integer divisions appearing in the wrong order,
 * i.e., with some integer division appearing before
 * some other integer division on which it depends.
 * The integer divisions therefore need to be ordered.
 * This will not affect the integer divisions aligned to those of "src",
 * since "src" is assumed to have ordered integer divisions.
 *
 * The result is not finalized as by design it will have redundant
 * divs if any divs from "src" were copied.
 */
================================================================================

文件路径: ./isl_map.c
注释行数: 11
注释内容:
/* Given two _disjoint_ basic sets bset1 and bset2, check whether
 * for any common value of the parameters and dimensions preceding pos
 * in both basic sets, the values of dimension pos in bset1 are
 * smaller or larger than those in bset2.
 *
 * Returns
 *	 1 if bset1 follows bset2
 *	-1 if bset1 precedes bset2
 *	 0 if bset1 and bset2 are incomparable
 *	-2 if some error occurred.
 */
================================================================================

文件路径: ./isl_map.c
注释行数: 11
注释内容:
/* Given two basic sets bset1 and bset2, check whether
 * for any common value of the parameters and dimensions preceding pos
 * there is a value of dimension pos in bset1 that is larger
 * than a value of the same dimension in bset2.
 *
 * Return
 *	 1 if there exists such a pair
 *	 0 if there is no such pair, but there is a pair of equal values
 *	-1 otherwise
 *	-2 if some error occurred.
 */
================================================================================

文件路径: ./isl_map.c
注释行数: 11
注释内容:
/* Given two sets set1 and set2, check whether
 * for any common value of the parameters and dimensions preceding pos
 * there is a value of dimension pos in set1 that is larger
 * than a value of the same dimension in set2.
 *
 * Return
 *	 1 if there exists such a pair
 *	 0 if there is no such pair, but there is a pair of equal values
 *	-1 otherwise
 *	-2 if some error occurred.
 */
================================================================================

文件路径: ./isl_map.c
注释行数: 18
注释内容:
/* Return -1 if the constraint "c1" should be sorted before "c2"
 * and 1 if it should be sorted after "c2".
 * Return 0 if the two constraints are the same (up to the constant term).
 *
 * In particular, if a constraint involves later variables than another
 * then it is sorted after this other constraint.
 * uset_gist depends on constraints without existentially quantified
 * variables sorting first.
 *
 * For constraints that have the same latest variable, those
 * with the same coefficient for this latest variable (first in absolute value
 * and then in actual value) are grouped together.
 * This is useful for detecting pairs of constraints that can
 * be chained in their printed representation.
 *
 * Finally, within a group, constraints are sorted according to
 * their coefficients (excluding the constant term).
 */
================================================================================

文件路径: ./isl_map.c
注释行数: 10
注释内容:
/* Remove obvious duplicates among the basic maps of "map".
 *
 * Unlike isl_map_normalize, this function does not remove redundant
 * constraints and only removes duplicates that have exactly the same
 * constraints in the input.  It does sort the constraints and
 * the basic maps to ease the detection of duplicates.
 *
 * If "map" has already been normalized or if the basic maps are
 * disjoint, then there can be no duplicates.
 */
================================================================================

文件路径: ./isl_map.c
注释行数: 15
注释内容:
/* Look for a pair of inequality constraints in "bmap" of the form
 *
 *	-l + i >= 0		or		i >= l
 * and
 *	n + l - i >= 0		or		i <= l + n
 *
 * with n < "m" and i the output dimension at position "pos".
 * (Note that n >= 0 as otherwise the two constraints would conflict.)
 * Furthermore, "l" is only allowed to involve parameters, input dimensions
 * and earlier output dimensions, as well as integer divisions that do
 * not involve any of the output dimensions.
 *
 * Return the index of the first inequality constraint or bmap->n_ineq
 * if no such pair can be found.
 */
================================================================================

文件路径: ./isl_map.c
注释行数: 23
注释内容:
/* Return the index of the equality of "bmap" that defines
 * the output dimension "pos" in terms of earlier dimensions.
 * The equality may also involve integer divisions, as long
 * as those integer divisions are defined in terms of
 * parameters or input dimensions.
 * In this case, *div is set to the number of integer divisions and
 * *ineq is set to the number of inequality constraints (provided
 * div and ineq are not NULL).
 *
 * The equality may also involve a single integer division involving
 * the output dimensions (typically only output dimension "pos") as
 * long as the coefficient of output dimension "pos" is 1 or -1 and
 * there is a pair of constraints i >= l and i <= l + n, with i referring
 * to output dimension "pos", l an expression involving only earlier
 * dimensions and n smaller than the coefficient of the integer division
 * in the equality.  In this case, the output dimension can be defined
 * in terms of a modulo expression that does not involve the integer division.
 * *div is then set to this single integer division and
 * *ineq is set to the index of constraint i >= l.
 *
 * Return bmap->n_eq if there is no such equality.
 * Return -1 on error.
 */
================================================================================

文件路径: ./isl_map.c
注释行数: 26
注释内容:
/* Plug in "subs" for dimension "type", "pos" of "bset".
 *
 * Let i be the dimension to replace and let "subs" be of the form
 *
 *	f/d
 *
 * Any integer division with a non-zero coefficient for i,
 *
 *	floor((a i + g)/m)
 *
 * is replaced by
 *
 *	floor((a f + d g)/(m d))
 *
 * Constraints of the form
 *
 *	a i + g
 *
 * are replaced by
 *
 *	a f + d g
 *
 * We currently require that "subs" is an integral expression.
 * Handling rational expressions may require us to add stride constraints
 * as we do in isl_basic_set_preimage_multi_aff.
 */
================================================================================

文件路径: ./isl_map.c
注释行数: 18
注释内容:
/* For each affine expression in ma of the form
 *
 *	x_i = (f_i y + h_i)/m_i
 *
 * with m_i different from one, add a constraint to "bmap"
 * of the form
 *
 *	f_i y + h_i = m_i alpha_i
 *
 * with alpha_i an additional existentially quantified variable.
 *
 * The input variables of "ma" correspond to a subset of the variables
 * of "bmap".  There are "n_before" variables in "bmap" before this
 * subset and "n_after" variables after this subset.
 * The integer divisions of the affine expressions in "ma" are assumed
 * to have been aligned.  There are "n_div_ma" of them and
 * they appear first in "bmap", straight after the "n_after" variables.
 */
================================================================================

文件路径: ./isl_map.c
注释行数: 46
注释内容:
/* Compute the preimage of the domain or range (depending on "type")
 * of "bmap" under the function represented by "ma".
 * In other words, plug in "ma" in the domain or range of "bmap".
 * The result is a basic map that lives in the same space as "bmap"
 * except that the domain or range has been replaced by
 * the domain space of "ma".
 *
 * If bmap is represented by
 *
 *	A(p) + S u + B x + T v + C(divs) >= 0,
 *
 * where u and x are input and output dimensions if type == isl_dim_out
 * while x and v are input and output dimensions if type == isl_dim_in,
 * and ma is represented by
 *
 *	x = D(p) + F(y) + G(divs')
 *
 * then the result is
 *
 *	A(p) + B D(p) + S u + B F(y) + T v + B G(divs') + C(divs) >= 0
 *
 * The divs in the input set are similarly adjusted.
 * In particular
 *
 *	floor((a_i(p) + s u + b_i x + t v + c_i(divs))/n_i)
 *
 * becomes
 *
 *	floor((a_i(p) + b_i D(p) + s u + b_i F(y) + t v +
 *		B_i G(divs') + c_i(divs))/n_i)
 *
 * If bmap is not a rational map and if F(y) involves any denominators
 *
 *	x_i = (f_i y + h_i)/m_i
 *
 * then additional constraints are added to ensure that we only
 * map back integer points.  That is we enforce
 *
 *	f_i y + h_i = m_i alpha_i
 *
 * with alpha_i an additional existentially quantified variable.
 *
 * We first copy over the divs from "ma".
 * Then we add the modified constraints and divs from "bmap".
 * Finally, we add the stride constraints, if needed.
 */
================================================================================

文件路径: ./isl_map.c
注释行数: 15
注释内容:
/* Compute the preimage of "map" under the function represented by "mpa".
 * In other words, plug in "mpa" in the domain or range of "map".
 * The result is a map that lives in the same space as "map",
 * except that the space of type "type" has been replaced by
 * the domain space of "mpa".
 *
 * If the map does not involve any constraints that refer to the
 * dimensions of the substituted space, then the only possible
 * effect of "mpa" on the map is to map the space to a different space.
 * We create a separate isl_multi_aff to effectuate this change
 * in order to avoid spurious splitting of the map along the pieces
 * of "mpa".
 * If "mpa" has a non-trivial explicit domain, however,
 * then the full substitution should be performed.
 */
================================================================================

文件路径: ./isl_map.c
注释行数: 17
注释内容:
/* Tighten the inequality constraints of "bset" that are outward with respect
 * to the point "vec".
 * That is, tighten the constraints that are not satisfied by "vec".
 *
 * "vec" is a point internal to some superset S of "bset" that is used
 * to make the subsets of S disjoint, by tightening one half of the constraints
 * that separate two subsets.  In particular, the constraints of S
 * are all satisfied by "vec" and should not be tightened.
 * Of the internal constraints, those that have "vec" on the outside
 * are tightened.  The shared facet is included in the adjacent subset
 * with the opposite constraint.
 * For constraints that saturate "vec", this criterion cannot be used
 * to determine which of the two sides should be tightened.
 * Instead, the sign of the first non-zero coefficient is used
 * to make this choice.  Note that this second criterion is never used
 * on the constraints of S since "vec" is interior to "S".
 */
================================================================================

文件路径: ./isl_affine_hull.c
注释行数: 13
注释内容:
/*
 * Copyright 2008-2009 Katholieke Universiteit Leuven
 * Copyright 2010      INRIA Saclay
 * Copyright 2012      Ecole Normale Superieure
 *
 * Use of this software is governed by the MIT license
 *
 * Written by Sven Verdoolaege, K.U.Leuven, Departement
 * Computerwetenschappen, Celestijnenlaan 200A, B-3001 Leuven, Belgium
 * and INRIA Saclay - Ile-de-France, Parc Club Orsay Universite,
 * ZAC des vignes, 4 rue Jacques Monod, 91893 Orsay, France
 * and Ecole Normale Superieure, 45 rue d'Ulm, 75230 Paris, France
 */
================================================================================

文件路径: ./isl_affine_hull.c
注释行数: 15
注释内容:
/* Find an integer point in the set represented by "tab"
 * that lies outside of the equality "eq" e(x) = 0.
 * If "up" is true, look for a point satisfying e(x) - 1 >= 0.
 * Otherwise, look for a point satisfying -e(x) - 1 >= 0 (i.e., e(x) <= -1).
 * The point, if found, is returned.
 * If no point can be found, a zero-length vector is returned.
 *
 * Before solving an ILP problem, we first check if simply
 * adding the normal of the constraint to one of the known
 * integer points in the basic set represented by "tab"
 * yields another point inside the basic set.
 *
 * The caller of this function ensures that the tableau is bounded or
 * that tab->basis and tab->n_unbounded have been set appropriately.
 */
================================================================================

文件路径: ./isl_affine_hull.c
注释行数: 13
注释内容:
/* Extend an initial (under-)approximation of the affine hull of basic
 * set represented by the tableau "tab"
 * by looking for points that do not satisfy one of the equalities
 * in the current approximation and adding them to that approximation
 * until no such points can be found any more.
 *
 * The caller of this function ensures that "tab" is bounded or
 * that tab->basis and tab->n_unbounded have been set appropriately.
 *
 * "bset" may be either NULL or the basic set represented by "tab".
 * If "bset" is not NULL, we check for any point we find if any
 * of its adjacent points also belong to "bset".
 */
================================================================================

文件路径: ./isl_affine_hull.c
注释行数: 10
注释内容:
/* Given a tableau of a set and a tableau of the corresponding
 * recession cone, detect and add all equalities to the tableau.
 * If the tableau is bounded, then we can simply keep the
 * tableau in its state after the return from extend_affine_hull.
 * However, if the tableau is unbounded, then
 * isl_tab_set_initial_basis_with_cone will add some additional
 * constraints to the tableau that have to be removed again.
 * In this case, we therefore rollback to the state before
 * any constraints were added and then add the equalities back in.
 */
================================================================================

文件路径: ./isl_affine_hull.c
注释行数: 31
注释内容:
/* Compute the affine hull of "bset", where "cone" is the recession cone
 * of "bset".
 *
 * We first compute a unimodular transformation that puts the unbounded
 * directions in the last dimensions.  In particular, we take a transformation
 * that maps all equalities to equalities (in HNF) on the first dimensions.
 * Let x be the original dimensions and y the transformed, with y_1 bounded
 * and y_2 unbounded.
 *
 *	       [ y_1 ]			[ y_1 ]   [ Q_1 ]
 *	x = U  [ y_2 ]			[ y_2 ] = [ Q_2 ] x
 *
 * Let's call the input basic set S.  We compute S' = preimage(S, U)
 * and drop the final dimensions including any constraints involving them.
 * This results in set S''.
 * Then we compute the affine hull A'' of S''.
 * Let F y_1 >= g be the constraint system of A''.  In the transformed
 * space the y_2 are unbounded, so we can add them back without any constraints,
 * resulting in
 *
 *		        [ y_1 ]
 *		[ F 0 ] [ y_2 ] >= g
 * or
 *		        [ Q_1 ]
 *		[ F 0 ] [ Q_2 ] x >= g
 * or
 *		F Q_1 x >= g
 *
 * The affine hull in the original space is then obtained as
 * A = preimage(A'', Q_1).
 */
================================================================================

文件路径: ./isl_affine_hull.c
注释行数: 16
注释内容:
/* Look for all equalities satisfied by the integer points in bset,
 * which is assumed not to have any explicit equalities.
 *
 * The equalities are obtained by successively looking for
 * a point that is affinely independent of the points found so far.
 * In particular, for each equality satisfied by the points so far,
 * we check if there is any point on a hyperplane parallel to the
 * corresponding hyperplane shifted by at least one (in either direction).
 *
 * Before looking for any outside points, we first compute the recession
 * cone.  The directions of this recession cone will always be part
 * of the affine hull, so there is no need for looking for any points
 * in these directions.
 * In particular, if the recession cone is full-dimensional, then
 * the affine hull is simply the whole universe.
 */
================================================================================

文件路径: ./isl_affine_hull.c
注释行数: 13
注释内容:
/* Look for all equalities satisfied by the integer points in bmap
 * that are independent of the equalities already explicitly available
 * in bmap.
 *
 * We first remove all equalities already explicitly available,
 * then look for additional equalities in the reduced space
 * and then transform the result to the original space.
 * The original equalities are _not_ added to this set.  This is
 * the responsibility of the calling function.
 * The resulting basic set has all meaning about the dimensions removed.
 * In particular, dimensions that correspond to existential variables
 * in bmap and that are found to be fixed are not removed.
 */
================================================================================

文件路径: ./isl_affine_hull.c
注释行数: 18
注释内容:
/* Given a rational affine matrix "M", add stride constraints to "bmap"
 * that ensure that
 *
 *		M(x)
 *
 * is an integer vector.  The variables x include all the variables
 * of "bmap" except the unknown divs.
 *
 * If d is the common denominator of M, then we need to impose that
 *
 *		d M(x) = 0 	mod d
 *
 * or
 *
 *		exists alpha : d M(x) = d alpha
 *
 * This function is similar to add_strides in isl_morph.c
 */
================================================================================

文件路径: ./isl_affine_hull.c
注释行数: 27
注释内容:
/* If there are any equalities that involve (multiple) unknown divs,
 * then extract the stride information encoded by those equalities
 * and make it explicitly available in "bmap".
 *
 * We first sort the divs so that the unknown divs appear last and
 * then we count how many equalities involve these divs.
 *
 * Let these equalities be of the form
 *
 *		A(x) + B y = 0
 *
 * where y represents the unknown divs and x the remaining variables.
 * Let [H 0] be the Hermite Normal Form of B, i.e.,
 *
 *		B = [H 0] Q
 *
 * Then x is a solution of the equalities iff
 *
 *		H^-1 A(x) (= - [I 0] Q y)
 *
 * is an integer vector.  Let d be the common denominator of H^-1.
 * We impose
 *
 *		d H^-1 A(x) = d alpha
 *
 * in add_strides, with alpha fresh existentially quantified variables.
 */
================================================================================

文件路径: ./isl_affine_hull.c
注释行数: 12
注释内容:
/* Compute the affine hull of each basic map in "map" separately
 * and make all stride information explicit so that we can remove
 * all unknown divs without losing this information.
 * The result is also guaranteed to be gaussed.
 *
 * In simple cases where a div is determined by an equality,
 * calling isl_basic_map_gauss is enough to make the stride information
 * explicit, as it will derive an explicit representation for the div
 * from the equality.  If, however, the stride information
 * is encoded through multiple unknown divs then we need to make
 * some extra effort in isl_basic_map_make_strides_explicit.
 */
================================================================================

文件路径: ./isl_affine_hull.c
注释行数: 19
注释内容:
/* Compute the affine hull of "map".
 *
 * We first compute the affine hull of each basic map separately.
 * Then we align the divs and recompute the affine hulls of the basic
 * maps since some of them may now have extra divs.
 * In order to avoid performing parametric integer programming to
 * compute explicit expressions for the divs, possible leading to
 * an explosion in the number of basic maps, we first drop all unknown
 * divs before aligning the divs.  Note that isl_map_local_affine_hull tries
 * to make sure that all stride information is explicitly available
 * in terms of known divs.  This involves calling isl_basic_set_gauss,
 * which is also needed because affine_hull assumes its input has been gaussed,
 * while isl_map_affine_hull may be called on input that has not been gaussed,
 * in particular from initial_facet_constraint.
 * Similarly, align_divs may reorder some divs so that we need to
 * gauss the result again.
 * Finally, we combine the individual affine hulls into a single
 * affine hull.
 */
================================================================================

文件路径: ./isl_union_templ.c
注释行数: 11
注释内容:
/*
 * Copyright 2010      INRIA Saclay
 * Copyright 2013      Ecole Normale Superieure
 *
 * Use of this software is governed by the MIT license
 *
 * Written by Sven Verdoolaege, INRIA Saclay - Ile-de-France,
 * Parc Club Orsay Universite, ZAC des vignes, 4 rue Jacques Monod,
 * 91893 Orsay, France 
 * and Ecole Normale Superieure, 45 rue d'Ulm, 75230 Paris, France
 */
================================================================================

文件路径: ./isl_union_templ.c
注释行数: 14
注释内容:
/* Data structure that specifies how isl_union_*_transform
 * should modify the base expressions in the union expression.
 *
 * If "inplace" is set, then the base expression in the input union
 * are modified in place.  This means that "fn" should not
 * change the meaning of the union or that the union only
 * has a single reference.
 * If "space" is not NULL, then a new union is created in this space.
 * If "filter" is not NULL, then only the base expressions that satisfy "filter"
 * are taken into account.
 * "filter_user" is passed as the second argument to "filter".
 * If "fn" it not NULL, then it is applied to each entry in the input.
 * "fn_user" is passed as the second argument to "fn".
 */
================================================================================

文件路径: ./isl_union_templ.c
注释行数: 10
注释内容:
/* Compute the sum of "u1" and "u2" on the union of their domains,
 * with the actual sum on the shared domain and
 * the defined expression on the symmetric difference of the domains.
 *
 * This is an internal function that is exposed under different
 * names depending on whether the base expressions have a zero default
 * value.
 * If they do, then this function is called "add".
 * Otherwise, it is called "union_add".
 */
================================================================================

文件路径: ./isl_union_templ.c
注释行数: 13
注释内容:
/* Data structure that specifies how isl_union_*_match_domain_op
 * should combine its arguments.
 *
 * If "filter" is not NULL, then only parts that pass the given
 * filter are considered for matching.
 * "fn" is applied to each part in the union and each corresponding
 * set in the union set, i.e., such that the set lives in the same space
 * as the domain of the part.
 * If "match_space" is not NULL, then the set extracted from the union set
 * does not live in the same space as the domain of the part,
 * but rather in the space that results from calling "match_space"
 * on this domain space.
 */
================================================================================

文件路径: ./isl_sort.c
注释行数: 23
注释内容:
/*
 * The code of this file was taken from http://jeffreystedfast.blogspot.be,
 * where it was posted in 2011 by Jeffrey Stedfast under the MIT license.
 * The MIT license text is as follows:
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to
 * deal in the Software without restriction, including without limitation the
 * rights to use, copy, modify, merge, publish, distribute, sublicense, and/or
 * sell copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in
 * all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
 * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS
 * IN THE SOFTWARE.
 */
================================================================================

文件路径: ./isl_sort.c
注释行数: 19
注释内容:
/* The code here is an optimized merge sort. Starting from a generic merge sort
 * the following optimizations were applied:
 *
 * o Batching of memcpy() calls: Instead of calling memcpy() to copy each and
 *   every element into a temporary buffer, blocks of elements are copied
 *   at a time.
 *
 * o To reduce the number of memcpy() calls further, copying leading
 *   and trailing elements into our temporary buffer is avoided, in case it is
 *   not necessary to merge them.
 *
 * A further optimization could be to specialize memcpy calls based on the
 * size of the types we compare. For now, this code does not include the
 * relevant optimization, as clang e.g. inlines a very efficient memcpy()
 * implementation. It is not clear, that the specialized version as provided in
 * the blog post, is really superior to the one that will be inlined by
 * default. So we decided to keep the code simple until this optimization was
 * proven to be beneficial.
 */
================================================================================

文件路径: ./isl_vec.c
注释行数: 10
注释内容:
/*
 * Copyright 2008-2009 Katholieke Universiteit Leuven
 * Copyright 2013      Ecole Normale Superieure
 *
 * Use of this software is governed by the MIT license
 *
 * Written by Sven Verdoolaege, K.U.Leuven, Departement
 * Computerwetenschappen, Celestijnenlaan 200A, B-3001 Leuven, Belgium
 * and Ecole Normale Superieure, 45 rue d’Ulm, 75230 Paris, France
 */
================================================================================

文件路径: ./isl_morph.c
注释行数: 11
注释内容:
/*
 * Copyright 2010-2011 INRIA Saclay
 * Copyright 2014      Ecole Normale Superieure
 *
 * Use of this software is governed by the MIT license
 *
 * Written by Sven Verdoolaege, INRIA Saclay - Ile-de-France,
 * Parc Club Orsay Universite, ZAC des vignes, 4 rue Jacques Monod,
 * 91893 Orsay, France 
 * and Ecole Normale Superieure, 45 rue d'Ulm, 75230 Paris, France
 */
================================================================================

文件路径: ./isl_morph.c
注释行数: 25
注释内容:
/* Given a basic set, exploit the equalities in the basic set to construct
 * a morphism that maps the basic set to a lower-dimensional space.
 * Specifically, the morphism reduces the number of dimensions of type "type".
 *
 * We first select the equalities of interest, that is those that involve
 * variables of type "type" and no later variables.
 * Denote those equalities as
 *
 *		-C(p) + M x = 0
 *
 * where C(p) depends on the parameters if type == isl_dim_set and
 * is a constant if type == isl_dim_param.
 *
 * Use isl_mat_final_variable_compression to construct a compression
 *
 *	x = T x'
 *
 *	x' = Q x
 *
 * If T is a zero-column matrix, then the set of equality constraints
 * do not admit a solution.  In this case, an empty morphism is returned.
 *
 * Both matrices are extended to map the full original space to the full
 * compressed space.
 */
================================================================================

文件路径: ./isl_morph.c
注释行数: 16
注释内容:
/* Construct a parameter compression for "bset".
 * We basically just call isl_mat_parameter_compression with the right input
 * and then extend the resulting matrix to include the variables.
 *
 * The implementation assumes that "bset" does not have any equalities
 * that only involve the parameters and that isl_basic_set_gauss has
 * been applied to "bset".
 *
 * Let the equalities be given as
 *
 *	B(p) + A x = 0.
 *
 * We use isl_mat_parameter_compression_ext to compute the compression
 *
 *	p = T p'.
 */
================================================================================

文件路径: ./isl_farkas.c
注释行数: 47
注释内容:
/*
 * Let C be a cone and define
 *
 *	C' := { y | forall x in C : y x >= 0 }
 *
 * C' contains the coefficients of all linear constraints
 * that are valid for C.
 * Furthermore, C'' = C.
 *
 * If C is defined as { x | A x >= 0 }
 * then any element in C' must be a non-negative combination
 * of the rows of A, i.e., y = t A with t >= 0.  That is,
 *
 *	C' = { y | exists t >= 0 : y = t A }
 *
 * If any of the rows in A actually represents an equality, then
 * also negative combinations of this row are allowed and so the
 * non-negativity constraint on the corresponding element of t
 * can be dropped.
 *
 * A polyhedron P = { x | b + A x >= 0 } can be represented
 * in homogeneous coordinates by the cone
 * C = { [z,x] | b z + A x >= and z >= 0 }
 * The valid linear constraints on C correspond to the valid affine
 * constraints on P.
 * This is essentially Farkas' lemma.
 *
 * Since
 *				  [ 1 0 ]
 *		[ w y ] = [t_0 t] [ b A ]
 *
 * we have
 *
 *	C' = { w, y | exists t_0, t >= 0 : y = t A and w = t_0 + t b }
 * or
 *
 *	C' = { w, y | exists t >= 0 : y = t A and w - t b >= 0 }
 *
 * In practice, we introduce an extra variable (w), shifting all
 * other variables to the right, and an extra inequality
 * (w - t b >= 0) corresponding to the positivity constraint on
 * the homogeneous coordinate.
 *
 * When going back from coefficients to solutions, we immediately
 * plug in 1 for z, which corresponds to shifting all variables
 * to the left, with the leftmost ending up in the constant position.
 */
================================================================================

文件路径: ./isl_farkas.c
注释行数: 13
注释内容:
/* Given a dimension specification of the solutions space, construct
 * a dimension specification for the space of coefficients.
 *
 * In particular transform
 *
 *	[params] -> { S }
 *
 * to
 *
 *	{ coefficients[[cst, params] -> S] }
 *
 * and prefix each dimension name with "c_".
 */
================================================================================

文件路径: ./isl_farkas.c
注释行数: 13
注释内容:
/* Given a dimension specification of the space of coefficients, construct
 * a dimension specification for the space of solutions.
 *
 * In particular transform
 *
 *	{ coefficients[[cst, params] -> S] }
 *
 * to
 *
 *	[params] -> { S }
 *
 * and drop the "c_" prefix from the dimension names.
 */
================================================================================

文件路径: ./isl_farkas.c
注释行数: 13
注释内容:
/* Compute the dual of "bset" by applying Farkas' lemma.
 * As explained above, we add an extra dimension to represent
 * the coefficient of the constant term when going from solutions
 * to coefficients (shift == 1) and we drop the extra dimension when going
 * in the opposite direction (shift == -1).
 * The dual can be created in an arbitrary space.
 * The caller is responsible for putting the result in the appropriate space.
 *
 * If "bset" is (obviously) empty, then the way this emptiness
 * is represented by the constraints does not allow for the application
 * of the standard farkas algorithm.  We therefore handle this case
 * specifically and return the universe basic set.
 */
================================================================================

文件路径: ./isl_farkas.c
注释行数: 14
注释内容:
/* Information about a single factor within isl_basic_set_coefficients_product.
 *
 * "start" is the position of the first coefficient (beyond
 * the one corresponding to the constant term) in this factor.
 * "dim" is the number of coefficients (other than
 * the one corresponding to the constant term) in this factor.
 * "n_line" is the number of lines in "coeff".
 * "n_ray" is the number of rays (other than lines) in "coeff".
 * "n_vertex" is the number of vertices in "coeff".
 *
 * While iterating over the vertices,
 * "pos" represents the inequality constraint corresponding
 * to the current vertex.
 */
================================================================================

文件路径: ./isl_farkas.c
注释行数: 10
注释内容:
/* Add a vertex to the product "bset" combining the currently selected
 * vertices of the factors.
 *
 * In the dual representation, the constant term is always zero.
 * The vertex itself is the sum of the contributions of the factors
 * with a shared denominator in position 1.
 *
 * First compute the shared denominator (lcm) and
 * then scale the numerators to this shared denominator.
 */
================================================================================

文件路径: ./isl_farkas.c
注释行数: 35
注释内容:
/* Combine the duals of the factors in the factorization of a basic set
 * to form the dual of the entire basic set.
 * The dual share the coefficient of the constant term.
 * All other coefficients are specific to a factor.
 * Any constraint not involving the coefficient of the constant term
 * can therefor simply be copied into the appropriate position.
 * This includes all equality constraints since the coefficient
 * of the constant term can always be increased and therefore
 * never appears in an equality constraint.
 * The inequality constraints involving the coefficient of
 * the constant term need to be combined across factors.
 * In particular, if this coefficient needs to be greater than or equal
 * to some linear combination of the other coefficients in each factor,
 * then it needs to be greater than or equal to the sum of
 * these linear combinations across the factors.
 *
 * Alternatively, the constraints of the dual can be seen
 * as the vertices, rays and lines of the original basic set.
 * Clearly, rays and lines can simply be copied,
 * while vertices needs to be combined across factors.
 * This means that the number of rays and lines in the product
 * is equal to the sum of the numbers in the factors,
 * while the number of vertices is the product
 * of the number of vertices in the factors.  Note that each
 * factor has at least one vertex.
 * The only exception is when the factor is the dual of an obviously empty set,
 * in which case a universe dual is created.
 * In this case, return a universe dual for the product as well.
 *
 * While constructing the vertices, look for the first combination
 * of inequality constraints that represent a vertex,
 * construct the corresponding vertex and then move on
 * to the next combination of inequality constraints until
 * all combinations have been considered.
 */
================================================================================

文件路径: ./isl_farkas.c
注释行数: 11
注释内容:
/* Given a factorization "f" of a basic set,
 * construct a basic set containing the tuples of coefficients of all
 * valid affine constraints on the product of the factors, ignoring
 * the space of input and output.
 * Note that this product may not be equal to the original basic set,
 * if a non-trivial transformation is involved.
 * This is handled by the caller.
 *
 * Compute the tuples of coefficients for each factor separately and
 * then combine the results.
 */
================================================================================

文件路径: ./isl_farkas.c
注释行数: 15
注释内容:
/* Given a factorization "f" of a basic set,
 * construct a basic set containing the tuples of coefficients of all
 * valid affine constraints on the basic set, ignoring
 * the space of input and output.
 *
 * The factorization may involve a linear transformation of the basic set.
 * In particular, the transformed basic set is formulated
 * in terms of x' = U x, i.e., x = V x', with V = U^{-1}.
 * The dual is then computed in terms of y' with y'^t [z; x'] >= 0.
 * Plugging in y' = [1 0; 0 V^t] y yields
 * y^t [1 0; 0 V] [z; x'] >= 0, i.e., y^t [z; x] >= 0, which is
 * the desired set of coefficients y.
 * Note that this transformation to y' only needs to be applied
 * if U is not the identity matrix.
 */
================================================================================

文件路径: ./isl_farkas.c
注释行数: 16
注释内容:
/* Construct a basic set containing the tuples of coefficients of all
 * valid affine constraints on the given basic set, ignoring
 * the space of input and output.
 *
 * The caller has already checked that "bset" does not involve
 * any local variables.  It may have parameters, though.
 * Treat them as regular variables internally.
 * This is especially important for the factorization,
 * since the (original) parameters should be taken into account
 * explicitly in this factorization.
 *
 * Check if the basic set can be factorized.
 * If so, compute constraints on the coefficients of the factors
 * separately and combine the results.
 * Otherwise, compute the results for the input basic set as a whole.
 */
================================================================================

文件路径: ./isl_range.c
注释行数: 15
注释内容:
/* Given a lower and upper bound on the final variable and constraints
 * on the remaining variables where these bounds are active,
 * eliminate the variable from data->poly based on these bounds.
 * If the polynomial has been determined to be monotonic
 * in the variable, then simply plug in the appropriate bound.
 * If the current polynomial is tight and if this bound is integer,
 * then the result is still tight.  In all other cases, the results
 * may not be tight.
 * Otherwise, plug in the largest bound (in absolute value) in
 * the positive terms (if an upper bound is wanted) or the negative terms
 * (if a lower bounded is wanted) and the other bound in the other terms.
 *
 * If all variables have been eliminated, then record the result.
 * Ohterwise, recurse on the next variable.
 */
================================================================================

文件路径: ./isl_map_subtract.c
注释行数: 11
注释内容:
/* Expand the constraint "c" into "v".  The initial "dim" dimensions
 * are the same, but "v" may have more divs than "c" and the divs of "c"
 * may appear in different positions in "v".
 * The number of divs in "c" is given by "n_div" and the mapping
 * of divs in "c" to divs in "v" is given by "div_map".
 *
 * Although it shouldn't happen in practice, it is theoretically
 * possible that two or more divs in "c" are mapped to the same div in "v".
 * These divs are then necessarily the same, so we simply add their
 * coefficients.
 */
================================================================================

文件路径: ./isl_map_subtract.c
注释行数: 29
注释内容:
/* Compute the set difference between bmap and map and call
 * dc->add on each of the piece until this function returns
 * a negative value.
 * Return 0 on success and -1 on error.  dc->add returning
 * a negative value is treated as an error, but the calling
 * function can interpret the results based on the state of dc.
 *
 * Assumes that map has known divs.
 *
 * The difference is computed by a backtracking algorithm.
 * Each level corresponds to a basic map in "map".
 * When a node in entered for the first time, we check
 * if the corresonding basic map intersects the current piece
 * of "bmap".  If not, we move to the next level.
 * Otherwise, we split the current piece into as many
 * pieces as there are non-redundant constraints of the current
 * basic map in the intersection.  Each of these pieces is
 * handled by a child of the current node.
 * In particular, if there are n non-redundant constraints,
 * then for each 0 <= i < n, a piece is cut off by adding
 * constraints 0 <= j < i and adding the opposite of constraint i.
 * If there are no non-redundant constraints, meaning that the current
 * piece is a subset of the current basic map, then we simply backtrack.
 *
 * In the leaves, we check if the remaining piece has any integer points
 * and if so, pass it along to dc->add.  As a special case, if nothing
 * has been removed when we end up in a leaf, we simply pass along
 * the original basic map.
 */
================================================================================

文件路径: ./isl_seq.c
注释行数: 20
注释内容:
/* Given two affine expressions "p" of length p_len (including the
 * denominator and the constant term) and "subs" of length subs_len,
 * plug in "subs" for the variable at position "pos".
 * The variables of "subs" and "p" are assumed to match up to subs_len,
 * but "p" may have additional variables.
 * "v" is an initialized isl_int that can be used internally.
 *
 * In particular, if "p" represents the expression
 *
 *	(a i + g)/m
 *
 * with i the variable at position "pos" and "subs" represents the expression
 *
 *	f/d
 *
 * then the result represents the expression
 *
 *	(a f + d g)/(m d)
 *
 */
================================================================================

文件路径: ./isl_input.c
注释行数: 15
注释内容:
/*
 * Copyright 2008-2009 Katholieke Universiteit Leuven
 * Copyright 2010      INRIA Saclay
 * Copyright 2012-2013 Ecole Normale Superieure
 * Copyright 2019      Cerebras Systems
 *
 * Use of this software is governed by the MIT license
 *
 * Written by Sven Verdoolaege, K.U.Leuven, Departement
 * Computerwetenschappen, Celestijnenlaan 200A, B-3001 Leuven, Belgium
 * and INRIA Saclay - Ile-de-France, Parc Club Orsay Universite,
 * ZAC des vignes, 4 rue Jacques Monod, 91893 Orsay, France 
 * and Ecole Normale Superieure, 45 rue d’Ulm, 75230 Paris, France
 * and Cerebras Systems, 175 S San Antonio Rd, Los Altos, CA, USA
 */
================================================================================

文件路径: ./isl_input.c
注释行数: 12
注释内容:
/* Read an isl_val from "s".
 *
 * The following token sequences are recognized
 *
 *	"infty"		->	infty
 *	"-" "infty"	->	-infty
 *	"NaN"		->	NaN
 *	n "/" d		->	n/d
 *	v		->	v
 *
 * where n, d and v are integer constants.
 */
================================================================================

文件路径: ./isl_input.c
注释行数: 10
注释内容:
/* Read an integer division from "s" and return it as an isl_pw_aff.
 *
 * The integer division can be of the form
 *
 *	[<affine expression>]
 *	floor(<affine expression>)
 *	ceil(<affine expression>)
 *	floord(<affine expression>,<denominator>)
 *	ceild(<affine expression>,<denominator>)
 */
================================================================================

文件路径: ./isl_input.c
注释行数: 12
注释内容:
/* Impose the lower bound "lower" on the variable represented by "range_pa".
 *
 * In particular, "range_pa" is of the form
 *
 *	D[..., i] -> i : C
 *
 * with D also the domains space of "lower' and "C" some constraints.
 *
 * Return the expression
 *
 *	D[..., i] -> i : C and i >= lower
 */
================================================================================

文件路径: ./isl_input.c
注释行数: 12
注释内容:
/* Impose the upper bound "upper" on the variable represented by "range_pa".
 *
 * In particular, "range_pa" is of the form
 *
 *	D[..., i] -> i : C
 *
 * with D also the domains space of "upper' and "C" some constraints.
 *
 * Return the expression
 *
 *	D[..., i] -> i : C and i <= upper
 */
================================================================================

文件路径: ./isl_input.c
注释行数: 12
注释内容:
/* Construct a piecewise affine expression corresponding
 * to the last variable in "v" that is greater than or equal to "pa".
 *
 * In particular, if D is the domain space of "pa",
 * then construct the expression
 *
 *	D[..., i] -> i,
 *
 * impose lower bound "pa" and return
 *
 *	D[..., i] -> i : i >= pa
 */
================================================================================

文件路径: ./isl_input.c
注释行数: 12
注释内容:
/* Construct a piecewise affine expression corresponding
 * to the last variable in "v" that is smaller than or equal to "pa".
 *
 * In particular, if D is the domain space of "pa",
 * then construct the expression
 *
 *	D[..., i] -> i,
 *
 * impose lower bound "pa" and return
 *
 *	D[..., i] -> i : i <= pa
 */
================================================================================

文件路径: ./isl_input.c
注释行数: 12
注释内容:
/* Construct a piecewise affine expression corresponding
 * to the last variable in "v" that ranges between "pa" and "pa2".
 *
 * In particular, if D is the domain space of "pa" (and "pa2"),
 * then construct the expression
 *
 *	D[..., i] -> i,
 *
 * impose lower bound "pa" and upper bound "pa2" and return
 *
 *	D[..., i] -> i : pa <= i <= pa2
 */
================================================================================

文件路径: ./isl_input.c
注释行数: 15
注释内容:
/* Given that the (piecewise) affine expression "pa"
 * has just been parsed, followed by a colon,
 * continue parsing as part of a piecewise affine expression.
 *
 * In particular, check if the colon is followed by a condition.
 * If so, parse the conditions(a) on "pa" and include them in the domain.
 * Otherwise, if the colon is followed by another (piecewise) affine expression
 * then consider the two expressions as endpoints of a range of values and
 * return a piecewise affine expression that takes values in that range.
 * Note that an affine expression followed by a comparison operator
 * is considered to be part of a condition.
 * If the colon is not followed by anything (inside the tuple element),
 * then consider "pa" as a lower bound on a range of values without upper bound
 * and return a piecewise affine expression that takes values in that range.
 */
================================================================================

文件路径: ./isl_input.c
注释行数: 35
注释内容:
/* Accept a piecewise affine expression.
 *
 * At the outer level, the piecewise affine expression may be of the form
 *
 *	aff1 : condition1; aff2 : conditions2; ...
 *
 * or one of
 *
 *	aff :
 *	aff1 : aff2
 *	: aff
 *	:
 *
 * or simply
 *
 *	aff
 *
 * each of the affine expressions may in turn include ternary operators.
 *
 * If the first token is a colon, then the expression must be
 * ":" or ": aff2", depending on whether anything follows the colon
 * inside the tuple element.
 * The first is considered to represent an arbitrary value.
 * The second is considered to represent a range of values
 * with the given upper bound and no lower bound.
 *
 * There may be parentheses around some subexpression of "aff1"
 * around "aff1" itself, around "aff1 : condition1" and/or
 * around the entire piecewise affine expression.
 * We therefore remove the opening parenthesis (if any) from the stream
 * in case the closing parenthesis follows the colon, but if the closing
 * parenthesis is the first thing in the stream after the parsed affine
 * expression, we push the parsed expression onto the stream and parse
 * again in case the parentheses enclose some subexpression of "aff1".
 */
================================================================================

文件路径: ./isl_input.c
注释行数: 10
注释内容:
/* This function is called for each element in a tuple inside read_tuple.
 * Add a new variable to "v" and construct a corresponding isl_pw_aff defined
 * over a space containing all variables in "v" defined so far.
 * The isl_pw_aff expresses the new variable in terms of earlier variables
 * if a definition is provided.  Otherwise, it is represented as being
 * equal to itself.
 * Add the isl_pw_aff to *list.
 * If the new variable was named, then adjust "space" accordingly and
 * return the updated space.
 */
================================================================================

文件路径: ./isl_input.c
注释行数: 15
注释内容:
/* Read a tuple and represent it as an isl_multi_pw_aff.
 * The range space of the isl_multi_pw_aff is the space of the tuple.
 * The domain space is an anonymous space
 * with a dimension for each variable in the set of variables in "v",
 * including the variables in the range.
 * If a given dimension is not defined in terms of earlier dimensions in
 * the input, then the corresponding isl_pw_aff is set equal to one time
 * the variable corresponding to the dimension being defined.
 *
 * The elements in the tuple are collected in a list by read_tuple_pw_aff_el.
 * Each element in this list is defined over a space representing
 * the variables defined so far.  We need to adjust the earlier
 * elements to have as many variables in the domain as the final
 * element in the list.
 */
================================================================================

文件路径: ./isl_input.c
注释行数: 15
注释内容:
/* Given two equal-length lists of piecewise affine expression with the space
 * of "set" as domain, construct a set in the same space that expresses
 * that "left" and "right" satisfy the comparison "type".
 *
 * A space is constructed of the same dimension as the number of elements
 * in the two lists.  The comparison is then expressed in a map from
 * this space to itself and wrapped into a set.  Finally the two lists
 * of piecewise affine expressions are plugged into this set.
 *
 * Let S be the space of "set" and T the constructed space.
 * The lists are first changed into two isl_multi_pw_affs in S -> T and
 * then combined into an isl_multi_pw_aff in S -> [T -> T],
 * while the comparison is first expressed in T -> T, then [T -> T]
 * and finally in S.
 */
================================================================================

文件路径: ./isl_input.c
注释行数: 14
注释内容:
/* Construct constraints of the form
 *
 *	a op b
 *
 * where a is an element in "left", op is an operator of type "type" and
 * b is an element in "right", add the constraints to "set" and return
 * the result.
 * "rational" is set if the constraints should be treated as
 * a rational constraints.
 *
 * If "type" is the type of a comparison operator between lists
 * of affine expressions, then a single (compound) constraint
 * is constructed by list_cmp instead.
 */
================================================================================

文件路径: ./isl_input.c
注释行数: 19
注释内容:
/* Read a constraint from "s", add it to "map" and return the result.
 * "v" contains a description of the identifiers parsed so far.
 * "rational" is set if the constraint should be treated as
 * a rational constraint.
 * The constraint read from "s" may be applied to multiple pairs
 * of affine expressions and may be chained.
 * In particular, a list of affine expressions is read, followed
 * by a comparison operator and another list of affine expressions.
 * The comparison operator is then applied to each pair of elements
 * in the two lists and the results are added to "map".
 * However, if the operator expects two lists of affine expressions,
 * then it is applied directly to those lists and the two lists
 * are required to have the same length.
 * If the next token is another comparison operator, then another
 * list of affine expressions is read and the process repeats.
 *
 * The processing is performed on a wrapped copy of "map" because
 * an affine expression cannot have a binary relation as domain.
 */
================================================================================

文件路径: ./isl_input.c
注释行数: 15
注释内容:
/* Parse an expression between parentheses and push the result
 * back on the stream.
 *
 * The parsed expression may be either an affine expression
 * or a condition.  The first type is pushed onto the stream
 * as an isl_pw_aff, while the second is pushed as an isl_map.
 *
 * If the initial token indicates the start of a condition,
 * we parse it as such.
 * Otherwise, we first parse an affine expression and push
 * that onto the stream.  If the affine expression covers the
 * entire expression between parentheses, we return.
 * Otherwise, we assume that the affine expression is the
 * start of a condition and continue parsing.
 */
================================================================================

文件路径: ./isl_input.c
注释行数: 21
注释内容:
/* Read a first order formula from "s", add the corresponding
 * constraints to "map" and return the result.
 *
 * In particular, read a formula of the form
 *
 *	a
 *
 * or
 *
 *	a implies b
 *
 * where a and b are disjunctions.
 *
 * In the first case, map is replaced by
 *
 *	map \cap { [..] : a }
 *
 * In the second case, it is replaced by
 *
 *	(map \setminus { [..] : a}) \cup (map \cap { [..] : b })
 */
================================================================================

文件路径: ./isl_input.c
注释行数: 12
注释内容:
/* First read the domain of the affine expression, which may be
 * a parameter space or a set.
 * The tricky part is that we don't know if the domain is a set or not,
 * so when we are trying to read the domain, we may actually be reading
 * the affine expression itself (defined on a parameter domains)
 * If the tuple we are reading is named, we assume it's the domain.
 * Also, if inside the tuple, the first thing we find is a nested tuple
 * or a new identifier, we again assume it's the domain.
 * Finally, if the tuple is empty, then it must be the domain
 * since it does not contain an affine expression.
 * Otherwise, we assume we are reading an affine expression.
 */
================================================================================

文件路径: ./isl_input.c
注释行数: 15
注释内容:
/* Extract an isl_multi_pw_aff with domain space "dom_space"
 * from a tuple "tuple" read by read_tuple.
 *
 * Note that the function read_tuple accepts tuples where some output or
 * set dimensions are defined in terms of other output or set dimensions
 * since this function is also used to read maps.  As a special case,
 * read_tuple also accept dimensions that are defined in terms of themselves
 * (i.e., that are not defined).
 * These cases are not allowed when extracting an isl_multi_pw_aff so check
 * that the definitions of the output/set dimensions do not involve any
 * output/set dimensions.
 * Finally, drop the output dimensions from the domain of the result
 * of read_tuple (which is of the form [input, output] -> [output],
 * with anonymous domain) and reset the space.
 */
================================================================================

文件路径: ./isl_input.c
注释行数: 13
注释内容:
/* Read a tuple of affine expressions, together with optional constraints
 * on the domain from "s".  "dom" represents the initial constraints
 * on the domain.
 *
 * The isl_multi_aff may live in either a set or a map space.
 * First read the first tuple and check if it is followed by a "->".
 * If so, convert the tuple into the domain of the isl_multi_pw_aff and
 * read in the next tuple.  This tuple (or the first tuple if it was
 * not followed by a "->") is then converted into an isl_multi_pw_aff
 * through a call to extract_mpa_from_tuple.
 * The result is converted to an isl_pw_multi_aff and
 * its domain is intersected with the domain.
 */
================================================================================

文件路径: ./isl_input.c
注释行数: 18
注释内容:
/* Read an isl_multi_pw_aff from "s".
 *
 * The input format is similar to that of map, except that any conditions
 * on the domains should be specified inside the tuple since each
 * piecewise affine expression may have a different domain.
 * However, additional, shared conditions can also be specified.
 * This is especially useful for setting the explicit domain
 * of a zero-dimensional isl_multi_pw_aff.
 *
 * Since we do not know in advance if the isl_multi_pw_aff lives
 * in a set or a map space, we first read the first tuple and check
 * if it is followed by a "->".  If so, we convert the tuple into
 * the domain of the isl_multi_pw_aff and read in the next tuple.
 * This tuple (or the first tuple if it was not followed by a "->")
 * is then converted into the isl_multi_pw_aff through a call
 * to extract_mpa_from_tuple and the domain of the result
 * is intersected with the domain.
 */
================================================================================

文件路径: ./isl_input.c
注释行数: 14
注释内容:
/* Read the core of a body of an isl_multi_union_pw_aff from "s",
 * i.e., everything except the parameter specification and
 * without shared domain constraints.
 * "v" contains a description of the identifiers parsed so far.
 * The parameters, if any, are specified by "space".
 *
 * The body is of the form
 *
 *	[{ [..] : ... ; [..] : ... }, { [..] : ... ; [..] : ... }]
 *
 * Read the tuple, collecting the individual isl_union_pw_aff
 * elements in a list and construct the result from the tuple space and
 * the list.
 */
================================================================================

文件路径: ./isl_input.c
注释行数: 15
注释内容:
/* Read the body of an isl_multi_union_pw_aff from "s",
 * i.e., everything except the parameter specification.
 * "v" contains a description of the identifiers parsed so far.
 * The parameters, if any, are specified by "space".
 *
 * In particular, handle the special case with shared domain constraints.
 * These are specified as
 *
 *	([...] : ...)
 *
 * and are especially useful for setting the explicit domain
 * of a zero-dimensional isl_multi_union_pw_aff.
 * The core isl_multi_union_pw_aff body ([...]) is read by
 * read_multi_union_pw_aff_body_core.
 */
================================================================================

文件路径: ./isl_input.c
注释行数: 25
注释内容:
/* Read an isl_multi_union_pw_aff from "s".
 *
 * The input has the form
 *
 *	[{ [..] : ... ; [..] : ... }, { [..] : ... ; [..] : ... }]
 *
 * or
 *
 *	[..] -> [{ [..] : ... ; [..] : ... }, { [..] : ... ; [..] : ... }]
 *
 * Additionally, a shared domain may be specified as
 *
 *	([..] : ...)
 *
 * or
 *
 *	[..] -> ([..] : ...)
 *
 * The first case is handled by the caller, the second case
 * is handled by read_multi_union_pw_aff_body.
 *
 * We first check for the special case of an empty tuple "[]".
 * Then we check if there are any parameters.
 * Finally, read the tuple and construct the result.
 */
================================================================================

文件路径: ./isl_input.c
注释行数: 12
注释内容:
/* Read an isl_multi_union_pw_aff from "s".
 *
 * In particular, handle the special case with shared domain constraints.
 * These are specified as
 *
 *	([...] : ...)
 *
 * and are especially useful for setting the explicit domain
 * of a zero-dimensional isl_multi_union_pw_aff.
 * The core isl_multi_union_pw_aff ([...]) is read by
 * read_multi_union_pw_aff_core.
 */
================================================================================

文件路径: ./isl_multi_intersect.c
注释行数: 10
注释内容:
/* Intersect the explicit domain of "multi" with "domain".
 *
 * The parameters of "multi" and "domain" are assumed to have been aligned.
 *
 * In the case of an isl_multi_union_pw_aff object, the explicit domain
 * is allowed to have only constraints on the parameters, while
 * "domain" contains actual domain elements.  In this case,
 * "domain" is intersected with those parameter constraints and
 * then used as the explicit domain of "multi".
 */
================================================================================

文件路径: ./isl_ast_graft_private.h
注释行数: 15
注释内容:
/* Representation of part of an AST ("node") with some additional polyhedral
 * information about the tree.
 *
 * "guard" contains conditions that should still be enforced by
 * some ancestor of the current tree.  In particular, the already
 * generated tree assumes that these conditions hold, but may not
 * have enforced them itself.
 * The guard should not contain any unknown divs as it will be used
 * to generate an if condition.
 *
 * "enforced" expresses constraints that are already enforced by the for
 * nodes in the current tree and that therefore do not need to be enforced
 * by any ancestor.
 * The constraints only involve outer loop iterators.
 */
================================================================================

文件路径: ./isl_mat.c
注释行数: 14
注释内容:
/*
 * Copyright 2008-2009 Katholieke Universiteit Leuven
 * Copyright 2010      INRIA Saclay
 * Copyright 2014      Ecole Normale Superieure
 * Copyright 2017      Sven Verdoolaege
 *
 * Use of this software is governed by the MIT license
 *
 * Written by Sven Verdoolaege, K.U.Leuven, Departement
 * Computerwetenschappen, Celestijnenlaan 200A, B-3001 Leuven, Belgium
 * and INRIA Saclay - Ile-de-France, Parc Club Orsay Universite,
 * ZAC des vignes, 4 rue Jacques Monod, 91893 Orsay, France
 * and Ecole Normale Superieure, 45 rue d'Ulm, 75230 Paris, France
 */
================================================================================

文件路径: ./isl_mat.c
注释行数: 12
注释内容:
/* Given matrix M, compute
 *
 *		M U = H
 *		M   = H Q
 *
 * with U and Q unimodular matrices and H a matrix in column echelon form
 * such that on each echelon row the entries in the non-echelon column
 * are non-negative (if neg == 0) or non-positive (if neg == 1)
 * and strictly smaller (in absolute value) than the entries in the echelon
 * column.
 * If U or Q are NULL, then these matrices are not computed.
 */
================================================================================

文件路径: ./isl_mat.c
注释行数: 11
注释内容:
/* Replace the variables x in the rows q by x' given by x = M x',
 * with M the matrix mat.
 *
 * If the number of new variables is greater than the original
 * number of variables, then the rows q have already been
 * preextended.  If the new number is smaller, then the coefficients
 * of the divs, which are not changed, need to be shifted down.
 * The row q may be the equalities, the inequalities or the
 * div expressions.  In the latter case, has_div is true and
 * we need to take into account the extra denominator column.
 */
================================================================================

文件路径: ./isl_mat.c
注释行数: 10
注释内容:
/* Replace the variables x in bset by x' given by x = M x', with
 * M the matrix mat.
 *
 * If there are fewer variables x' then there are x, then we perform
 * the transformation in place, which means that, in principle,
 * this frees up some extra variables as the number
 * of columns remains constant, but we would have to extend
 * the div array too as the number of rows in this array is assumed
 * to be equal to extra.
 */
================================================================================

文件路径: ./isl_mat.c
注释行数: 12
注释内容:
/* Return rows that extend a basis of "mat1" to one
 * that covers both "mat1" and "mat2".
 * The Hermite normal form of the concatenation of the two matrices is
 *
 *	                     [ Q1 ]
 *	[ M1 ] = [ H1 0  0 ] [ Q2 ]
 *	[ M2 ] = [ H2 H3 0 ] [ Q3 ]
 *
 * The number of columns in H1 and H3 determine the number of rows
 * in Q1 and Q2.  Q1 is a basis for M1, while Q2 extends this basis
 * to also cover M2.
 */
================================================================================

文件路径: ./isl_tarjan.h
注释行数: 10
注释内容:
/* Structure for representing the graph being traversed
 * using Tarjan's algorithm.
 * len is the number of nodes
 * node is an array of nodes
 * stack contains the nodes on the path from the root to the current node
 * sp is the stack pointer
 * index is the index of the last node visited
 * order contains the elements of the components separated by -1
 * op represents the current position in order
 */
================================================================================

文件路径: ./isl_space.c
注释行数: 15
注释内容:
/*
 * Copyright 2008-2009 Katholieke Universiteit Leuven
 * Copyright 2010      INRIA Saclay
 * Copyright 2013-2014 Ecole Normale Superieure
 * Copyright 2018-2019 Cerebras Systems
 *
 * Use of this software is governed by the MIT license
 *
 * Written by Sven Verdoolaege, K.U.Leuven, Departement
 * Computerwetenschappen, Celestijnenlaan 200A, B-3001 Leuven, Belgium
 * and INRIA Saclay - Ile-de-France, Parc Club Orsay Universite,
 * ZAC des vignes, 4 rue Jacques Monod, 91893 Orsay, France 
 * and Ecole Normale Superieure, 45 rue d’Ulm, 75230 Paris, France
 * and Cerebras Systems, 175 S San Antonio Rd, Los Altos, CA, USA
 */
================================================================================

文件路径: ./isl_space.c
注释行数: 12
注释内容:
/* Check if the tuple of type "type1" of "space1" is the same as
 * the tuple of type "type2" of "space2".
 *
 * That is, check if the tuples have the same identifier, the same dimension
 * and the same internal structure.
 * The identifiers of the dimensions inside the tuples do not affect the result.
 *
 * Note that this function only checks the tuples themselves.
 * If nested tuples are involved, then we need to be careful not
 * to have result affected by possibly differing parameters
 * in those nested tuples.
 */
================================================================================

文件路径: ./isl_space.c
注释行数: 14
注释内容:
/* Internal function that introduces a domain in "space"
 * corresponding to the range space of "tuple".
 * In particular, if "space" is a parameter space, then the result
 * is a set space.  If "space" is a set space, then the result
 * is a map space with the original space as range.
 * Parameters that correspond to the identifiers in "tuple" are removed.
 *
 * The parameters are removed in reverse order (under the assumption
 * that they appear in the same order in "multi") because
 * it is slightly more efficient to remove parameters at the end.
 *
 * For pretty-printing purposes, the identifiers of the set dimensions
 * of the introduced domain are set to the identifiers in "tuple".
 */
================================================================================

文件路径: ./isl_test_cpp-generic.cc
注释行数: 14
注释内容:
/* Test the pointer interface for interaction between isl C and C++ types.
 *
 * This tests:
 * - construction from an isl C object
 * - check that constructed objects are non-null
 * - get a non-owned C pointer from an isl C++ object usable in __isl_keep
 *   methods
 * - use copy to get an owned C pointer from an isl C++ object which is usable
 *   in __isl_take methods. Verify that the original C++ object retains a valid
 *   pointer.
 * - use release to get an owned C pointer from an isl C++ object which is
 *   usable in __isl_take methods. Verify that the original C++ object gave up
 *   its pointer and now is null.
 */
================================================================================

文件路径: ./isl_test_cpp-generic.cc
注释行数: 18
注释内容:
/* Test that isl objects can be constructed.
 *
 * This tests:
 *  - construction of a null object
 *  - construction from a string
 *  - construction from an integer
 *  - static constructor without a parameter
 *  - conversion construction (implicit)
 *  - conversion construction (explicit)
 *  - construction of empty union set
 *
 *  The tests to construct from integers and strings cover functionality that
 *  is also tested in the parameter type tests, but here we verify that
 *  multiple overloaded constructors are available and that overload resolution
 *  works as expected.
 *
 *  Construction from an isl C pointer is tested in test_pointer.
 */
================================================================================

文件路径: ./isl_output.c
注释行数: 15
注释内容:
/*
 * Copyright 2008-2009 Katholieke Universiteit Leuven
 * Copyright 2010      INRIA Saclay
 * Copyright 2012-2013 Ecole Normale Superieure
 * Copyright 2019      Cerebras Systems
 *
 * Use of this software is governed by the MIT license
 *
 * Written by Sven Verdoolaege, K.U.Leuven, Departement
 * Computerwetenschappen, Celestijnenlaan 200A, B-3001 Leuven, Belgium
 * and INRIA Saclay - Ile-de-France, Parc Club Orsay Universite,
 * ZAC des vignes, 4 rue Jacques Monod, 91893 Orsay, France 
 * and Ecole Normale Superieure, 45 rue d'Ulm, 75230 Paris, France
 * and Cerebras Systems, 175 S San Antonio Rd, Los Altos, CA, USA
 */
================================================================================

文件路径: ./isl_output.c
注释行数: 11
注释内容:
/* Print one side of a constraint "c" to "p", with
 * the variable names taken from "space" and the integer division definitions
 * taken from "div".
 * "last" is the position of the last non-zero coefficient.
 * Let c' be the result of zeroing out this coefficient, then
 * the partial constraint
 *
 *	c' op
 *
 * is printed.
 */
================================================================================

文件路径: ./isl_output.c
注释行数: 11
注释内容:
/* Given an integer division
 *
 *	floor(f/m)
 *
 * at position "pos" in "div", print the corresponding modulo expression
 *
 *	(f) mod m
 *
 * to "p".  The variable names are taken from "space", while any
 * nested integer division definitions are taken from "div".
 */
================================================================================

文件路径: ./isl_output.c
注释行数: 15
注释内容:
/* Given an equality constraint with a non-zero coefficient "c"
 * in position "pos", is this term of the form
 *
 *	a m floor(g/m),
 *
 * with c = a m?
 * Return the position of the corresponding integer division if so.
 * Return the number of integer divisions if not.
 * Return isl_size_error on error.
 *
 * Modulo constraints are currently not printed in C format.
 * Other than that, "pos" needs to correspond to an integer division
 * with explicit representation and "c" needs to be a multiple
 * of the denominator of the integer division.
 */
================================================================================

文件路径: ./isl_output.c
注释行数: 16
注释内容:
/* Print equality constraint "c" to "p" as a modulo constraint,
 * with the variable names taken from "space" and
 * the integer division definitions taken from "div".
 * "last" is the position of the last non-zero coefficient, which is
 * moreover assumed to be negative and a multiple of the denominator
 * of the corresponding integer division.  "div_pos" is the corresponding
 * position in the sequence of integer divisions.
 *
 * The equality is of the form
 *
 *	f - a m floor(g/m) = 0.
 *
 * Print it as
 *
 *	a (g mod m) = -f + a g
 */
================================================================================

文件路径: ./isl_output.c
注释行数: 40
注释内容:
/* Print the constraints of "bmap" to "p".
 * The names of the variables are taken from "space" and
 * the integer division definitions are taken from "div".
 * Div constraints are only printed in "dump" mode.
 * The constraints are sorted prior to printing (except in "dump" mode).
 *
 * If x is the last variable with a non-zero coefficient,
 * then a lower bound
 *
 *	f - a x >= 0
 *
 * is printed as
 *
 *	a x <= f
 *
 * while an upper bound
 *
 *	f + a x >= 0
 *
 * is printed as
 *
 *	a x >= -f
 *
 * If the next constraint has an opposite sign for the same last coefficient,
 * then it is printed as
 *
 *	f >= a x
 *
 * or
 *
 *	-f <= a x
 *
 * instead.  In fact, the "a x" part is not printed explicitly, but
 * reused from the next constraint, which is therefore treated as
 * a first constraint in the conjunction.
 *
 * If the constant term of "f" is -1, then "f" is replaced by "f + 1" and
 * the comparison operator is replaced by the strict variant.
 * Essentially, ">= 1" is replaced by "> 0".
 */
================================================================================

文件路径: ./isl_output.c
注释行数: 20
注释内容:
/* Look for the last of the "n" integer divisions that is used in "aff" and
 * that can be printed as a modulo and
 * return the position of this integer division.
 * Return "n" if no such integer division can be found.
 * Return isl_size_error on error.
 *
 * In particular, look for an integer division that appears in "aff"
 * with a coefficient that is a multiple of the denominator
 * of the integer division.
 * That is, check if the numerator of "aff" is of the form
 *
 *	f(...) + a m floor(g/m)
 *
 * and return the position of "floor(g/m)".
 *
 * Note that, unlike print_as_modulo_pos, no check needs to be made
 * for whether the integer division can be printed, since it will
 * need to be printed as an integer division anyway if it is not printed
 * as a modulo.
 */
================================================================================

文件路径: ./isl_output.c
注释行数: 16
注释内容:
/* Print the numerator of the affine expression "aff" to "p",
 * with the variable names taken from "space",
 * given that the numerator of "aff" is of the form
 *
 *	f(...) + a m floor(g/m)
 *
 * with "floor(g/m)" the integer division at position "last".
 *
 * First replace "aff" by its numerator and rewrite it as
 *
 *	f(...) + a g - a (g mod m)
 *
 * Recursively write out (the numerator of) "f(...) + a g"
 * (which may involve other modulo expressions) and
 * then write out "- a (g mod m)".
 */
================================================================================

文件路径: ./isl_output.c
注释行数: 11
注释内容:
/* Print dimension "pos" of data->space to "p".
 *
 * data->user is assumed to be an isl_multi_pw_aff.
 *
 * If the current dimension is an output dimension, then print
 * the corresponding piecewise affine expression.
 * Otherwise, print the name of the dimension.
 * Make sure to use the same space in both cases.
 * In particular, use the domain space for printing names as
 * that is the space that is used for printing constraints.
 */
================================================================================

文件路径: ./isl_scan.c
注释行数: 18
注释内容:
/* Look for all integer points in "bset", which is assumed to be bounded,
 * and call callback->add on each of them.
 *
 * We first compute a reduced basis for the set and then scan
 * the set in the directions of this basis.
 * We basically perform a depth first search, where in each level i
 * we compute the range in the i-th basis vector direction, given
 * fixed values in the directions of the previous basis vector.
 * We then add an equality to the tableau fixing the value in the
 * direction of the current basis vector to each value in the range
 * in turn and then continue to the next level.
 *
 * The search is implemented iteratively.  "level" identifies the current
 * basis vector.  "init" is true if we want the first value at the current
 * level and false if we want the next value.
 * Solutions are added in the leaves of the search tree, i.e., after
 * we have fixed a value in each direction of the basis.
 */
================================================================================

文件路径: ./isl_factorization.c
注释行数: 14
注释内容:
/*
 * Copyright 2005-2007 Universiteit Leiden
 * Copyright 2008-2009 Katholieke Universiteit Leuven
 * Copyright 2010      INRIA Saclay
 *
 * Use of this software is governed by the MIT license
 *
 * Written by Sven Verdoolaege, Leiden Institute of Advanced Computer Science,
 * Universiteit Leiden, Niels Bohrweg 1, 2333 CA Leiden, The Netherlands
 * and K.U.Leuven, Departement Computerwetenschappen, Celestijnenlaan 200A,
 * B-3001 Leuven, Belgium
 * and INRIA Saclay - Ile-de-France, Parc Club Orsay Universite,
 * ZAC des vignes, 4 rue Jacques Monod, 91893 Orsay, France 
 */
================================================================================

文件路径: ./isl_int_sioimath.h
注释行数: 41
注释内容:
/* The type to represent integers optimized for small values. It is either a
 * pointer to an mp_int ( = mpz_t*; big representation) or an int32_t (small
 * represenation) with a discriminator at the least significant bit. In big
 * representation it will be always zero because of heap alignment. It is set
 * to 1 for small representation and use the 32 most significant bits for the
 * int32_t.
 *
 * Structure on 64 bit machines, with 8-byte aligment (3 bits):
 *
 * Big representation:
 * MSB                                                          LSB
 * |------------------------------------------------------------000
 * |                            mpz_t*                            |
 * |                           != NULL                            |
 *
 * Small representation:
 * MSB                           32                             LSB
 * |------------------------------|00000000000000000000000000000001
 * |          int32_t             |
 * |  2147483647 ... -2147483647  |
 *                                                                ^
 *                                                                |
 *                                                        discriminator bit
 *
 * On 32 bit machines isl_sioimath type is blown up to 8 bytes, i.e.
 * isl_sioimath is guaranteed to be at least 8 bytes. This is to ensure the
 * int32_t can be hidden in that type without data loss. In the future we might
 * optimize this to use 31 hidden bits in a 32 bit pointer. We may also use 63
 * bits on 64 bit machines, but this comes with the cost of additional overflow
 * checks because there is no standardized 128 bit integer we could expand to.
 *
 * We use native integer types and avoid union structures to avoid assumptions
 * on the machine's endianness.
 *
 * This implementation makes the following assumptions:
 * - long can represent any int32_t
 * - mp_small is signed long
 * - mp_usmall is unsigned long
 * - adresses returned by malloc are aligned to 2-byte boundaries (leastmost
 *   bit is zero)
 */
================================================================================

文件路径: ./isl_int_sioimath.h
注释行数: 11
注释内容:
/* The negation of the smallest possible number in int32_t, INT32_MIN
 * (0x80000000u, -2147483648), cannot be represented in an int32_t, therefore
 * every operation that may produce this value needs to special-case it.
 * The operations are:
 * abs(INT32_MIN)
 * -INT32_MIN   (negation)
 * -1 * INT32_MIN (multiplication)
 * INT32_MIN/-1 (any division: divexact, fdiv, cdiv, tdiv)
 * To avoid checking these cases, we exclude INT32_MIN from small
 * representation.
 */
================================================================================

文件路径: ./isl_int_sioimath.h
注释行数: 22
注释内容:
/* A common situation is to call an IMath function with at least one argument
 * that is currently in small representation or an integer parameter, i.e. a big
 * representation of the same number is required. Promoting the original
 * argument comes with multiple problems, such as modifying a read-only
 * argument, the responsibility of deallocation and the execution cost. Instead,
 * we make a copy by 'faking' the IMath internal structure.
 *
 * We reserve the maximum number of required digits on the stack to avoid heap
 * allocations.
 *
 * mp_digit can be uint32_t or uint16_t. This code must work for little and big
 * endian digits. The structure for an uint64_t argument and 32-bit mp_digits is
 * sketched below.
 *
 * |----------------------------|
 *            uint64_t
 *
 * |-------------||-------------|
 *    mp_digit        mp_digit
 *    digits[1]       digits[0]
 * Most sig digit  Least sig digit
 */
================================================================================

文件路径: ./isl_int_sioimath.h
注释行数: 12
注释内容:
/* Convert a native integer to IMath's digit representation. A native integer
 * might be big- or little endian, but IMath always stores the least significant
 * digit in the lowest array indices.  memcpy therefore is not possible.
 *
 * We also have to consider that long and mp_digit can be of different sizes,
 * depending on the compiler (LP64, LLP64) and IMath's USE_64BIT_WORDS. This
 * macro should work for all of them.
 *
 * "used" is set to the number of written digits. It must be minimal (IMath
 * checks zeroness using the used field), but always at least one.  Also note
 * that the result of num>>(sizeof(num)*CHAR_BIT) is undefined.
 */
================================================================================

文件路径: ./isl_schedule_node.c
注释行数: 12
注释内容:
/*
 * Copyright 2013-2014 Ecole Normale Superieure
 * Copyright 2014      INRIA Rocquencourt
 * Copyright 2016      Sven Verdoolaege
 *
 * Use of this software is governed by the MIT license
 *
 * Written by Sven Verdoolaege,
 * Ecole Normale Superieure, 45 rue d'Ulm, 75230 Paris, France
 * and Inria Paris - Rocquencourt, Domaine de Voluceau - Rocquencourt,
 * B.P. 105 - 78153 Le Chesnay, France
 */
================================================================================

文件路径: ./isl_schedule_node.c
注释行数: 13
注释内容:
/* Internal data structure for
 * isl_schedule_node_get_prefix_schedule_union_pw_multi_aff
 *
 * "initialized" is set if the filter field has been initialized.
 * If "universe_domain" is not set, then the collected filter is intersected
 * with the domain of the root domain node.
 * "universe_filter" is set if we are only collecting the universes of filters
 * "collect_prefix" is set if we are collecting prefixes.
 * "filter" collects all outer filters and is NULL until "initialized" is set.
 * "prefix" collects all outer band partial schedules (if "collect_prefix"
 * is set).  If it is used, then it is initialized by the caller
 * of collect_filter_prefix to a zero-dimensional function.
 */
================================================================================

文件路径: ./isl_schedule_node.c
注释行数: 15
注释内容:
/* Update "data" based on the tree node "tree" in case "data" has
 * not been initialized yet.
 *
 * Return 0 on success and -1 on error.
 *
 * If "tree" is a filter, then we set data->filter to this filter
 * (or its universe).
 * If "tree" is a domain, then this means we have reached the root
 * of the schedule tree without being able to extract any information.
 * We therefore initialize data->filter to the universe of the domain,
 * or the domain itself if data->universe_domain is not set.
 * If "tree" is a band with at least one member, then we set data->filter
 * to the universe of the schedule domain and replace the zero-dimensional
 * data->prefix by the band schedule (if data->collect_prefix is set).
 */
================================================================================

文件路径: ./isl_schedule_node.c
注释行数: 14
注释内容:
/* Update "data" based on the tree node "tree" in case "data" has
 * already been initialized.
 *
 * Return 0 on success and -1 on error.
 *
 * If "tree" is a domain and data->universe_domain is not set, then
 * intersect data->filter with the domain.
 * If "tree" is a filter, then we intersect data->filter with this filter
 * (or its universe).
 * If "tree" is a band with at least one member and data->collect_prefix
 * is set, then we extend data->prefix with the band schedule.
 * If "tree" is an extension, then we make sure that we are not collecting
 * information on any extended domain elements.
 */
================================================================================

文件路径: ./isl_schedule_node.c
注释行数: 26
注释内容:
/* Collect filter and/or prefix information from the first "n"
 * elements in "list" (which represent the ancestors of a node).
 * Store the results in "data".
 *
 * Extension nodes are only supported if they do not affect the outcome,
 * i.e., if we are collecting information on non-extended domain elements,
 * or if we are collecting the universe domain (without prefix).
 *
 * Return 0 on success and -1 on error.
 *
 * We traverse the list from innermost ancestor (last element)
 * to outermost ancestor (first element), calling collect_filter_prefix_init
 * on each node as long as we have not been able to extract any information
 * yet and collect_filter_prefix_update afterwards.
 * If we come across an expansion node, then we interrupt the traversal
 * and call collect_filter_prefix_expansion to restart the traversal
 * over the remaining ancestors and to combine the results with those
 * that have already been collected.
 * If we come across an extension node and we are only computing
 * the universe domain, then we interrupt the traversal and call
 * collect_universe_domain_extension to restart the traversal
 * over the remaining ancestors and to combine the results with those
 * that have already been collected.
 * On successful return, data->initialized will be set since the outermost
 * ancestor is a domain node, which always results in an initialization.
 */
================================================================================

文件路径: ./isl_schedule_node.c
注释行数: 14
注释内容:
/* Return the concatenation of the partial schedules of all outer band
 * nodes of "node" interesected with all outer filters
 * as an isl_multi_union_pw_aff.
 * None of the ancestors of "node" may be an extension node, unless
 * there is also a filter ancestor that filters out all the extended
 * domain elements.
 *
 * If "node" is pointing at the root of the schedule tree, then
 * there are no domain elements reaching the current node, so
 * we return an empty result.
 *
 * We collect all the filters and partial schedules in collect_filter_prefix
 * and intersect the domain of the combined schedule with the combined filter.
 */
================================================================================

文件路径: ./isl_schedule_node.c
注释行数: 19
注释内容:
/* Return the concatenation of the partial schedules of all outer band
 * nodes of "node" interesected with all outer filters
 * as an isl_union_pw_multi_aff.
 * None of the ancestors of "node" may be an extension node, unless
 * there is also a filter ancestor that filters out all the extended
 * domain elements.
 *
 * If "node" is pointing at the root of the schedule tree, then
 * there are no domain elements reaching the current node, so
 * we return an empty result.
 *
 * We collect all the filters and partial schedules in collect_filter_prefix.
 * The partial schedules are collected as an isl_multi_union_pw_aff.
 * If this isl_multi_union_pw_aff is zero-dimensional, then it does not
 * contain any domain information, so we construct the isl_union_pw_multi_aff
 * result as a zero-dimensional function on the collected filter.
 * Otherwise, we convert the isl_multi_union_pw_aff to
 * an isl_multi_union_pw_aff and intersect the domain with the filter.
 */
================================================================================

文件路径: ./isl_schedule_node.c
注释行数: 11
注释内容:
/* Return the concatenation of the partial schedules of all outer band
 * nodes of "node" intersected with all outer domain constraints.
 * None of the ancestors of "node" may be an extension node, unless
 * there is also a filter ancestor that filters out all the extended
 * domain elements.
 *
 * Essentially, this function intersects the domain of the output
 * of isl_schedule_node_get_prefix_schedule_union_map with the output
 * of isl_schedule_node_get_domain, except that it only traverses
 * the ancestors of "node" once.
 */
================================================================================

文件路径: ./isl_schedule_node.c
注释行数: 12
注释内容:
/* Return the domain elements that reach "node".
 *
 * If "node" is pointing at the root of the schedule tree, then
 * there are no domain elements reaching the current node, so
 * we return an empty result.
 * None of the ancestors of "node" may be an extension node, unless
 * there is also a filter ancestor that filters out all the extended
 * domain elements.
 *
 * Otherwise, we collect all filters reaching the node,
 * intersected with the root domain in collect_filter_prefix.
 */
================================================================================

文件路径: ./isl_schedule_node.c
注释行数: 11
注释内容:
/* Return the subtree schedule of "node".
 *
 * Since isl_schedule_tree_get_subtree_schedule_union_map does not handle
 * trees that do not contain any schedule information, we first
 * move down to the first relevant descendant and handle leaves ourselves.
 *
 * If the subtree rooted at "node" contains any expansion nodes, then
 * the returned subtree schedule is formulated in terms of the expanded
 * domains.
 * The subtree is not allowed to contain any extension nodes.
 */
================================================================================

文件路径: ./isl_schedule_node.c
注释行数: 10
注释内容:
/* Return the number of children of "node"?
 *
 * Any node other than the leaf nodes is considered to have at least
 * one child, even if the corresponding isl_schedule_tree does not
 * have any children.  That is, the number of children of "node" is
 * only zero if its tree is the explicit empty tree.  Otherwise,
 * if the isl_schedule_tree has any children, then it is equal
 * to the number of children of "node".  If it has zero children,
 * then "node" still has a leaf node as child.
 */
================================================================================

文件路径: ./isl_schedule_node.c
注释行数: 10
注释内容:
/* Callback for "traverse" to enter a node and to move
 * to the deepest initial subtree that should be traversed
 * for use in a preorder visit.
 *
 * If the user callback returns a negative value, then we abort
 * the traversal.  If this callback returns zero, then we skip
 * the subtree rooted at the current node.  Otherwise, we move
 * down to the first child and repeat the process until a leaf
 * is reached.
 */
================================================================================

文件路径: ./isl_schedule_node.c
注释行数: 10
注释内容:
/* Traverse the descendants of "node" (including the node itself)
 * in depth first preorder.
 *
 * If "fn" returns isl_bool_error on any of the nodes,
 * then the traversal is aborted.
 * If "fn" returns isl_bool_false on any of the nodes, then the subtree rooted
 * at that node is skipped.
 *
 * Return isl_stat_ok on success and isl_stat_error on failure.
 */
================================================================================

文件路径: ./isl_schedule_node.c
注释行数: 23
注释内容:
/* Tile "node" with tile sizes "sizes".
 *
 * The current node is replaced by two nested nodes corresponding
 * to the tile dimensions and the point dimensions.
 *
 * Return a pointer to the outer (tile) node.
 *
 * If any of the descendants of "node" depend on the set of outer band nodes,
 * then we refuse to tile the node.
 *
 * If the scale tile loops option is set, then the tile loops
 * are scaled by the tile sizes.  If the shift point loops option is set,
 * then the point loops are shifted to start at zero.
 * In particular, these options affect the tile and point loop schedules
 * as follows
 *
 *	scale	shift	original	tile		point
 *
 *	0	0	i		floor(i/s)	i
 *	1	0	i		s * floor(i/s)	i
 *	0	1	i		floor(i/s)	i - s * floor(i/s)
 *	1	1	i		s * floor(i/s)	i - s * floor(i/s)
 */
================================================================================

文件路径: ./isl_schedule_node.c
注释行数: 16
注释内容:
/* Move the band node "node" down to all the leaves in the subtree
 * rooted at "node".
 * Return a pointer to the node in the resulting tree that is in the same
 * position as the node pointed to by "node" in the original tree.
 *
 * If the node only has a leaf child, then nothing needs to be done.
 * Otherwise, the child of the node is removed and the result is
 * appended to all the leaves in the subtree rooted at the original child.
 * Since the node is moved to the leaves, it needs to be expanded
 * according to the expansion, if any, defined by that subtree.
 * In the end, the original node is replaced by the result of
 * attaching copies of the expanded node to the leaves.
 *
 * If any of the nodes in the subtree rooted at "node" depend on
 * the set of outer band nodes then we refuse to sink the band node.
 */
================================================================================

文件路径: ./isl_schedule_node.c
注释行数: 15
注释内容:
/* Update the ancestors of "node" to point to the tree that "node"
 * now points to.
 * That is, replace the child in the original parent that corresponds
 * to the current tree position by node->tree and continue updating
 * the ancestors in the same way until the root is reached.
 *
 * If "fn" is not NULL, then it is called on each ancestor as we move up
 * the tree so that it can modify the ancestor before it is added
 * to the list of ancestors of the modified node.
 * The additional "pos" argument records the position
 * of the "tree" argument in the original schedule tree.
 *
 * If "node" originally points to a leaf of the schedule tree, then make sure
 * that in the end it points to a leaf in the updated schedule tree.
 */
================================================================================

文件路径: ./isl_schedule_node.c
注释行数: 20
注释内容:
/* Internal data structure for the group_ancestor callback.
 *
 * If "finished" is set, then we no longer need to modify
 * any further ancestors.
 *
 * "contraction" and "expansion" represent the expansion
 * that reflects the grouping.
 *
 * "domain" contains the domain elements that reach the position
 * where the grouping is performed.  That is, it is the range
 * of the resulting expansion.
 * "domain_universe" is the universe of "domain".
 * "group" is the set of group elements, i.e., the domain
 * of the resulting expansion.
 * "group_universe" is the universe of "group".
 *
 * "sched" is the schedule for the group elements, in pratice
 * an identity mapping on "group_universe".
 * "dim" is the dimension of "sched".
 */
================================================================================

文件路径: ./isl_schedule_node.c
注释行数: 12
注释内容:
/* Update the band tree root "tree" to refer to the group instances
 * in data->group rather than the original domain elements in data->domain.
 * "pos" is the position in the original schedule tree where the modified
 * "tree" will be attached.
 *
 * Add the part of the identity schedule on the group instances data->sched
 * that corresponds to this band node to the band schedule.
 * If the domain elements that reach the node and that are part
 * of data->domain_universe are all elements of data->domain (and therefore
 * replaced by the group instances) then this data->domain_universe
 * is removed from the domain of the band schedule.
 */
================================================================================

文件路径: ./isl_schedule_node.c
注释行数: 14
注释内容:
/* Update the expansion tree root "tree" to refer to the group instances
 * in data->group rather than the original domain elements in data->domain.
 * "pos" is the position in the original schedule tree where the modified
 * "tree" will be attached.
 *
 * Let G_1 -> D_1 be the expansion of "tree" and G_2 -> D_2 the newly
 * introduced expansion in a descendant of "tree".
 * We first double-check that D_2 is a subset of D_1.
 * Then we remove D_2 from the range of G_1 -> D_1 and add the mapping
 * G_1 -> D_1 . D_2 -> G_2.
 * Simmilarly, we restrict the domain of the contraction to the universe
 * of the range of the updated expansion and add G_2 -> D_2 . D_1 -> G_1,
 * attempting to remove the domain constraints of this additional part.
 */
================================================================================

文件路径: ./isl_schedule_node.c
注释行数: 15
注释内容:
/* Update the tree root "tree" to refer to the group instances
 * in data->group rather than the original domain elements in data->domain.
 * "pos" is the position in the original schedule tree where the modified
 * "tree" will be attached.
 *
 * If we have come across a domain or expansion node before (data->finished
 * is set), then we no longer need perform any modifications.
 *
 * If "tree" is a filter, then we add data->group_universe to the filter.
 * We also remove data->domain_universe from the filter if all the domain
 * elements in this universe that reach the filter node are part of
 * the elements that are being grouped by data->expansion.
 * If "tree" is a band, domain or expansion, then it is handled
 * in a separate function.
 */
================================================================================

文件路径: ./isl_schedule_node.c
注释行数: 19
注释内容:
/* Group the domain elements that reach "node" into instances
 * of a single statement with identifier "group_id".
 * In particular, group the domain elements according to their
 * prefix schedule.
 *
 * That is, introduce an expansion node with as contraction
 * the prefix schedule (with the target space replaced by "group_id")
 * and as expansion the inverse of this contraction (with its range
 * intersected with the domain elements that reach "node").
 * The outer nodes are then modified to refer to the group instances
 * instead of the original domain elements.
 *
 * No instance of "group_id" is allowed to reach "node" prior
 * to the grouping.
 * No ancestor of "node" is allowed to be an extension node.
 *
 * Return a pointer to original node in tree, i.e., the child
 * of the newly introduced expansion node.
 */
================================================================================

文件路径: ./isl_schedule_node.c
注释行数: 29
注释内容:
/* Callback for "traverse" to enter a node and to move
 * to the deepest initial subtree that should be traversed
 * by isl_schedule_node_gist.
 *
 * The "filters" list is extended by one element each time
 * we come across a filter node by the result of intersecting
 * the last element in the list with the filter on the filter node.
 *
 * If the filter on the current filter node is a subset of
 * the original context passed to isl_schedule_node_gist,
 * then there is no need to go into its subtree since it cannot
 * be further simplified by the context.  The "filters" list is
 * still extended for consistency, but the actual value of the
 * added element is immaterial since it will not be used.
 *
 * Otherwise, the filter on the current filter node is replaced by
 * the gist of the original filter with respect to the intersection
 * of the original context with the intermediate filters.
 *
 * If the new element in the "filters" list is empty, then no elements
 * can reach the descendants of the current filter node.  The subtree
 * underneath the filter node is therefore removed.
 *
 * Each expansion node we come across is handled by
 * gist_enter_expansion.
 *
 * Each extension node we come across is handled by
 * gist_enter_extension.
 */
================================================================================

文件路径: ./isl_schedule_node.c
注释行数: 26
注释内容:
/* Callback for "traverse" to leave a node for isl_schedule_node_gist.
 *
 * In particular, if the current node is a filter node, then we remove
 * the element on the "filters" list that was added when we entered
 * the node.  There is no need to compute any gist here, since we
 * already did that when we entered the node.
 *
 * Expansion nodes are handled by gist_leave_expansion.
 *
 * If the current node is an extension, then remove the element
 * in data->filters that was added by gist_enter_extension.
 *
 * If the current node is a band node, then we compute the gist of
 * the band node with respect to the intersection of the original context
 * and the intermediate filters.
 *
 * If the current node is a sequence or set node, then some of
 * the filter children may have become empty and so they are removed.
 * If only one child is left, then the set or sequence node along with
 * the single remaining child filter is removed.  The filter can be
 * removed because the filters on a sequence or set node are supposed
 * to partition the incoming domain instances.
 * In principle, it should then be impossible for there to be zero
 * remaining children, but should this happen, we replace the entire
 * subtree with an empty filter.
 */
================================================================================

文件路径: ./isl_schedule_node.c
注释行数: 11
注释内容:
/* Compute the gist of the subtree at "node" with respect to
 * the reaching domain elements in "context".
 * In particular, compute the gist of all band and filter nodes
 * in the subtree with respect to "context".  Children of set or sequence
 * nodes that end up with an empty filter are removed completely.
 *
 * We keep track of the intersection of "context" with all outer filters
 * of the current node within the subtree in the final element of "filters".
 * Initially, this list contains the single element "context" and it is
 * extended or shortened each time we enter or leave a filter node.
 */
================================================================================

文件路径: ./isl_schedule_node.c
注释行数: 14
注释内容:
/* Callback for "traverse" to enter a node and to move
 * to the deepest initial subtree that should be traversed
 * by isl_schedule_node_get_subtree_expansion.
 *
 * Whenever we come across an expansion node, the last element
 * of data->expansions is combined with the expansion
 * on the expansion node.
 *
 * Whenever we come across a filter node that is the child
 * of a set or sequence node, data->expansions is extended
 * with a new element that restricts the previous element
 * to the elements selected by the filter.
 * The previous element can then be reused while backtracking.
 */
================================================================================

文件路径: ./isl_schedule_node.c
注释行数: 10
注释内容:
/* Callback for "traverse" to leave a node for
 * isl_schedule_node_get_subtree_expansion.
 *
 * If we come across a filter node that is the child
 * of a set or sequence node, then we remove the element
 * of data->expansions that was added in subtree_expansion_enter.
 *
 * If we reach a leaf node, then the accumulated expansion is
 * added to data->res.
 */
================================================================================

文件路径: ./isl_schedule_node.c
注释行数: 11
注释内容:
/* Return a mapping from the domain elements that reach "node"
 * to the corresponding domain elements in the leaves of the subtree
 * rooted at "node" obtained by composing the intermediate expansions.
 *
 * We start out with an identity mapping between the domain elements
 * that reach "node" and compose it with all the expansions
 * on a path from "node" to a leaf while traversing the subtree.
 * Within the children of an a sequence or set node, the
 * accumulated expansion is restricted to the elements selected
 * by the filter child.
 */
================================================================================

文件路径: ./isl_schedule_node.c
注释行数: 14
注释内容:
/* Callback for "traverse" to enter a node and to move
 * to the deepest initial subtree that should be traversed
 * by isl_schedule_node_get_subtree_contraction.
 *
 * Whenever we come across an expansion node, the last element
 * of data->contractions is combined with the contraction
 * on the expansion node.
 *
 * Whenever we come across a filter node that is the child
 * of a set or sequence node, data->contractions is extended
 * with a new element that restricts the previous element
 * to the elements selected by the filter.
 * The previous element can then be reused while backtracking.
 */
================================================================================

文件路径: ./isl_schedule_node.c
注释行数: 10
注释内容:
/* Callback for "traverse" to leave a node for
 * isl_schedule_node_get_subtree_contraction.
 *
 * If we come across a filter node that is the child
 * of a set or sequence node, then we remove the element
 * of data->contractions that was added in subtree_contraction_enter.
 *
 * If we reach a leaf node, then the accumulated contraction is
 * added to data->res.
 */
================================================================================

文件路径: ./isl_schedule_node.c
注释行数: 11
注释内容:
/* Return a mapping from the domain elements in the leaves of the subtree
 * rooted at "node" to the corresponding domain elements that reach "node"
 * obtained by composing the intermediate contractions.
 *
 * We start out with an identity mapping between the domain elements
 * that reach "node" and compose it with all the contractions
 * on a path from "node" to a leaf while traversing the subtree.
 * Within the children of an a sequence or set node, the
 * accumulated contraction is restricted to the elements selected
 * by the filter child.
 */
================================================================================

文件路径: ./isl_schedule_node.c
注释行数: 16
注释内容:
/* Insert an extension node on top of "node" with extension "extension".
 * In addition, insert a filter that separates node from the extension
 * between the extension node and "node".
 * Return a pointer to the inserted filter node.
 *
 * If "node" already appears in an extension (i.e., if it is the child
 * of a filter in a sequence inside an extension node), then extend that
 * extension with "extension" instead.
 * In this case, a pointer to the original filter node is returned.
 * Note that if some of the elements in the new extension live in the
 * same space as those of the original extension or the domain elements
 * reaching the original extension, then we insert a new extension anyway.
 * Otherwise, we would have to adjust the filters in the sequence child
 * of the extension to ensure that the elements in the new extension
 * are filtered out.
 */
================================================================================

文件路径: ./isl_schedule_node.c
注释行数: 16
注释内容:
/* Insert a node "graft" into the schedule tree of "node" such that it
 * is executed before (if "before" is set) or after (if "before" is not set)
 * the node that "node" points to.
 * The root of "graft" is an extension node.
 * Return a pointer to the node that "node" pointed to.
 *
 * We first insert an extension node on top of "node" (or extend
 * the extension node if there already is one), with a filter on "node"
 * separating it from the extension.
 * We then insert a filter in the graft to separate it from the original
 * domain elements and combine the original and new tree in a sequence.
 * If we have extended an extension node, then the children of this
 * sequence are spliced in the sequence of the extended extension
 * at the position where "node" appears in the original extension.
 * Otherwise, the sequence pair is attached to the new extension node.
 */
================================================================================

文件路径: ./isl_schedule_node.c
注释行数: 26
注释内容:
/* Insert a node "graft" into the schedule tree of "node" such that it
 * is executed before (if "before" is set) or after (if "before" is not set)
 * the node that "node" points to.
 * The root of "graft" may be either a domain or an extension node.
 * In the latter case, the domain of the extension needs to correspond
 * to the outer band nodes of "node".
 * The elements of the domain or the range of the extension may not
 * intersect with the domain elements that reach "node".
 * The schedule tree of "graft" may not be anchored.
 *
 * The schedule tree of "node" is modified to include an extension node
 * corresponding to the root node of "graft" as a child of the original
 * parent of "node".  The original node that "node" points to and the
 * child of the root node of "graft" are attached to this extension node
 * through a sequence, with appropriate filters and with the child
 * of "graft" appearing before or after the original "node".
 *
 * If "node" already appears inside a sequence that is the child of
 * an extension node and if the spaces of the new domain elements
 * do not overlap with those of the original domain elements,
 * then that extension node is extended with the new extension
 * rather than introducing a new segment of extension and sequence nodes.
 *
 * Return a pointer to the same node in the modified tree that
 * "node" pointed to in the original tree.
 */
================================================================================

文件路径: ./isl_schedule_node.c
注释行数: 12
注释内容:
/* Insert a node "graft" into the schedule tree of "node" such that it
 * is executed before the node that "node" points to.
 * The root of "graft" may be either a domain or an extension node.
 * In the latter case, the domain of the extension needs to correspond
 * to the outer band nodes of "node".
 * The elements of the domain or the range of the extension may not
 * intersect with the domain elements that reach "node".
 * The schedule tree of "graft" may not be anchored.
 *
 * Return a pointer to the same node in the modified tree that
 * "node" pointed to in the original tree.
 */
================================================================================

文件路径: ./isl_schedule_node.c
注释行数: 12
注释内容:
/* Insert a node "graft" into the schedule tree of "node" such that it
 * is executed after the node that "node" points to.
 * The root of "graft" may be either a domain or an extension node.
 * In the latter case, the domain of the extension needs to correspond
 * to the outer band nodes of "node".
 * The elements of the domain or the range of the extension may not
 * intersect with the domain elements that reach "node".
 * The schedule tree of "graft" may not be anchored.
 *
 * Return a pointer to the same node in the modified tree that
 * "node" pointed to in the original tree.
 */
================================================================================

文件路径: ./isl_schedule_node.c
注释行数: 14
注释内容:
/* Split the domain elements that reach "node" into those that satisfy
 * "filter" and those that do not.  Arrange for the first subset to be
 * executed before or after the second subset, depending on the value
 * of "before".
 * Return a pointer to the tree corresponding to the second subset,
 * except when this subset is empty in which case the original pointer
 * is returned.
 * If both subsets are non-empty, then a sequence node is introduced
 * to impose the order.  If the grandparent of the original node was
 * itself a sequence, then the original child is replaced by two children
 * in this sequence instead.
 * The children in the sequence are copies of the original subtree,
 * simplified with respect to their filters.
 */
================================================================================

文件路径: ./isl_schedule_node.c
注释行数: 11
注释内容:
/* Compute the pullback of schedule node "node"
 * by the function represented by "upma".
 * In other words, plug in "upma" in the iteration domains
 * of schedule node "node".
 * We currently do not handle expansion nodes.
 *
 * Note that this is only a helper function for
 * isl_schedule_pullback_union_pw_multi_aff.  In order to maintain consistency,
 * this function should not be called on a single node without also
 * calling it on all the other nodes.
 */
================================================================================

文件路径: ./isl_schedule_node.c
注释行数: 10
注释内容:
/* Expand the tree rooted at "node" by extending all leaves
 * with an expansion node with as child "tree".
 * The expansion is determined by "contraction" and "domain".
 * That is, the elements of "domain" are contracted according
 * to "contraction".  The expansion relation is then the inverse
 * of "contraction" with its range intersected with "domain".
 *
 * Insert the appropriate expansion node on top of "tree" and
 * then plug in the result in all leaves of "node".
 */
================================================================================

文件路径: ./isl_schedule_node.c
注释行数: 11
注释内容:
/* Given two nodes that point to the same schedule tree, return their
 * closest shared ancestor.
 *
 * Since the two nodes point to the same schedule, they share at least
 * one ancestor, the root of the schedule.  We move down from the root
 * to the first ancestor where the respective children have a different
 * child position.  This is the requested ancestor.
 * If there is no ancestor where the children have a different position,
 * then one node is an ancestor of the other and then this node is
 * the requested ancestor.
 */
================================================================================

文件路径: ./isl_val_sioimath.c
注释行数: 11
注释内容:
/* Store a representation of the absolute value of the numerator of "v"
 * in terms of chunks of size "size" at "chunks".
 * The least significant chunk is stored first.
 * The number of chunks in the result can be obtained by calling
 * isl_val_n_abs_num_chunks.  The user is responsible for allocating
 * enough memory to store the results.
 *
 * In the special case of a zero value, isl_val_n_abs_num_chunks will
 * return one, while impz_export will not fill in any chunks.  We therefore
 * do it ourselves.
 */
================================================================================

文件路径: ./isl_stream.c
注释行数: 39
注释内容:
/* Move to the next state at the innermost level.
 * Return 1 if successful.
 * Return 0 if we are at the end of the innermost level.
 * Return -1 on error.
 *
 * If we are in state isl_yaml_mapping_key_start, then we have just
 * started a mapping and we are expecting a key.  If the mapping started
 * with a '{', then we check if the next token is a '}'.  If so,
 * then the mapping is empty and there is no next state at this level.
 * Otherwise, we assume that there is at least one key (the one from
 * which we derived the indentation in isl_stream_yaml_read_start_mapping.
 *
 * If we are in state isl_yaml_mapping_key, then the we expect a colon
 * followed by a value, so there is always a next state unless
 * some error occurs.
 *
 * If we are in state isl_yaml_mapping_val, then there may or may
 * not be a subsequent key in the same mapping.
 * In flow format, the next key is preceded by a comma.
 * In block format, the next key has the same indentation as the first key.
 * If the first token has a smaller indentation, then we have reached
 * the end of the current mapping.
 *
 * If we are in state isl_yaml_sequence_start, then we have just
 * started a sequence.  If the sequence started with a '[',
 * then we check if the next token is a ']'.  If so, then the sequence
 * is empty and there is no next state at this level.
 * Otherwise, we assume that there is at least one element in the sequence
 * (the one from which we derived the indentation in
 * isl_stream_yaml_read_start_sequence.
 *
 * If we are in state isl_yaml_sequence, then there may or may
 * not be a subsequent element in the same sequence.
 * In flow format, the next element is preceded by a comma.
 * In block format, the next element is introduced by a dash with
 * the same indentation as that of the first element.
 * If the first token is not a dash or if it has a smaller indentation,
 * then we have reached the end of the current sequence.
 */
================================================================================

文件路径: ./isl_stream.c
注释行数: 10
注释内容:
/* Start reading a YAML mapping.
 * Return 0 on success and -1 on error.
 *
 * If the first token on the stream is a '{' then we remove this token
 * from the stream and keep track of the fact that the mapping
 * is given in flow format.
 * Otherwise, we assume the first token is the first key of the mapping and
 * keep track of its indentation, but keep the token on the stream.
 * In both cases, the next token we expect is the first key of the mapping.
 */
================================================================================

文件路径: ./isl_stream.c
注释行数: 12
注释内容:
/* Start reading a YAML sequence.
 * Return 0 on success and -1 on error.
 *
 * If the first token on the stream is a '[' then we remove this token
 * from the stream and keep track of the fact that the sequence
 * is given in flow format.
 * Otherwise, we assume the first token is the dash that introduces
 * the first element of the sequence and keep track of its indentation,
 * but keep the token on the stream.
 * In both cases, the next token we expect is the first element
 * of the sequence.
 */
================================================================================

文件路径: ./isl_union_map.c
注释行数: 14
注释内容:
/*
 * Copyright 2010-2011 INRIA Saclay
 * Copyright 2013-2014 Ecole Normale Superieure
 * Copyright 2014      INRIA Rocquencourt
 * Copyright 2016-2017 Sven Verdoolaege
 *
 * Use of this software is governed by the MIT license
 *
 * Written by Sven Verdoolaege, INRIA Saclay - Ile-de-France,
 * Parc Club Orsay Universite, ZAC des vignes, 4 rue Jacques Monod,
 * 91893 Orsay, France 
 * and Inria Paris - Rocquencourt, Domaine de Voluceau - Rocquencourt,
 * B.P. 105 - 78153 Le Chesnay, France
 */
================================================================================

文件路径: ./isl_union_map.c
注释行数: 17
注释内容:
/* Data structure that specifies how gen_bin_op should
 * construct results from the inputs.
 *
 * If "subtract" is set, then a map in the first input is copied to the result
 * if there is no corresponding map in the second input.
 * Otherwise, a map in the first input with no corresponding map
 * in the second input is ignored.
 * If "filter" is not NULL, then it specifies which maps in the first
 * input may have a matching map in the second input.
 * In particular, it makes sure that "match_space" can be called
 * on the space of the map.
 * "match_space" specifies how to transform the space of a map
 * in the first input to the space of the corresponding map
 * in the second input.
 * "fn_map" specifies how the matching maps, one from each input,
 * should be combined to form a map in the result.
 */
================================================================================

文件路径: ./isl_union_map.c
注释行数: 10
注释内容:
/* Look for the map in data->umap2 that corresponds to "map", if any.
 * Return (isl_bool_true, matching map) if there is one,
 * (isl_bool_false, NULL) if there is no matching map and
 * (isl_bool_error, NULL) on error.
 *
 * If not NULL, then data->control->filter specifies whether "map"
 * can have any matching map.  If so,
 * data->control->match_space specifies which map in data->umap2
 * corresponds to "map".
 */
================================================================================

文件路径: ./isl_union_map.c
注释行数: 18
注释内容:
/* Data structure that specifies how un_op should modify
 * the maps in the union map.
 *
 * If "inplace" is set, then the maps in the input union map
 * are modified in place.  This means that "fn_map" should not
 * change the meaning of the map or that the union map only
 * has a single reference.
 * If "total" is set, then all maps need to be modified and
 * the results need to live in the same space.
 * Otherwise, a new union map is constructed to store the results.
 * If "filter" is not NULL, then only the input maps that satisfy "filter"
 * are taken into account.  "filter_user" is passed as the second argument
 * to "filter".  No filter can be set if "inplace" or
 * "total" is set.
 * At most one of "fn_map" or "fn_map2" can be set, specifying
 * how the maps (selected by "filter") should be transformed.
 * If "fn_map2" is set, then "fn_map2_user" is passed as the second argument.
 */
================================================================================

文件路径: ./isl_union_map.c
注释行数: 15
注释内容:
/* Check if the data->umap is single-valued on "set".
 *
 * If data->umap consists of a single map on "set", then test it
 * as an isl_map.
 *
 * Otherwise, compute
 *
 *	M \circ M^-1
 *
 * check if the result is a subset of the identity mapping and
 * store the result in data->sv.
 *
 * Terminate as soon as data->umap has been determined not to
 * be single-valued.
 */
================================================================================

文件路径: ./isl_union_map.c
注释行数: 12
注释内容:
/* Is "map" obviously not an identity relation because
 * it maps elements from one space to another space?
 * Update *non_identity accordingly.
 *
 * In particular, if the domain and range spaces are the same,
 * then the map is not considered to obviously not be an identity relation.
 * Otherwise, the map is considered to obviously not be an identity relation
 * if it is is non-empty.
 *
 * If "map" is determined to obviously not be an identity relation,
 * then the search is aborted.
 */
================================================================================

文件路径: ./isl_union_map.c
注释行数: 10
注释内容:
/* Given a list of the maps, with their fixed values at output dimension "pos",
 * check whether the ranges of the maps form an obvious partition.
 *
 * We first sort the maps according to their fixed values.
 * If all maps have a different value, then we know the ranges form
 * a partition.
 * Otherwise, we collect the maps with the same fixed value and
 * check whether each such collection is obviously injective
 * based on later dimensions.
 */
================================================================================

文件路径: ./isl_map_lexopt_templ.c
注释行数: 11
注释内容:
/*
 * Copyright 2010      INRIA Saclay
 * Copyright 2012      Ecole Normale Superieure
 *
 * Use of this software is governed by the MIT license
 *
 * Written by Sven Verdoolaege,
 * INRIA Saclay - Ile-de-France, Parc Club Orsay Universite,
 * ZAC des vignes, 4 rue Jacques Monod, 91893 Orsay, France
 * and Ecole Normale Superieure, 45 rue d’Ulm, 75230 Paris, France
 */
================================================================================

文件路径: ./isl_map_lexopt_templ.c
注释行数: 11
注释内容:
/* Compute the lexicographic minimum (or maximum if "flags" includes
 * ISL_OPT_MAX) of "bmap" over the domain "dom" and return the result.
 * If "empty" is not NULL, then *empty is assigned a set that
 * contains those parts of the domain where there is no solution.
 * If "flags" includes ISL_OPT_FULL, then "dom" is NULL and the optimum
 * should be computed over the domain of "bmap".  "empty" is also NULL
 * in this case.
 * If "bmap" is marked as rational (ISL_BASIC_MAP_RATIONAL),
 * then the rational optimum is computed.  Otherwise, the integral optimum
 * is computed.
 */
================================================================================

文件路径: ./isl_map_lexopt_templ.c
注释行数: 17
注释内容:
/* Given a basic map "bmap", compute the lexicographically minimal
 * (or maximal) image element for each domain element in dom.
 * If empty is not NULL, then set *empty to those elements in dom
 * that do not have an image element.
 * If "flags" includes ISL_OPT_FULL, then "dom" is NULL and the optimum
 * should be computed over the domain of "bmap".  "empty" is also NULL
 * in this case.
 *
 * We first make sure the basic sets in dom are disjoint and then
 * simply collect the results over each of the basic sets separately.
 * We could probably improve the efficiency a bit by moving the union
 * domain down into the parametric integer programming.
 *
 * If a full optimum is being computed (i.e., "flags" includes ISL_OPT_FULL),
 * then no domain is given and there is then also no need to consider
 * the disjuncts of the domain.
 */
================================================================================

文件路径: ./isl_aff.c
注释行数: 18
注释内容:
/*
 * Copyright 2011      INRIA Saclay
 * Copyright 2011      Sven Verdoolaege
 * Copyright 2012-2014 Ecole Normale Superieure
 * Copyright 2014      INRIA Rocquencourt
 * Copyright 2016      Sven Verdoolaege
 * Copyright 2018,2020 Cerebras Systems
 *
 * Use of this software is governed by the MIT license
 *
 * Written by Sven Verdoolaege, INRIA Saclay - Ile-de-France,
 * Parc Club Orsay Universite, ZAC des vignes, 4 rue Jacques Monod,
 * 91893 Orsay, France
 * and Ecole Normale Superieure, 45 rue d’Ulm, 75230 Paris, France
 * and Inria Paris - Rocquencourt, Domaine de Voluceau - Rocquencourt,
 * B.P. 105 - 78153 Le Chesnay, France
 * and Cerebras Systems, 175 S San Antonio Rd, Los Altos, CA, USA
 */
================================================================================

文件路径: ./isl_aff.c
注释行数: 19
注释内容:
/* Look for any divs j that appear with a unit coefficient inside
 * the definitions of other divs i and plug them into the definitions
 * of the divs i.
 *
 * In particular, an expression of the form
 *
 *	floor((f(..) + floor(g(..)/n))/m)
 *
 * is simplified to
 *
 *	floor((n * f(..) + g(..))/(n * m))
 *
 * This simplification is correct because we can move the expression
 * f(..) into the inner floor in the original expression to obtain
 *
 *	floor(floor((n * f(..) + g(..))/n)/m)
 *
 * from which we can derive the simplified expression.
 */
================================================================================

文件路径: ./isl_aff.c
注释行数: 11
注释内容:
/* Given f, return floor(f).
 * If f is an integer expression, then just return f.
 * If f is a constant, then return the constant floor(f).
 * Otherwise, if f = g/m, write g = q m + r,
 * create a new div d = [r/m] and return the expression q + d.
 * The coefficients in r are taken to lie between -m/2 and m/2.
 *
 * reduce_div_coefficients performs the same normalization.
 *
 * As a special case, floor(NaN) = NaN.
 */
================================================================================

文件路径: ./isl_aff.c
注释行数: 12
注释内容:
/* Given f, return ceil(f).
 * If f is an integer expression, then just return f.
 * Otherwise, let f be the expression
 *
 *	e/m
 *
 * then return
 *
 *	floor((e + m - 1)/m)
 *
 * As a special case, ceil(NaN) = NaN.
 */
================================================================================

文件路径: ./isl_aff.c
注释行数: 10
注释内容:
/* Return a map containing pairs of elements in the domains of "pa1" and "pa2"
 * where the function values are ordered in the same way as "order",
 * which returns a set in the shared domain of its two arguments.
 *
 * Let "pa1" and "pa2" be defined on domains A and B respectively.
 * We first pull back the two functions such that they are defined on
 * the domain [A -> B].  Then we apply "order", resulting in a set
 * in the space [A -> B].  Finally, we unwrap this set to obtain
 * a map in the space A -> B.
 */
================================================================================

文件路径: ./isl_aff.c
注释行数: 12
注释内容:
/* Return an affine expression that is equal to pwaff_true for elements
 * where "cond" is non-zero and to pwaff_false for elements where "cond"
 * is zero.
 * That is, return cond ? pwaff_true : pwaff_false;
 *
 * If "cond" involves and NaN, then we conservatively return a NaN
 * on its entire domain.  In principle, we could consider the pieces
 * where it is NaN separately from those where it is not.
 *
 * If "pwaff_true" and "pwaff_false" are obviously equal to each other,
 * then only use the domain of "cond" to restrict the domain.
 */
================================================================================

文件路径: ./isl_aff.c
注释行数: 12
注释内容:
/* Return the set of domain elements where "ma1" is lexicographically
 * greater than to "ma2".  If "equal" is set, then include the domain
 * elements where they are equal.
 *
 * In particular, for all but the final entry,
 * include the set of elements where this entry is strictly greater in "ma1"
 * and all previous entries are equal.
 * The final entry is also allowed to be equal in the two functions
 * if "equal" is set.
 *
 * The case where there are no entries is handled separately.
 */
================================================================================

文件路径: ./isl_aff.c
注释行数: 67
注释内容:
/* Extract an affine expression that expresses the output dimension "pos"
 * of "bmap" in terms of the parameters and input dimensions from
 * equality "eq".
 * Note that this expression may involve integer divisions defined
 * in terms of parameters and input dimensions.
 * The equality may also involve references to earlier (but not later)
 * output dimensions.  These are replaced by the corresponding elements
 * in "ma".
 *
 * If the equality is of the form
 *
 *	f(i) + h(j) + a x + g(i) = 0,
 *
 * with f(i) a linear combinations of the parameters and input dimensions,
 * g(i) a linear combination of integer divisions defined in terms of the same
 * and h(j) a linear combinations of earlier output dimensions,
 * then the affine expression is
 *
 *	(-f(i) - g(i))/a - h(j)/a
 *
 * If the equality is of the form
 *
 *	f(i) + h(j) - a x + g(i) = 0,
 *
 * then the affine expression is
 *
 *	(f(i) + g(i))/a - h(j)/(-a)
 *
 *
 * If "div" refers to an integer division (i.e., it is smaller than
 * the number of integer divisions), then the equality constraint
 * does involve an integer division (the one at position "div") that
 * is defined in terms of output dimensions.  However, this integer
 * division can be eliminated by exploiting a pair of constraints
 * x >= l and x <= l + n, with n smaller than the coefficient of "div"
 * in the equality constraint.  "ineq" refers to inequality x >= l, i.e.,
 * -l + x >= 0.
 * In particular, let
 *
 *	x = e(i) + m floor(...)
 *
 * with e(i) the expression derived above and floor(...) the integer
 * division involving output dimensions.
 * From
 *
 *	l <= x <= l + n,
 *
 * we have
 *
 *	0 <= x - l <= n
 *
 * This means
 *
 *	e(i) + m floor(...) - l = (e(i) + m floor(...) - l) mod m
 *	                        = (e(i) - l) mod m
 *
 * Therefore,
 *
 *	x - l = (e(i) - l) mod m
 *
 * or
 *
 *	x = ((e(i) - l) mod m) + l
 *
 * The variable "shift" below contains the expression -l, which may
 * also involve a linear combination of earlier output dimensions.
 */
================================================================================

文件路径: ./isl_aff.c
注释行数: 12
注释内容:
/* Given a basic map with output dimensions defined
 * in terms of the parameters input dimensions and earlier
 * output dimensions using an equality (and possibly a pair on inequalities),
 * extract an isl_aff that expresses output dimension "pos" in terms
 * of the parameters and input dimensions.
 * Note that this expression may involve integer divisions defined
 * in terms of parameters and input dimensions.
 * "ma" contains the expressions corresponding to earlier output dimensions.
 *
 * This function shares some similarities with
 * isl_basic_map_has_defining_equality and isl_constraint_get_bound.
 */
================================================================================

文件路径: ./isl_aff.c
注释行数: 18
注释内容:
/* Create an isl_pw_multi_aff that is equivalent to
 * isl_map_intersect_domain(isl_map_from_basic_map(bmap), domain).
 * The given basic map is such that each output dimension is defined
 * in terms of the parameters and input dimensions using an equality.
 *
 * Since some applications expect the result of isl_pw_multi_aff_from_map
 * to only contain integer affine expressions, we compute the floor
 * of the expression before returning.
 *
 * Remove all constraints involving local variables without
 * an explicit representation (resulting in the removal of those
 * local variables) prior to the actual extraction to ensure
 * that the local spaces in which the resulting affine expressions
 * are created do not contain any unknown local variables.
 * Removing such constraints is safe because constraints involving
 * unknown local variables are not used to determine whether
 * a basic map is obviously single-valued.
 */
================================================================================

文件路径: ./isl_aff.c
注释行数: 27
注释内容:
/* Try and create an isl_pw_multi_aff that is equivalent to the given isl_map,
 * taking into account that the output dimension at position "d"
 * can be represented as
 *
 *	x = floor((e(...) + c1) / m)
 *
 * given that constraint "i" is of the form
 *
 *	e(...) + c1 - m x >= 0
 *
 *
 * Let "map" be of the form
 *
 *	A -> B
 *
 * We construct a mapping
 *
 *	A -> [A -> x = floor(...)]
 *
 * apply that to the map, obtaining
 *
 *	[A -> x = floor(...)] -> B
 *
 * and equate dimension "d" to x.
 * We then compute a isl_pw_multi_aff representation of the resulting map
 * and plug in the mapping above.
 */
================================================================================

文件路径: ./isl_aff.c
注释行数: 13
注释内容:
/* Is constraint "c" of the form
 *
 *	e(...) + c1 - m x >= 0
 *
 * or
 *
 *	-e(...) + c2 + m x >= 0
 *
 * where m > 1 and e only depends on parameters and input dimemnsions?
 *
 * "offset" is the offset of the output dimensions
 * "pos" is the position of output dimension x.
 */
================================================================================

文件路径: ./isl_aff.c
注释行数: 33
注释内容:
/* Try and create an isl_pw_multi_aff that is equivalent to the given isl_map.
 *
 * As a special case, we first check if there is any pair of constraints,
 * shared by all the basic maps in "map" that force a given dimension
 * to be equal to the floor of some affine combination of the input dimensions.
 *
 * In particular, if we can find two constraints
 *
 *	e(...) + c1 - m x >= 0		i.e.,		m x <= e(...) + c1
 *
 * and
 *
 *	-e(...) + c2 + m x >= 0		i.e.,		m x >= e(...) - c2
 *
 * where m > 1 and e only depends on parameters and input dimemnsions,
 * and such that
 *
 *	c1 + c2 < m			i.e.,		-c2 >= c1 - (m - 1)
 *
 * then we know that we can take
 *
 *	x = floor((e(...) + c1) / m)
 *
 * without having to perform any computation.
 *
 * Note that we know that
 *
 *	c1 + c2 >= 1
 *
 * If c1 + c2 were 0, then we would have detected an equality during
 * simplification.  If c1 + c2 were negative, then we would have detected
 * a contradiction.
 */
================================================================================

文件路径: ./isl_aff.c
注释行数: 21
注释内容:
/* Given an affine expression
 *
 *	[A -> B] -> f(A,B)
 *
 * construct an isl_multi_aff
 *
 *	[A -> B] -> B'
 *
 * such that dimension "d" in B' is set to "aff" and the remaining
 * dimensions are set equal to the corresponding dimensions in B.
 * "n_in" is the dimension of the space A.
 * "n_out" is the dimension of the space B.
 *
 * If "is_set" is set, then the affine expression is of the form
 *
 *	[B] -> f(B)
 *
 * and we construct an isl_multi_aff
 *
 *	B -> B'
 */
================================================================================

文件路径: ./isl_aff.c
注释行数: 56
注释内容:
/* Try and create an isl_pw_multi_aff that is equivalent to the given isl_map,
 * taking into account that the dimension at position "d" can be written as
 *
 *	x = m a + f(..)						(1)
 *
 * where m is equal to "gcd".
 * "i" is the index of the equality in "hull" that defines f(..).
 * In particular, the equality is of the form
 *
 *	f(..) - x + m g(existentials) = 0
 *
 * or
 *
 *	-f(..) + x + m g(existentials) = 0
 *
 * We basically plug (1) into "map", resulting in a map with "a"
 * in the range instead of "x".  The corresponding isl_pw_multi_aff
 * defining "a" is then plugged back into (1) to obtain a definition for "x".
 *
 * Specifically, given the input map
 *
 *	A -> B
 *
 * We first wrap it into a set
 *
 *	[A -> B]
 *
 * and define (1) on top of the corresponding space, resulting in "aff".
 * We use this to create an isl_multi_aff that maps the output position "d"
 * from "a" to "x", leaving all other (intput and output) dimensions unchanged.
 * We plug this into the wrapped map, unwrap the result and compute the
 * corresponding isl_pw_multi_aff.
 * The result is an expression
 *
 *	A -> T(A)
 *
 * We adjust that to
 *
 *	A -> [A -> T(A)]
 *
 * so that we can plug that into "aff", after extending the latter to
 * a mapping
 *
 *	[A -> B] -> B'
 *
 *
 * If "map" is actually a set, then there is no "A" space, meaning
 * that we do not need to perform any wrapping, and that the result
 * of the recursive call is of the form
 *
 *	[T]
 *
 * which is plugged into a mapping of the form
 *
 *	B -> B'
 */
================================================================================

文件路径: ./isl_aff.c
注释行数: 15
注释内容:
/* Try and create an isl_pw_multi_aff that is equivalent to the given isl_map.
 * "hull" contains the equalities valid for "map".
 *
 * Check if any of the output dimensions is "strided".
 * That is, we check if it can be written as
 *
 *	x = m a + f(..)
 *
 * with m greater than 1, a some combination of existentially quantified
 * variables and f an expression in the parameters and input dimensions.
 * If so, we remove the stride in pw_multi_aff_from_map_stride.
 *
 * Otherwise, we continue with pw_multi_aff_from_map_check_div for a further
 * special case.
 */
================================================================================

文件路径: ./isl_aff.c
注释行数: 10
注释内容:
/* Try and create an isl_pw_multi_aff that is equivalent to the given isl_map.
 *
 * As a special case, we first check if all output dimensions are uniquely
 * defined in terms of the parameters and input dimensions over the entire
 * domain.  If so, we extract the desired isl_pw_multi_aff directly
 * from the affine hull of "map" and its domain.
 *
 * Otherwise, continue with pw_multi_aff_from_map_check_strides for more
 * special cases.
 */
================================================================================

文件路径: ./isl_aff.c
注释行数: 17
注释内容:
/* Plug in "subs" for dimension "type", "pos" of "aff".
 *
 * Let i be the dimension to replace and let "subs" be of the form
 *
 *	f/d
 *
 * and "aff" of the form
 *
 *	(a i + g)/m
 *
 * The result is
 *
 *	(a f + d g')/(m d)
 *
 * where g' is the result of plugging in "subs" in each of the integer
 * divisions in g.
 */
================================================================================

文件路径: ./isl_aff.c
注释行数: 18
注释内容:
/* Plug in "subs" for dimension "type", "pos" of "pma".
 *
 * pma is of the form
 *
 *	A_i(v) -> M_i(v)
 *
 * while subs is of the form
 *
 *	v' = B_j(v) -> S_j
 *
 * Each pair i,j such that C_ij = A_i \cap B_i is non-empty
 * has a contribution in the result, in particular
 *
 *	C_ij(S_j) -> M_i(S_j)
 *
 * Note that plugging in S_j in C_ij may also result in an empty set
 * and this contribution should simply be discarded.
 */
================================================================================

文件路径: ./isl_aff.c
注释行数: 36
注释内容:
/* Compute the preimage of a range of dimensions in the affine expression "src"
 * under "ma" and put the result in "dst".  The number of dimensions in "src"
 * that precede the range is given by "n_before".  The number of dimensions
 * in the range is given by the number of output dimensions of "ma".
 * The number of dimensions that follow the range is given by "n_after".
 * If "has_denom" is set (to one),
 * then "src" and "dst" have an extra initial denominator.
 * "n_div_ma" is the number of existentials in "ma"
 * "n_div_bset" is the number of existentials in "src"
 * The resulting "dst" (which is assumed to have been allocated by
 * the caller) contains coefficients for both sets of existentials,
 * first those in "ma" and then those in "src".
 * f, c1, c2 and g are temporary objects that have been initialized
 * by the caller.
 *
 * Let src represent the expression
 *
 *	(a(p) + f_u u + b v + f_w w + c(divs))/d
 *
 * and let ma represent the expressions
 *
 *	v_i = (r_i(p) + s_i(y) + t_i(divs'))/m_i
 *
 * We start out with the following expression for dst:
 *
 *	(a(p) + f_u u + 0 y + f_w w + 0 divs' + c(divs) + f \sum_i b_i v_i)/d
 *
 * with the multiplication factor f initially equal to 1
 * and f \sum_i b_i v_i kept separately.
 * For each x_i that we substitute, we multiply the numerator
 * (and denominator) of dst by c_1 = m_i and add the numerator
 * of the x_i expression multiplied by c_2 = f b_i,
 * after removing the common factors of c_1 and c_2.
 * The multiplication factor f also needs to be multiplied by c_1
 * for the next x_j, j > i.
 */
================================================================================

文件路径: ./isl_aff.c
注释行数: 19
注释内容:
/* Compute the pullback of "aff" by the function represented by "ma".
 * In other words, plug in "ma" in "aff".  The result is an affine expression
 * defined over the domain space of "ma".
 *
 * If "aff" is represented by
 *
 *	(a(p) + b x + c(divs))/d
 *
 * and ma is represented by
 *
 *	x = D(p) + F(y) + G(divs')
 *
 * then the result is
 *
 *	(a(p) + b D(p) + b F(y) + b G(divs') + c(divs))/d
 *
 * The divs in the local space of the input are similarly adjusted
 * through a call to isl_local_space_preimage_multi_aff.
 */
================================================================================

文件路径: ./isl_aff.c
注释行数: 10
注释内容:
/* Apply "aff" to "mpa".  The range of "mpa" needs to be compatible
 * with the domain of "aff".  The domain of the result is the same
 * as that of "mpa".
 * "mpa" and "aff" are assumed to have been aligned.
 *
 * We first extract the parametric constant from "aff", defined
 * over the correct domain.
 * Then we add the appropriate combinations of the members of "mpa".
 * Finally, we add the integer divisions through recursive calls.
 */
================================================================================

文件路径: ./isl_aff.c
注释行数: 15
注释内容:
/* Return a map containing pairs of elements in the domains of "mpa1" and "mpa2"
 * where the function values of "mpa1" lexicographically satisfies
 * "strict_base"/"base" compared to that of "mpa2".
 * "space" is the space of the result.
 * The parameters of "mpa1" and "mpa2" are assumed to have been aligned.
 *
 * "mpa1" lexicographically satisfies "strict_base"/"base" compared to "mpa2"
 * if, for some i, the i-th element of "mpa1" satisfies "strict_base"/"base"
 * when compared to the i-th element of "mpa2" while all previous elements are
 * pairwise equal.
 * In particular, if i corresponds to the final elements
 * then they need to satisfy "base", while "strict_base" needs to be satisfied
 * for other values of i.
 * If "base" is a strict order, then "base" and "strict_base" are the same.
 */
================================================================================

文件路径: ./isl_aff.c
注释行数: 10
注释内容:
/* Given a function "pma1" of the form A[B -> C] -> D and
 * a function "pma2" of the form E -> B,
 * replace the domain of the wrapped relation inside the domain of "pma1"
 * by the preimage with respect to "pma2".
 * In other words, plug in "pma2" in this nested domain.
 * The result is of the form A[E -> C] -> D.
 *
 * In particular, extend E -> B to A[E -> C] -> A[B -> C] and
 * plug that into "pma1".
 */
================================================================================

文件路径: ./isl_aff.c
注释行数: 10
注释内容:
/* Check that the domain space of "upa" matches "space".
 *
 * This function is called from isl_multi_union_pw_aff_set_union_pw_aff and
 * can in principle never fail since the space "space" is that
 * of the isl_multi_union_pw_aff and is a set space such that
 * there is no domain space to match.
 *
 * We check the parameters and double-check that "space" is
 * indeed that of a set.
 */
================================================================================

文件路径: ./isl_aff.c
注释行数: 10
注释内容:
/* Compute the pullback of "upa" by the function represented by "upma".
 * In other words, plug in "upma" in "upa".  The result contains
 * expressions defined over the domain space of "upma".
 *
 * Run over all pairs of elements in "upa" and "upma", perform
 * the pullback when appropriate and collect the results.
 * If the hash value were based on the domain space rather than
 * the function space, then we could run through all elements
 * of "upma" and directly pick out the corresponding element of "upa".
 */
================================================================================

文件路径: ./isl_aff.c
注释行数: 10
注释内容:
/* Construct and return a multi union piecewise affine expression
 * that is equal to the given union piecewise multi affine expression.
 *
 * In order to be able to perform the conversion, the input
 * needs to be non-empty and may only involve a single range space.
 *
 * If the resulting multi union piecewise affine expression has
 * an explicit domain, then assign it the domain of the input.
 * In other cases, the domain is stored in the individual elements.
 */
================================================================================

文件路径: ./isl_aff.c
注释行数: 11
注释内容:
/* Replace the range space of all the piecewise affine expressions in "upma" by
 * the range space of "space".
 *
 * This assumes that all these expressions have the same output dimension.
 *
 * Since the spaces of the expressions change, so do their hash values.
 * We therefore need to create a new isl_union_pw_multi_aff.
 * Note that the hash value is currently computed based on the entire
 * space even though there can only be a single expression with a given
 * domain space.
 */
================================================================================

文件路径: ./isl_aff.c
注释行数: 12
注释内容:
/* Apply "aff" to "mupa".  The space of "mupa" is equal to the domain of "aff".
 * In particular, the spaces have been aligned.
 * The result is defined over the shared domain of the elements of "mupa"
 *
 * We first extract the parametric constant part of "aff" and
 * define that over the shared domain.
 * Then we iterate over all input dimensions of "aff" and add the corresponding
 * multiples of the elements of "mupa".
 * Finally, we consider the integer divisions, calling the function
 * recursively to obtain an isl_union_pw_aff corresponding to the
 * integer division argument.
 */
================================================================================

文件路径: ./isl_printer_private.h
注释行数: 16
注释内容:
/* A printer to a file or a string.
 *
 * "dump" is set if the printing is performed from an isl_*_dump function.
 *
 * yaml_style is the YAML style in which the next elements should
 * be printed and may be either ISL_YAML_STYLE_BLOCK or ISL_YAML_STYLE_FLOW,
 * with ISL_YAML_STYLE_FLOW being the default.
 * yaml_state keeps track of the currently active YAML elements.
 * yaml_size is the size of this arrays, while yaml_depth
 * is the number of elements currently in use.
 * yaml_state may be NULL if no YAML printing is being performed.
 *
 * notes keeps track of arbitrary notes as a mapping between
 * name identifiers and note identifiers.  It may be NULL
 * if there are no notes yet.
 */
================================================================================

文件路径: ./isl_point.c
注释行数: 14
注释内容:
/*
 * Copyright 2010      INRIA Saclay
 * Copyright 2013      Ecole Normale Superieure
 * Copyright 2015      Sven Verdoolaege
 * Copyright 2019      Cerebras Systems
 *
 * Use of this software is governed by the MIT license
 *
 * Written by Sven Verdoolaege, INRIA Saclay - Ile-de-France,
 * Parc Club Orsay Universite, ZAC des vignes, 4 rue Jacques Monod,
 * 91893 Orsay, France
 * and Ecole Normale Superieure, 45 rue d'Ulm, 75230 Paris, France
 * and Cerebras Systems, 175 S San Antonio Rd, Los Altos, CA, USA
 */
================================================================================

文件路径: ./isl_box.c
注释行数: 11
注释内容:
/*
 * Copyright 2010-2011 INRIA Saclay
 * Copyright 2012-2013 Ecole Normale Superieure
 *
 * Use of this software is governed by the MIT license
 *
 * Written by Sven Verdoolaege, INRIA Saclay - Ile-de-France,
 * Parc Club Orsay Universite, ZAC des vignes, 4 rue Jacques Monod,
 * 91893 Orsay, France
 * and Ecole Normale Superieure, 45 rue d'Ulm, 75230 Paris, France
 */
================================================================================

文件路径: ./isl_box.c
注释行数: 12
注释内容:
/* Data used in set_dim_extent and compute_size_in_direction.
 *
 * "bset" is a wrapped copy of the basic map that has the selected
 * output dimension as range.
 * "pos" is the position of the variable representing the output dimension,
 * i.e., the variable for which the size should be computed.  This variable
 * is also the last variable in "bset".
 * "size" is the best size found so far
 * (infinity if no offset was found so far).
 * "offset" is the offset corresponding to the best size
 * (NULL if no offset was found so far).
 */
================================================================================

文件路径: ./isl_box.c
注释行数: 18
注释内容:
/* Look for a fixed-size range of values for the output dimension "pos"
 * of "map", by looking for a lower-bound expression in the parameters
 * and input dimensions such that the range of the output dimension
 * is a constant shifted by this expression.
 *
 * In particular, look through the explicit lower bounds on the output dimension
 * for candidate expressions and pick the one that results in the smallest size.
 * Initialize the size with infinity and if no better size is found
 * then invalidate the box.  Otherwise, set the offset and size
 * in the given direction by those that correspond to the smallest size.
 *
 * Note that while evaluating the size corresponding to a lower bound,
 * an affine expression is constructed from the lower bound.
 * This lower bound may therefore not have any unknown local variables.
 * Eliminate any unknown local variables up front.
 * No such restriction needs to be imposed on the set over which
 * the size is computed.
 */
================================================================================

文件路径: ./isl_schedule_tree.c
注释行数: 14
注释内容:
/*
 * Copyright 2013-2014 Ecole Normale Superieure
 * Copyright 2014      INRIA Rocquencourt
 * Copyright 2016      INRIA Paris
 *
 * Use of this software is governed by the MIT license
 *
 * Written by Sven Verdoolaege,
 * Ecole Normale Superieure, 45 rue d'Ulm, 75230 Paris, France
 * and Inria Paris - Rocquencourt, Domaine de Voluceau - Rocquencourt,
 * B.P. 105 - 78153 Le Chesnay, France
 * and Centre de Recherche Inria de Paris, 2 rue Simone Iff - Voie DQ12,
 * CS 42112, 75589 Paris Cedex 12, France
 */
================================================================================

文件路径: ./isl_schedule_tree.c
注释行数: 11
注释内容:
/* Should we skip the root of "tree" while looking for the first
 * descendant with schedule information?
 * That is, is it impossible to derive any information about
 * the iteration domain from this node?
 *
 * We do not want to skip leaf or error nodes because there is
 * no point in looking any deeper from these nodes.
 * We can only extract partial iteration domain information
 * from an extension node, but extension nodes are not supported
 * by the caller and it will error out on them.
 */
================================================================================

文件路径: ./isl_schedule_tree.c
注释行数: 20
注释内容:
/* Extend the schedule map "outer" with the subtree schedule
 * of a set or sequence node.
 *
 * The schedule for the set or sequence node itself is composed of
 * pieces of the form
 *
 *	filter -> []
 *
 * or
 *
 *	filter -> [index]
 *
 * The first form is used if there is only a single child or
 * if the current node is a set node and the schedule_separate_components
 * option is not set.
 *
 * Each of the pieces above is extended with the subtree schedule of
 * the child of the corresponding filter, if any, padded with zeros
 * to ensure that all pieces have the same range dimension.
 */
================================================================================

文件路径: ./isl_schedule_tree.c
注释行数: 10
注释内容:
/* Extend the schedule map "outer" with the subtree schedule of "tree".
 *
 * If the root of the tree is a set or a sequence, then we extend
 * the schedule map in subtree_schedule_extend_from_children.
 * Otherwise, we extend the schedule map with the partial schedule
 * corresponding to the root of the tree and then continue with
 * the single child of this root.
 * In the special case of an expansion, the schedule map is "extended"
 * by applying the expansion to the domain of the schedule map.
 */
================================================================================

文件路径: ./isl_schedule_tree.c
注释行数: 12
注释内容:
/* Return the subtree schedule of a node that contains some schedule
 * information, i.e., a node that would not be skipped by
 * isl_schedule_tree_first_schedule_descendant and that is not a leaf.
 *
 * If the tree contains any expansions, then the returned subtree
 * schedule is formulated in terms of the expanded domains.
 * The tree is not allowed to contain any extension nodes.
 *
 * We start with an initial zero-dimensional subtree schedule based
 * on the domain information in the root node and then extend it
 * based on the schedule information in the root node and its descendants.
 */
================================================================================

文件路径: ./isl_schedule_tree.c
注释行数: 12
注释内容:
/* Given an isolate AST generation option "isolate" for a band of size pos + n,
 * return the corresponding option for a band covering the first "pos"
 * members.
 *
 * The input isolate option is of the form
 *
 *	isolate[[flattened outer bands] -> [pos; n]]
 *
 * The output isolate option is of the form
 *
 *	isolate[[flattened outer bands] -> [pos]]
 */
================================================================================

文件路径: ./isl_schedule_tree.c
注释行数: 23
注释内容:
/* Given an isolate AST generation option "isolate" for a band of size pos + n,
 * return the corresponding option for a band covering the final "n"
 * members within a band covering the first "pos" members.
 *
 * The input isolate option is of the form
 *
 *	isolate[[flattened outer bands] -> [pos; n]]
 *
 * The output isolate option is of the form
 *
 *	isolate[[flattened outer bands; pos] -> [n]]
 *
 *
 * The range is first split into
 *
 *	isolate[[flattened outer bands] -> [[pos] -> [n]]]
 *
 * and then the first pos members are moved to the domain
 *
 *	isolate[[[flattened outer bands] -> [pos]] -> [n]]
 *
 * after which the domain is flattened to obtain the desired output.
 */
================================================================================

文件路径: ./isl_schedule_tree.c
注释行数: 11
注释内容:
/* Print "tree" to "p".
 *
 * If "n_ancestor" is non-negative, then "child_pos" contains the child
 * positions of a descendant of the current node that should be marked
 * (by the comment "YOU ARE HERE").  In particular, if "n_ancestor"
 * is zero, then the current node should be marked.
 * The marking is only printed in YAML block format.
 *
 * Implicit leaf nodes are not printed, except if they correspond
 * to the node that should be marked.
 */
================================================================================

文件路径: ./isl_printer.c
注释行数: 19
注释内容:
/* If we are printing a YAML document and we are at the start of an element,
 * print whatever is needed before we can print the actual element and
 * keep track of the fact that we are now printing the element.
 * If "eol" is set, then whatever we print is going to be the last
 * thing that gets printed on this line.
 *
 * If we are about the print the first key of a mapping, then nothing
 * extra needs to be printed.  For any other key, however, we need
 * to either move to the next line (in block format) or print a comma
 * (in flow format).
 * Before printing a value in a mapping, we need to print a colon.
 *
 * For sequences, in flow format, we only need to print a comma
 * for each element except the first.
 * In block format, before the first element in the sequence,
 * we move to a new line, print a dash and increase the indentation.
 * Before any other element, we print a dash on a new line,
 * temporarily moving the indentation back.
 */
================================================================================

文件路径: ./isl_printer.c
注释行数: 11
注释内容:
/* Finish a YAML mapping and pop it from the state stack.
 *
 * In flow style, print the closing brace.
 *
 * In block style, first check if we are still in the
 * isl_yaml_mapping_first_key_start state.  If so, we have not printed
 * anything yet, so print "{}" to indicate an empty mapping.
 * If we increased the indentation in isl_printer_yaml_start_mapping,
 * then decrease it again.
 * If this is the outer mapping then print a newline.
 */
================================================================================

文件路径: ./isl_printer.c
注释行数: 14
注释内容:
/* Finish a YAML sequence and pop it from the state stack.
 *
 * In flow style, print the closing bracket.
 *
 * In block style, check if we are still in the
 * isl_yaml_sequence_first_start state.  If so, we have not printed
 * anything yet, so print "[]" or " []" to indicate an empty sequence.
 * We print the extra space when we instructed enter_state not
 * to print a space at the end of the line.
 * Otherwise, undo the increase in indentation performed by
 * enter_state when moving away from the isl_yaml_sequence_first_start
 * state.
 * If this is the outer sequence then print a newline.
 */
================================================================================

文件路径: ./isl_val_imath.c
注释行数: 11
注释内容:
/* Store a representation of the absolute value of the numerator of "v"
 * in terms of chunks of size "size" at "chunks".
 * The least significant chunk is stored first.
 * The number of chunks in the result can be obtained by calling
 * isl_val_n_abs_num_chunks.  The user is responsible for allocating
 * enough memory to store the results.
 *
 * In the special case of a zero value, isl_val_n_abs_num_chunks will
 * return one, while impz_export will not fill in any chunks.  We therefore
 * do it ourselves.
 */
================================================================================

文件路径: ./isl_aff_map.c
注释行数: 12
注释内容:
/*
 * Copyright 2011      INRIA Saclay
 * Copyright 2012-2013 Ecole Normale Superieure
 * Copyright 2016      Sven Verdoolaege
 *
 * Use of this software is governed by the MIT license
 *
 * Written by Sven Verdoolaege, INRIA Saclay - Ile-de-France,
 * Parc Club Orsay Universite, ZAC des vignes, 4 rue Jacques Monod,
 * 91893 Orsay, France
 * and Ecole Normale Superieure, 45 rue d'Ulm, 75230 Paris, France
 */
================================================================================

文件路径: ./isl_reordering.c
注释行数: 11
注释内容:
/* Return a reordering that moves the parameters identified by
 * the elements of "tuple" to a domain tuple inserted into "space".
 * The parameters that remain, are moved from their original positions
 * in the list of parameters to their new positions in this list.
 * The parameters that get removed, are moved to the corresponding
 * positions in the new domain.  Note that these set dimensions
 * do not necessarily need to appear as parameters in "space".
 * Any other dimensions are shifted by the number of extra dimensions
 * introduced, i.e., the number of dimensions in the new domain
 * that did not appear as parameters in "space".
 */
================================================================================

文件路径: ./isl_schedule_band.c
注释行数: 11
注释内容:
/*
 * Copyright 2013-2014 Ecole Normale Superieure
 * Copyright 2014      INRIA Rocquencourt
 *
 * Use of this software is governed by the MIT license
 *
 * Written by Sven Verdoolaege,
 * Ecole Normale Superieure, 45 rue d'Ulm, 75230 Paris, France
 * and Inria Paris - Rocquencourt, Domaine de Voluceau - Rocquencourt,
 * B.P. 105 - 78153 Le Chesnay, France
 */
================================================================================

文件路径: ./isl_schedule_band.c
注释行数: 11
注释内容:
/* Given a parameter space "space", extend it to a set space
 *
 *	{ type[x] }
 *
 * or
 *
 *	{ [isolate[] -> type[x]] }
 *
 * depending on whether "isolate" is set.
 * These can be used to encode loop AST generation options of the given type.
 */
================================================================================

文件路径: ./isl_schedule_band.c
注释行数: 12
注释内容:
/* Add encodings of the "n" loop AST generation options "type" to "options".
 * If "isolate" is set, then these options refer to the isolated part.
 *
 * In particular, for each sequence of consecutive identical types "t",
 * different from the default, add an option
 *
 *	{ t[x] : first <= x <= last }
 *
 * or
 *
 *	{ [isolate[] -> t[x]] : first <= x <= last }
 */
================================================================================

文件路径: ./isl_schedule_band.c
注释行数: 10
注释内容:
/* Construct universe sets of the spaces that encode loop AST generation
 * types (for the isolated part if "isolate" is set).  That is, construct
 *
 *	{ atomic[x]; separate[x]; unroll[x] }
 *
 * or
 *
 *	{ [isolate[] -> atomic[x]]; [isolate[] -> separate[x]];
 *	  [isolate[] -> unroll[x]] }
 */
================================================================================

文件路径: ./isl_schedule_band.c
注释行数: 11
注释内容:
/* Replace the AST build options associated to "band" by "options".
 * If there are any loop AST generation type options, then they
 * are extracted and stored in band->loop_type.  Otherwise,
 * band->loop_type is removed to indicate that the default applies
 * to all members.  Similarly for the loop AST generation type options
 * for the isolated part, which are stored in band->isolate_loop_type.
 * The remaining options are stored in band->ast_build_options.
 *
 * Set anchored if the options include an isolate option since the
 * domain of the wrapped map references the outer band node schedules.
 */
================================================================================

文件路径: ./isl_schedule_band.c
注释行数: 10
注释内容:
/* Given the schedule of a band, construct the corresponding
 * schedule for the tile loops based on the given tile sizes
 * and return the result.
 *
 * If the scale tile loops options is set, then the tile loops
 * are scaled by the tile sizes.
 *
 * That is replace each schedule dimension "i" by either
 * "floor(i/s)" or "s * floor(i/s)".
 */
================================================================================

文件路径: ./isl_schedule_band.c
注释行数: 12
注释内容:
/* Replace "band" by a band corresponding to the point loops of a tiling
 * with the given tile sizes.
 * "tile" is the corresponding tile loop band.
 *
 * If the shift point loops option is set, then the point loops
 * are shifted to start at zero.  That is, each schedule dimension "i"
 * is replaced by "i - s * floor(i/s)".
 * The expression "floor(i/s)" (or "s * floor(i/s)") is extracted from
 * the tile band.
 *
 * Otherwise, the band is left untouched.
 */
================================================================================

文件路径: ./isl_multi_union_add_templ.c
注释行数: 16
注释内容:
/* Compute the sum of "multi1" and "multi2" on the union of their domains,
 * with the actual sum on the shared domain and
 * the defined expression on the symmetric difference of the domains.
 *
 * We simply iterate over the elements in both arguments and
 * call isl_union_pw_aff_union_add on each of them, if there is
 * at least one element.
 *
 * Otherwise, the two expressions have an explicit domain and
 * the union of these explicit domains is computed.
 * This assumes that the explicit domains are either both in terms
 * of specific domains elements or both in terms of parameters.
 * However, if one of the expressions does not have any constraints
 * on its explicit domain, then this is allowed as well and the result
 * is the expression with no constraints on its explicit domain.
 */
================================================================================

文件路径: ./isl_multi_templ.c
注释行数: 10
注释内容:
/* Reset the space of "multi".  This function is called from isl_pw_templ.c
 * and doesn't know if the space of an element object is represented
 * directly or through its domain.  It therefore passes along both,
 * which we pass along to the element function since we don't know how
 * that is represented either.
 *
 * If "multi" has an explicit domain, then the caller is expected
 * to make sure that any modification that would change the dimensions
 * of the explicit domain has bee applied before this function is called.
 */
================================================================================

文件路径: ./isl_multi_templ.c
注释行数: 12
注释内容:
/* Given two multi expressions, "multi1"
 *
 *	[A] -> [B1 B2]
 *
 * where B2 starts at position "pos", and "multi2"
 *
 *	[A] -> [D]
 *
 * return the multi expression
 *
 *	[A] -> [B1 D B2]
 */
================================================================================

文件路径: ./isl_vertices.c
注释行数: 15
注释内容:
/* Check whether we can select constraint "level", given the current selection
 * reflected by facets in "tab", the rows of "facets" and the earlier
 * "selected" elements of "selection".
 *
 * If the constraint is (strictly) redundant in the tableau, selecting it would
 * result in an empty tableau, so it can't be selected.
 * If the set variable part of the constraint is not linearly independent
 * of the set variable parts of the already selected constraints,
 * the constraint cannot be selected.
 * If selecting the constraint results in an empty tableau, the constraint
 * cannot be selected.
 * Finally, if selecting the constraint results in some explicitly
 * deselected constraints turning into equalities, then the corresponding
 * vertices have already been generated, so the constraint cannot be selected.
 */
================================================================================

文件路径: ./isl_vertices.c
注释行数: 42
注释内容:
/* Compute the parametric vertices and the chamber decomposition
 * of the parametric polytope defined using the same constraints
 * as "bset".  "bset" is assumed to have no existentially quantified
 * variables.
 *
 * The vertices themselves are computed in a fairly simplistic way.
 * We simply run through all combinations of d constraints,
 * with d the number of set variables, and check if those d constraints
 * define a vertex.  To avoid the generation of duplicate vertices,
 * which we may happen if a vertex is defined by more that d constraints,
 * we make sure we only generate the vertex for the d constraints with
 * smallest index.
 *
 * Only potential vertices with a full-dimensional activity domain
 * are considered.  However, if the input has (implicit) equality
 * constraints among the parameters, then activity domain
 * should be considered full-dimensional if it does not satisfy
 * any extra equality constraints beyond those of the input.
 * The implicit equality constraints of the input are therefore first detected.
 * If there are any, then the input is mapped to a lower dimensional space
 * such that the check for full-dimensional activity domains
 * can be performed with respect to a full-dimensional space.
 * Note that it is important to leave "bset" unmodified while detecting
 * equality constraints since the inequality constraints of "bset"
 * are assumed to correspond to those of the tableau.
 *
 * We set up a tableau and keep track of which facets have been
 * selected.  The tableau is marked strict_redundant so that we can be
 * sure that any constraint that is marked redundant (and that is not
 * also marked zero) is not an equality.
 * If a constraint is marked DESELECTED, it means the constraint was
 * SELECTED before (in combination with the same selection of earlier
 * constraints).  If such a deselected constraint turns out to be an
 * equality, then any vertex that may still be found with the current
 * selection has already been generated when the constraint was selected.
 * A constraint is marked UNSELECTED when there is no way selecting
 * the constraint could lead to a vertex (in combination with the current
 * selection of earlier constraints).
 *
 * The set variable coefficients of the selected constraints are stored
 * in the facets matrix.
 */
================================================================================

文件路径: ./isl_vertices.c
注释行数: 22
注释内容:
/* Compute the chamber decomposition of the parametric polytope respresented
 * by "bset" given the parametric vertices and their activity domains.
 *
 * We are only interested in full-dimensional chambers.
 * Each of these chambers is the intersection of the activity domains of
 * one or more vertices and the union of all chambers is equal to the
 * projection of the entire parametric polytope onto the parameter space.
 *
 * We first create an initial chamber by intersecting as many activity
 * domains as possible without ending up with an empty or lower-dimensional
 * set.  As a minor optimization, we only consider those activity domains
 * that contain some arbitrary point.
 *
 * For each of the interior facets of the chamber, we construct a todo item,
 * containing the facet and a constraint containing the other side of the facet,
 * for constructing the chamber on the other side.
 * While their are any todo items left, we pick a todo item and
 * create the required chamber by intersecting all activity domains
 * that contain the facet and have a full-dimensional intersection with
 * the other side of the facet.  For each of the interior facets, we
 * again create todo items, taking care to cancel opposite todo items.
 */
================================================================================

文件路径: ./isl_vertices.c
注释行数: 12
注释内容:
/* Check whether the parametric vertex described by "vertex"
 * lies on the facet corresponding to constraint "facet" of "bset".
 * The isl_vec "v" is a temporary vector than can be used by this function.
 *
 * We eliminate the variables from the facet constraint using the
 * equalities defining the vertex and check if the result is identical
 * to zero.
 *
 * It would probably be better to keep track of the constraints defining
 * a vertex during the vertex construction so that we could simply look
 * it up here.
 */
================================================================================

文件路径: ./isl_vertices.c
注释行数: 10
注释内容:
/* Triangulate the polytope spanned by the vertices with ids
 * in "simplex_ids" and "other_ids" and call "fn" on each of
 * the resulting simplices.
 * If the input polytope is already a simplex, we simply call "fn".
 * Otherwise, we pick a point from "other_ids" and add it to "simplex_ids".
 * Then we consider each facet of "bset" that does not contain the point
 * we just picked, but does contain some of the other points in "other_ids"
 * and call ourselves recursively on the polytope spanned by the new
 * "simplex_ids" and those points in "other_ids" that lie on the facet.
 */
================================================================================

文件路径: ./isl_tab_lexopt_templ.c
注释行数: 12
注释内容:
/*
 * Copyright 2008-2009 Katholieke Universiteit Leuven
 * Copyright 2010      INRIA Saclay
 * Copyright 2011      Sven Verdoolaege
 *
 * Use of this software is governed by the MIT license
 *
 * Written by Sven Verdoolaege, K.U.Leuven, Departement
 * Computerwetenschappen, Celestijnenlaan 200A, B-3001 Leuven, Belgium
 * and INRIA Saclay - Ile-de-France, Parc Club Orsay Universite,
 * ZAC des vignes, 4 rue Jacques Monod, 91893 Orsay, France
 */
================================================================================

文件路径: ./isl_tab_lexopt_templ.c
注释行数: 32
注释内容:
/* Given a basic map with at least two parallel constraints (as found
 * by the function parallel_constraints), first look for more constraints
 * parallel to the two constraint and replace the found list of parallel
 * constraints by a single constraint with as "input" part the minimum
 * of the input parts of the list of constraints.  Then, recursively call
 * basic_map_partial_lexopt (possibly finding more parallel constraints)
 * and plug in the definition of the minimum in the result.
 *
 * As in parallel_constraints, only inequality constraints that only
 * involve input variables that do not occur in any other inequality
 * constraints are considered.
 *
 * More specifically, given a set of constraints
 *
 *	a x + b_i(p) >= 0
 *
 * Replace this set by a single constraint
 *
 *	a x + u >= 0
 *
 * with u a new parameter with constraints
 *
 *	u <= b_i(p)
 *
 * Any solution to the new system is also a solution for the original system
 * since
 *
 *	a x >= -u >= -b_i(p)
 *
 * Moreover, m = min_i(b_i(p)) satisfies the constraints on u and can
 * therefore be plugged into the solution.
 */
================================================================================

文件路径: ./isl_tab_lexopt_templ.c
注释行数: 24
注释内容:
/* Compute the lexicographic minimum (or maximum if "flags" includes
 * ISL_OPT_MAX) of "bmap" over the domain "dom" and return the result as
 * either a map or a piecewise multi-affine expression depending on TYPE.
 * If "empty" is not NULL, then *empty is assigned a set that
 * contains those parts of the domain where there is no solution.
 * If "flags" includes ISL_OPT_FULL, then "dom" is NULL and the optimum
 * should be computed over the domain of "bmap".  "empty" is also NULL
 * in this case.
 * If "bmap" is marked as rational (ISL_BASIC_MAP_RATIONAL),
 * then we compute the rational optimum.  Otherwise, we compute
 * the integral optimum.
 *
 * We perform some preprocessing.  As the PILP solver does not
 * handle implicit equalities very well, we first make sure all
 * the equalities are explicitly available.
 *
 * We also add context constraints to the basic map and remove
 * redundant constraints.  This is only needed because of the
 * way we handle simple symmetries.  In particular, we currently look
 * for symmetries on the constraints, before we set up the main tableau.
 * It is then no good to look for symmetries on possibly redundant constraints.
 * If the domain was extracted from the basic map, then there is
 * no need to add back those constraints again.
 */
================================================================================

文件路径: ./isl_map_simplify.c
注释行数: 14
注释内容:
/*
 * Copyright 2008-2009 Katholieke Universiteit Leuven
 * Copyright 2012-2013 Ecole Normale Superieure
 * Copyright 2014-2015 INRIA Rocquencourt
 * Copyright 2016      Sven Verdoolaege
 *
 * Use of this software is governed by the MIT license
 *
 * Written by Sven Verdoolaege, K.U.Leuven, Departement
 * Computerwetenschappen, Celestijnenlaan 200A, B-3001 Leuven, Belgium
 * and Ecole Normale Superieure, 45 rue d’Ulm, 75230 Paris, France
 * and Inria Paris - Rocquencourt, Domaine de Voluceau - Rocquencourt,
 * B.P. 105 - 78153 Le Chesnay, France
 */
================================================================================

文件路径: ./isl_map_simplify.c
注释行数: 20
注释内容:
/* Reduce the coefficient of the variable at position "pos"
 * in integer division "div", such that it lies in the half-open
 * interval (1/2,1/2], extracting any excess value from this integer division.
 * "pos" is as determined by isl_basic_map_offset, i.e., pos == 0
 * corresponds to the constant term.
 *
 * That is, the integer division is of the form
 *
 *	floor((... + (c * d + r) * x_pos + ...)/d)
 *
 * with -d < 2 * r <= d.
 * Replace it by
 *
 *	floor((... + r * x_pos + ...)/d) + c * x_pos
 *
 * If 2 * ((c * d + r) % d) <= d, then c = floor((c * d + r)/d).
 * Otherwise, c = floor((c * d + r)/d) + 1.
 *
 * This is the same normalization that is performed by isl_aff_floor.
 */
================================================================================

文件路径: ./isl_map_simplify.c
注释行数: 13
注释内容:
/* Remove any common factor in numerator and denominator of the div expression,
 * not taking into account the constant term.
 * That is, if the div is of the form
 *
 *	floor((a + m f(x))/(m d))
 *
 * then replace it by
 *
 *	floor((floor(a/m) + f(x))/d)
 *
 * The difference {a/m}/d in the argument satisfies 0 <= {a/m}/d < 1/d
 * and can therefore not influence the result of the floor.
 */
================================================================================

文件路径: ./isl_map_simplify.c
注释行数: 13
注释内容:
/* Remove any common factor in numerator and denominator of a div expression,
 * not taking into account the constant term.
 * That is, look for any div of the form
 *
 *	floor((a + m f(x))/(m d))
 *
 * and replace it by
 *
 *	floor((floor(a/m) + f(x))/d)
 *
 * The difference {a/m}/d in the argument satisfies 0 <= {a/m}/d < 1/d
 * and can therefore not influence the result of the floor.
 */
================================================================================

文件路径: ./isl_map_simplify.c
注释行数: 23
注释内容:
/* The last local variable involved in the equality constraint
 * at position "eq" in "bmap" is the local variable at position "div".
 * It can therefore be used to extract an explicit representation
 * for that variable.
 * Do so unless the local variable already has an explicit representation or
 * the explicit representation would involve any other local variables
 * that in turn do not have an explicit representation.
 * An equality constraint involving local variables without an explicit
 * representation can be used in isl_basic_map_drop_redundant_divs
 * to separate out an independent local variable.  Introducing
 * an explicit representation here would block this transformation,
 * while the partial explicit representation in itself is not very useful.
 * Set *progress if anything is changed.
 *
 * The equality constraint is of the form
 *
 *	f(x) + n e >= 0
 *
 * with n a positive number.  The explicit representation derived from
 * this constraint is
 *
 *	floor((-f(x))/n)
 */
================================================================================

文件路径: ./isl_map_simplify.c
注释行数: 19
注释内容:
/* Perform fangcheng (Gaussian elimination) on the equality
 * constraints of "bmap".
 * That is, put them into row-echelon form, starting from the last column
 * backward and use them to eliminate the corresponding coefficients
 * from all constraints.
 *
 * If "progress" is not NULL, then it gets set if the elimination
 * results in any changes.
 * The elimination process may result in some equality constraints
 * getting interchanged or removed.
 * If "swap" or "drop" are not NULL, then they get called when
 * two equality constraints get interchanged or
 * when a number of final equality constraints get removed.
 * As a special case, if the input turns out to be empty,
 * then drop gets called with the number of removed equality
 * constraints set to the total number of equality constraints.
 * If "swap" or "drop" are not NULL, then the local variables (if any)
 * are assumed to be in a valid order.
 */
================================================================================

文件路径: ./isl_map_simplify.c
注释行数: 13
注释内容:
/* Is the inequality ineq (obviously) redundant with respect
 * to the constraints in "ci"?
 *
 * Look for an inequality in "ci" with the same coefficients and then
 * check if the contant term of "ineq" is greater than or equal
 * to the constant term of that inequality.  If so, "ineq" is clearly
 * redundant.
 *
 * Note that hash_index_ineq ignores a stored constraint if it has
 * the same address as the passed inequality.  It is ok to pass
 * the address of a local variable here since it will never be
 * the same as the address of a constraint in "ci".
 */
================================================================================

文件路径: ./isl_map_simplify.c
注释行数: 48
注释内容:
/* Normalize divs that appear in equalities.
 *
 * In particular, we assume that bmap contains some equalities
 * of the form
 *
 *	a x = m * e_i
 *
 * and we want to replace the set of e_i by a minimal set and
 * such that the new e_i have a canonical representation in terms
 * of the vector x.
 * If any of the equalities involves more than one divs, then
 * we currently simply bail out.
 *
 * Let us first additionally assume that all equalities involve
 * a div.  The equalities then express modulo constraints on the
 * remaining variables and we can use "parameter compression"
 * to find a minimal set of constraints.  The result is a transformation
 *
 *	x = T(x') = x_0 + G x'
 *
 * with G a lower-triangular matrix with all elements below the diagonal
 * non-negative and smaller than the diagonal element on the same row.
 * We first normalize x_0 by making the same property hold in the affine
 * T matrix.
 * The rows i of G with a 1 on the diagonal do not impose any modulo
 * constraint and simply express x_i = x'_i.
 * For each of the remaining rows i, we introduce a div and a corresponding
 * equality.  In particular
 *
 *	g_ii e_j = x_i - g_i(x')
 *
 * where each x'_k is replaced either by x_k (if g_kk = 1) or the
 * corresponding div (if g_kk != 1).
 *
 * If there are any equalities not involving any div, then we
 * first apply a variable compression on the variables x:
 *
 *	x = C x''	x'' = C_2 x
 *
 * and perform the above parameter compression on A C instead of on A.
 * The resulting compression is then of the form
 *
 *	x'' = T(x') = x_0 + G x'
 *
 * and in constructing the new divs and the corresponding equalities,
 * we have to replace each x'', i.e., the x'_k with (g_kk = 1),
 * by the corresponding row from C_2.
 */
================================================================================

文件路径: ./isl_map_simplify.c
注释行数: 12
注释内容:
/* Given two constraints "k" and "l" that are opposite to each other,
 * except for the constant term, check if we can use them
 * to obtain an expression for one of the hitherto unknown divs or
 * a "better" expression for a div for which we already have an expression.
 * "sum" is the sum of the constant terms of the constraints.
 * If this sum is strictly smaller than the coefficient of one
 * of the divs, then this pair can be used define the div.
 * To avoid the introduction of circular definitions of divs, we
 * do not use the pair if the resulting expression would refer to
 * any other undefined divs or if any known div is defined in
 * terms of the unknown div.
 */
================================================================================

文件路径: ./isl_map_simplify.c
注释行数: 35
注释内容:
/* Given a known integer division "div" that is not integral
 * (with denominator 1), eliminate it from the constraints in "bmap"
 * where it appears with a (positive or negative) unit coefficient.
 * If "progress" is not NULL, then it gets set if the elimination
 * results in any changes.
 *
 * That is, replace
 *
 *	floor(e/m) + f >= 0
 *
 * by
 *
 *	e + m f >= 0
 *
 * and
 *
 *	-floor(e/m) + f >= 0
 *
 * by
 *
 *	-e + m f + m - 1 >= 0
 *
 * The first conversion is valid because floor(e/m) >= -f is equivalent
 * to e/m >= -f because -f is an integral expression.
 * The second conversion follows from the fact that
 *
 *	-floor(e/m) = ceil(-e/m) = floor((-e + m - 1)/m)
 *
 *
 * Note that one of the div constraints may have been eliminated
 * due to being redundant with respect to the constraint that is
 * being modified by this function.  The modified constraint may
 * no longer imply this div constraint, so we add it back to make
 * sure we do not lose any information.
 */
================================================================================

文件路径: ./isl_map_simplify.c
注释行数: 12
注释内容:
/* Eliminate selected known divs from constraints where they appear with
 * a (positive or negative) unit coefficient.
 * In particular, only handle those for which "select" returns isl_bool_true.
 * If "progress" is not NULL, then it gets set if the elimination
 * results in any changes.
 *
 * We skip integral divs, i.e., those with denominator 1, as we would
 * risk eliminating the div from the div constraints.  We do not need
 * to handle those divs here anyway since the div constraints will turn
 * out to form an equality and this equality can then be used to eliminate
 * the div from all constraints.
 */
================================================================================

文件路径: ./isl_map_simplify.c
注释行数: 11
注释内容:
/* Remove all constraints from "bmap" that reference any unknown local
 * variables (directly or indirectly).
 *
 * Dropping all constraints on a local variable will make it redundant,
 * so it will get removed implicitly by
 * isl_basic_map_drop_constraints_involving_dims.  Some other local
 * variables may also end up becoming redundant if they only appear
 * in constraints together with the unknown local variable.
 * Therefore, start over after calling
 * isl_basic_map_drop_constraints_involving_dims.
 */
================================================================================

文件路径: ./isl_map_simplify.c
注释行数: 12
注释内容:
/* Update the groups in "group" based on the (linear part of a) constraint "c".
 *
 * In particular, for any variable involved in the constraint,
 * find the actual group id from before and replace the group
 * of the corresponding variable by the minimal group of all
 * the variables involved in the constraint considered so far
 * (if this minimum is smaller) or replace the minimum by this group
 * (if the minimum is larger).
 *
 * At the end, all the variables in "c" will (indirectly) point
 * to the minimal of the groups that they referred to originally.
 */
================================================================================

文件路径: ./isl_map_simplify.c
注释行数: 20
注释内容:
/* Drop constraints from "bmap" that only involve variables that are
 * not related to any of the variables marked with a "-1" in "group".
 *
 * We construct groups of variables that collect variables that
 * (indirectly) appear in some common constraint of "bmap".
 * Each group is identified by the first variable in the group,
 * except for the special group of variables that was already identified
 * in the input as -1 (or are related to those variables).
 * If group[i] is equal to i (or -1), then the group of i is i (or -1),
 * otherwise the group of i is the group of group[i].
 *
 * We first initialize groups for the remaining variables.
 * Then we iterate over the constraints of "bmap" and update the
 * group of the variables in the constraint by the smallest group.
 * Finally, we resolve indirect references to groups by running over
 * the variables.
 *
 * After computing the groups, we drop constraints that do not involve
 * any variables in the -1 group.
 */
================================================================================

文件路径: ./isl_map_simplify.c
注释行数: 10
注释内容:
/* Drop constraints from "context" that are irrelevant for computing
 * the gist of "bset".
 *
 * In particular, drop constraints in variables that are not related
 * to any of the variables involved in the constraints of "bset"
 * in the sense that there is no sequence of constraints that connects them.
 *
 * We first mark all variables that appear in "bset" as belonging
 * to a "-1" group and then continue with group_and_drop_irrelevant_constraints.
 */
================================================================================

文件路径: ./isl_map_simplify.c
注释行数: 12
注释内容:
/* Drop constraints from "context" that are irrelevant for computing
 * the gist of the inequalities "ineq".
 * Inequalities in "ineq" for which the corresponding element of row
 * is set to -1 have already been marked for removal and should be ignored.
 *
 * In particular, drop constraints in variables that are not related
 * to any of the variables involved in "ineq"
 * in the sense that there is no sequence of constraints that connects them.
 *
 * We first mark all variables that appear in "bset" as belonging
 * to a "-1" group and then continue with group_and_drop_irrelevant_constraints.
 */
================================================================================

文件路径: ./isl_map_simplify.c
注释行数: 13
注释内容:
/* Update the inequalities in "bset" based on the information in "row"
 * and "tab".
 *
 * In particular, the array "row" contains either -1, meaning that
 * the corresponding inequality of "bset" is redundant, or the index
 * of an inequality in "tab".
 *
 * If the row entry is -1, then drop the inequality.
 * Otherwise, if the constraint is marked redundant in the tableau,
 * then drop the inequality.  Similarly, if it is marked as an equality
 * in the tableau, then turn the inequality into an equality and
 * perform Gaussian elimination.
 */
================================================================================

文件路径: ./isl_map_simplify.c
注释行数: 32
注释内容:
/* Remove all information from bset that is redundant in the context
 * of context.
 * "ineq" contains the (possibly transformed) inequalities of "bset",
 * in the same order.
 * The (explicit) equalities of "bset" are assumed to have been taken
 * into account by the transformation such that only the inequalities
 * are relevant.
 * "context" is assumed not to be empty.
 *
 * "row" keeps track of the constraint index of a "bset" inequality in "tab".
 * A value of -1 means that the inequality is obviously redundant and may
 * not even appear in  "tab".
 *
 * We first mark the inequalities of "bset"
 * that are obviously redundant with respect to some inequality in "context".
 * Then we remove those constraints from "context" that have become
 * irrelevant for computing the gist of "bset".
 * Note that this removal of constraints cannot be replaced by
 * a factorization because factors in "bset" may still be connected
 * to each other through constraints in "context".
 *
 * If there are any inequalities left, we construct a tableau for
 * the context and then add the inequalities of "bset".
 * Before adding these inequalities, we freeze all constraints such that
 * they won't be considered redundant in terms of the constraints of "bset".
 * Then we detect all redundant constraints (among the
 * constraints that weren't frozen), first by checking for redundancy in the
 * the tableau and then by checking if replacing a constraint by its negation
 * would lead to an empty set.  This last step is fairly expensive
 * and could be optimized by more reuse of the tableau.
 * Finally, we update bset according to the results.
 */
================================================================================

文件路径: ./isl_map_simplify.c
注释行数: 30
注释内容:
/* Remove all information from "bset" that is redundant in the context
 * of "context", for the case where the combined equalities of
 * "bset" and "context" allow for a compression that can be obtained
 * by preapplication of "T".
 * If the compression of "context" is empty, meaning that "bset" and
 * "context" do not intersect, then return the empty set.
 *
 * "bset" itself is not transformed by "T".  Instead, the inequalities
 * are extracted from "bset" and those are transformed by "T".
 * uset_gist_full then determines which of the transformed inequalities
 * are redundant with respect to the transformed "context" and removes
 * the corresponding inequalities from "bset".
 *
 * After preapplying "T" to the inequalities, any common factor is
 * removed from the coefficients.  If this results in a tightening
 * of the constant term, then the same tightening is applied to
 * the corresponding untransformed inequality in "bset".
 * That is, if after plugging in T, a constraint f(x) >= 0 is of the form
 *
 *	g f'(x) + r >= 0
 *
 * with 0 <= r < g, then it is equivalent to
 *
 *	f'(x) >= 0
 *
 * This means that f(x) >= 0 is equivalent to f(x) - r >= 0 in the affine
 * subspace compressed by T since the latter would be transformed to
 *
 *	g f'(x) >= 0
 */
================================================================================

文件路径: ./isl_map_simplify.c
注释行数: 25
注释内容:
/* Remove all information from bset that is redundant in the context
 * of context.  In particular, equalities that are linear combinations
 * of those in context are removed.  Then the inequalities that are
 * redundant in the context of the equalities and inequalities of
 * context are removed.
 *
 * First of all, we drop those constraints from "context"
 * that are irrelevant for computing the gist of "bset".
 * Alternatively, we could factorize the intersection of "context" and "bset".
 *
 * We first compute the intersection of the integer affine hulls
 * of "bset" and "context",
 * compute the gist inside this intersection and then reduce
 * the constraints with respect to the equalities of the context
 * that only involve variables already involved in the input.
 * If the intersection of the affine hulls turns out to be empty,
 * then return the empty set.
 *
 * If two constraints are mutually redundant, then uset_gist_full
 * will remove the second of those constraints.  We therefore first
 * sort the constraints so that constraints not involving existentially
 * quantified variables are given precedence over those that do.
 * We have to perform this sorting before the variable compression,
 * because that may effect the order of the variables.
 */
================================================================================

文件路径: ./isl_map_simplify.c
注释行数: 20
注释内容:
/* Construct and return a variable compression based on the equality
 * constraints in "bmap1" and "bmap2" that do not involve the local variables.
 * "n1" is the number of (initial) equality constraints in "bmap1"
 * that do involve local variables.
 * "n2" is the number of (initial) equality constraints in "bmap2"
 * that do involve local variables.
 * "total" is the total number of other variables.
 * This function assumes that Gaussian elimination
 * has been applied to the equality constraints in both "bmap1" and "bmap2"
 * such that the equality constraints not involving local variables
 * are those that start at "n1" or "n2".
 *
 * If either of "bmap1" and "bmap2" does not have such equality constraints,
 * then simply compute the compression based on the equality constraints
 * in the other basic map.
 * Otherwise, combine the equality constraints from both into a new
 * basic map such that Gaussian elimination can be applied to this combination
 * and then construct a variable compression from the resulting
 * equality constraints.
 */
================================================================================

文件路径: ./isl_map_simplify.c
注释行数: 32
注释内容:
/* Extract the stride constraints from "bmap", compressed
 * with respect to both the stride constraints in "context" and
 * the remaining equality constraints in both "bmap" and "context".
 * "bmap_n_eq" is the number of (initial) stride constraints in "bmap".
 * "context_n_eq" is the number of (initial) stride constraints in "context".
 *
 * Let x be all variables in "bmap" (and "context") other than the local
 * variables.  First compute a variable compression
 *
 *	x = V x'
 *
 * based on the non-stride equality constraints in "bmap" and "context".
 * Consider the stride constraints of "context",
 *
 *	A(x) + B(y) = 0
 *
 * with y the local variables and plug in the variable compression,
 * resulting in
 *
 *	A(V x') + B(y) = 0
 *
 * Use these constraints to compute a parameter compression on x'
 *
 *	x' = T x''
 *
 * Now consider the stride constraints of "bmap"
 *
 *	C(x) + D(y) = 0
 *
 * and plug in x = V*T x''.
 * That is, return A = [C*V*T D].
 */
================================================================================

文件路径: ./isl_map_simplify.c
注释行数: 28
注释内容:
/* Remove the prime factors from *g that have an exponent that
 * is strictly smaller than the exponent in "c".
 * All exponents in *g are known to be smaller than or equal
 * to those in "c".
 *
 * That is, if *g is equal to
 *
 *	p_1^{e_1} p_2^{e_2} ... p_n^{e_n}
 *
 * and "c" is equal to
 *
 *	p_1^{f_1} p_2^{f_2} ... p_n^{f_n}
 *
 * then update *g to
 *
 *	p_1^{e_1 * (e_1 = f_1)} p_2^{e_2 * (e_2 = f_2)} ...
 *		p_n^{e_n * (e_n = f_n)}
 *
 * If e_i = f_i, then c / *g does not have any p_i factors and therefore
 * neither does the gcd of *g and c / *g.
 * If e_i < f_i, then the gcd of *g and c / *g has a positive
 * power min(e_i, s_i) of p_i with s_i = f_i - e_i among its factors.
 * Dividing *g by this gcd therefore strictly reduces the exponent
 * of the prime factors that need to be removed, while leaving the
 * other prime factors untouched.
 * Repeating this process until gcd(*g, c / *g) = 1 therefore
 * removes all undesired factors, without removing any others.
 */
================================================================================

文件路径: ./isl_map_simplify.c
注释行数: 49
注释内容:
/* Reduce the "n" stride constraints in "bmap" based on a copy "A"
 * of the same stride constraints in a compressed space that exploits
 * all equalities in the context and the other equalities in "bmap".
 *
 * If the stride constraints of "bmap" are of the form
 *
 *	C(x) + D(y) = 0
 *
 * then A is of the form
 *
 *	B(x') + D(y) = 0
 *
 * If any of these constraints involves only a single local variable y,
 * then the constraint appears as
 *
 *	f(x) + m y_i = 0
 *
 * in "bmap" and as
 *
 *	h(x') + m y_i = 0
 *
 * in "A".
 *
 * Let g be the gcd of m and the coefficients of h.
 * Then, in particular, g is a divisor of the coefficients of h and
 *
 *	f(x) = h(x')
 *
 * is known to be a multiple of g.
 * If some prime factor in m appears with the same exponent in g,
 * then it can be removed from m because f(x) is already known
 * to be a multiple of g and therefore in particular of this power
 * of the prime factors.
 * Prime factors that appear with a smaller exponent in g cannot
 * be removed from m.
 * Let g' be the divisor of g containing all prime factors that
 * appear with the same exponent in m and g, then
 *
 *	f(x) + m y_i = 0
 *
 * can be replaced by
 *
 *	f(x) + m/g' y_i' = 0
 *
 * Note that (if g' != 1) this changes the explicit representation
 * of y_i to that of y_i', so the integer division at position i
 * is marked unknown and later recomputed by a call to
 * isl_basic_map_gauss.
 */
================================================================================

文件路径: ./isl_map_simplify.c
注释行数: 20
注释内容:
/* Return a basic map that has the same intersection with "context" as "bmap"
 * and that is as "simple" as possible.
 *
 * The core computation is performed on the pure constraints.
 * When we add back the meaning of the integer divisions, we need
 * to (re)introduce the div constraints.  If we happen to have
 * discovered that some of these integer divisions are equal to
 * some affine combination of other variables, then these div
 * constraints may end up getting simplified in terms of the equalities,
 * resulting in extra inequalities on the other variables that
 * may have been removed already or that may not even have been
 * part of the input.  We try and remove those constraints of
 * this form that are most obviously redundant with respect to
 * the context.  We also remove those div constraints that are
 * redundant with respect to the other constraints in the result.
 *
 * The stride constraints among the equality constraints in "bmap" are
 * also simplified with respecting to the other equality constraints
 * in "bmap" and with respect to all equality constraints in "context".
 */
================================================================================

文件路径: ./isl_map_simplify.c
注释行数: 13
注释内容:
/* Drop all inequalities from "bmap" that also appear in "context".
 * "context" is assumed to have only known local variables and
 * the initial local variables of "bmap" are assumed to be the same
 * as those of "context".
 * The constraints of both "bmap" and "context" are assumed
 * to have been sorted using isl_basic_map_sort_constraints.
 *
 * Run through the inequality constraints of "bmap" and "context"
 * in sorted order.
 * If a constraint of "bmap" involves variables not in "context",
 * then it cannot appear in "context".
 * If a matching constraint is found, it is removed from "bmap".
 */
================================================================================

文件路径: ./isl_map_simplify.c
注释行数: 11
注释内容:
/* Drop all equalities from "bmap" that also appear in "context".
 * "context" is assumed to have only known local variables and
 * the initial local variables of "bmap" are assumed to be the same
 * as those of "context".
 *
 * Run through the equality constraints of "bmap" and "context"
 * in sorted order.
 * If a constraint of "bmap" involves variables not in "context",
 * then it cannot appear in "context".
 * If a matching constraint is found, it is removed from "bmap".
 */
================================================================================

文件路径: ./isl_map_simplify.c
注释行数: 25
注释内容:
/* Return a map that has the same intersection with "context" as "map"
 * and that is as "simple" as possible.
 *
 * If "map" is already the universe, then we cannot make it any simpler.
 * Similarly, if "context" is the universe, then we cannot exploit it
 * to simplify "map"
 * If "map" and "context" are identical to each other, then we can
 * return the corresponding universe.
 *
 * If either "map" or "context" consists of multiple disjuncts,
 * then check if "context" happens to be a subset of "map",
 * in which case all constraints can be removed.
 * In case of multiple disjuncts, the standard procedure
 * may not be able to detect that all constraints can be removed.
 *
 * If none of these cases apply, we have to work a bit harder.
 * During this computation, we make use of a single disjunct context,
 * so if the original context consists of more than one disjunct
 * then we need to approximate the context by a single disjunct set.
 * Simply taking the simple hull may drop constraints that are
 * only implicitly available in each disjunct.  We therefore also
 * look for constraints among those defining "map" that are valid
 * for the context.  These can then be used to simplify away
 * the corresponding constraints in "map".
 */
================================================================================

文件路径: ./isl_map_simplify.c
注释行数: 14
注释内容:
/* Are "map1" and "map2" obviously disjoint?
 *
 * If one of them is empty or if they live in different spaces (ignoring
 * parameters), then they are clearly disjoint.
 * This is checked by isl_map_plain_is_disjoint_global.
 *
 * If they have different parameters, then we skip any further tests.
 *
 * If they are obviously equal, but not obviously empty, then we will
 * not be able to detect if they are disjoint.
 *
 * Otherwise we check if each basic map in "map1" is obviously disjoint
 * from each basic map in "map2".
 */
================================================================================

文件路径: ./isl_map_simplify.c
注释行数: 31
注释内容:
/* Check if we can combine a given div with lower bound l and upper
 * bound u with some other div and if so return that other div.
 * Otherwise, return a position beyond the integer divisions.
 * Return -1 on error.
 *
 * We first check that
 *	- the bounds are opposites of each other (except for the constant
 *	  term)
 *	- the bounds do not reference any other div
 *	- no div is defined in terms of this div
 *
 * Let m be the size of the range allowed on the div by the bounds.
 * That is, the bounds are of the form
 *
 *	e <= a <= e + m - 1
 *
 * with e some expression in the other variables.
 * We look for another div b such that no third div is defined in terms
 * of this second div b and such that in any constraint that contains
 * a (except for the given lower and upper bound), also contains b
 * with a coefficient that is m times that of b.
 * That is, all constraints (except for the lower and upper bound)
 * are of the form
 *
 *	e + f (a + m b) >= 0
 *
 * Furthermore, in the constraints that only contain b, the coefficient
 * of b should be equal to 1 or -1.
 * If so, we return b so that "a + m b" can be replaced by
 * a single div "c = a + m b".
 */
================================================================================

文件路径: ./isl_map_simplify.c
注释行数: 10
注释内容:
/* Internal data structure used during the construction and/or evaluation of
 * an inequality that ensures that a pair of bounds always allows
 * for an integer value.
 *
 * "tab" is the tableau in which the inequality is evaluated.  It may
 * be NULL until it is actually needed.
 * "v" contains the inequality coefficients.
 * "g", "fl" and "fu" are temporary scalars used during the construction and
 * evaluation.
 */
================================================================================

文件路径: ./isl_map_simplify.c
注释行数: 52
注释内容:
/* Given a lower and an upper bound on div i, do they always allow
 * for an integer value of the given div?
 * Determine this property by constructing an inequality
 * such that the property is guaranteed when the inequality is nonnegative.
 * The lower bound is inequality l, while the upper bound is inequality u.
 * The constructed inequality is stored in data->v.
 *
 * Let the upper bound be
 *
 *	-n_u a + e_u >= 0
 *
 * and the lower bound
 *
 *	n_l a + e_l >= 0
 *
 * Let n_u = f_u g and n_l = f_l g, with g = gcd(n_u, n_l).
 * We have
 *
 *	- f_u e_l <= f_u f_l g a <= f_l e_u
 *
 * Since all variables are integer valued, this is equivalent to
 *
 *	- f_u e_l - (f_u - 1) <= f_u f_l g a <= f_l e_u + (f_l - 1)
 *
 * If this interval is at least f_u f_l g, then it contains at least
 * one integer value for a.
 * That is, the test constraint is
 *
 *	f_l e_u + f_u e_l + f_l - 1 + f_u - 1 + 1 >= f_u f_l g
 *
 * or
 *
 *	f_l e_u + f_u e_l + f_l - 1 + f_u - 1 + 1 - f_u f_l g >= 0
 *
 * If the coefficients of f_l e_u + f_u e_l have a common divisor g',
 * then the constraint can be scaled down by a factor g',
 * with the constant term replaced by
 * floor((f_l e_{u,0} + f_u e_{l,0} + f_l - 1 + f_u - 1 + 1 - f_u f_l g)/g').
 * Note that the result of applying Fourier-Motzkin to this pair
 * of constraints is
 *
 *	f_l e_u + f_u e_l >= 0
 *
 * If the constant term of the scaled down version of this constraint,
 * i.e., floor((f_l e_{u,0} + f_u e_{l,0})/g') is equal to the constant
 * term of the scaled down test constraint, then the test constraint
 * is known to hold and no explicit evaluation is required.
 * This is essentially the Omega test.
 *
 * If the test constraint consists of only a constant term, then
 * it is sufficient to look at the sign of this constant term.
 */
================================================================================

文件路径: ./isl_map_simplify.c
注释行数: 11
注释内容:
/* Remove more kinds of divs that are not strictly needed.
 * In particular, if all pairs of lower and upper bounds on a div
 * are such that they allow at least one integer value of the div,
 * then we can eliminate the div using Fourier-Motzkin without
 * introducing any spurious solutions.
 *
 * If at least one of the two constraints has a unit coefficient for the div,
 * then the presence of such a value is guaranteed so there is no need to check.
 * In particular, the value attained by the bound with unit coefficient
 * can serve as this intermediate value.
 */
================================================================================

文件路径: ./isl_map_simplify.c
注释行数: 49
注释内容:
/* Given a pair of divs div1 and div2 such that, except for the lower bound l
 * and the upper bound u, div1 always occurs together with div2 in the form
 * (div1 + m div2), where m is the constant range on the variable div1
 * allowed by l and u, replace the pair div1 and div2 by a single
 * div that is equal to div1 + m div2.
 *
 * The new div will appear in the location that contains div2.
 * We need to modify all constraints that contain
 * div2 = (div - div1) / m
 * The coefficient of div2 is known to be equal to 1 or -1.
 * (If a constraint does not contain div2, it will also not contain div1.)
 * If the constraint also contains div1, then we know they appear
 * as f (div1 + m div2) and we can simply replace (div1 + m div2) by div,
 * i.e., the coefficient of div is f.
 *
 * Otherwise, we first need to introduce div1 into the constraint.
 * Let l be
 *
 *	div1 + f >=0
 *
 * and u
 *
 *	-div1 + f' >= 0
 *
 * A lower bound on div2
 *
 *	div2 + t >= 0
 *
 * can be replaced by
 *
 *	m div2 + div1 + m t + f >= 0
 *
 * An upper bound
 *
 *	-div2 + t >= 0
 *
 * can be replaced by
 *
 *	-(m div2 + div1) + m t + f' >= 0
 *
 * These constraint are those that we would obtain from eliminating
 * div1 using Fourier-Motzkin.
 *
 * After all constraints have been modified, we drop the lower and upper
 * bound and then drop div1.
 * Since the new div is only placed in the same location that used
 * to store div2, but otherwise has a different meaning, any possible
 * explicit representation of the original div2 is removed.
 */
================================================================================

文件路径: ./isl_map_simplify.c
注释行数: 16
注释内容:
/* Given two inequality constraints
 *
 *	f(x) + n d + c >= 0,		(ineq)
 *
 * with d the variable at position "pos", and
 *
 *	f(x) + c0 >= 0,			(lower)
 *
 * compute the maximal value of the lower bound ceil((-f(x) - c)/n)
 * determined by the first constraint.
 * That is, store
 *
 *	ceil((c0 - c)/n)
 *
 * in *l.
 */
================================================================================

文件路径: ./isl_map_simplify.c
注释行数: 16
注释内容:
/* Given two inequality constraints
 *
 *	f(x) + n d + c >= 0,		(ineq)
 *
 * with d the variable at position "pos", and
 *
 *	-f(x) - c0 >= 0,		(upper)
 *
 * compute the minimal value of the lower bound ceil((-f(x) - c)/n)
 * determined by the first constraint.
 * That is, store
 *
 *	ceil((-c1 - c)/n)
 *
 * in *u.
 */
================================================================================

文件路径: ./isl_map_simplify.c
注释行数: 27
注释内容:
/* Given a lower bound constraint "ineq" on "div" in "bmap",
 * does the corresponding lower bound have a fixed value in "bmap"?
 *
 * In particular, "ineq" is of the form
 *
 *	f(x) + n d + c >= 0
 *
 * with n > 0, c the constant term and
 * d the existentially quantified variable "div".
 * That is, the lower bound is
 *
 *	ceil((-f(x) - c)/n)
 *
 * Look for a pair of constraints
 *
 *	f(x) + c0 >= 0
 *	-f(x) + c1 >= 0
 *
 * i.e., -c1 <= -f(x) <= c0, that fix ceil((-f(x) - c)/n) to a constant value.
 * That is, check that
 *
 *	ceil((-c1 - c)/n) = ceil((c0 - c)/n)
 *
 * If so, return the index of inequality f(x) + c0 >= 0.
 * Otherwise, return bmap->n_ineq.
 * Return -1 on error.
 */
================================================================================

文件路径: ./isl_map_simplify.c
注释行数: 19
注释内容:
/* Given a lower bound constraint "ineq" on the existentially quantified
 * variable "div", such that the corresponding lower bound has
 * a fixed value in "bmap", assign this fixed value to the variable and
 * then try and drop redundant divs again,
 * freeing the temporary data structure "pairs" that was associated
 * to the old version of "bmap".
 * "lower" determines the constant value for the lower bound.
 *
 * In particular, "ineq" is of the form
 *
 *	f(x) + n d + c >= 0,
 *
 * while "lower" is of the form
 *
 *	f(x) + c0 >= 0
 *
 * The lower bound is ceil((-f(x) - c)/n) and its constant value
 * is ceil((c0 - c)/n).
 */
================================================================================

文件路径: ./isl_map_simplify.c
注释行数: 42
注释内容:
/* Remove divs that are not strictly needed based on the inequality
 * constraints.
 * In particular, if a div only occurs positively (or negatively)
 * in constraints, then it can simply be dropped.
 * Also, if a div occurs in only two constraints and if moreover
 * those two constraints are opposite to each other, except for the constant
 * term and if the sum of the constant terms is such that for any value
 * of the other values, there is always at least one integer value of the
 * div, i.e., if one plus this sum is greater than or equal to
 * the (absolute value) of the coefficient of the div in the constraints,
 * then we can also simply drop the div.
 *
 * If an existentially quantified variable does not have an explicit
 * representation, appears in only a single lower bound that does not
 * involve any other such existentially quantified variables and appears
 * in this lower bound with coefficient 1,
 * then fix the variable to the value of the lower bound.  That is,
 * turn the inequality into an equality.
 * If for any value of the other variables, there is any value
 * for the existentially quantified variable satisfying the constraints,
 * then this lower bound also satisfies the constraints.
 * It is therefore safe to pick this lower bound.
 *
 * The same reasoning holds even if the coefficient is not one.
 * However, fixing the variable to the value of the lower bound may
 * in general introduce an extra integer division, in which case
 * it may be better to pick another value.
 * If this integer division has a known constant value, then plugging
 * in this constant value removes the existentially quantified variable
 * completely.  In particular, if the lower bound is of the form
 * ceil((-f(x) - c)/n) and there are two constraints, f(x) + c0 >= 0 and
 * -f(x) + c1 >= 0 such that ceil((-c1 - c)/n) = ceil((c0 - c)/n),
 * then the existentially quantified variable can be assigned this
 * shared value.
 *
 * We skip divs that appear in equalities or in the definition of other divs.
 * Divs that appear in the definition of other divs usually occur in at least
 * 4 constraints, but the constraints may have been simplified.
 *
 * If any divs are left after these simple checks then we move on
 * to more complicated cases in drop_more_redundant_divs.
 */
================================================================================

文件路径: ./isl_map_simplify.c
注释行数: 41
注释内容:
/* Remove divs that are not strictly needed.
 *
 * First look for an equality constraint involving two or more
 * existentially quantified variables without an explicit
 * representation.  Replace the combination that appears
 * in the equality constraint by a single existentially quantified
 * variable such that the equality can be used to derive
 * an explicit representation for the variable.
 * If there are no more such equality constraints, then continue
 * with isl_basic_map_drop_redundant_divs_ineq.
 *
 * In particular, if the equality constraint is of the form
 *
 *	f(x) + \sum_i c_i a_i = 0
 *
 * with a_i existentially quantified variable without explicit
 * representation, then apply a transformation on the existentially
 * quantified variables to turn the constraint into
 *
 *	f(x) + g a_1' = 0
 *
 * with g the gcd of the c_i.
 * In order to easily identify which existentially quantified variables
 * have a complete explicit representation, i.e., without being defined
 * in terms of other existentially quantified variables without
 * an explicit representation, the existentially quantified variables
 * are first sorted.
 *
 * The variable transformation is computed by extending the row
 * [c_1/g ... c_n/g] to a unimodular matrix, obtaining the transformation
 *
 *	[a_1']   [c_1/g ... c_n/g]   [ a_1 ]
 *	[a_2']                       [ a_2 ]
 *	 ...   =         U             ....
 *	[a_n']            	     [ a_n ]
 *
 * with [c_1/g ... c_n/g] representing the first row of U.
 * The inverse of U is then plugged into the original constraints.
 * The call to isl_basic_map_simplify makes sure the explicit
 * representation for a_1' is extracted from the equality constraint.
 */
================================================================================

文件路径: ./isl_map_simplify.c
注释行数: 30
注释内容:
/* If "bmap" is an integer set that satisfies any equality involving
 * more than 2 variables and/or has coefficients different from -1 and 1,
 * then use variable compression to reduce the coefficients by removing
 * any (hidden) common factor.
 * In particular, apply the variable compression to each constraint,
 * factor out any common factor in the non-constant coefficients and
 * then apply the inverse of the compression.
 * At the end, we mark the basic map as having reduced constants.
 * If this flag is still set on the next invocation of this function,
 * then we skip the computation.
 *
 * Removing a common factor may result in a tightening of some of
 * the constraints.  If this happens, then we may end up with two
 * opposite inequalities that can be replaced by an equality.
 * We therefore call isl_basic_map_detect_inequality_pairs,
 * which checks for such pairs of inequalities as well as eliminate_divs_eq
 * and isl_basic_map_gauss if such a pair was found.
 *
 * Tightening may also result in some other constraints becoming
 * (rationally) redundant with respect to the tightened constraint
 * (in combination with other constraints).  The basic map may
 * therefore no longer be assumed to have no redundant constraints.
 *
 * Note that this function may leave the result in an inconsistent state.
 * In particular, the constraints may not be gaussed.
 * Unfortunately, isl_map_coalesce actually depends on this inconsistent state
 * for some of the test cases to pass successfully.
 * Any potential modification of the representation is therefore only
 * performed on a single copy of the basic map.
 */
================================================================================

文件路径: ./isl_map_simplify.c
注释行数: 13
注释内容:
/* Shift the integer division at position "div" of "bmap"
 * by "shift" times the variable at position "pos".
 * "pos" is as determined by isl_basic_map_offset, i.e., pos == 0
 * corresponds to the constant term.
 *
 * That is, if the integer division has the form
 *
 *	floor(f(x)/d)
 *
 * then replace it by
 *
 *	floor((f(x) + shift * d * x_pos)/d) - shift * x_pos
 */
================================================================================

文件路径: ./isl_tab.h
注释行数: 61
注释内容:
/* The tableau maintains equality relations.
 * Each column and each row is associated to a variable or a constraint.
 * The "value" of an inequality constraint is the value of the corresponding
 * slack variable.
 * The "row_var" and "col_var" arrays map column and row indices
 * to indices in the "var" and "con" arrays.  The elements of these
 * arrays maintain extra information about the variables and the constraints.
 * Each row expresses the corresponding row variable as an affine expression
 * of the column variables.
 * The first two columns in the matrix contain the common denominator of
 * the row and the numerator of the constant term.
 * If "M" is set, then the third column represents the "big parameter".
 * The third (M = 0) or fourth (M = 1) column
 * in the matrix is called column 0 with respect to the col_var array.
 * The sample value of the tableau is the value that assigns zero
 * to all the column variables and the constant term of each affine
 * expression to the corresponding row variable.
 * The operations on the tableau maintain the property that the sample
 * value satisfies the non-negativity constraints (usually on the slack
 * variables).
 *
 * The big parameter represents an arbitrarily big (and divisible)
 * positive number.  If present, then the sign of a row is determined
 * lexicographically, with the sign of the big parameter coefficient
 * considered first.  The big parameter is only used while
 * solving PILP problems.
 *
 * The first n_dead column variables have their values fixed to zero.
 * The corresponding tab_vars are flagged "is_zero".
 * Some of the rows that have have zero coefficients in all but
 * the dead columns are also flagged "is_zero".
 *
 * The first n_redundant rows correspond to inequality constraints
 * that are always satisfied for any value satisfying the non-redundant
 * rows.  The corresponding tab_vars are flagged "is_redundant".
 * A row variable that is flagged "is_zero" is also flagged "is_redundant"
 * since the constraint has been reduced to 0 = 0 and is therefore always
 * satisfied.
 *
 * There are "n_var" variables in total.  The first "n_param" of these
 * are called parameters and the last "n_div" of these are called divs.
 * The basic tableau operations makes no distinction between different
 * kinds of variables.  These special variables are only used while
 * solving PILP problems.
 *
 * Dead columns and redundant rows are detected on the fly.
 * However, the basic operations do not ensure that all dead columns
 * or all redundant rows are detected.
 * isl_tab_detect_implicit_equalities and isl_tab_detect_redundant can be used
 * to perform an exhaustive search for dead columns and redundant rows.
 *
 * The samples matrix contains "n_sample" integer points that have at some
 * point been elements satisfying the tableau.  The first "n_outside"
 * of them no longer satisfy the tableau.  They are kept because they
 * can be reinstated during rollback when the constraint that cut them
 * out is removed.  These samples are only maintained for the context
 * tableau while solving PILP problems.
 *
 * If "preserve" is set, then we want to keep all constraints in the
 * tableau, even if they turn out to be redundant.
 */
================================================================================

文件路径: ./isl_opt_mpa_templ.c
注释行数: 10
注释内容:
/* Compute the optima of the set or output dimensions as a function of the
 * parameters (and input dimensions), but independently of
 * the other set or output dimensions,
 * given a function "opt" that computes this optimum
 * for a single dimension.
 *
 * If the resulting multi piecewise affine expression has
 * an explicit domain, then assign it the (parameter) domain of the input.
 * In other cases, the (parameter) domain is stored in the individual elements.
 */
================================================================================

文件路径: ./isl_obj.c
注释行数: 14
注释内容:
/*
 * Copyright 2010      INRIA Saclay
 * Copyright 2014      Ecole Normale Superieure
 * Copyright 2014      INRIA Rocquencourt
 *
 * Use of this software is governed by the MIT license
 *
 * Written by Sven Verdoolaege, INRIA Saclay - Ile-de-France,
 * Parc Club Orsay Universite, ZAC des vignes, 4 rue Jacques Monod,
 * 91893 Orsay, France 
 * and Ecole Normale Superieure, 45 rue d'Ulm, 75230 Paris, France
 * and Inria Paris - Rocquencourt, Domaine de Voluceau - Rocquencourt,
 * B.P. 105 - 78153 Le Chesnay, France
 */
================================================================================

文件路径: ./isl_pw_union_opt.c
注释行数: 13
注释内容:
/*
 * Copyright 2011      INRIA Saclay
 * Copyright 2012      Ecole Normale Superieure
 * Copyright 2020      Cerebras Systems
 *
 * Use of this software is governed by the MIT license
 *
 * Written by Sven Verdoolaege, INRIA Saclay - Ile-de-France,
 * Parc Club Orsay Universite, ZAC des vignes, 4 rue Jacques Monod,
 * 91893 Orsay, France
 * and Ecole Normale Superieure, 45 rue d'Ulm, 75230 Paris, France
 * and Cerebras Systems, 175 S San Antonio Rd, Los Altos, CA, USA
 */
================================================================================

文件路径: ./isl_pw_union_opt.c
注释行数: 29
注释内容:
/* Given (potentially) updated cells "i" of data_i->pw and "j" of data_j->pw and
 * a set "better" where the piece from data_j->pw is better
 * than the piece from data_i->pw,
 * (further) update the specified cells such that only the better elements
 * remain on the (non-empty) intersection.
 *
 * Let C be the set "better".
 * Let A be the cell data_i->cell[i] and B the cell data_j->cell[j].
 *
 * The elements in C need to be removed from A, except for those parts
 * that lie outside of B.  That is,
 *
 *	A <- (A \setminus C) \cup ((A \cap C) \setminus B')
 *
 * Conversely, the elements in B need to be restricted to C, except
 * for those parts that lie outside of A.  That is
 *
 *	B <- (B \cap C) \cup ((B \setminus C) \setminus A')
 *
 * Since all pairs of pieces are considered, the domains are updated
 * several times.  A and B refer to these updated domains
 * (kept track of in data_i->cell[i] and data_j->cell[j]), while A' and B' refer
 * to the original domains of the pieces.  It is safe to use these
 * original domains because the difference between, say, A' and A is
 * the domains of pw2-pieces that have been removed before and
 * those domains are disjoint from B.  A' is used instead of A
 * because the continued updating of A may result in this domain
 * getting broken up into more disjuncts.
 */
================================================================================

文件路径: ./isl_pw_union_opt.c
注释行数: 23
注释内容:
/* Given (potentially) updated cells "i" of data_i->pw and "j" of data_j->pw and
 * a function "cmp" that returns the set of elements where
 * "el1" is "better" than "el2",
 * (further) update the specified cells such that only the "better" elements
 * remain on the (non-empty) intersection.
 *
 * The base computation is performed by isl_pw_*_union_opt_cmp_pair,
 * which splits the cells according to the set of elements
 * where the piece from data_j->pw is better than the piece from data_i->pw.
 *
 * In some cases, there may be a subset of the intersection
 * where both pieces have the same value and can therefore
 * both be considered to be "better" than the other.
 * This can result in unnecessary splitting on this subset.
 * Avoid some of these cases by checking whether
 * data_i->pw is always better than data_j->pw on the intersection.
 * In particular, do this for the special case where this intersection
 * is equal to the cell "j" and data_i->pw is better on its entire cell.
 *
 * Similarly, if data_i->pw is never better than data_j->pw,
 * then no splitting will occur and there is no need to check
 * where data_j->pw is better than data_i->pw.
 */
================================================================================

文件路径: ./isl_pw_union_opt.c
注释行数: 16
注释内容:
/* Given two piecewise expressions data1->pw and data2->pw, replace
 * their domains
 * by the sets in data1->cell and data2->cell and combine the results into
 * a single piecewise expression.
 * The pieces of data1->pw and data2->pw are assumed to have been sorted
 * according to the function value expressions.
 * The pieces of the result are also sorted in this way.
 *
 * Run through the pieces of data1->pw and data2->pw in order until they
 * have both been exhausted, picking the piece from data1->pw or data2->pw
 * depending on which should come first, together with the corresponding
 * domain from data1->cell or data2->cell.  In cases where the next pieces
 * in both data1->pw and data2->pw have the same function value expression,
 * construct only a single piece in the result with as domain
 * the union of the domains in data1->cell and data2->cell.
 */
================================================================================

文件路径: ./isl_pw_union_opt.c
注释行数: 18
注释内容:
/* Given a function "cmp" that returns the set of elements where
 * "el1" is "better" than "el2", return a piecewise
 * expression defined on the union of the definition domains
 * of "pw1" and "pw2" that maps to the "best" of "pw1" and
 * "pw2" on each cell.  If only one of the two input functions
 * is defined on a given cell, then it is considered the best.
 *
 * Run through all pairs of pieces in "pw1" and "pw2".
 * If the domains of these pieces intersect, then the intersection
 * needs to be distributed over the two pieces based on "cmp".
 *
 * After the updated domains have been computed, the result is constructed
 * from "pw1", "pw2", data[0].cell and data[1].cell.  If there are any pieces
 * in "pw1" and "pw2" with the same function value expression, then
 * they are combined into a single piece in the result.
 * In order to be able to do this efficiently, the pieces of "pw1" and
 * "pw2" are first sorted according to their function value expressions.
 */
================================================================================

文件路径: ./isl_fold.c
注释行数: 10
注释内容:
/* Determine the sign of the constant quasipolynomial "qp".
 *
 * Return
 *	-1 if qp <= 0
 *	 1 if qp >= 0
 *	 0 if unknown
 *
 * For qp == 0, we can return either -1 or 1.  In practice, we return 1.
 * For qp == NaN, the sign is undefined, so we return 0.
 */
================================================================================

文件路径: ./isl_fold.c
注释行数: 20
注释内容:
/* Determine, if possible, the sign of the quasipolynomial "qp" on
 * the domain "set".
 *
 * If qp is a constant, then the problem is trivial.
 * If qp is linear, then we check if the minimum of the corresponding
 * affine constraint is non-negative or if the maximum is non-positive.
 *
 * Otherwise, we check if the outermost variable "v" has a lower bound "l"
 * in "set".  If so, we write qp(v,v') as
 *
 *	q(v,v') * (v - l) + r(v')
 *
 * if q(v,v') and r(v') have the same known sign, then the original
 * quasipolynomial has the same sign as well.
 *
 * Return
 *	-1 if qp <= 0
 *	 1 if qp >= 0
 *	 0 if unknown
 */
================================================================================

文件路径: ./isl_val_gmp.c
注释行数: 11
注释内容:
/* Store a representation of the absolute value of the numerator of "v"
 * in terms of chunks of size "size" at "chunks".
 * The least significant chunk is stored first.
 * The number of chunks in the result can be obtained by calling
 * isl_val_n_abs_num_chunks.  The user is responsible for allocating
 * enough memory to store the results.
 *
 * In the special case of a zero value, isl_val_n_abs_num_chunks will
 * return one, while mpz_export will not fill in any chunks.  We therefore
 * do it ourselves.
 */
================================================================================

文件路径: ./isl_schedule_node_private.h
注释行数: 16
注释内容:
/* An isl_schedule_node points to a particular location in a schedule tree.
 *
 * "schedule" is the schedule that the node is pointing to.
 * "ancestors" is a list of the n ancestors of the node
 * that is being pointed to.
 * The first ancestor is the root of "schedule", while the last ancestor
 * is the parent of the specified location.
 * "child_pos" is an array of child positions of the same length as "ancestors",
 * where ancestor i (i > 0) appears in child_pos[i - 1] of ancestor i - 1 and
 * "tree" appears in child_pos[n - 1] of ancestor n - 1.
 * "tree" is the subtree at the specified location.
 *
 * Note that the same isl_schedule_tree object may appear several times
 * in a schedule tree and therefore does not uniquely identify a position
 * in the schedule tree.
 */
================================================================================

文件路径: ./isl_union_single.c
注释行数: 11
注释内容:
/*
 * Copyright 2010      INRIA Saclay
 * Copyright 2013      Ecole Normale Superieure
 *
 * Use of this software is governed by the MIT license
 *
 * Written by Sven Verdoolaege, INRIA Saclay - Ile-de-France,
 * Parc Club Orsay Universite, ZAC des vignes, 4 rue Jacques Monod,
 * 91893 Orsay, France
 * and Ecole Normale Superieure, 45 rue d'Ulm, 75230 Paris, France
 */
================================================================================

文件路径: ./pip.c
注释行数: 15
注释内容:
/* The input of this program is the same as that of the "example" program
 * from the PipLib distribution, except that the "big parameter column"
 * should always be -1.
 *
 * Context constraints in PolyLib format
 * -1
 * Problem constraints in PolyLib format
 * Optional list of options
 *
 * The options are
 *	Maximize	compute maximum instead of minimum
 *	Rational	compute rational optimum instead of integer optimum
 *	Urs_parms	don't assume parameters are non-negative
 *	Urs_unknowns	don't assume unknowns are non-negative
 */
================================================================================

文件路径: ./isl_stride.c
注释行数: 27
注释内容:
/* Set the stride and offset of data->pos to the given
 * value and expression.
 *
 * If we had already found a stride before, then the two strides
 * are combined into a single stride.
 *
 * In particular, if the new stride information is of the form
 *
 *	i = f + s (...)
 *
 * and the old stride information is of the form
 *
 *	i = f2 + s2 (...)
 *
 * then we compute the extended gcd of s and s2
 *
 *	a s + b s2 = g,
 *
 * with g = gcd(s,s2), multiply the first equation with t1 = b s2/g
 * and the second with t2 = a s1/g.
 * This results in
 *
 *	i = (b s2 + a s1)/g i = t1 f + t2 f2 + (s s2)/g (...)
 *
 * so that t1 f + t2 f2 is the combined offset and (s s2)/g = lcm(s,s2)
 * is the combined stride.
 */
================================================================================

文件路径: ./isl_stride.c
注释行数: 34
注释内容:
/* Check if constraint "c" imposes any stride on dimension data->pos
 * and, if so, update the stride information in "data".
 *
 * In order to impose a stride on the dimension, "c" needs to be an equality
 * and it needs to involve the dimension.  Note that "c" may also be
 * a div constraint and thus an inequality that we cannot use.
 *
 * Let c be of the form
 *
 *	h(p) + g * v * i + g * stride * f(alpha) = 0
 *
 * with h(p) an expression in terms of the parameters and other dimensions
 * and f(alpha) an expression in terms of the existentially quantified
 * variables.
 *
 * If "stride" is not zero and not one, then it represents a non-trivial stride
 * on "i".  We compute a and b such that
 *
 *	a v + b stride = 1
 *
 * We have
 *
 *	g v i = -h(p) + g stride f(alpha)
 *
 *	a g v i = -a h(p) + g stride f(alpha)
 *
 *	a g v i + b g stride i = -a h(p) + g stride * (...)
 *
 *	g i = -a h(p) + g stride * (...)
 *
 *	i = -a h(p)/g + stride * (...)
 *
 * The expression "-a h(p)/g" can therefore be used as offset.
 */
================================================================================

文件路径: ./isl_coalesce.c
注释行数: 21
注释内容:
/*
 * Copyright 2008-2009 Katholieke Universiteit Leuven
 * Copyright 2010      INRIA Saclay
 * Copyright 2012-2013 Ecole Normale Superieure
 * Copyright 2014      INRIA Rocquencourt
 * Copyright 2016      INRIA Paris
 * Copyright 2020      Cerebras Systems
 *
 * Use of this software is governed by the MIT license
 *
 * Written by Sven Verdoolaege, K.U.Leuven, Departement
 * Computerwetenschappen, Celestijnenlaan 200A, B-3001 Leuven, Belgium
 * and INRIA Saclay - Ile-de-France, Parc Club Orsay Universite,
 * ZAC des vignes, 4 rue Jacques Monod, 91893 Orsay, France 
 * and Ecole Normale Superieure, 45 rue d’Ulm, 75230 Paris, France
 * and Inria Paris - Rocquencourt, Domaine de Voluceau - Rocquencourt,
 * B.P. 105 - 78153 Le Chesnay, France
 * and Centre de Recherche Inria de Paris, 2 rue Simone Iff - Voie DQ12,
 * CS 42112, 75589 Paris Cedex 12, France
 * and Cerebras Systems, 175 S San Antonio Rd, Los Altos, CA, USA
 */
================================================================================

文件路径: ./isl_coalesce.c
注释行数: 21
注释内容:
/* Internal information associated to a basic map in a map
 * that is to be coalesced by isl_map_coalesce.
 *
 * "bmap" is the basic map itself (or NULL if "removed" is set)
 * "tab" is the corresponding tableau (or NULL if "removed" is set)
 * "hull_hash" identifies the affine space in which "bmap" lives.
 * "modified" is set if this basic map may not be identical
 * to any of the basic maps in the input.
 * "removed" is set if this basic map has been removed from the map
 * "simplify" is set if this basic map may have some unknown integer
 * divisions that were not present in the input basic maps.  The basic
 * map should then be simplified such that we may be able to find
 * a definition among the constraints.
 *
 * "eq" and "ineq" are only set if we are currently trying to coalesce
 * this basic map with another basic map, in which case they represent
 * the position of the inequalities of this basic map with respect to
 * the other basic map.  The number of elements in the "eq" array
 * is twice the number of equalities in the "bmap", corresponding
 * to the two inequalities that make up each equality.
 */
================================================================================

文件路径: ./isl_coalesce.c
注释行数: 21
注释内容:
/* Replace the pair of basic maps i and j by the basic map bounded
 * by the valid constraints in both basic maps and the constraints
 * in extra (if not NULL).
 * Place the fused basic map in the position that is the smallest of i and j.
 *
 * If "detect_equalities" is set, then look for equalities encoded
 * as pairs of inequalities.
 * If "check_number" is set, then the original basic maps are only
 * replaced if the total number of constraints does not increase.
 * While the number of integer divisions in the two basic maps
 * is assumed to be the same, the actual definitions may be different.
 * We only copy the definition from one of the basic map if it is
 * the same as that of the other basic map.  Otherwise, we mark
 * the integer division as unknown and simplify the basic map
 * in an attempt to recover the integer division definition.
 * If any extra constraints get introduced, then these may
 * involve integer divisions with a unit coefficient.
 * Eliminate those that do not appear with any other coefficient
 * in other constraints, to ensure they get eliminated completely,
 * improving the chances of further coalescing.
 */
================================================================================

文件路径: ./isl_coalesce.c
注释行数: 29
注释内容:
/* Given a pair of basic maps i and j such that all constraints are either
 * "valid" or "cut", check if the facets corresponding to the "cut"
 * constraints of i lie entirely within basic map j.
 * If so, replace the pair by the basic map consisting of the valid
 * constraints in both basic maps.
 * Checking whether the facet lies entirely within basic map j
 * is performed by checking whether the constraints of basic map j
 * are valid for the facet.  These tests are performed on a rational
 * tableau to avoid the theoretical possibility that a constraint
 * that was considered to be a cut constraint for the entire basic map i
 * happens to be considered to be a valid constraint for the facet,
 * even though it cuts off the same rational points.
 *
 * To see that we are not introducing any extra points, call the
 * two basic maps A and B and the resulting map U and let x
 * be an element of U \setminus ( A \cup B ).
 * A line connecting x with an element of A \cup B meets a facet F
 * of either A or B.  Assume it is a facet of B and let c_1 be
 * the corresponding facet constraint.  We have c_1(x) < 0 and
 * so c_1 is a cut constraint.  This implies that there is some
 * (possibly rational) point x' satisfying the constraints of A
 * and the opposite of c_1 as otherwise c_1 would have been marked
 * valid for A.  The line connecting x and x' meets a facet of A
 * in a (possibly rational) point that also violates c_1, but this
 * is impossible since all cut constraints of B are valid for all
 * cut facets of A.
 * In case F is a facet of A rather than B, then we can apply the
 * above reasoning to find a facet of B separating x from A \cup B first.
 */
================================================================================

文件路径: ./isl_coalesce.c
注释行数: 51
注释内容:
/* Basic map "i" has an inequality "k" that is adjacent
 * to some inequality of basic map "j".  All the other inequalities
 * are valid for "j".
 * If not NULL, then "extra" contains extra wrapping constraints that are valid
 * for both "i" and "j".
 * Check if basic map "j" forms an extension of basic map "i",
 * taking into account the extra constraints, if any.
 *
 * Note that this function is only called if some of the equalities or
 * inequalities of basic map "j" do cut basic map "i".  The function is
 * correct even if there are no such cut constraints, but in that case
 * the additional checks performed by this function are overkill.
 *
 * In particular, we replace constraint k, say f >= 0, by constraint
 * f <= -1, add the inequalities of "j" that are valid for "i",
 * as well as the "extra" constraints, if any,
 * and check if the result is a subset of basic map "j".
 * To improve the chances of the subset relation being detected,
 * any variable that only attains a single integer value
 * in the tableau of "i" is first fixed to that value.
 * If the result is a subset, then we know that this result is exactly equal
 * to basic map "j" since all its constraints are valid for basic map "j".
 * By combining the valid constraints of "i" (all equalities and all
 * inequalities except "k"), the valid constraints of "j" and
 * the "extra" constraints, if any, we therefore
 * obtain a basic map that is equal to their union.
 * In this case, there is no need to perform a rollback of the tableau
 * since it is going to be destroyed in fuse().
 *
 *
 *	|\__			|\__
 *	|   \__			|   \__
 *	|      \_	=>	|      \__
 *	|_______| _		|_________\
 *
 *
 *	|\			|\
 *	| \			| \
 *	|  \			|  \
 *	|  |			|   \
 *	|  ||\		=>      |    \
 *	|  || \			|     \
 *	|  ||  |		|      |
 *	|__||_/			|_____/
 *
 *
 *	_______			 _______
 *     |       | __		|       \__
 *     |       ||__|	=>	|        __|
 *     |_______|		|_______/
 */
================================================================================

文件路径: ./isl_coalesce.c
注释行数: 20
注释内容:
/* Given the compressed version of inequality constraint "ineq"
 * of info->bmap in "v", check if the constraint can be tightened,
 * where the compression is based on an equality constraint valid
 * for info->tab.
 * If so, add the tightened version of the inequality constraint
 * to info->tab.  "v" may be modified by this function.
 *
 * That is, if the compressed constraint is of the form
 *
 *	m f() + c >= 0
 *
 * with 0 < c < m, then it is equivalent to
 *
 *	f() >= 0
 *
 * This means that c can also be subtracted from the original,
 * uncompressed constraint without affecting the integer points
 * in info->tab.  Add this tightened constraint as an extra row
 * to info->tab to make this information explicitly available.
 */
================================================================================

文件路径: ./isl_coalesce.c
注释行数: 37
注释内容:
/* Tighten the (non-redundant) constraints on the facet represented
 * by info->tab.
 * In particular, on input, info->tab represents the result
 * of relaxing the "n" inequality constraints of info->bmap in "relaxed"
 * by one, i.e., replacing f_i >= 0 by f_i + 1 >= 0, and then
 * replacing the one at index "l" by the corresponding equality,
 * i.e., f_k + 1 = 0, with k = relaxed[l].
 *
 * Compute a variable compression from the equality constraint f_k + 1 = 0
 * and use it to tighten the other constraints of info->bmap
 * (that is, all constraints that have not been relaxed),
 * updating info->tab (and leaving info->bmap untouched).
 * The compression handles essentially two cases, one where a variable
 * is assigned a fixed value and can therefore be eliminated, and one
 * where one variable is a shifted multiple of some other variable and
 * can therefore be replaced by that multiple.
 * Gaussian elimination would also work for the first case, but for
 * the second case, the effectiveness would depend on the order
 * of the variables.
 * After compression, some of the constraints may have coefficients
 * with a common divisor.  If this divisor does not divide the constant
 * term, then the constraint can be tightened.
 * The tightening is performed on the tableau info->tab by introducing
 * extra (temporary) constraints.
 *
 * Only constraints that are possibly affected by the compression are
 * considered.  In particular, if the constraint only involves variables
 * that are directly mapped to a distinct set of other variables, then
 * no common divisor can be introduced and no tightening can occur.
 *
 * It is important to only consider the non-redundant constraints
 * since the facet constraint has been relaxed prior to the call
 * to this function, meaning that the constraints that were redundant
 * prior to the relaxation may no longer be redundant.
 * These constraints will be ignored in the fused result, so
 * the fusion detection should not exploit them.
 */
================================================================================

文件路径: ./isl_coalesce.c
注释行数: 11
注释内容:
/* Replace the basic maps "i" and "j" by an extension of "i"
 * along the "n" inequality constraints in "relax" by one.
 * The tableau info[i].tab has already been extended.
 * Extend info[i].bmap accordingly by relaxing all constraints in "relax"
 * by one.
 * Each integer division that does not have exactly the same
 * definition in "i" and "j" is marked unknown and the basic map
 * is scheduled to be simplified in an attempt to recover
 * the integer division definition.
 * Place the extension in the position that is the smallest of i and j.
 */
================================================================================

文件路径: ./isl_coalesce.c
注释行数: 44
注释内容:
/* Basic map "i" has "n" inequality constraints (collected in "relax")
 * that are such that they include basic map "j" if they are relaxed
 * by one.  All the other inequalities are valid for "j".
 * Check if basic map "j" forms an extension of basic map "i".
 *
 * In particular, relax the constraints in "relax", compute the corresponding
 * facets one by one and check whether each of these is included
 * in the other basic map.
 * Before testing for inclusion, the constraints on each facet
 * are tightened to increase the chance of an inclusion being detected.
 * (Adding the valid constraints of "j" to the tableau of "i", as is done
 * in is_adj_ineq_extension, may further increase those chances, but this
 * is not currently done.)
 * If each facet is included, we know that relaxing the constraints extends
 * the basic map with exactly the other basic map (we already know that this
 * other basic map is included in the extension, because all other
 * inequality constraints are valid of "j") and we can replace the
 * two basic maps by this extension.
 *
 * If any of the relaxed constraints turn out to be redundant, then bail out.
 * isl_tab_select_facet refuses to handle such constraints.  It may be
 * possible to handle them anyway by making a distinction between
 * redundant constraints with a corresponding facet that still intersects
 * the set (allowing isl_tab_select_facet to handle them) and
 * those where the facet does not intersect the set (which can be ignored
 * because the empty facet is trivially included in the other disjunct).
 * However, relaxed constraints that turn out to be redundant should
 * be fairly rare and no such instance has been reported where
 * coalescing would be successful.
 *        ____			  _____
 *       /    || 		 /     |
 *      /     ||  		/      |
 *      \     ||   	=>	\      |
 *       \    ||		 \     |
 *        \___||		  \____|
 *
 *
 *	 \			|\
 *	|\\			| \
 *	| \\			|  \
 *	|  |		=>	|  /
 *	| /			| /
 *	|/			|/
 */
================================================================================

文件路径: ./isl_coalesce.c
注释行数: 33
注释内容:
/* This function has two modes of operations.
 *
 * If "add_valid" is set, then all the constraints of info->bmap
 * (except the opposite of "bound") are valid for the other basic map.
 * In this case, attempts are made to wrap some of these valid constraints
 * to more tightly fit around "set".  Only successful wrappings are recorded
 * and failed wrappings are ignored.
 *
 * If "add_valid" is not set, then some of the constraints of info->bmap
 * are not valid for the other basic map, and only those are considered
 * for wrapping.  In this case all attempted wrappings need to succeed.
 * Otherwise "wraps" is marked as failed.
 * Note that the constraints that are valid for the other basic map
 * will be added to the combined basic map by default, so there is
 * no need to wrap them.
 * The caller wrap_in_facets even relies on this function not wrapping
 * any constraints that are already valid.
 *
 * Only consider constraints that are not redundant (as determined
 * by info->tab) and that are valid or invalid depending on "add_valid".
 * Wrap each constraint around "bound" such that it includes the whole
 * set "set" and append the resulting constraint to "wraps".
 * "wraps" is assumed to have been pre-allocated to the appropriate size.
 * wraps->n_row is the number of actual wrapped constraints that have
 * been added.
 * If any of the wrapping problems results in a constraint that is
 * identical to "bound", then this means that "set" is unbounded in such
 * a way that no wrapping is possible.
 * Similarly, if we want to bound the coefficients of the wrapping
 * constraints and a newly added wrapping constraint does not
 * satisfy the bound, then the wrapping is considered to have failed.
 * Note though that "wraps" is only marked failed if "add_valid" is not set.
 */
================================================================================

文件路径: ./isl_coalesce.c
注释行数: 20
注释内容:
/* For each constraint in info->bmap that is not redundant (as determined
 * by info->tab) and that is not a valid constraint for the other basic map,
 * wrap the constraint around "bound" such that it includes the whole
 * set "set" and append the resulting constraint to "wraps".
 * Note that the constraints that are valid for the other basic map
 * will be added to the combined basic map by default, so there is
 * no need to wrap them.
 * The caller wrap_in_facets even relies on this function not wrapping
 * any constraints that are already valid.
 * "wraps" is assumed to have been pre-allocated to the appropriate size.
 * wraps->n_row is the number of actual wrapped constraints that have
 * been added.
 * If any of the wrapping problems results in a constraint that is
 * identical to "bound", then this means that "set" is unbounded in such
 * a way that no wrapping is possible.  If this happens then "wraps"
 * is marked as failed.
 * Similarly, if we want to bound the coefficients of the wrapping
 * constraints and a newly added wrapping constraint does not
 * satisfy the bound, then "wraps" is also marked as failed.
 */
================================================================================

文件路径: ./isl_coalesce.c
注释行数: 16
注释内容:
/* Return a set that corresponds to the non-redundant constraints
 * (as recorded in tab) of bmap.
 *
 * It's important to remove the redundant constraints as some
 * of the other constraints may have been modified after the
 * constraints were marked redundant.
 * In particular, a constraint may have been relaxed.
 * Redundant constraints are ignored when a constraint is relaxed
 * and should therefore continue to be ignored ever after.
 * Otherwise, the relaxation might be thwarted by some of
 * these constraints.
 *
 * Update the underlying set to ensure that the dimension doesn't change.
 * Otherwise the integer divisions could get dropped if the tab
 * turns out to be empty.
 */
================================================================================

文件路径: ./isl_coalesce.c
注释行数: 25
注释内容:
/* Wrap some constraints of info->bmap that bound the facet defined
 * by inequality "k" around (the opposite of) this inequality to
 * include "set".  "bound" may be used to store the negated inequality.
 *
 * If "add_valid" is set, then all ridges are already valid and
 * the purpose is to wrap "set" more tightly.  In this case,
 * wrapping doesn't fail, although it is possible that no constraint
 * gets wrapped.
 *
 * If "add_valid" is not set, then some of the ridges are cut constraints
 * and only those are wrapped around "set".
 *
 * Since the wrapped constraints are not guaranteed to contain the whole
 * of info->bmap, we check them in check_wraps.
 * If any of the wrapped constraints turn out to be invalid, then
 * check_wraps will mark "wraps" as failed if "add_valid" is not set.
 * If "add_valid" is set, then the offending constraints are
 * simply removed.
 *
 * If any of the cut constraints of info->bmap turn out
 * to be redundant with respect to other constraints
 * then these will neither be wrapped nor added directly to the result.
 * The result may therefore not be correct.
 * Skip wrapping and mark "wraps" as failed in this case.
 */
================================================================================

文件路径: ./isl_coalesce.c
注释行数: 15
注释内容:
/* Basic map "i" has an inequality (say "k") that is adjacent
 * to some inequality of basic map "j".  All the other inequalities
 * are valid for "j".
 * Check if basic map "j" forms an extension of basic map "i".
 *
 * Note that this function is only called if some of the equalities or
 * inequalities of basic map "j" do cut basic map "i".  The function is
 * correct even if there are no such cut constraints, but in that case
 * the additional checks performed by this function are overkill.
 *
 * First try and wrap the ridges of "k" around "j".
 * Note that those ridges are already valid for "j",
 * but the wrapped versions may wrap "j" more tightly,
 * increasing the chances of "j" being detected as an extension of "i"
 */
================================================================================

文件路径: ./isl_coalesce.c
注释行数: 31
注释内容:
/* Both basic maps have at least one inequality with and adjacent
 * (but opposite) inequality in the other basic map.
 * Check that there are no cut constraints and that there is only
 * a single pair of adjacent inequalities.
 * If so, we can replace the pair by a single basic map described
 * by all but the pair of adjacent inequalities.
 * Any additional points introduced lie strictly between the two
 * adjacent hyperplanes and can therefore be integral.
 *
 *        ____			  _____
 *       /    ||\		 /     \
 *      /     || \		/       \
 *      \     ||  \	=>	\        \
 *       \    ||  /		 \       /
 *        \___||_/		  \_____/
 *
 * The test for a single pair of adjacent inequalities is important
 * for avoiding the combination of two basic maps like the following
 *
 *       /|
 *      / |
 *     /__|
 *         _____
 *         |   |
 *         |   |
 *         |___|
 *
 * If there are some cut constraints on one side, then we may
 * still be able to fuse the two basic maps, but we need to perform
 * some additional checks in is_adj_ineq_extension.
 */
================================================================================

文件路径: ./isl_coalesce.c
注释行数: 21
注释内容:
/* Given a basic set i with a constraint k that is adjacent to
 * basic set j, check if we can wrap
 * both the facet corresponding to k (if "wrap_facet" is set) and basic map j
 * (always) around their ridges to include the other set.
 * If so, replace the pair of basic sets by their union.
 *
 * All constraints of i (except k) are assumed to be valid or
 * cut constraints for j.
 * Wrapping the cut constraints to include basic map j may result
 * in constraints that are no longer valid of basic map i
 * we have to check that the resulting wrapping constraints are valid for i.
 * If "wrap_facet" is not set, then all constraints of i (except k)
 * are assumed to be valid for j.
 *        ____			  _____
 *       /    | 		 /     \
 *      /     ||  		/      |
 *      \     ||   	=>	\      |
 *       \    ||		 \     |
 *        \___||		  \____|
 *
 */
================================================================================

文件路径: ./isl_coalesce.c
注释行数: 21
注释内容:
/* Given a cut constraint t(x) >= 0 of basic map i, stored in row "w"
 * of wrap.mat, replace it by its relaxed version t(x) + 1 >= 0, and
 * add wrapping constraints to wrap.mat for all constraints
 * of basic map j that bound the part of basic map j that sticks out
 * of the cut constraint.
 * "set_i" is the underlying set of basic map i.
 * If any wrapping fails, then wraps->mat.n_row is reset to zero.
 *
 * In particular, we first intersect basic map j with t(x) + 1 = 0.
 * If the result is empty, then t(x) >= 0 was actually a valid constraint
 * (with respect to the integer points), so we add t(x) >= 0 instead.
 * Otherwise, we wrap the constraints of basic map j that are not
 * redundant in this intersection and that are not already valid
 * for basic map i over basic map i.
 * Note that it is sufficient to wrap the constraints to include
 * basic map i, because we will only wrap the constraints that do
 * not include basic map i already.  The wrapped constraint will
 * therefore be more relaxed compared to the original constraint.
 * Since the original constraint is valid for basic map j, so is
 * the wrapped constraint.
 */
================================================================================

文件路径: ./isl_coalesce.c
注释行数: 17
注释内容:
/* Given a pair of basic maps i and j such that j sticks out
 * of i at n cut constraints, each time by at most one,
 * try to compute wrapping constraints and replace the two
 * basic maps by a single basic map.
 * The other constraints of i are assumed to be valid for j.
 * "set_i" is the underlying set of basic map i.
 * "wraps" has been initialized to be of the right size.
 *
 * For each cut constraint t(x) >= 0 of i, we add the relaxed version
 * t(x) + 1 >= 0, along with wrapping constraints for all constraints
 * of basic map j that bound the part of basic map j that sticks out
 * of the cut constraint.
 *
 * If any wrapping fails, i.e., if we cannot wrap to touch
 * the union, then we give up.
 * Otherwise, the pair of basic maps is replaced by their union.
 */
================================================================================

文件路径: ./isl_coalesce.c
注释行数: 11
注释内容:
/* Given a pair of basic maps i and j such that j sticks out
 * of i at n cut constraints, each time by at most one,
 * try to compute wrapping constraints and replace the two
 * basic maps by a single basic map.
 * The other constraints of i are assumed to be valid for j.
 *
 * The core computation is performed by try_wrap_in_facets.
 * This function simply extracts an underlying set representation
 * of basic map i and initializes the data structure for keeping
 * track of wrapping constraints.
 */
================================================================================

文件路径: ./isl_coalesce.c
注释行数: 59
注释内容:
/* Given two basic sets i and j,
 * check if relaxing all the cut constraints of i by one turns
 * them into valid constraint for j and check if we can wrap in
 * the bits that are sticking out.
 * If so, replace the pair by their union.
 *
 * We first check if all relaxed cut inequalities of i are valid for j
 * and then try to wrap in the intersections of the relaxed cut inequalities
 * with j.
 *
 * During this wrapping, we consider the points of j that lie at a distance
 * of exactly 1 from i.  In particular, we ignore the points that lie in
 * between this lower-dimensional space and the basic map i.
 * We can therefore only apply this to integer maps.
 *        ____			  _____
 *       / ___|_		 /     \
 *      / |    |  		/      |
 *      \ |    |   	=>	\      |
 *       \|____|		 \     |
 *        \___| 		  \____/
 *
 *	 _____			 ______
 *	| ____|_		|      \
 *	| |     |		|       |
 *	| |	|	=>	|       |
 *	|_|     |		|       |
 *	  |_____|		 \______|
 *
 *	 _______
 *	|       |
 *	|  |\   |
 *	|  | \  |
 *	|  |  \ |
 *	|  |   \|
 *	|  |    \
 *	|  |_____\
 *	|       |
 *	|_______|
 *
 * Wrapping can fail if the result of wrapping one of the facets
 * around its edges does not produce any new facet constraint.
 * In particular, this happens when we try to wrap in unbounded sets.
 *
 *	 _______________________________________________________________________
 *	|
 *	|  ___
 *	| |   |
 *	|_|   |_________________________________________________________________
 *	  |___|
 *
 * The following is not an acceptable result of coalescing the above two
 * sets as it includes extra integer points.
 *	 _______________________________________________________________________
 *	|
 *	|     
 *	|      
 *	|
 *	 \______________________________________________________________________
 */
================================================================================

文件路径: ./isl_coalesce.c
注释行数: 16
注释内容:
/* Given two basic maps such that "j" has at least one equality constraint
 * that is adjacent to an inequality constraint of "i" and such that "i" has
 * exactly one inequality constraint that is adjacent to an equality
 * constraint of "j", check whether "i" can be extended to include "j" or
 * whether "j" can be wrapped into "i".
 * All remaining constraints of "i" and "j" are assumed to be valid
 * or cut constraints of the other basic map.
 * However, none of the equality constraints of "i" are cut constraints.
 *
 * If "i" has any "cut" inequality constraints, then check if relaxing
 * each of them by one is sufficient for them to become valid.
 * If so, check if the inequality constraint adjacent to an equality
 * constraint of "j" along with all these cut constraints
 * can be relaxed by one to contain exactly "j".
 * Otherwise, or if this fails, check if "j" can be wrapped into "i".
 */
================================================================================

文件路径: ./isl_coalesce.c
注释行数: 10
注释内容:
/* At least one of the basic maps has an equality that is adjacent
 * to an inequality.  Make sure that only one of the basic maps has
 * such an equality and that the other basic map has exactly one
 * inequality adjacent to an equality.
 * If the other basic map does not have such an inequality, then
 * check if all its constraints are either valid or cut constraints
 * and, if so, try wrapping in the first map into the second.
 * Otherwise, try to extend one basic map with the other or
 * wrap one basic map in the other.
 */
================================================================================

文件路径: ./isl_coalesce.c
注释行数: 12
注释内容:
/* Disjunct "j" lies on a hyperplane that is adjacent to disjunct "i".
 * In particular, disjunct "i" has an inequality constraint that is adjacent
 * to a (combination of) equality constraint(s) of disjunct "j",
 * but disjunct "j" has no explicit equality constraint adjacent
 * to an inequality constraint of disjunct "i".
 *
 * Disjunct "i" is already known not to have any equality constraints
 * that are adjacent to an equality or inequality constraint.
 * Check that, other than the inequality constraint mentioned above,
 * all other constraints of disjunct "i" are valid for disjunct "j".
 * If so, try and wrap in disjunct "j".
 */
================================================================================

文件路径: ./isl_coalesce.c
注释行数: 18
注释内容:
/* The two basic maps lie on adjacent hyperplanes.  In particular,
 * basic map "i" has an equality that lies parallel to basic map "j".
 * Check if we can wrap the facets around the parallel hyperplanes
 * to include the other set.
 *
 * We perform basically the same operations as can_wrap_in_facet,
 * except that we don't need to select a facet of one of the sets.
 *				_
 *	\\			\\
 *	 \\		=>	 \\
 *	  \			  \|
 *
 * If there is more than one equality of "i" adjacent to an equality of "j",
 * then the result will satisfy one or more equalities that are a linear
 * combination of these equalities.  These will be encoded as pairs
 * of inequalities in the wrapping constraints and need to be made
 * explicit.
 */
================================================================================

文件路径: ./isl_coalesce.c
注释行数: 12
注释内容:
/* Basic map "i" has one or more equality constraints that separate it
 * from basic map "j".  Check if it happens to be an extension
 * of basic map "j".
 * In particular, check that all constraints of "j" are valid for "i",
 * except for one inequality constraint that is adjacent
 * to an inequality constraints of "i".
 * If so, check for "i" being an extension of "j" by calling
 * is_adj_ineq_extension.
 *
 * Clean up the memory allocated for keeping track of the status
 * of the constraints before returning.
 */
================================================================================

文件路径: ./isl_coalesce.c
注释行数: 86
注释内容:
/* Check if the union of the given pair of basic maps
 * can be represented by a single basic map.
 * If so, replace the pair by the single basic map and return
 * isl_change_drop_first, isl_change_drop_second or isl_change_fuse.
 * Otherwise, return isl_change_none.
 * The two basic maps are assumed to live in the same local space.
 * The "eq" and "ineq" fields of info[i] and info[j] are assumed
 * to have been initialized by the caller, either to NULL or
 * to valid information.
 *
 * We first check the effect of each constraint of one basic map
 * on the other basic map.
 * The constraint may be
 *	redundant	the constraint is redundant in its own
 *			basic map and should be ignore and removed
 *			in the end
 *	valid		all (integer) points of the other basic map
 *			satisfy the constraint
 *	separate	no (integer) point of the other basic map
 *			satisfies the constraint
 *	cut		some but not all points of the other basic map
 *			satisfy the constraint
 *	adj_eq		the given constraint is adjacent (on the outside)
 *			to an equality of the other basic map
 *	adj_ineq	the given constraint is adjacent (on the outside)
 *			to an inequality of the other basic map
 *
 * We consider seven cases in which we can replace the pair by a single
 * basic map.  We ignore all "redundant" constraints.
 *
 *	1. all constraints of one basic map are valid
 *		=> the other basic map is a subset and can be removed
 *
 *	2. all constraints of both basic maps are either "valid" or "cut"
 *	   and the facets corresponding to the "cut" constraints
 *	   of one of the basic maps lies entirely inside the other basic map
 *		=> the pair can be replaced by a basic map consisting
 *		   of the valid constraints in both basic maps
 *
 *	3. there is a single pair of adjacent inequalities
 *	   (all other constraints are "valid")
 *		=> the pair can be replaced by a basic map consisting
 *		   of the valid constraints in both basic maps
 *
 *	4. one basic map has a single adjacent inequality, while the other
 *	   constraints are "valid".  The other basic map has some
 *	   "cut" constraints, but replacing the adjacent inequality by
 *	   its opposite and adding the valid constraints of the other
 *	   basic map results in a subset of the other basic map
 *		=> the pair can be replaced by a basic map consisting
 *		   of the valid constraints in both basic maps
 *
 *	5. there is a single adjacent pair of an inequality and an equality,
 *	   the other constraints of the basic map containing the inequality are
 *	   "valid".  Moreover, if the inequality the basic map is relaxed
 *	   and then turned into an equality, then resulting facet lies
 *	   entirely inside the other basic map
 *		=> the pair can be replaced by the basic map containing
 *		   the inequality, with the inequality relaxed.
 *
 *	6. there is a single inequality adjacent to an equality,
 *	   the other constraints of the basic map containing the inequality are
 *	   "valid".  Moreover, the facets corresponding to both
 *	   the inequality and the equality can be wrapped around their
 *	   ridges to include the other basic map
 *		=> the pair can be replaced by a basic map consisting
 *		   of the valid constraints in both basic maps together
 *		   with all wrapping constraints
 *
 *	7. one of the basic maps extends beyond the other by at most one.
 *	   Moreover, the facets corresponding to the cut constraints and
 *	   the pieces of the other basic map at offset one from these cut
 *	   constraints can be wrapped around their ridges to include
 *	   the union of the two basic maps
 *		=> the pair can be replaced by a basic map consisting
 *		   of the valid constraints in both basic maps together
 *		   with all wrapping constraints
 *
 *	8. the two basic maps live in adjacent hyperplanes.  In principle
 *	   such sets can always be combined through wrapping, but we impose
 *	   that there is only one such pair, to avoid overeager coalescing.
 *
 * Throughout the computation, we maintain a collection of tableaus
 * corresponding to the basic maps.  When the basic maps are dropped
 * or combined, the tableaus are modified accordingly.
 */
================================================================================

文件路径: ./isl_coalesce.c
注释行数: 11
注释内容:
/* Shift the integer division at position "div" of the basic map
 * represented by "info" by "shift".
 *
 * That is, if the integer division has the form
 *
 *	floor(f(x)/d)
 *
 * then replace it by
 *
 *	floor((f(x) + shift * d)/d) - shift
 */
================================================================================

文件路径: ./isl_coalesce.c
注释行数: 29
注释内容:
/* If the integer division at position "div" is defined by an equality,
 * i.e., a stride constraint, then change the integer division expression
 * to have a constant term equal to zero.
 *
 * Let the equality constraint be
 *
 *	c + f + m a = 0
 *
 * The integer division expression is then typically of the form
 *
 *	a = floor((-f - c')/m)
 *
 * The integer division is first shifted by t = floor(c/m),
 * turning the equality constraint into
 *
 *	c - m floor(c/m) + f + m a' = 0
 *
 * i.e.,
 *
 *	(c mod m) + f + m a' = 0
 *
 * That is,
 *
 *	a' = (-f - (c mod m))/m = floor((-f)/m)
 *
 * because a' is an integer and 0 <= (c mod m) < m.
 * The constant term of a' can therefore be zeroed out,
 * but only if the integer division expression is of the expected form.
 */
================================================================================

文件路径: ./isl_coalesce.c
注释行数: 12
注释内容:
/* The basic maps represented by "info1" and "info2" are known
 * to have the same number of integer divisions.
 * Check if pairs of integer divisions are equal to each other
 * despite the fact that they differ by a rational constant.
 *
 * In particular, look for any pair of integer divisions that
 * only differ in their constant terms.
 * If either of these integer divisions is defined
 * by stride constraints, then modify it to have a zero constant term.
 * If both are defined by stride constraints then in the end they will have
 * the same (zero) constant term.
 */
================================================================================

文件路径: ./isl_coalesce.c
注释行数: 13
注释内容:
/* If "shift" is an integer constant, then shift the integer division
 * at position "div" of the basic map represented by "info" by "shift".
 * If "shift" is not an integer constant, then do nothing.
 * If "shift" is equal to zero, then no shift needs to be performed either.
 *
 * That is, if the integer division has the form
 *
 *	floor(f(x)/d)
 *
 * then replace it by
 *
 *	floor((f(x) + shift * d)/d) - shift
 */
================================================================================

文件路径: ./isl_coalesce.c
注释行数: 33
注释内容:
/* Check if some of the divs in the basic map represented by "info1"
 * are shifts of the corresponding divs in the basic map represented
 * by "info2", taking into account the equality constraints "eq1" of "info1"
 * and "eq2" of "info2".  If so, align them with those of "info2".
 * "info1" and "info2" are assumed to have the same number
 * of integer divisions.
 *
 * An integer division is considered to be a shift of another integer
 * division if, after simplification with respect to the equality
 * constraints of the other basic map, one is equal to the other
 * plus a constant.
 *
 * In particular, for each pair of integer divisions, if both are known,
 * have the same denominator and are not already equal to each other,
 * simplify each with respect to the equality constraints
 * of the other basic map.  If the difference is an integer constant,
 * then move this difference outside.
 * That is, if, after simplification, one integer division is of the form
 *
 *	floor((f(x) + c_1)/d)
 *
 * while the other is of the form
 *
 *	floor((f(x) + c_2)/d)
 *
 * and n = (c_2 - c_1)/d is an integer, then replace the first
 * integer division by
 *
 *	floor((f_1(x) + c_1 + n * d)/d) - n,
 *
 * where floor((f_1(x) + c_1 + n * d)/d) = floor((f2(x) + c_2)/d)
 * after simplification with respect to the equality constraints.
 */
================================================================================

文件路径: ./isl_coalesce.c
注释行数: 23
注释内容:
/* Check if some of the divs in the basic map represented by "info1"
 * are shifts of the corresponding divs in the basic map represented
 * by "info2".  If so, align them with those of "info2".
 * Only do this if "info1" and "info2" have the same number
 * of integer divisions.
 *
 * An integer division is considered to be a shift of another integer
 * division if, after simplification with respect to the equality
 * constraints of the other basic map, one is equal to the other
 * plus a constant.
 *
 * First check if pairs of integer divisions are equal to each other
 * despite the fact that they differ by a rational constant.
 * If so, try and arrange for them to have the same constant term.
 *
 * Then, extract the equality constraints and continue with
 * harmonize_divs_with_hulls.
 *
 * If the equality constraints of both basic maps are the same,
 * then there is no need to perform any shifting since
 * the coefficients of the integer divisions should have been
 * reduced in the same way.
 */
================================================================================

文件路径: ./isl_coalesce.c
注释行数: 27
注释内容:
/* For each of the "n" integer division variables "expanded",
 * if the variable has a fixed value, then add two inequality
 * constraints expressing the fixed value.
 * Otherwise, add the corresponding div constraints.
 * The caller is responsible for removing the div constraints
 * that it added for all these "n" integer divisions.
 *
 * The div constraints and the pair of inequality constraints
 * forcing the fixed value cannot both be added for a given variable
 * as the combination may render some of the original constraints redundant.
 * These would then be ignored during the coalescing detection,
 * while they could remain in the fused result.
 *
 * The two added inequality constraints are
 *
 *	-a + v >= 0
 *	a - v >= 0
 *
 * with "a" the variable and "v" its fixed value.
 * The facet corresponding to one of these two constraints is selected
 * in the tableau to ensure that the pair of inequality constraints
 * is treated as an equality constraint.
 *
 * The information in info->ineq is thrown away because it was
 * computed in terms of div constraints, while some of those
 * have now been replaced by these pairs of inequality constraints.
 */
================================================================================

文件路径: ./isl_coalesce.c
注释行数: 30
注释内容:
/* Insert the "n" integer division variables "expanded"
 * into info->tab and info->bmap and
 * update info->ineq with respect to the redundant constraints
 * in the resulting tableau.
 * "bmap" contains the result of this insertion in info->bmap,
 * while info->bmap is the original version
 * of "bmap", i.e., the one that corresponds to the current
 * state of info->tab.  The number of constraints in info->bmap
 * is assumed to be the same as the number of constraints
 * in info->tab.  This is required to be able to detect
 * the extra constraints in "bmap".
 *
 * In particular, introduce extra variables corresponding
 * to the extra integer divisions and add the div constraints
 * that were added to "bmap" after info->tab was created
 * from info->bmap.
 * Furthermore, check if these extra integer divisions happen
 * to attain a fixed integer value in info->tab.
 * If so, replace the corresponding div constraints by pairs
 * of inequality constraints that fix these
 * integer divisions to their single integer values.
 * Replace info->bmap by "bmap" to match the changes to info->tab.
 * info->ineq was computed without a tableau and therefore
 * does not take into account the redundant constraints
 * in the tableau.  Mark them here.
 * There is no need to check the newly added div constraints
 * since they cannot be redundant.
 * The redundancy check is not performed when constants have been discovered
 * since info->ineq is completely thrown away in this case.
 */
================================================================================

文件路径: ./isl_coalesce.c
注释行数: 13
注释内容:
/* Expand info->tab and info->bmap in the same way "bmap" was expanded
 * in isl_basic_map_expand_divs using the expansion "exp" and
 * update info->ineq with respect to the redundant constraints
 * in the resulting tableau. info->bmap is the original version
 * of "bmap", i.e., the one that corresponds to the current
 * state of info->tab.  The number of constraints in info->bmap
 * is assumed to be the same as the number of constraints
 * in info->tab.  This is required to be able to detect
 * the extra constraints in "bmap".
 *
 * Extract the positions where extra local variables are introduced
 * from "exp" and call tab_insert_divs.
 */
================================================================================

文件路径: ./isl_coalesce.c
注释行数: 30
注释内容:
/* Check if the union of the basic maps represented by info[i] and info[j]
 * can be represented by a single basic map,
 * after expanding the divs of info[i] to match those of info[j].
 * If so, replace the pair by the single basic map and return
 * isl_change_drop_first, isl_change_drop_second or isl_change_fuse.
 * Otherwise, return isl_change_none.
 *
 * The caller has already checked for info[j] being a subset of info[i].
 * If some of the divs of info[j] are unknown, then the expanded info[i]
 * will not have the corresponding div constraints.  The other patterns
 * therefore cannot apply.  Skip the computation in this case.
 *
 * The expansion is performed using the divs "div" and expansion "exp"
 * computed by the caller.
 * info[i].bmap has already been expanded and the result is passed in
 * as "bmap".
 * The "eq" and "ineq" fields of info[i] reflect the status of
 * the constraints of the expanded "bmap" with respect to info[j].tab.
 * However, inequality constraints that are redundant in info[i].tab
 * have not yet been marked as such because no tableau was available.
 *
 * Replace info[i].bmap by "bmap" and expand info[i].tab as well,
 * updating info[i].ineq with respect to the redundant constraints.
 * Then try and coalesce the expanded info[i] with info[j],
 * reusing the information in info[i].eq and info[i].ineq.
 * If this does not result in any coalescing or if it results in info[j]
 * getting dropped (which should not happen in practice, since the case
 * of info[j] being a subset of info[i] has already been checked by
 * the caller), then revert info[i] to its original state.
 */
================================================================================

文件路径: ./isl_coalesce.c
注释行数: 24
注释内容:
/* Check if the union of "bmap" and the basic map represented by info[j]
 * can be represented by a single basic map,
 * after expanding the divs of "bmap" to match those of info[j].
 * If so, replace the pair by the single basic map and return
 * isl_change_drop_first, isl_change_drop_second or isl_change_fuse.
 * Otherwise, return isl_change_none.
 *
 * In particular, check if the expanded "bmap" contains the basic map
 * represented by the tableau info[j].tab.
 * The expansion is performed using the divs "div" and expansion "exp"
 * computed by the caller.
 * Then we check if all constraints of the expanded "bmap" are valid for
 * info[j].tab.
 *
 * If "i" is not equal to -1, then "bmap" is equal to info[i].bmap.
 * In this case, the positions of the constraints of info[i].bmap
 * with respect to the basic map represented by info[j] are stored
 * in info[i].
 *
 * If the expanded "bmap" does not contain the basic map
 * represented by the tableau info[j].tab and if "i" is not -1,
 * i.e., if the original "bmap" is info[i].bmap, then expand info[i].tab
 * as well and check if that results in coalescing.
 */
================================================================================

文件路径: ./isl_coalesce.c
注释行数: 18
注释内容:
/* Check if the union of "bmap_i" and the basic map represented by info[j]
 * can be represented by a single basic map,
 * after aligning the divs of "bmap_i" to match those of info[j].
 * If so, replace the pair by the single basic map and return
 * isl_change_drop_first, isl_change_drop_second or isl_change_fuse.
 * Otherwise, return isl_change_none.
 *
 * In particular, check if "bmap_i" contains the basic map represented by
 * info[j] after aligning the divs of "bmap_i" to those of info[j].
 * Note that this can only succeed if the number of divs of "bmap_i"
 * is smaller than (or equal to) the number of divs of info[j].
 *
 * We first check if the divs of "bmap_i" are all known and form a subset
 * of those of info[j].bmap.  If so, we pass control over to
 * coalesce_with_expanded_divs.
 *
 * If "i" is not equal to -1, then "bmap" is equal to info[i].bmap.
 */
================================================================================

文件路径: ./isl_coalesce.c
注释行数: 17
注释内容:
/* Check if basic map "j" is a subset of basic map "i" after
 * exploiting the extra equalities of "j" to simplify the divs of "i".
 * If so, remove basic map "j" and return isl_change_drop_second.
 *
 * If "j" does not have any equalities or if they are the same
 * as those of "i", then we cannot exploit them to simplify the divs.
 * Similarly, if there are no divs in "i", then they cannot be simplified.
 * If, on the other hand, the affine hulls of "i" and "j" do not intersect,
 * then "j" cannot be a subset of "i".
 *
 * Otherwise, we intersect "i" with the affine hull of "j" and then
 * check if "j" is a subset of the result after aligning the divs.
 * If so, then "j" is definitely a subset of "i" and can be removed.
 * Note that if after intersection with the affine hull of "j".
 * "i" still has more divs than "j", then there is no way we can
 * align the divs of "i" to those of "j".
 */
================================================================================

文件路径: ./isl_coalesce.c
注释行数: 15
注释内容:
/* Check if the union of and the basic maps represented by info[i] and info[j]
 * can be represented by a single basic map, by aligning or equating
 * their integer divisions.
 * If so, replace the pair by the single basic map and return
 * isl_change_drop_first, isl_change_drop_second or isl_change_fuse.
 * Otherwise, return isl_change_none.
 *
 * Note that we only perform any test if the number of divs is different
 * in the two basic maps.  In case the number of divs is the same,
 * we have already established that the divs are different
 * in the two basic maps.
 * In particular, if the number of divs of basic map i is smaller than
 * the number of divs of basic map j, then we check if j is a subset of i
 * and vice versa.
 */
================================================================================

文件路径: ./isl_coalesce.c
注释行数: 11
注释内容:
/* Return a list of affine expressions, one for each integer division
 * in "bmap_i".  For each integer division that also appears in "bmap_j",
 * the affine expression is set to NaN.  The number of NaNs in the list
 * is equal to the number of integer divisions in "bmap_j".
 * For the other integer divisions of "bmap_i", the corresponding
 * element in the list is a purely affine expression equal to the integer
 * division in "hull".
 * If no such list can be constructed, then the number of elements
 * in the returned list is smaller than the number of integer divisions
 * in "bmap_i".
 */
================================================================================

文件路径: ./isl_coalesce.c
注释行数: 16
注释内容:
/* Add variables to info->bmap and info->tab corresponding to the elements
 * in "list" that are not set to NaN.
 * "extra_var" is the number of these elements.
 * "dim" is the offset in the variables of "tab" where we should
 * start considering the elements in "list".
 * When this function returns, the total number of variables in "tab"
 * is equal to "dim" plus the number of elements in "list".
 *
 * The newly added existentially quantified variables are not given
 * an explicit representation because the corresponding div constraints
 * do not appear in info->bmap.  These constraints are not added
 * to info->bmap because for internal consistency, they would need to
 * be added to info->tab as well, where they could combine with the equality
 * that is added later to result in constraints that do not hold
 * in the original input.
 */
================================================================================

文件路径: ./isl_coalesce.c
注释行数: 13
注释内容:
/* Coalesce basic map "j" into basic map "i" after adding the extra integer
 * divisions in "i" but not in "j" to basic map "j", with values
 * specified by "list".  The total number of elements in "list"
 * is equal to the number of integer divisions in "i", while the number
 * of NaN elements in the list is equal to the number of integer divisions
 * in "j".
 *
 * If no coalescing can be performed, then we need to revert basic map "j"
 * to its original state.  We do the same if basic map "i" gets dropped
 * during the coalescing, even though this should not happen in practice
 * since we have already checked for "j" being a subset of "i"
 * before we reach this stage.
 */
================================================================================

文件路径: ./isl_coalesce.c
注释行数: 14
注释内容:
/* Check if we can coalesce basic map "j" into basic map "i" after copying
 * those extra integer divisions in "i" that can be simplified away
 * using the extra equalities in "j".
 * All divs are assumed to be known and not contain any nested divs.
 *
 * We first check if there are any extra equalities in "j" that we
 * can exploit.  Then we check if every integer division in "i"
 * either already appears in "j" or can be simplified using the
 * extra equalities to a purely affine expression.
 * If these tests succeed, then we try to coalesce the two basic maps
 * by introducing extra dimensions in "j" corresponding to
 * the extra integer divisions "i" fixed to the corresponding
 * purely affine expression.
 */
================================================================================

文件路径: ./isl_coalesce.c
注释行数: 20
注释内容:
/* Check if the union of the given pair of basic maps
 * can be represented by a single basic map.
 * If so, replace the pair by the single basic map and return
 * isl_change_drop_first, isl_change_drop_second or isl_change_fuse.
 * Otherwise, return isl_change_none.
 *
 * We first check if the two basic maps live in the same local space,
 * after aligning the divs that differ by only an integer constant.
 * If so, we do the complete check.  Otherwise, we check if they have
 * the same number of integer divisions and can be coalesced, if one is
 * an obvious subset of the other or if the extra integer divisions
 * of one basic map can be simplified away using the extra equalities
 * of the other basic map.
 *
 * Note that trying to coalesce pairs of disjuncts with the same
 * number, but different local variables may drop the explicit
 * representation of some of these local variables.
 * This operation is therefore not performed when
 * the "coalesce_preserve_locals" option is set.
 */
================================================================================

文件路径: ./isl_coalesce.c
注释行数: 14
注释内容:
/* Pairwise coalesce the basic maps in the range [start1, end1[ of "info"
 * with those in the range [start2, end2[, skipping basic maps
 * that have been removed (either before or within this function).
 *
 * For each basic map i in the first range, we check if it can be coalesced
 * with respect to any previously considered basic map j in the second range.
 * If i gets dropped (because it was a subset of some j), then
 * we can move on to the next basic map.
 * If j gets dropped, we need to continue checking against the other
 * previously considered basic maps.
 * If the two basic maps got fused, then we recheck the fused basic map
 * against the previously considered basic maps, starting at i + 1
 * (even if start2 is greater than i + 1).
 */
================================================================================

文件路径: ./isl_coalesce.c
注释行数: 12
注释内容:
/* Update the basic maps in "map" based on the information in "info".
 * In particular, remove the basic maps that have been marked removed and
 * update the others based on the information in the corresponding tableau.
 * Since we detected implicit equalities without calling
 * isl_basic_map_gauss, we need to do it now.
 * Also call isl_basic_map_simplify if we may have lost the definition
 * of one or more integer divisions.
 * If a basic map is still equal to the one from which the corresponding "info"
 * entry was created, then redundant constraint and
 * implicit equality constraint detection have been performed
 * on the corresponding tableau and the basic map can be marked as such.
 */
================================================================================

文件路径: ./isl_coalesce.c
注释行数: 25
注释内容:
/* For each pair of basic maps in the map, check if the union of the two
 * can be represented by a single basic map.
 * If so, replace the pair by the single basic map and start over.
 *
 * We factor out any (hidden) common factor from the constraint
 * coefficients to improve the detection of adjacent constraints.
 * Note that this function does not call isl_basic_map_gauss,
 * but it does make sure that only a single copy of the basic map
 * is affected.  This means that isl_basic_map_gauss may have
 * to be called at the end of the computation (in update_basic_maps)
 * on this single copy to ensure that
 * the basic maps are not left in an unexpected state.
 *
 * Since we are constructing the tableaus of the basic maps anyway,
 * we exploit them to detect implicit equalities and redundant constraints.
 * This also helps the coalescing as it can ignore the redundant constraints.
 * In order to avoid confusion, we make all implicit equalities explicit
 * in the basic maps.  If the basic map only has a single reference
 * (this happens in particular if it was modified by
 * isl_basic_map_reduce_coefficients), then isl_basic_map_gauss
 * does not get called on the result.  The call to
 * isl_basic_map_gauss in update_basic_maps resolves this as well.
 * For each basic map, we also compute the hash of the apparent affine hull
 * for use in coalesce.
 */
================================================================================

文件路径: ./isl_pw_templ.c
注释行数: 12
注释内容:
/*
 * Copyright 2010-2011 INRIA Saclay
 * Copyright 2011      Sven Verdoolaege
 * Copyright 2012-2014 Ecole Normale Superieure
 *
 * Use of this software is governed by the MIT license
 *
 * Written by Sven Verdoolaege, INRIA Saclay - Ile-de-France,
 * Parc Club Orsay Universite, ZAC des vignes, 4 rue Jacques Monod,
 * 91893 Orsay, France
 * and Ecole Normale Superieure, 45 rue d’Ulm, 75230 Paris, France
 */
================================================================================

文件路径: ./isl_pw_templ.c
注释行数: 11
注释内容:
/* Return the base expression associated to
 * the cell at position "pos" in "pw".
 * This may be either a copy or the base expression itself
 * if there is only one reference to "pw".
 * This allows the base expression to be modified inplace
 * if both the piecewise expression and this base expression
 * have only a single reference.
 * The caller is not allowed to modify "pw" between this call and
 * a subsequent call to isl_pw_*_restore_*.
 * The only exception is that isl_pw_*_free can be called instead.
 */
================================================================================

文件路径: ./isl_union_multi.c
注释行数: 14
注释内容:
/*
 * Copyright 2010      INRIA Saclay
 * Copyright 2013      Ecole Normale Superieure
 * Copyright 2015      INRIA Paris-Rocquencourt
 *
 * Use of this software is governed by the MIT license
 *
 * Written by Sven Verdoolaege, INRIA Saclay - Ile-de-France,
 * Parc Club Orsay Universite, ZAC des vignes, 4 rue Jacques Monod,
 * 91893 Orsay, France
 * and Ecole Normale Superieure, 45 rue d'Ulm, 75230 Paris, France
 * and INRIA Paris-Rocquencourt, Domaine de Voluceau, Rocquenqourt, B.P. 105,
 * 78153 Le Chesnay Cedex France
 */
================================================================================

文件路径: ./isl_union_multi.c
注释行数: 10
注释内容:
/* Return the entry, if any, in "u" that lives in "space".
 * If "reserve" is set, then an entry is created if it does not exist yet.
 * Return NULL on error and isl_hash_table_entry_none if no entry was found.
 * Note that when "reserve" is set, the function will never return
 * isl_hash_table_entry_none.
 *
 * First look for the group of expressions with the same domain space,
 * creating one if needed.
 * Then look for the expression living in the specified space in that group.
 */
================================================================================

文件路径: ./isl_schedule.c
注释行数: 12
注释内容:
/*
 * Copyright 2011      INRIA Saclay
 * Copyright 2012-2014 Ecole Normale Superieure
 * Copyright 2016      Sven Verdoolaege
 *
 * Use of this software is governed by the MIT license
 *
 * Written by Sven Verdoolaege, INRIA Saclay - Ile-de-France,
 * Parc Club Orsay Universite, ZAC des vignes, 4 rue Jacques Monod,
 * 91893 Orsay, France
 * and Ecole Normale Superieure, 45 rue d'Ulm, 75230 Paris, France
 */
================================================================================

文件路径: ./isl_schedule.c
注释行数: 11
注释内容:
/* Return a schedule encapsulating the given schedule tree.
 *
 * We currently only allow schedule trees with a domain or extension as root.
 *
 * The leaf field is initialized as a leaf node so that it can be
 * used to represent leaves in the constructed schedule.
 * The reference count is set to -1 since the isl_schedule_tree
 * should never be freed.  It is up to the (internal) users of
 * these leaves to ensure that they are only used while the schedule
 * is still alive.
 */
================================================================================

文件路径: ./isl_schedule.c
注释行数: 12
注释内容:
/* Construct a schedule that combines the schedules "schedule1" and "schedule2"
 * with a top-level node (underneath the domain node) of type "type",
 * either isl_schedule_node_sequence or isl_schedule_node_set.
 * The domains of the two schedules are assumed to be disjoint.
 *
 * The new schedule has as domain the union of the domains of the two
 * schedules.  The child of the domain node is a node of type "type"
 * with two filters corresponding to the domains of the input schedules.
 * If one (or both) of the top-level nodes of the two schedules is itself
 * of type "type", then the filter is pushed into the children of that
 * node and the sequence or set is flattened.
 */
================================================================================

文件路径: ./isl_constraint.c
注释行数: 11
注释内容:
/*
 * Copyright 2008-2009 Katholieke Universiteit Leuven
 * Copyright 2010      INRIA Saclay
 *
 * Use of this software is governed by the MIT license
 *
 * Written by Sven Verdoolaege, K.U.Leuven, Departement
 * Computerwetenschappen, Celestijnenlaan 200A, B-3001 Leuven, Belgium
 * and INRIA Saclay - Ile-de-France, Parc Club Orsay Universite,
 * ZAC des vignes, 4 rue Jacques Monod, 91893 Orsay, France 
 */
================================================================================

文件路径: ./isl_constraint.c
注释行数: 14
注释内容:
/* Is "constraint" an equality that corresponds to integer division "div"?
 *
 * That is, given an integer division of the form
 *
 *	a = floor((f + c)/m)
 *
 * is the equality of the form
 *
 *		-f + m d + c' = 0
 * ?
 * Note that the constant term is not checked explicitly, but given
 * that this is a valid equality constraint, the constant c' necessarily
 * has a value close to -c.
 */
================================================================================

文件路径: ./isl_constraint.c
注释行数: 16
注释内容:
/* For each pair of lower and upper bounds on the variable "pos"
 * of type "type", call "fn" with these lower and upper bounds and the
 * set of constraints on the remaining variables where these bounds
 * are active, i.e., (stricly) larger/smaller than the other lower/upper bounds.
 *
 * If the designated variable is equal to an affine combination of the
 * other variables then fn is called with both lower and upper
 * set to the corresponding equality.
 *
 * If there is no lower (or upper) bound, then NULL is passed
 * as the corresponding bound.
 *
 * We first check if the variable is involved in any equality.
 * If not, we count the number of lower and upper bounds and
 * act accordingly.
 */
================================================================================

文件路径: ./isl_constraint.c
注释行数: 10
注释内容:
/* For an inequality constraint
 *
 *	f >= 0
 *
 * or an equality constraint
 *
 *	f = 0
 *
 * return the affine expression f.
 */
================================================================================

文件路径: ./isl_constraint.c
注释行数: 11
注释内容:
/* Compare two constraints based on their final (non-zero) coefficients.
 * In particular, the constraint that involves later variables or
 * that has a larger coefficient for a shared latest variable
 * is considered "greater" than the other constraint.
 *
 * Return -1 if "c1" is "smaller" than "c2", 1 if "c1" is "greater"
 * than "c2" and 0 if they are equal.
 *
 * If the constraints live in different local spaces, then we cannot
 * really compare the constraints so we compare the local spaces instead.
 */
================================================================================

文件路径: ./isl_flow.c
注释行数: 17
注释内容:
/*
 * Copyright 2005-2007 Universiteit Leiden
 * Copyright 2008-2009 Katholieke Universiteit Leuven
 * Copyright 2010      INRIA Saclay
 * Copyright 2012      Universiteit Leiden
 * Copyright 2014      Ecole Normale Superieure
 *
 * Use of this software is governed by the MIT license
 *
 * Written by Sven Verdoolaege, Leiden Institute of Advanced Computer Science,
 * Universiteit Leiden, Niels Bohrweg 1, 2333 CA Leiden, The Netherlands
 * and K.U.Leuven, Departement Computerwetenschappen, Celestijnenlaan 200A,
 * B-3001 Leuven, Belgium
 * and INRIA Saclay - Ile-de-France, Parc Club Orsay Universite,
 * ZAC des vignes, 4 rue Jacques Monod, 91893 Orsay, France 
 * and Ecole Normale Superieure, 45 rue d'Ulm, 75230 Paris, France
 */
================================================================================

文件路径: ./isl_flow.c
注释行数: 17
注释内容:
/* A structure containing the input for dependence analysis:
 * - a sink
 * - n_must + n_may (<= max_source) sources
 * - a function for determining the relative order of sources and sink
 * - an optional function "coscheduled" for determining whether sources
 *   may be coscheduled.  If "coscheduled" is NULL, then the sources
 *   are assumed not to be coscheduled.
 * The must sources are placed before the may sources.
 *
 * domain_map is an auxiliary map that maps the sink access relation
 * to the domain of this access relation.
 * This field is only needed when restrict_fn is set and
 * the field itself is set by isl_access_info_compute_flow.
 *
 * restrict_fn is a callback that (if not NULL) will be called
 * right before any lexicographical maximization.
 */
================================================================================

文件路径: ./isl_flow.c
注释行数: 16
注释内容:
/* Return -n, 0 or n (with n a positive value), depending on whether
 * the source access identified by p1 should be sorted before, together
 * or after that identified by p2.
 *
 * If p1 appears before p2, then it should be sorted first.
 * For more generic initial schedules, it is possible that neither
 * p1 nor p2 appears before the other, or at least not in any obvious way.
 * We therefore also check if p2 appears before p1, in which case p2
 * should be sorted first.
 * If not, we try to order the two statements based on the description
 * of the iteration domains.  This results in an arbitrary, but fairly
 * stable ordering.
 *
 * In case of an error, sort_info.error is set to true and all elements are
 * reported to be equal.
 */
================================================================================

文件路径: ./isl_flow.c
注释行数: 10
注释内容:
/* Initialize an empty isl_flow structure corresponding to a given
 * isl_access_info structure.
 * For each must access, two dependences are created (initialized
 * to the empty relation), one for the resulting must dependences
 * and one for the resulting may dependences.  May accesses can
 * only lead to may dependences, so only one dependence is created
 * for each of them.
 * This function is private as isl_flow structures are only supposed
 * to be created by isl_access_info_compute_flow.
 */
================================================================================

文件路径: ./isl_flow.c
注释行数: 10
注释内容:
/* Return a map that enforces that the domain iteration occurs after
 * the range iteration at the given level.
 * If level is odd, then the domain iteration should occur after
 * the target iteration in their shared level/2 outermost loops.
 * In this case we simply need to enforce that these outermost
 * loop iterations are the same.
 * If level is even, then the loop iterator of the domain should
 * be greater than the loop iterator of the range at the last
 * of the level/2 shared loops, i.e., loop level/2 - 1.
 */
================================================================================

文件路径: ./isl_flow.c
注释行数: 12
注释内容:
/* Compute the partial lexicographic maximum of "dep" on domain "sink",
 * but first check if the user has set acc->restrict_fn and if so
 * update either the input or the output of the maximization problem
 * with respect to the resulting restriction.
 *
 * Since the user expects a mapping from sink iterations to source iterations,
 * whereas the domain of "dep" is a wrapped map, mapping sink iterations
 * to accessed array elements, we first need to project out the accessed
 * sink array elements by applying acc->domain_map.
 * Similarly, the sink restriction specified by the user needs to be
 * converted back to the wrapped map.
 */
================================================================================

文件路径: ./isl_flow.c
注释行数: 15
注释内容:
/* Given a possible flow dependence temp_rel[j] between source j and the sink
 * at level sink_level, remove those elements for which
 * there is an iteration of another source k < j that is closer to the sink.
 * The flow dependences temp_rel[k] are updated with the improved sources.
 * Any improved source needs to precede the sink at the same level
 * and needs to follow source j at the same or a deeper level.
 * The lower this level, the later the execution date of source k.
 * We therefore consider lower levels first.
 *
 * If temp_rel[j] is empty, then there can be no improvement and
 * we return immediately.
 *
 * This function returns isl_stat_ok in case it was executed successfully and
 * isl_stat_error in case of errors during the execution of this function.
 */
================================================================================

文件路径: ./isl_flow.c
注释行数: 20
注释内容:
/* Given a dependence relation "old_map" between a must-source and the sink,
 * return a subset of the dependences, augmented with instances
 * of the source at position "pos" in "acc" that are coscheduled
 * with the must-source and that access the same element.
 * That is, if the input lives in a space T -> K, then the output
 * lives in the space [T -> S] -> K, with S the space of source "pos", and
 * the domain factor of the domain product is a subset of the input.
 * The sources are considered to be coscheduled if they have the same values
 * for the initial "depth" coordinates.
 *
 * First construct a dependence relation S -> K and a mapping
 * between coscheduled sources T -> S.
 * The second is combined with the original dependence relation T -> K
 * to form a relation in T -> [S -> K], which is subsequently
 * uncurried to [T -> S] -> K.
 * This result is then intersected with the dependence relation S -> K
 * to form the output.
 *
 * In case a negative depth is given, NULL is returned to indicate an error.
 */
================================================================================

文件路径: ./isl_flow.c
注释行数: 35
注释内容:
/* After the dependences derived from a must-source have been computed
 * at a certain level, check if any of the sources of the must-dependences
 * may be coscheduled with other sources.
 * If they are any such sources, then there is no way of determining
 * which of the sources actually comes last and the must-dependences
 * need to be turned into may-dependences, while dependences from
 * the other sources need to be added to the may-dependences as well.
 * "acc" describes the sources and a callback for checking whether
 * two sources may be coscheduled.  If acc->coscheduled is NULL then
 * the sources are assumed not to be coscheduled.
 * "must_rel" and "may_rel" describe the must and may-dependence relations
 * computed at the current level for the must-sources.  Some of the dependences
 * may be moved from "must_rel" to "may_rel".
 * "flow" contains all dependences computed so far (apart from those
 * in "must_rel" and "may_rel") and may be updated with additional
 * dependences derived from may-sources.
 *
 * In particular, consider all the must-sources with a non-empty
 * dependence relation in "must_rel".  They are considered in reverse
 * order because that is the order in which they are considered in the caller.
 * If any of the must-sources are coscheduled, then the last one
 * is the one that will have a corresponding dependence relation.
 * For each must-source i, consider both all the previous must-sources
 * and all the may-sources.  If any of those may be coscheduled with
 * must-source i, then compute the coscheduled instances that access
 * the same memory elements.  The result is a relation [T -> S] -> K.
 * The projection onto T -> K is a subset of the must-dependence relation
 * that needs to be turned into may-dependences.
 * The projection onto S -> K needs to be added to the may-dependences
 * of source S.
 * Since a given must-source instance may be coscheduled with several
 * other source instances, the dependences that need to be turned
 * into may-dependences are first collected and only actually removed
 * from the must-dependences after all other sources have been considered.
 */
================================================================================

文件路径: ./isl_flow.c
注释行数: 40
注释内容:
/* Compute dependences for the case where there is at least one
 * "must" access.
 *
 * The core algorithm considers all levels in which a source may precede
 * the sink, where a level may either be a statement level or a loop level.
 * The outermost statement level is 1, the first loop level is 2, etc...
 * The algorithm basically does the following:
 * for all levels l of the read access from innermost to outermost
 *	for all sources w that may precede the sink access at that level
 *	    compute the last iteration of the source that precedes the sink access
 *					    at that level
 *	    add result to possible last accesses at level l of source w
 *	    for all sources w2 that we haven't considered yet at this level that may
 *					    also precede the sink access
 *		for all levels l2 of w from l to innermost
 *		    for all possible last accesses dep of w at l
 *			compute last iteration of w2 between the source and sink
 *								of dep
 *			add result to possible last accesses at level l of write w2
 *			and replace possible last accesses dep by the remainder
 *
 *
 * The above algorithm is applied to the must access.  During the course
 * of the algorithm, we keep track of sink iterations that still
 * need to be considered.  These iterations are split into those that
 * haven't been matched to any source access (mustdo) and those that have only
 * been matched to may accesses (maydo).
 * At the end of each level, must-sources and may-sources that are coscheduled
 * with the sources of the must-dependences at that level are considered.
 * If any coscheduled instances are found, then corresponding may-dependences
 * are added and the original must-dependences are turned into may-dependences.
 * Afterwards, the may accesses that occur after must-dependence sources
 * are considered.
 * In particular, we consider may accesses that precede the remaining
 * sink iterations, moving elements from mustdo to maydo when appropriate,
 * and may accesses that occur between a must source and a sink of any 
 * dependences found at the current level, turning must dependences into
 * may dependences when appropriate.
 * 
 */
================================================================================

文件路径: ./isl_flow.c
注释行数: 17
注释内容:
/* Given a "sink" access, a list of n "source" accesses,
 * compute for each iteration of the sink access
 * and for each element accessed by that iteration,
 * the source access in the list that last accessed the
 * element accessed by the sink access before this sink access.
 * Each access is given as a map from the loop iterators
 * to the array indices.
 * The result is a list of n relations between source and sink
 * iterations and a subset of the domain of the sink access,
 * corresponding to those iterations that access an element
 * not previously accessed.
 *
 * To deal with multi-valued sink access relations, the sink iteration
 * domain is first extended with dimensions that correspond to the data
 * space.  However, these extra dimensions are not projected out again.
 * It is up to the caller to decide whether these dimensions should be kept.
 */
================================================================================

文件路径: ./isl_flow.c
注释行数: 17
注释内容:
/* Given a "sink" access, a list of n "source" accesses,
 * compute for each iteration of the sink access
 * and for each element accessed by that iteration,
 * the source access in the list that last accessed the
 * element accessed by the sink access before this sink access.
 * Each access is given as a map from the loop iterators
 * to the array indices.
 * The result is a list of n relations between source and sink
 * iterations and a subset of the domain of the sink access,
 * corresponding to those iterations that access an element
 * not previously accessed.
 *
 * To deal with multi-valued sink access relations,
 * access_info_compute_flow_core extends the sink iteration domain
 * with dimensions that correspond to the data space.  These extra dimensions
 * are projected out from the result of access_info_compute_flow_core.
 */
================================================================================

文件路径: ./isl_flow.c
注释行数: 10
注释内容:
/* The different types of access relations that isl_union_access_info
 * keeps track of.

 * "isl_access_sink" represents the sink accesses.
 * "isl_access_must_source" represents the definite source accesses.
 * "isl_access_may_source" represents the possible source accesses.
 * "isl_access_kill" represents the kills.
 *
 * isl_access_sink is sometimes treated differently and
 * should therefore appear first.
 */
================================================================================

文件路径: ./isl_flow.c
注释行数: 14
注释内容:
/* This structure represents the input for a dependence analysis computation.
 *
 * "access" contains the access relations.
 *
 * "schedule" or "schedule_map" represents the execution order.
 * Exactly one of these fields should be NULL.  The other field
 * determines the execution order.
 *
 * The domains of these four maps refer to the same iteration spaces(s).
 * The ranges of the first three maps also refer to the same data space(s).
 *
 * After a call to isl_union_access_info_introduce_schedule,
 * the "schedule_map" field no longer contains useful information.
 */
================================================================================

文件路径: ./isl_flow.c
注释行数: 22
注释内容:
/* Prepend the schedule dimensions to the iteration domains.
 *
 * That is, if the schedule is of the form
 *
 *	D -> S
 *
 * while the access relations are of the form
 *
 *	D -> A
 *
 * then the updated access relations are of the form
 *
 *	[S -> D] -> A
 *
 * The schedule map is also replaced by the map
 *
 *	[S -> D] -> D
 *
 * that is used during the internal computation.
 * Neither the original schedule map nor this updated schedule map
 * are used after the call to this function.
 */
================================================================================

文件路径: ./isl_flow.c
注释行数: 14
注释内容:
/* This structure represents the result of a dependence analysis computation.
 *
 * "must_dep" represents the full definite dependences
 * "may_dep" represents the full non-definite dependences.
 * Both are of the form
 *
 *	[Source] -> [[Sink -> Data]]
 *
 * (after the schedule dimensions have been projected out).
 * "must_no_source" represents the subset of the sink accesses for which
 * definitely no source was found.
 * "may_no_source" represents the subset of the sink accesses for which
 * possibly, but not definitely, no source was found.
 */
================================================================================

文件路径: ./isl_flow.c
注释行数: 20
注释内容:
/* Drop the schedule dimensions from the iteration domains in "flow".
 * In particular, the schedule dimensions have been prepended
 * to the iteration domains prior to the dependence analysis by
 * replacing the iteration domain D, by the wrapped map [S -> D].
 * Replace these wrapped maps by the original D.
 *
 * In particular, the dependences computed by access_info_compute_flow_core
 * are of the form
 *
 *	[S -> D] -> [[S' -> D'] -> A]
 *
 * The schedule dimensions are projected out by first currying the range,
 * resulting in
 *
 *	[S -> D] -> [S' -> [D' -> A]]
 *
 * and then computing the factor range
 *
 *	D -> [D' -> A]
 */
================================================================================

文件路径: ./isl_flow.c
注释行数: 12
注释内容:
/* Determine the shared nesting level and the "textual order" of
 * the given accesses.
 *
 * We first determine the minimal schedule dimension for both accesses.
 *
 * If among those dimensions, we can find one where both have a fixed
 * value and if moreover those values are different, then the previous
 * dimension is the last shared nesting level and the textual order
 * is determined based on the order of the fixed values.
 * If no such fixed values can be found, then we set the shared
 * nesting level to the minimal schedule dimension, with no textual ordering.
 */
================================================================================

文件路径: ./isl_flow.c
注释行数: 22
注释内容:
/* Drop dependences from "flow" that purely originate from kills.
 * That is, only keep those dependences that originate from
 * the original must-sources "must" and/or the original may-sources "may".
 * In particular, "must" contains the must-sources from before
 * the kills were added and "may" contains the may-source from before
 * the kills were removed.
 *
 * The dependences are of the form
 *
 *	Source -> [Sink -> Data]
 *
 * Only those dependences are kept where the Source -> Data part
 * is a subset of the original may-sources or must-sources.
 * Of those, only the must-dependences that intersect with the must-sources
 * remain must-dependences.
 * If there is some overlap between the may-sources and the must-sources,
 * then the may-dependences and must-dependences may also overlap.
 * This should be fine since the may-dependences are only kept
 * disjoint from the must-dependences for the isl_union_map_compute_flow
 * interface.  This interface does not support kills, so it will
 * not end up calling this function.
 */
================================================================================

文件路径: ./isl_flow.c
注释行数: 19
注释内容:
/* Given a description of the "sink" accesses, the "source" accesses and
 * a schedule, compute for each instance of a sink access
 * and for each element accessed by that instance,
 * the possible or definite source accesses that last accessed the
 * element accessed by the sink access before this sink access
 * in the sense that there is no intermediate definite source access.
 *
 * The must_no_source and may_no_source elements of the result
 * are subsets of access->sink.  The elements must_dep and may_dep
 * map domain elements of access->{may,must)_source to
 * domain elements of access->sink.
 *
 * This function is used when only the schedule map representation
 * is available.
 *
 * We first prepend the schedule dimensions to the domain
 * of the accesses so that we can easily compare their relative order.
 * Then we consider each sink access individually in compute_flow.
 */
================================================================================

文件路径: ./isl_flow.c
注释行数: 10
注释内容:
/* Data structure for keeping track of individual scheduled sink and source
 * accesses when computing dependence analysis based on a schedule tree.
 *
 * "n_sink" is the number of used entries in "sink"
 * "n_source" is the number of used entries in "source"
 *
 * "set_sink", "must" and "node" are only used inside collect_sink_source,
 * to keep track of the current node and
 * of what extract_sink_source needs to do.
 */
================================================================================

文件路径: ./isl_flow.c
注释行数: 24
注释内容:
/* isl_schedule_foreach_schedule_node_top_down callback for collecting
 * individual scheduled source and sink accesses (taking into account
 * the domain of the schedule).
 *
 * We only collect accesses at the leaves of the schedule tree.
 * We prepend the schedule dimensions at the leaf to the iteration
 * domains of the source and sink accesses and then extract
 * the individual accesses (per space).
 *
 * In particular, if the prefix schedule at the node is of the form
 *
 *	D -> S
 *
 * while the access relations are of the form
 *
 *	D -> A
 *
 * then the updated access relations are of the form
 *
 *	[S -> D] -> A
 *
 * Note that S consists of a single space such that introducing S
 * in the access relations does not increase the number of spaces.
 */
================================================================================

文件路径: ./isl_flow.c
注释行数: 16
注释内容:
/* isl_access_info_compute_flow callback for determining whether
 * the shared nesting level and the ordering within that level
 * for two scheduled accesses for use in compute_single_flow.
 *
 * The tokens passed to this function refer to the leaves
 * in the schedule tree where the accesses take place.
 *
 * If n is the shared number of loops, then we need to return
 * "2 * n + 1" if "first" precedes "second" inside the innermost
 * shared loop and "2 * n" otherwise.
 *
 * The innermost shared ancestor may be the leaves themselves
 * if the accesses take place in the same leaf.  Otherwise,
 * it is either a set node or a sequence node.  Only in the case
 * of a sequence node do we consider one access to precede the other.
 */
================================================================================

文件路径: ./isl_flow.c
注释行数: 17
注释内容:
/* Given a scheduled sink access relation "sink", compute the corresponding
 * dependences on the sources in "data" and add the computed dependences
 * to "uf".
 *
 * The dependences computed by access_info_compute_flow_core are of the form
 *
 *	[S -> I] -> [[S' -> I'] -> A]
 *
 * The schedule dimensions are projected out by first currying the range,
 * resulting in
 *
 *	[S -> I] -> [S' -> [I' -> A]]
 *
 * and then computing the factor range
 *
 *	I -> [I' -> A]
 */
================================================================================

文件路径: ./isl_flow.c
注释行数: 21
注释内容:
/* Given a description of the "sink" accesses, the "source" accesses and
 * a schedule, compute for each instance of a sink access
 * and for each element accessed by that instance,
 * the possible or definite source accesses that last accessed the
 * element accessed by the sink access before this sink access
 * in the sense that there is no intermediate definite source access.
 * Only consider dependences between statement instances that belong
 * to the domain of the schedule.
 *
 * The must_no_source and may_no_source elements of the result
 * are subsets of access->sink.  The elements must_dep and may_dep
 * map domain elements of access->{may,must)_source to
 * domain elements of access->sink.
 *
 * This function is used when a schedule tree representation
 * is available.
 *
 * We extract the individual scheduled source and sink access relations
 * (taking into account the domain of the schedule) and
 * then compute dependences for each scheduled sink individually.
 */
================================================================================

文件路径: ./isl_flow.c
注释行数: 20
注释内容:
/* Given a description of the "sink" accesses, the "source" accesses and
 * a schedule, compute for each instance of a sink access
 * and for each element accessed by that instance,
 * the possible or definite source accesses that last accessed the
 * element accessed by the sink access before this sink access
 * in the sense that there is no intermediate definite source access.
 *
 * The must_no_source and may_no_source elements of the result
 * are subsets of access->sink.  The elements must_dep and may_dep
 * map domain elements of access->{may,must)_source to
 * domain elements of access->sink.
 *
 * If any kills have been specified, then they are treated as
 * must-sources internally.  Any dependence that purely derives
 * from an original kill is removed from the output.
 *
 * We check whether the schedule is available as a schedule tree
 * or a schedule map and call the corresponding function to perform
 * the analysis.
 */
================================================================================

文件路径: ./isl_flow.c
注释行数: 16
注释内容:
/* Given a collection of "sink" and "source" accesses,
 * compute for each iteration of a sink access
 * and for each element accessed by that iteration,
 * the source access in the list that last accessed the
 * element accessed by the sink access before this sink access.
 * Each access is given as a map from the loop iterators
 * to the array indices.
 * The result is a relations between source and sink
 * iterations and a subset of the domain of the sink accesses,
 * corresponding to those iterations that access an element
 * not previously accessed.
 *
 * We collect the inputs in an isl_union_access_info object,
 * call isl_union_access_info_compute_flow and extract
 * the outputs from the result.
 */
================================================================================

文件路径: ./interface/template_cpp.h
注释行数: 11
注释内容:
/* A representation of a template class.
 *
 * "class_name" is the name of the template class.
 * "super_name" is the (fully qualified) name of the corresponding
 * plain C++ interface class, from which this template class derives.
 * "clazz" describes the plain class.
 *
 * "class_tuples" contains the specializations.
 * It is initialized with a predefined set of specializations,
 * but may be extended during the generations of the specializations.
 */
================================================================================

文件路径: ./interface/generator.cc
注释行数: 32
注释内容:
/*
 * Copyright 2011,2015 Sven Verdoolaege. All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 *
 *    1. Redistributions of source code must retain the above copyright
 *       notice, this list of conditions and the following disclaimer.
 *
 *    2. Redistributions in binary form must reproduce the above
 *       copyright notice, this list of conditions and the following
 *       disclaimer in the documentation and/or other materials provided
 *       with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY SVEN VERDOOLAEGE ''AS IS'' AND ANY
 * EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
 * PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL SVEN VERDOOLAEGE OR
 * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
 * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
 * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA,
 * OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
 * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
 * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 *
 * The views and conclusions contained in the software and documentation
 * are those of the authors and should not be interpreted as
 * representing official policies, either expressed or implied, of
 * Sven Verdoolaege.
 */
================================================================================

文件路径: ./interface/generator.cc
注释行数: 18
注释内容:
/* Collect all functions that belong to a certain type, separating
 * constructors from methods that set an enum value,
 * methods that set a persistent callback and
 * from regular methods, while keeping track of the _to_str,
 * _copy and _free functions, if any, separately.
 * Methods that accept any enum arguments that are not specifically handled
 * are not supported.
 * If there are any overloaded
 * functions, then they are grouped based on their name after removing the
 * argument type suffix.
 * Check for functions that describe subclasses before considering
 * any other functions in order to be able to detect those other
 * functions as belonging to the subclasses.
 * Sort the names of the functions based on their lengths
 * to ensure that nested subclasses are handled later.
 *
 * Also extract information about automatic conversion functions.
 */
================================================================================

文件路径: ./interface/generator.cc
注释行数: 16
注释内容:
/* Return a sequence of the types of which the given type declaration is
 * marked as being a subtype.
 * The order of the types is the opposite of the order in which they
 * appear in the source.  In particular, the first annotation
 * is the one that is closest to the annotated type and the corresponding
 * type is then also the first that will appear in the sequence of types.
 * This is also the order in which the annotations appear
 * in the AttrVec returned by Decl::getAttrs() in older versions of clang.
 * In newer versions of clang, the order is that in which
 * the attribute appears in the source.
 * Use the position of the "isl_export" attribute to determine
 * whether this is an old (with reversed order) or a new version.
 * The "isl_export" attribute is automatically added
 * after each "isl_subclass" attribute.  If it appears in the list before
 * any "isl_subclass" is encountered, then this must be a reversed list.
 */
================================================================================

文件路径: ./interface/generator.cc
注释行数: 16
注释内容:
/* Does the callback argument "param" take its argument at position "pos"?
 *
 * The memory management annotations of arguments to function pointers
 * are not recorded by clang, so the information cannot be extracted
 * from the type of "param".
 * Instead, go to the location in the source where the callback argument
 * is declared, look for the right argument of the callback itself and
 * then check if it has an "__isl_take" memory management annotation.
 *
 * If the return value of the function has a memory management annotation,
 * then the spelling of "param" will point to the spelling
 * of this memory management annotation.  Since the macro is defined
 * on the command line (in main), this location does not have a file entry.
 * In this case, move up one level in the macro expansion to the location
 * where the memory management annotation is used.
 */
================================================================================

文件路径: ./interface/extract_interface.cc
注释行数: 32
注释内容:
/*
 * Copyright 2011 Sven Verdoolaege. All rights reserved.
 * 
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 
 *    1. Redistributions of source code must retain the above copyright
 *       notice, this list of conditions and the following disclaimer.
 * 
 *    2. Redistributions in binary form must reproduce the above
 *       copyright notice, this list of conditions and the following
 *       disclaimer in the documentation and/or other materials provided
 *       with the distribution.
 * 
 * THIS SOFTWARE IS PROVIDED BY SVEN VERDOOLAEGE ''AS IS'' AND ANY
 * EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
 * PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL SVEN VERDOOLAEGE OR
 * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
 * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
 * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA,
 * OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
 * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
 * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 * 
 * The views and conclusions contained in the software and documentation
 * are those of the authors and should not be interpreted as
 * representing official policies, either expressed or implied, of
 * Sven Verdoolaege.
 */
================================================================================

文件路径: ./interface/template_cpp.cc
注释行数: 32
注释内容:
/*
 * Copyright 2020 Cerebras Systems. All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 *
 *    1. Redistributions of source code must retain the above copyright
 *       notice, this list of conditions and the following disclaimer.
 *
 *    2. Redistributions in binary form must reproduce the above
 *       copyright notice, this list of conditions and the following
 *       disclaimer in the documentation and/or other materials provided
 *       with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY CEREBRAS SYSTEMS ''AS IS'' AND ANY
 * EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
 * PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL CEREBRAS SYSTEMS OR
 * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
 * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
 * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA,
 * OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
 * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
 * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 *
 * The views and conclusions contained in the software and documentation
 * are those of the authors and should not be interpreted as
 * representing official policies, either expressed or implied, of
 * Cerebras Systems.
 */
================================================================================

文件路径: ./interface/template_cpp.cc
注释行数: 23
注释内容:
/* Signatures for methods of types containing a given substring
 * that override the default signatures, where larger substrings
 * appear first.
 *
 * In particular, "gist" is usually a regular binary operation,
 * but for any type derived from "aff", the argument refers
 * to the domain of the function.
 *
 * The "size" method can usually simply be inherited from
 * the corresponding plain C++ type, but for a "fixed_box",
 * the size lives in the space of the box or its range.
 *
 * The "space" method is usually a regular unary operation
 * that returns the single space of the elements in the object,
 * with the same number of tuples.
 * However, a "union" object may contain elements from many spaces and
 * therefore its space only refers to the symbolic constants and
 * has zero tuples, except if it is also a "multi_union" object,
 * in which case it has a fixed range space and the space of the object
 * has a single tuple.
 * Note that since "space' is also the name of a template class,
 * the default space method is handled by print_type_named_member_method.
 */
================================================================================

文件路径: ./interface/template_cpp.cc
注释行数: 15
注释内容:
/* The initial sequence of specialization kinds for base types.
 * The specialization kinds for other types are derived
 * from the corresponding base types.
 *
 * In particular, this sequence specifies how many tuples
 * a given type can have and whether it is anonymous.
 *
 * "space" can have any number of tuples.
 * "set" and "point" can have zero or one tuple.
 * "map" can only have two tuples.
 * "aff" can have one or two tuples, the last of which is anonymous.
 * "fixed_box" can represent a (proper) set) or a map.
 * "val" and "id" are treated as anonymous sets so that
 * they can form the basis of "multi_val" and "multi_id".
 */
================================================================================

文件路径: ./interface/template_cpp.cc
注释行数: 11
注释内容:
/* Construct a templated C++ bindings generator from
 * the exported types and functions and the set of all declared functions.
 *
 * On top of the initialization of the shared parts
 * of C++ bindings generators, add a template class
 * for each plain C++ class for which template kinds
 * have been defined.
 * In particular, determine the base type from which the plain C++ class
 * was derived using type constructors and check if any template kinds
 * have been registered for this base type.
 */
================================================================================

文件路径: ./interface/template_cpp.cc
注释行数: 12
注释内容:
/* Print all specializations of all template classes.
 *
 * Each class has a predefined set of initial specializations,
 * but while such a specialization is being printed,
 * the need for other specializations may arise and
 * these are added at the end of the list of specializations.
 * That is, class_tuples.size() may change during the execution
 * of the loop.
 *
 * For each specialization of a template class, call
 * the print_class virtual method.
 */
================================================================================

文件路径: ./interface/template_cpp.cc
注释行数: 10
注释内容:
/* If a method with signature "sig" requires additional template parameters
 * compared to those of the class, then print a declaration for them.
 * If this->declarations is set, then this will be part of a method declaration,
 * requiring extra indentation.
 *
 * Construct the sequence of all required template parameters
 * with those of the template class appearing first.
 * If this sequence has any parameters not induced by the template class itself,
 * then print a declaration for these extra parameters.
 */
================================================================================

文件路径: ./interface/template_cpp.cc
注释行数: 12
注释内容:
/* Print a lambda for passing to the plain method corresponding to "method"
 * with signature "sig".
 *
 * The method is assumed to have only the callback as argument,
 * which means the arguments of the callback are shifted by 2
 * with respect to the arguments of the signature
 * (one for the position of the callback argument plus
 * one for the return kind of the callback).
 *
 * The lambda takes arguments with plain isl types and
 * calls the callback of "method" with templated arguments.
 */
================================================================================

文件路径: ./interface/template_cpp.cc
注释行数: 11
注释内容:
/* Print a definition of the member method "method", which is known
 * to have a callback argument, with signature "sig".
 *
 * First print a lambda for passing to the corresponding plain method and
 * calling the callback of "method" with templated arguments.
 * Then call the plain method, replacing the original callback
 * by the lambda.
 *
 * The return value is assumed to be isl_bool or isl_stat
 * so that no conversion to a template type is required.
 */
================================================================================

文件路径: ./interface/template_cpp.cc
注释行数: 11
注释内容:
/* Print a definition of the method "method" with signature "sig",
 * if "deleted" is not set.
 *
 * If "deleted" is set, then the corresponding declaration
 * is marked "delete" and no definition needs to be printed.
 *
 * Otherwise print the method header, preceded by the template parameters,
 * if needed.
 * The body depends on whether the method is a constructor or
 * takes a callback.
 */
================================================================================

文件路径: ./interface/template_cpp.cc
注释行数: 14
注释内容:
/* Signatures for constructors and methods named after some other class.
 *
 * Two forms of constructors are handled
 * - conversion from another object
 * - construction of a multi-expression from a space and a list
 *
 * Methods named after some other class also come in two forms
 * - extraction of information such as the space or a list
 * - construction of a multi-expression from a space and a list
 *
 * In both cases, the first form is a unary operation and
 * the second has an extra argument with a kind that is equal
 * to that of the first argument, except that the final tuple is anonymous.
 */
================================================================================

文件路径: ./interface/template_cpp.cc
注释行数: 10
注释内容:
/* Update the substitution "sub" to map "general" to "specific"
 * if "specific" is a special case of "general" consistent with "sub",
 * given that "general" is not a pair and can be assigned "specific".
 * Return true if successful.
 * Otherwise, return false.
 *
 * Check whether "general" is already assigned something in "sub".
 * If so, it must be assigned "specific".
 * Otherwise, there is a conflict.
 */
================================================================================

文件路径: ./interface/template_cpp.cc
注释行数: 14
注释内容:
/* Update the substitution "sub" to map "general" to "specific"
 * if "specific" is a special case of "general" consistent with "sub".
 * Return true if successful.
 * Otherwise, return false.
 *
 * If "general" is a pair and "specific" is not,
 * then "specific" cannot be a special case.
 * If both are pairs, then update the substitution based
 * on both sides.
 * If "general" is Anonymous, then "specific" must be Anonymous as well.
 * If "general" is Leaf, then "specific" cannot be a pair.
 *
 * Otherwise, assign "specific" to "general", if possible.
 */
================================================================================

文件路径: ./interface/template_cpp.cc
注释行数: 10
注释内容:
/* Try and compute a unifier of "kind1" and "kind2",
 * i.e., a substitution that produces the same result when
 * applied to both "kind1" and "kind2",
 * for the case where both "kind1" and "kind2" are pairs.
 * Return this unifier if it was found.
 * Return an empty substitution if no unifier can be found.
 *
 * First compute a unifier for the left parts of the pairs and,
 * if successful, combine it with a unifier for the right parts.
 */
================================================================================

文件路径: ./interface/template_cpp.cc
注释行数: 15
注释内容:
/* Try and compute a unifier of "kind1" and "kind2",
 * i.e., a substitution that produces the same result when
 * applied to both "kind1" and "kind2".
 * Return this unifier if it was found.
 * Return an empty substitution if no unifier can be found.
 *
 * If one of the tuple kinds is a pair then assign it
 * to the other tuple kind, if possible.
 * If neither is a pair, then try and assign one to the other.
 * Otherwise, let compute_pair_unifier compute a unifier.
 *
 * Note that an assignment is added to the unifier even
 * if "kind1" and "kind2" are identical.
 * This ensures that a successful substitution is never empty.
 */
================================================================================

文件路径: ./interface/template_cpp.cc
注释行数: 14
注释内容:
/* Try and compute a unifier of "kind1" and "kind2",
 * i.e., a substitution that produces the same result when
 * applied to both "kind1" and "kind2".
 * Return this unifier if it was found.
 * Return an empty substitution if no unifier can be found.
 *
 * Start with an empty substitution and compute a unifier for
 * each pair of tuple kinds, combining the results.
 * If no combined unifier can be found or
 * if the numbers of tuple kinds are different, then return
 * an empty substitution.
 * This assumes that the number of tuples is greater than zero,
 * as otherwise an empty substitution would be returned as well.
 */
================================================================================

文件路径: ./interface/template_cpp.cc
注释行数: 10
注释内容:
/* Try and construct a Kind that is a specialization of both "general" and
 * "specific", where "specific" is known _not_ to be a specialization
 * of "general" and not to contain any Leaf.
 *
 * First check whether "general" is a specialization of "specific".
 * If so, simply return "general".
 * Otherwise, rename the placeholders in the two kinds apart and
 * try and compute a unifier.
 * If this succeeds, then return the result of applying the unifier.
 */
================================================================================

文件路径: ./interface/template_cpp.cc
注释行数: 10
注释内容:
/* Try and add a template class specialization corresponding to "kind".
 * The new specialization needs to be a specialization of both
 * the current specialization and "kind".
 *
 * The current template class specialization is known not to be a special case
 * of "kind".
 *
 * Try and unify the two kinds and, if this succeeds, add the result
 * to this list of template class specializations.
 */
================================================================================

文件路径: ./interface/template_cpp.cc
注释行数: 19
注释内容:
/* Print a declaration or definition of the method "method"
 * if the template class specialization matches "match_arg".
 * Return true if so.
 * "sig" is the complete signature, of which "match_arg" refers
 * to the first argument or the return type.
 *
 * Since "sig" may have parameters with the same names as
 * those in instance.kind, rename them apart first.
 *
 * If the template class specialization is a special case of
 * (the renamed) "match_arg"
 * then apply the specializer to the complete (renamed) signature,
 * check that the return kind is allowed and, if so,
 * print the declaration or definition using the specialized signature.
 *
 * If the template class specialization is not a special case of "match_arg"
 * then add a further specialization to the list of specializations
 * of the template class.
 */
================================================================================

文件路径: ./interface/template_cpp.cc
注释行数: 14
注释内容:
/* Print a declaration or definition of the member method "method"
 * if it matches the signature "sig".
 * Return true if so.
 *
 * First determine the part of the signature that needs to match
 * the template class specialization and
 * check that it has the same number of template arguments.
 * Also check that the number of arguments of the signature
 * matches that of the method.
 * If there is at least one argument, then check that the first method argument
 * is an isl_ctx if and only if the first signature argument is Ctx.
 *
 * If these tests succeed, proceed with the actual matching.
 */
================================================================================

文件路径: ./interface/template_cpp.cc
注释行数: 11
注释内容:
/* Print a declaration or definition of the "at" member method "method".
 *
 * There are two types of methods called "at".
 * One type extracts an element from a multi-expression and
 * the other extracts an element from a list.
 *
 * In the first case, the return type is an anonymous function
 * while the object type is not.  In this case, the return kind
 * should have a final Anonymous tuple.
 * Otherwise, the return kind should be the same as the object kind.
 */
================================================================================

文件路径: ./interface/template_cpp.cc
注释行数: 10
注释内容:
/* Print a declaration or definition of the member method "method".
 *
 * If the method is called "at", then it requires special treatment.
 * Otherwise, check if the signature is overridden for this class or
 * if the method is named after some other type.
 * Otherwise look for an appropriate signature using different variations
 * of the method name.  First try the method name itself,
 * then the method name with the return type removed and
 * finally the method name with the callback argument type removed.
 */
================================================================================

文件路径: ./interface/template_cpp.cc
注释行数: 20
注释内容:
/* Print the declaration and definition of a constructor
 * for the template class specialization "instance" taking
 * an instance with more specialized template arguments,
 * where "params" holds the template parameters of "instance".
 * It is assumed that there is at least one template parameter as otherwise
 * there are no template arguments to be specialized and
 * no constructor needs to be printed.
 *
 * In particular, the constructor takes an object of the same instance where
 * for each template parameter, the corresponding template argument
 * of the input object is a subclass of the template argument
 * of the constructed object.
 *
 * Pick fresh names for all template parameters and
 * add a constructor with these fresh names as extra template parameters and
 * a constraint requiring that each of them is a subclass
 * of the corresponding class template parameter.
 * The plain C++ interface object of the constructed object is initialized with
 * the plain C++ interface object of the constructor argument.
 */
================================================================================

文件路径: ./interface/template_cpp.cc
注释行数: 21
注释内容:
/* Print the declaration and definition of a constructor
 * for the template class specialization "instance" taking
 * an instance of the base class.
 *
 * If the instance kind is that of an anonymous set
 * (i.e., it has a single tuple that is set to Anonymous),
 * then allow the constructor to be called externally.
 * This is mostly useful for being able to use isl::val and
 * isl::typed::val<Anonymous> interchangeably and similarly for isl::id.
 *
 * If the instance is of any other kind, then make this constructor private
 * to avoid objects of the plain interface being converted automatically.
 * Also make sure that it does not apply to any type derived
 * from the base class.  In particular, this makes sure it does
 * not apply to any other specializations of this template class as
 * otherwise any conflict in specializations would simply point
 * to the private constructor.
 *
 * A factory method is added to be able to perform the conversion explicitly,
 * with an explicit specification of the template arguments.
 */
================================================================================

文件路径: ./interface/template_cpp.cc
注释行数: 25
注释内容:
/* Print a "declaration" for the given template class specialization.
 * In particular, print the class definition and the method declarations.
 *
 * The template parameters are the distinct variable names
 * in the instance kind.
 *
 * Each instance of the template class derives from the corresponding
 * plain C++ interface class.
 *
 * All (other) template classes are made friends of this template class
 * to allow them to call the private constructor taking an object
 * of the plain interface.
 *
 * Besides the constructors and methods that forward
 * to the corresponding methods in the plain C++ interface class,
 * some extra constructors are defined.
 * The default zero-argument constructor is useful for declaring
 * a variable that only gets assigned a value at a later stage.
 * The constructor taking an instance with more specialized
 * template arguments is useful for lifting the class hierarchy
 * of the template arguments to the template class.
 * The constructor taking an instance of the base class
 * is useful for (explicitly) constructing a template type
 * from a plain type.
 */
================================================================================

文件路径: ./interface/python.cc
注释行数: 32
注释内容:
/*
 * Copyright 2011,2015 Sven Verdoolaege. All rights reserved.
 * 
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 
 *    1. Redistributions of source code must retain the above copyright
 *       notice, this list of conditions and the following disclaimer.
 * 
 *    2. Redistributions in binary form must reproduce the above
 *       copyright notice, this list of conditions and the following
 *       disclaimer in the documentation and/or other materials provided
 *       with the distribution.
 * 
 * THIS SOFTWARE IS PROVIDED BY SVEN VERDOOLAEGE ''AS IS'' AND ANY
 * EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
 * PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL SVEN VERDOOLAEGE OR
 * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
 * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
 * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA,
 * OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
 * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
 * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 * 
 * The views and conclusions contained in the software and documentation
 * are those of the authors and should not be interpreted as
 * representing official policies, either expressed or implied, of
 * Sven Verdoolaege.
 */
================================================================================

文件路径: ./interface/python.cc
注释行数: 11
注释内容:
/* Print a check that the argument in position "pos" is of type "type"
 * with the given indentation.
 * If this fails and if "upcast" is set, then convert the first
 * argument to "super" and call the method "name" on it, passing
 * the remaining of the "n" arguments.
 * If the check fails and "upcast" is not set, then simply raise
 * an exception.
 * If "upcast" is not set, then the "super", "name" and "n" arguments
 * to this function are ignored.
 * "fmt" is the format for printing Python method arguments.
 */
================================================================================

文件路径: ./interface/python.cc
注释行数: 10
注释内容:
/* For each of the "n" initial arguments of the function "method"
 * that refer to an isl structure,
 * including the object on which the method is called,
 * check if the corresponding actual argument is of the right type.
 * If not, try and convert it to the right type.
 * If that doesn't work and if "super" contains at least one element,
 * try and convert self to the type of the first superclass in "super" and
 * call the corresponding method.
 * If "first_is_ctx" is set, then the first argument is skipped.
 */
================================================================================

文件路径: ./interface/python.cc
注释行数: 17
注释内容:
/* Construct a wrapper for callback argument "param" (at position "arg").
 * Assign the wrapper to "cb".  We assume here that a function call
 * has at most one callback argument.
 *
 * The wrapper converts the arguments of the callback to python types,
 * taking a copy if the C callback does not take its arguments.
 * If any exception is thrown, the wrapper keeps track of it in exc_info[0]
 * and returns a value indicating an error.  Otherwise the wrapper
 * returns a value indicating success.
 * In case the C callback is expected to return an isl_stat,
 * the error value is -1 and the success value is 0.
 * In case the C callback is expected to return an isl_bool,
 * the error value is -1 and the success value is 1 or 0 depending
 * on the result of the Python callback.
 * Otherwise, None is returned to indicate an error and
 * a copy of the object in case of success.
 */
================================================================================

文件路径: ./interface/python.cc
注释行数: 19
注释内容:
/* Print the argument at position "arg" in call to "fd".
 * "fmt" is the format for printing Python method arguments.
 * "skip" is the number of initial arguments of "fd" that are
 * skipped in the Python method.
 *
 * If the (first) argument is an isl_ctx, then print "ctx",
 * assuming that the caller has made the context available
 * in a "ctx" variable.
 * Otherwise, if the argument is a callback, then print a reference to
 * the callback wrapper "cb".
 * Otherwise, if the argument is marked as consuming a reference,
 * then pass a copy of the pointer stored in the corresponding
 * argument passed to the Python method.
 * Otherwise, if the argument is a string, then the python string is first
 * encoded as a byte sequence, using 'ascii' as encoding.  This assumes
 * that all strings passed to isl can be converted to 'ascii'.
 * Otherwise, if the argument is a pointer, then pass this pointer itself.
 * Otherwise, pass the argument directly.
 */
================================================================================

文件路径: ./interface/python.cc
注释行数: 26
注释内容:
/* Print the return statement of the python method corresponding
 * to the C function "method" with the given indentation.
 * If the object on which the method was called
 * may have a persistent callback, then first check if any of those failed.
 * "fmt" is the format for printing Python method arguments.
 *
 * If the method returns a new instance of the same object type and
 * if the class has any persistent callbacks, then the data
 * for these callbacks are copied from the original to the new object.
 * If the method it itself setting a persistent callback,
 * then keep track of the constructed C callback (such that it doesn't
 * get destroyed) and the data structure that holds the captured exception
 * (such that it can be raised again).
 *
 * If the return type is a (const) char *, then convert the result
 * to a Python string, raising an error on NULL and freeing
 * the C string if needed.  For python 3 compatibility, the string returned
 * by isl is explicitly decoded as an 'ascii' string.  This is correct
 * as all strings returned by isl are expected to be 'ascii'.
 *
 * If the return type is isl_stat, isl_bool or isl_size, then
 * raise an error on isl_stat_error, isl_bool_error or isl_size_error.
 * In case of isl_bool, the result is converted to
 * a Python boolean.
 * In case of isl_size, the result is converted to a Python int.
 */
================================================================================

文件路径: ./interface/python.cc
注释行数: 12
注释内容:
/* Print a call to "method", along with the corresponding
 * return statement, with the given indentation.
 * "drop_ctx" is set if the first argument is an isl_ctx.
 * "drop_user" is set if the last argument is a "user" argument
 * corresponding to a callback argument.
 *
 * A "ctx" variable is first initialized as it may be needed
 * in the first call to print_arg_in_call and in print_method_return.
 *
 * If the method has a callback function, then any exception
 * thrown in the callback also need to be rethrown.
 */
================================================================================

文件路径: ./interface/python.cc
注释行数: 24
注释内容:
/* Print a python method corresponding to the C function "method".
 * "super" contains the superclasses of the class to which the method belongs,
 * with the first element corresponding to the annotation that appears
 * closest to the annotated type.  This superclass is the least
 * general extension of the annotated type in the linearization
 * of the class hierarchy.
 *
 * If the first argument of "method" is something other than an instance
 * of the class, then mark the python method as static.
 * If, moreover, this first argument is an isl_ctx, then remove
 * it from the arguments of the Python method.
 *
 * If the function has a callback argument, then it also has a "user"
 * argument.  Since Python has closures, there is no need for such
 * a user argument in the Python interface, so we simply drop it.
 * We also create a wrapper ("cb") for the callback.
 *
 * If the function consumes a reference, then we pass it a copy of
 * the actual argument.
 *
 * For methods that are identified as "get" methods, also
 * print a variant of the method using a name that includes
 * the "get_" prefix.
 */
================================================================================

文件路径: ./interface/python.cc
注释行数: 14
注释内容:
/* Print a test that checks whether the arguments passed
 * to the Python method correspond to the arguments
 * expected by "fd".
 * "drop_ctx" is set if the first argument of "fd" is an isl_ctx,
 * which does not appear as an argument to the Python method.
 *
 * If an automatic conversion function is available for any
 * of the argument types, then also allow the argument
 * to be of the type as prescribed by the second input argument
 * of the conversion function.
 * The corresponding arguments are then converted to the expected types
 * if needed.  The argument tuple first needs to be converted to a list
 * in order to be able to modify the entries.
 */
================================================================================

文件路径: ./interface/python.cc
注释行数: 12
注释内容:
/* Print a python method "name" corresponding to "fd" setting
 * the enum value "value".
 * "super" contains the superclasses of the class to which the method belongs,
 * with the first element corresponding to the annotation that appears
 * closest to the annotated type.
 *
 * The last argument of the C function does not appear in the method call,
 * but is fixed to "value" instead.
 * Other than that, the method printed here is similar to one
 * printed by python_generator::print_method, except that
 * some of the special cases do not occur.
 */
================================================================================

文件路径: ./interface/python.cc
注释行数: 15
注释内容:
/* Print declarations for methods printing the class representation,
 * provided there is a corresponding *_to_str function.
 *
 * In particular, provide an implementation of __str__ and __repr__ methods to
 * override the default representation used by python. Python uses __str__ to
 * pretty print the class (e.g., when calling print(obj)) and uses __repr__
 * when printing a precise representation of an object (e.g., when dumping it
 * in the REPL console).
 *
 * Check the type of the argument before calling the *_to_str function
 * on it in case the method was called on an object from a subclass.
 *
 * The return value of the *_to_str function is decoded to a python string
 * assuming an 'ascii' encoding.  This is necessary for python 3 compatibility.
 */
================================================================================

文件路径: ./interface/python.cc
注释行数: 10
注释内容:
/* Print code to set method type signatures.
 *
 * To be able to call C functions it is necessary to explicitly set their
 * argument and result types.  Do this for all exported constructors and
 * methods (including those that set a persistent callback and
 * those that set an enum value),
 * as well as for the *_to_str and the type function, if they exist.
 * Assuming each exported class has a *_copy and a *_free method,
 * also unconditionally set the type of such methods.
 */
================================================================================

文件路径: ./interface/python.cc
注释行数: 17
注释内容:
/* Print out the definition of this isl_class.
 *
 * We first check if this isl_class is a subclass of one or more other classes.
 * If it is, we make sure those superclasses are printed out first.
 *
 * Then we print a constructor with several cases, one for constructing
 * a Python object from a return value, one for each function that
 * was marked as a constructor and for each type based subclass.
 *
 * Next, we print out some common methods and the methods corresponding
 * to functions that are not marked as constructors, including those
 * that set a persistent callback and those that set an enum value.
 *
 * Finally, we tell ctypes about the types of the arguments of the
 * constructor functions and the return types of those function returning
 * an isl object.
 */
================================================================================

文件路径: ./interface/cpp.h
注释行数: 12
注释内容:
/* A generated method that performs one or more argument conversions and
 * then calls the original method.
 *
 * A ConversionMethod inherits from a NoCopyMethod, because
 * unlike methods that call an isl C function,
 * a conversion method never calls release() on an isl type argument,
 * so they can all be passed as const references.
 *
 * "this_type" is the name of the type to which "this" should be converted
 * (if different from clazz.name).
 * "get_param_fn" returns the method argument at position "pos".
 */
================================================================================

文件路径: ./interface/plain_cpp.cc
注释行数: 32
注释内容:
/*
 * Copyright 2016, 2017 Tobias Grosser. All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 *
 *    1. Redistributions of source code must retain the above copyright
 *       notice, this list of conditions and the following disclaimer.
 *
 *    2. Redistributions in binary form must reproduce the above
 *       copyright notice, this list of conditions and the following
 *       disclaimer in the documentation and/or other materials provided
 *       with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY TOBIAS GROSSER ''AS IS'' AND ANY
 * EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
 * PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL TOBIAS GROSSER OR
 * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
 * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
 * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA,
 * OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
 * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
 * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 *
 * The views and conclusions contained in the software and documentation
 * are those of the authors and should not be interpreted as
 * representing official policies, either expressed or implied, of
 * Tobias Grosser.
 */
================================================================================

文件路径: ./interface/plain_cpp.cc
注释行数: 10
注释内容:
/* Generate a cpp interface based on the extracted types and functions.
 *
 * Print first a set of forward declarations for all isl wrapper
 * classes, then the declarations of the classes, and at the end all
 * implementations.
 *
 * If checked C++ bindings are being generated,
 * then wrap them in a namespace to avoid conflicts
 * with the default C++ bindings (with automatic checks using exceptions).
 */
================================================================================

文件路径: ./interface/plain_cpp.cc
注释行数: 13
注释内容:
/* Print declarations for class "clazz" to "os".
 *
 * If "clazz" is a subclass based on a type function,
 * then it is made to inherit from the (immediate) superclass and
 * a "type" attribute is added for use in the "as" and "isa"
 * methods of the superclass.
 *
 * Conversely, if "clazz" is a superclass with a type function,
 * then declare those "as" and "isa" methods.
 *
 * The pointer to the isl object is only added for classes that
 * are not subclasses, since subclasses refer to the same isl object.
 */
================================================================================

文件路径: ./interface/plain_cpp.cc
注释行数: 19
注释内容:
/* Print global factory functions.
 *
 * Each class has two global factory functions:
 *
 * 	set manage(__isl_take isl_set *ptr);
 * 	set manage_copy(__isl_keep isl_set *ptr);
 *
 * A user can construct isl C++ objects from a raw pointer and indicate whether
 * they intend to take the ownership of the object or not through these global
 * factory functions. This ensures isl object creation is very explicit and
 * pointers are not converted by accident. Thanks to overloading, manage() and
 * manage_copy() can be called on any isl raw pointer and the corresponding
 * object is automatically created, without the user having to choose the right
 * isl object type.
 *
 * For a subclass based on a type function, no factory functions
 * are introduced because they share the C object type with
 * the superclass.
 */
================================================================================

文件路径: ./interface/plain_cpp.cc
注释行数: 13
注释内容:
/* Print declarations of protected constructors.
 *
 * Each class has currently one protected constructor:
 *
 * 	1) Constructor from a plain isl_* C pointer
 *
 * Example:
 *
 * 	set(__isl_take isl_set *ptr);
 *
 * The raw pointer constructor is kept protected. Object creation is only
 * possible through manage() or manage_copy().
 */
================================================================================

文件路径: ./interface/plain_cpp.cc
注释行数: 12
注释内容:
/* Print declarations of public constructors.
 *
 * Each class currently has two public constructors:
 *
 * 	1) A default constructor
 * 	2) A copy constructor
 *
 * Example:
 *
 *	set();
 *	set(const set &set);
 */
================================================================================

文件路径: ./interface/plain_cpp.cc
注释行数: 34
注释内容:
/* Print declaration of pointer functions.
 * Since type based subclasses share the pointer with their superclass,
 * they can also reuse these functions from the superclass.
 *
 * To obtain a raw pointer three functions are provided:
 *
 * 	1) __isl_give isl_set *copy()
 *
 * 	  Returns a pointer to a _copy_ of the internal object
 *
 * 	2) __isl_keep isl_set *get()
 *
 * 	  Returns a pointer to the internal object
 *
 * 	3) __isl_give isl_set *release()
 *
 * 	  Returns a pointer to the internal object and resets the
 * 	  internal pointer to nullptr.
 *
 * We also provide functionality to explicitly check if a pointer is
 * currently managed by this object.
 *
 * 	4) bool is_null()
 *
 * 	  Check if the current object is a null pointer.
 *
 * The functions get() and release() model the value_ptr proposed in
 * http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2012/n3339.pdf.
 * The copy() function is an extension to allow the user to explicitly
 * copy the underlying object.
 *
 * Also generate a declaration to delete copy() for r-values, for
 * r-values release() should be used to avoid unnecessary copies.
 */
================================================================================

文件路径: ./interface/plain_cpp.cc
注释行数: 11
注释内容:
/* Print a template declaration with given indentation
 * for the "isa_type" method that ensures it is only enabled
 * when called with a template argument
 * that represents a type that is equal to that
 * of the return type of the type function of "super".
 * In particular, "isa_type" gets called from "isa"
 * with as template argument the type of the "type" field
 * of the subclass.
 * The check ensures that this subclass is in fact a direct subclass
 * of "super".
 */
================================================================================

文件路径: ./interface/plain_cpp.cc
注释行数: 10
注释内容:
/* Print declarations for the "as" and "isa" methods, if the printed class
 * is a superclass with a type function.
 *
 * "isa" checks whether an object is of a given subclass type.
 * "isa_type" does the same, but gets passed the value of the type field
 * of the subclass as a function argument and the type of this field
 * as a template argument.
 * "as" tries to cast an object to a given subclass type, returning
 * an invalid object if the object is not of the given type.
 */
================================================================================

文件路径: ./interface/plain_cpp.cc
注释行数: 10
注释内容:
/* Given a method "method" for setting a persistent callback,
 * print the fields that are needed for marshalling the callback.
 *
 * In particular, print
 * - the declaration of a data structure for storing the C++ callback function
 * - a shared pointer to such a data structure
 * - the declaration of a static inline method
 *   for use as the C callback function
 * - the declaration of a private method for setting the callback function
 */
================================================================================

文件路径: ./interface/plain_cpp.cc
注释行数: 12
注释内容:
/* Print an operator for inserting objects of the class
 * into an output stream.
 *
 * Unless checked C++ bindings are being generated,
 * the operator requires its argument to be non-NULL.
 * An exception is thrown if anything went wrong during the printing.
 * During this printing, isl is made not to print any error message
 * because the error message is included in the exception.
 *
 * If checked C++ bindings are being generated and anything went wrong,
 * then record this failure in the output stream.
 */
================================================================================

文件路径: ./interface/plain_cpp.cc
注释行数: 18
注释内容:
/* Print implementation of global factory functions.
 *
 * Each class has two global factory functions:
 *
 * 	set manage(__isl_take isl_set *ptr);
 * 	set manage_copy(__isl_keep isl_set *ptr);
 *
 * Unless checked C++ bindings are being generated,
 * both functions require the argument to be non-NULL.
 * An exception is thrown if anything went wrong during the copying
 * in manage_copy.
 * During the copying, isl is made not to print any error message
 * because the error message is included in the exception.
 *
 * For a subclass based on a type function, no factory functions
 * are introduced because they share the C object type with
 * the superclass.
 */
================================================================================

文件路径: ./interface/plain_cpp.cc
注释行数: 17
注释内容:
/* Print implementations of public constructors.
 *
 * The pointer to the isl object is either initialized directly or
 * through the (immediate) superclass.
 *
 * If the class has any persistent callbacks, then copy them
 * from the original object in the copy constructor.
 * If the class is a subclass, then the persistent callbacks
 * are assumed to be copied by the copy constructor of the superclass.
 *
 * Throw an exception from the copy constructor if anything went wrong
 * during the copying or if the input is NULL, if any copying is performed.
 * During the copying, isl is made not to print any error message
 * because the error message is included in the exception.
 * No exceptions are thrown if checked C++ bindings
 * are being generated,
 */
================================================================================

文件路径: ./interface/plain_cpp.cc
注释行数: 21
注释内容:
/* Print definition for "method",
 * without any automatic type conversions.
 *
 * This method distinguishes three kinds of methods: member methods, static
 * methods, and constructors.
 *
 * Member methods and static methods return a newly managed
 * isl C++ object.
 *
 * Constructors create a new object from a given set of input parameters. They
 * do not return a value, but instead update the pointer stored inside the
 * newly created object.
 *
 * Unless checked C++ bindings are being generated,
 * the inputs of the method are first checked for being valid isl objects and
 * a copy of the associated isl::ctx is saved (if needed).
 * If any failure occurs, either during the check for the inputs or
 * during the isl function call, an exception is thrown.
 * During the function call, isl is made not to print any error message
 * because the error message is included in the exception.
 */
================================================================================

文件路径: ./interface/plain_cpp.cc
注释行数: 16
注释内容:
/* Print a definition for "method",
 * where "this" or at least one of the argument types needs to be converted.
 *
 * "method" is assumed to be a member method.
 *
 * The generated method performs the required conversion(s) and
 * calls the method generated without conversions.
 *
 * Perform a conversion from the argument in the method declaration
 * (as specified by Method::get_param) to the argument of the C function,
 * if needed.
 * Such a conversion may require the isl_ctx to be available.
 * In order to be able to use this isl_ctx, the current object needs
 * to valid.  The validity of other arguments is checked
 * by the called method.
 */
================================================================================

文件路径: ./interface/plain_cpp.cc
注释行数: 15
注释内容:
/* Print implementations for the "as" and "isa" methods, if the printed class
 * is a superclass with a type function.
 *
 * "isa" checks whether an object is of a given subclass type.
 * "isa_type" does the same, but gets passed the value of the type field
 * of the subclass as a function argument and the type of this field
 * as a template argument.
 * "as" casts an object to a given subclass type, erroring out
 * if the object is not of the given type.
 *
 * If the input is an invalid object, then these methods raise
 * an exception.
 * If checked bindings are being generated,
 * then an invalid boolean or object is returned instead.
 */
================================================================================

文件路径: ./interface/plain_cpp.cc
注释行数: 12
注释内容:
/* Print code for saving a copy of the isl::ctx available at the start
 * of the method "method" in a "saved_ctx" variable,
 * for use in exception handling.
 *
 * If checked bindings are being generated,
 * then the "saved_ctx" variable is not needed.
 * If "method" is a member function, then obtain the isl_ctx from
 * the "this" object.
 * If the first argument of the method is an isl::ctx, then use that one.
 * Otherwise, save a copy of the isl::ctx associated to the first argument
 * of isl object type.
 */
================================================================================

文件路径: ./interface/plain_cpp.cc
注释行数: 12
注释内容:
/* Print code to make isl not print an error message when an error occurs
 * within the current scope (if exceptions are available),
 * since the error message will be included in the exception.
 * If exceptions are not available, then exception::on_error
 * is set to ISL_ON_ERROR_ABORT and isl is therefore made to abort instead.
 *
 * If checked bindings are being generated,
 * then leave it to the user to decide what isl should do on error.
 * Otherwise, assume that a valid isl::ctx is available
 * in the "saved_ctx" variable,
 * e.g., through a prior call to print_save_ctx.
 */
================================================================================

文件路径: ./interface/plain_cpp.cc
注释行数: 17
注释内容:
/* Print code that checks whether the execution of the core of "method"
 * was successful.
 *
 * If checked bindings are being generated,
 * then no checks are performed.
 *
 * Otherwise, first check if any of the callbacks failed with
 * an exception.  If so, the "eptr" in the corresponding data structure
 * contains the exception that was caught and that needs to be rethrown.
 * Then check if the function call failed in any other way and throw
 * the appropriate exception.
 * In particular, if the return type is isl_stat, isl_bool or isl_size,
 * then a negative value indicates a failure.  If the return type
 * is an isl type, then a NULL value indicates a failure.
 * Assume print_save_ctx has made sure that a valid isl::ctx
 * is available in the "ctx" variable.
 */
================================================================================

文件路径: ./interface/plain_cpp.cc
注释行数: 19
注释内容:
/* Print the return statement of the C++ method "method".
 *
 * The result of the corresponding isl function is returned as a new
 * object if the underlying isl function returns an isl_* ptr, as a bool
 * if the isl function returns an isl_bool, as void if the isl functions
 * returns an isl_stat,
 * as std::string if the isl function returns 'const char *', and as
 * unmodified return value otherwise.
 * If checked C++ bindings are being generated,
 * then an isl_bool return type is transformed into a boolean and
 * an isl_stat into a stat since no exceptions can be generated
 * on negative results from the isl function.
 * If the method returns a new instance of the same object type and
 * if the class has any persistent callbacks, then the data
 * for these callbacks are copied from the original to the new object.
 * If "clazz" is a subclass that is based on a type function and
 * if the return type corresponds to the superclass data type,
 * then it is replaced by the subclass data type.
 */
================================================================================

文件路径: ./interface/plain_cpp.cc
注释行数: 10
注释内容:
/* Print the call to the C++ callback function "call",
 * with the given indentation, wrapped
 * for use inside the lambda function that is used as the C callback function,
 * in the case where checked C++ bindings are being generated.
 *
 * In particular, print
 *
 *        auto ret = @call@;
 *        return ret.release();
 */
================================================================================

文件路径: ./interface/plain_cpp.cc
注释行数: 38
注释内容:
/* Print the call to the C++ callback function "call",
 * with the given indentation and with return type "rtype", wrapped
 * for use inside the lambda function that is used as the C callback function.
 *
 * In particular, print
 *
 *        ISL_CPP_TRY {
 *          @call@;
 *          return isl_stat_ok;
 *        } ISL_CPP_CATCH_ALL {
 *          data->eptr = std::current_exception();
 *          return isl_stat_error;
 *        }
 * or
 *        ISL_CPP_TRY {
 *          auto ret = @call@;
 *          return ret ? isl_bool_true : isl_bool_false;
 *        } ISL_CPP_CATCH_ALL {
 *          data->eptr = std::current_exception();
 *          return isl_bool_error;
 *        }
 * or
 *        ISL_CPP_TRY {
 *          auto ret = @call@;
 *          return ret.release();
 *        } ISL_CPP_CATCH_ALL {
 *          data->eptr = std::current_exception();
 *          return NULL;
 *        }
 *
 * depending on the return type.
 *
 * where ISL_CPP_TRY is defined to "try" and ISL_CPP_CATCH_ALL to "catch (...)"
 * (if exceptions are available).
 *
 * If checked C++ bindings are being generated, then
 * the call is wrapped differently.
 */
================================================================================

文件路径: ./interface/plain_cpp.cc
注释行数: 22
注释内容:
/* Print the declaration for a "prefix"_data data structure
 * that can be used for passing to a C callback function
 * containing a copy of the C++ callback function "param",
 * along with an std::exception_ptr that is used to store any
 * exceptions thrown in the C++ callback.
 *
 * If the C callback is of the form
 *
 *      isl_stat (*fn)(__isl_take isl_map *map, void *user)
 *
 * then the following declaration is printed:
 *
 *      struct <prefix>_data {
 *        std::function<stat(map)> func;
 *        std::exception_ptr eptr;
 *      }
 *
 * (without a newline or a semicolon).
 *
 * The std::exception_ptr object is not added to "prefix"_data
 * if checked C++ bindings are being generated.
 */
================================================================================

文件路径: ./interface/plain_cpp.cc
注释行数: 14
注释内容:
/* Given a group of methods with the same name,
 * should extra methods be added that take as arguments
 * those types that can be converted to the original argument type
 * through a unary constructor?
 *
 * Note that even if this method returns true,
 * the extra methods are only printed by the caller
 * if exactly one of the methods in the group was originally defined
 * in the printed class.
 * Signal that they should be printed if the group contains
 * both methods originally defined in the printed class and
 * methods that have been copied from an ancestor
 * by checking whether there are at least two methods in the group.
 */
================================================================================

文件路径: ./interface/plain_cpp.cc
注释行数: 28
注释内容:
/* Print the body of C function callback with the given indentation
 * that can be use as an argument to "param" for marshalling
 * the corresponding C++ callback.
 * The data structure that contains the C++ callback is of type
 * "prefix"_data.
 *
 * For a callback of the form
 *
 *      isl_stat (*fn)(__isl_take isl_map *map, void *user)
 *
 * the following code is generated:
 *
 *        auto *data = static_cast<struct <prefix>_data *>(arg_1);
 *        ISL_CPP_TRY {
 *          stat ret = (data->func)(manage(arg_0));
 *          return isl_stat_ok;
 *        } ISL_CPP_CATCH_ALL {
 *          data->eptr = std::current_exception();
 *          return isl_stat_error;
 *        }
 *
 * If checked C++ bindings are being generated, then
 * generate the following code:
 *
 *        auto *data = static_cast<struct <prefix>_data *>(arg_1);
 *        stat ret = (data->func)(manage(arg_0));
 *        return isl_stat(ret);
 */
================================================================================

文件路径: ./interface/plain_cpp.cc
注释行数: 50
注释内容:
/* Print the local variables that are needed for a callback argument,
 * in particular, print a lambda function that wraps the callback and
 * a pointer to the actual C++ callback function.
 *
 * For a callback of the form
 *
 *      isl_stat (*fn)(__isl_take isl_map *map, void *user)
 *
 * the following lambda function is generated:
 *
 *      auto fn_lambda = [](isl_map *arg_0, void *arg_1) -> isl_stat {
 *        auto *data = static_cast<struct fn_data *>(arg_1);
 *        try {
 *          stat ret = (data->func)(manage(arg_0));
 *          return isl_stat_ok;
 *        } catch (...) {
 *          data->eptr = std::current_exception();
 *          return isl_stat_error;
 *        }
 *      };
 *
 * A copy of the std::function C++ callback function is stored in
 * a fn_data data structure for passing to the C callback function,
 * along with an std::exception_ptr that is used to store any
 * exceptions thrown in the C++ callback.
 *
 *      struct fn_data {
 *        std::function<stat(map)> func;
 *        std::exception_ptr eptr;
 *      } fn_data = { fn };
 *
 * This std::function object represents the actual user
 * callback function together with the locally captured state at the caller.
 *
 * The lambda function is expected to be used as a C callback function
 * where the lambda itself is provided as the function pointer and
 * where the user void pointer is a pointer to fn_data.
 * The std::function object is extracted from the pointer to fn_data
 * inside the lambda function.
 *
 * The std::exception_ptr object is not added to fn_data
 * if checked C++ bindings are being generated.
 * The body of the generated lambda function then is as follows:
 *
 *        stat ret = (data->func)(manage(arg_0));
 *        return isl_stat(ret);
 *
 * If the C callback does not take its arguments, then
 * manage_copy is used instead of manage.
 */
================================================================================

文件路径: ./interface/cpp_conversion.cc
注释行数: 15
注释内容:
/* Print functions for converting objects of "clazz"
 * between the default and the checked C++ bindings.
 *
 * The conversion from default to checked is called "check".
 * The inverse conversion is called "uncheck".
 * For example, to "set", the following two functions are generated:
 *
 *	checked::set check(set obj) {
 *		return checked::manage(obj.copy());
 *	}
 *
 *	set uncheck(checked::set obj) {
 *		return manage(obj.copy());
 *	}
 */
================================================================================

文件路径: ./interface/cpp.cc
注释行数: 32
注释内容:
/*
 * Copyright 2016, 2017 Tobias Grosser. All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 *
 *    1. Redistributions of source code must retain the above copyright
 *       notice, this list of conditions and the following disclaimer.
 *
 *    2. Redistributions in binary form must reproduce the above
 *       copyright notice, this list of conditions and the following
 *       disclaimer in the documentation and/or other materials provided
 *       with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY TOBIAS GROSSER ''AS IS'' AND ANY
 * EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
 * PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL TOBIAS GROSSER OR
 * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
 * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
 * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA,
 * OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
 * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
 * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 *
 * The views and conclusions contained in the software and documentation
 * are those of the authors and should not be interpreted as
 * representing official policies, either expressed or implied, of
 * Tobias Grosser.
 */
================================================================================

文件路径: ./interface/cpp.cc
注释行数: 10
注释内容:
/* Construct a generator for C++ bindings.
 *
 * The classes and methods are extracted by the constructor
 * of the generator superclass.
 *
 * Additionally extract information about types
 * that can be converted to a class and copy all methods
 * from superclasses that can be converted to a given class
 * to that class.
 */
================================================================================

文件路径: ./interface/cpp.cc
注释行数: 15
注释内容:
/* Is the method derived from "fd", with method name "name" and
 * with distance to the original ancestor "depth",
 * overridden by a method already in "clazz"?
 *
 * A method is considered to have been overridden if there
 * is a method with the same name in "clazz" that has the same signature and
 * that comes from an ancestor closer to "clazz",
 * where an ancestor is closer if the distance in the class hierarchy
 * is smaller or the distance is the same and the ancestor appears
 * closer in the declaration of the type (in which case it gets added first).
 *
 * If a method with the same signature has already been added,
 * but it does not override the method derived from "fd",
 * then this method is removed since it is overridden by "fd".
 */
================================================================================

文件路径: ./interface/cpp.cc
注释行数: 10
注释内容:
/* Copy methods from the superclasses of "clazz"
 * if an object of this class can be implicitly converted to an object
 * from the superclass, keeping track
 * of the classes that have already been handled in "done".
 *
 * Make sure the superclasses have copied methods from their superclasses first
 * since those methods could be copied further down to this class.
 *
 * Consider the superclass that appears closest to the subclass first.
 */
================================================================================

文件路径: ./interface/cpp.cc
注释行数: 11
注释内容:
/* For each (proper) class, copy methods from its superclasses,
 * if an object from the class can be converted to an object
 * from the superclass.
 *
 * Type based subclasses are not considered for now since
 * they do not have any explicit superclasses.
 *
 * Iterate through all (proper) classes and copy methods
 * from their superclasses,
 * unless they have already been determined by a recursive call.
 */
================================================================================

文件路径: ./interface/cpp.cc
注释行数: 12
注释内容:
/* Print declarations or implementations of constructors.
 *
 * For each isl function that is marked as __isl_constructor,
 * add a corresponding C++ constructor.
 *
 * Example of declarations:
 *
 * 	inline /\* implicit *\/ union_set(basic_set bset);
 * 	inline /\* implicit *\/ union_set(set set);
 * 	inline explicit val(ctx ctx, long i);
 * 	inline explicit val(ctx ctx, const std::string &str);
 */
================================================================================

文件路径: ./interface/cpp.cc
注释行数: 16
注释内容:
/* Update "convert" to reflect the next combination of automatic conversions
 * for the arguments of "fd",
 * returning false if there are no more combinations.
 *
 * In particular, find the last argument for which an automatic
 * conversion function is available mapping to the type of this argument and
 * that is not already marked for conversion.
 * Mark this argument, if any, for conversion and clear the markings
 * of all subsequent arguments.
 * Repeated calls to this method therefore run through
 * all possible combinations.
 *
 * Note that the first function argument is never considered
 * for automatic conversion since this is the argument
 * from which the isl_ctx used in the conversion is extracted.
 */
================================================================================

文件路径: ./interface/cpp.cc
注释行数: 22
注释内容:
/* Print a declaration or definition for a method called "name"
 * derived from "fd".
 *
 * If the method was copied from a superclass, then print a definition
 * that calls the corresponding method in the superclass.
 * Otherwise, for methods that are identified as "get" methods, also
 * print a declaration or definition for the method
 * using a name that includes the "get_" prefix.
 *
 * If the generated method is an object method, then check
 * whether any of its arguments can be automatically converted
 * from something else, and, if so, generate a method
 * for each combination of converted arguments.
 * Do so by constructing a ConversionMethod that changes the converted arguments
 * to those of the sources of the conversions.
 *
 * Note that a method may be both copied from a superclass and
 * have arguments that can be automatically converted.
 * In this case, the conversion methods for the arguments
 * call the corresponding method in this class, which
 * in turn will call the method in the superclass.
 */
================================================================================

文件路径: ./interface/cpp.cc
注释行数: 21
注释内容:
/* Print the use of the argument at position "pos" to "os".
 *
 * Member methods pass the isl object corresponding to "this"
 * as first argument (at position 0).
 * Any other arguments are passed along from the method arguments.
 *
 * If the argument value is loaded from a this pointer, the original
 * value must be preserved and must consequently be copied.  Values that are
 * loaded from method parameters do not need to be preserved, as such values
 * will already be copies of the actual parameters.  It is consequently possible
 * to directly take the pointer from these values, which saves
 * an unnecessary copy.
 *
 * In case the parameter is a callback function, two parameters get printed,
 * a wrapper for the callback function and a pointer to the actual
 * callback function.  The wrapper is expected to be available
 * in a previously declared variable <name>_lambda, while
 * the actual callback function is expected to be stored
 * in a structure called <name>_data.
 * The caller of this function must ensure that these variables exist.
 */
================================================================================

文件路径: ./interface/cpp.cc
注释行数: 43
注释内容:
/* Print the header for "method", without newline or semicolon,
 * using "type_printer" to print argument and return types.
 *
 * Print the header of a declaration if this->declarations is set,
 * otherwise print the header of a method definition.
 *
 * This function prints headers for member methods, static methods, and
 * constructors, either for their declaration or definition.
 *
 * Member functions are declared as "const", as they do not change the current
 * object, but instead create a new object. They always retrieve the first
 * parameter of the original isl function from the this-pointer of the object,
 * such that only starting at the second parameter the parameters of the
 * original function become part of the method's interface.
 *
 * A function
 *
 * 	__isl_give isl_set *isl_set_intersect(__isl_take isl_set *s1,
 * 		__isl_take isl_set *s2);
 *
 * is translated into:
 *
 * 	inline set intersect(set set2) const
 *
 * For static functions and constructors all parameters of the original isl
 * function are exposed.
 *
 * Parameters of which no copy is required, are passed
 * as const reference, which allows the compiler to optimize the parameter
 * transfer.
 *
 * Constructors are marked as explicit using the C++ keyword 'explicit' or as
 * implicit using a comment in place of the explicit keyword. By annotating
 * implicit constructors with a comment, users of the interface are made
 * aware of the potential danger that implicit construction is possible
 * for these constructors, whereas without a comment not every user would
 * know that implicit construction is allowed in absence of an explicit keyword.
 *
 * Note that in case "method" is a ConversionMethod, the argument returned
 * by Method::get_param may be different from the original argument.
 * The name of the argument is, however, derived from the original
 * function argument.
 */
================================================================================

文件路径: ./interface/cpp.cc
注释行数: 16
注释内容:
/* Generate the list of argument types for a callback function of
 * type "type", appearing in argument position "arg".
 * If "cpp" is set, then generate the C++ type list, otherwise
 * the C type list.
 *
 * For a callback of type
 *
 *      isl_stat (*)(__isl_take isl_map *map, void *user)
 *
 * the following C++ argument list is generated:
 *
 *      map
 *
 * The arguments of the callback are considered to appear
 * after the position of the callback itself.
 */
================================================================================

文件路径: ./interface/cpp.cc
注释行数: 11
注释内容:
/* Generate the full cpp type of a callback function of type "type",
 * appearing in argument position "arg".
 *
 * For a callback of type
 *
 *      isl_stat (*)(__isl_take isl_map *map, void *user)
 *
 * the following type is generated:
 *
 *      std::function<stat(map)>
 */
================================================================================

文件路径: ./interface/cpp.cc
注释行数: 12
注释内容:
/* Return the number of parameters of the corresponding C function.
 *
 * If the method has a callback argument, we reduce the number of parameters
 * that are exposed by one to hide the user pointer from the interface. On
 * the C++ side no user pointer is needed, as arguments can be forwarded
 * as part of the std::function argument which specifies the callback function.
 *
 * The user pointer is also removed from the number of parameters
 * of the C function because the pair of callback and user pointer
 * is considered as a single argument that is printed as a whole
 * by Method::print_param_use.
 */
================================================================================

文件路径: ./interface/cpp.cc
注释行数: 12
注释内容:
/* Should the parameter at position "pos" be a copy (rather than
 * a const reference)?
 *
 * Strictly speaking, a copy is only needed on isl types that are
 * not marked __isl_keep, since those will be release()'d
 * by code printed by Method::print_param_use.
 *
 * However, there may be other arguments such as integer types
 * that are more naturally passed as a copy.
 * The default is therefore to require a copy, except for
 * arguments marked __isl_keep, string arguments or callback arguments.
 */
================================================================================

文件路径: ./interface/generator.h
注释行数: 33
注释内容:
/* isl_class collects all constructors and methods for an isl "class".
 * "name" is the name of the class.
 * If this object describes a subclass of a C type, then
 * "subclass_name" is the name of that subclass and "superclass_name"
 * is the name of the immediate superclass of that subclass.  Otherwise,
 * "subclass_name" is equal to "name" and "superclass_name" is undefined.
 * "type" is the declaration that introduces the type.
 * "persistent_callbacks" contains the set of functions that
 * set a persistent callback.
 * "set_enums" maps the set of functions that set an enum value
 * to information associated to each value.
 * A function is considered to set an enum value if it returns
 * an object of the same type and if its last argument is of an enum type.
 * "methods" contains the set of methods, grouped by method name.
 * "fn_to_str" is a reference to the *_to_str method of this class, if any.
 * "fn_copy" is a reference to the *_copy method of this class, if any.
 * "fn_free" is a reference to the *_free method of this class, if any.
 * "fn_type" is a reference to a function that described subclasses, if any.
 * If "fn_type" is set, then "type_subclasses" maps the values returned
 * by that function to the names of the corresponding subclasses.
 *
 * The following fields are only used for the C++ bindings.
 * For methods that are not derived from a function that applies
 * directly to this class, but are rather copied from some ancestor,
 * "copied_from" records the direct superclass from which the method
 * was copied (where it may have been copied from a further ancestor) and
 * "copy_depth" records the distance to the ancestor to which
 * the function applies.
 * "construction_types" contains the set of isl classes that can be
 * implicitly converted to this class through a unary constructor,
 * mapped to the single argument
 * of this unary constructor.
 */
================================================================================

文件路径: ./include/isl/hmap_templ.c
注释行数: 11
注释内容:
/*
 * Copyright 2011      INRIA Saclay
 * Copyright 2013      Ecole Normale Superieure
 *
 * Use of this software is governed by the MIT license
 *
 * Written by Sven Verdoolaege, INRIA Saclay - Ile-de-France,
 * Parc Club Orsay Universite, ZAC des vignes, 4 rue Jacques Monod,
 * 91893 Orsay, France
 * and Ecole Normale Superieure, 45 rue d’Ulm, 75230 Paris, France
 */
================================================================================

文件路径: ./include/isl/ctx.h
注释行数: 24
注释内容:
/* Nearly all isa functions require a struct isl_ctx allocated using
 * isl_ctx_alloc.  This ctx contains (or will contain) options that
 * control the behavior of the library and some caches.
 *
 * An object allocated within a given ctx should never be used inside
 * another ctx.  Functions for moving objects from one ctx to another
 * will be added as the need arises.
 *
 * A given context should only be used inside a single thread.
 * A global context for synchronization between different threads
 * as well as functions for moving a context to a different thread
 * will be added as the need arises.
 *
 * If anything goes wrong (out of memory, failed assertion), then
 * the library will currently simply abort.  This will be made
 * configurable in the future.
 * Users of the library should expect functions that return
 * a pointer to a structure, to return NULL, indicating failure.
 * Any function accepting a pointer to a structure will treat
 * a NULL argument as a failure, resulting in the function freeing
 * the remaining structures (if any) and returning NULL itself
 * (in case of pointer return type).
 * The only exception is the isl_ctx argument, which should never be NULL.
 */
================================================================================

文件路径: ./include/isl/root_headfile/isl_stream_private.h
注释行数: 17
注释内容:
/* An input stream that may be either a file or a string.
 *
 * line and col are the line and column number of the next character (1-based).
 * start_line and start_col are set by isl_stream_getc to point
 * to the position of the returned character.
 * last_line is the line number of the previous token.
 *
 * yaml_state and yaml_indent keep track of the currently active YAML
 * elements.  yaml_size is the size of these arrays, while yaml_depth
 * is the number of elements currently in use.
 * yaml_state and yaml_indent may be NULL if no YAML parsing is being
 * performed.
 * yaml_state keeps track of what is expected next at each level.
 * yaml_indent keeps track of the indentation at each level, with
 * ISL_YAML_INDENT_FLOW meaning that the element is in flow format
 * (such that the indentation is not relevant).
 */
================================================================================

文件路径: ./include/isl/root_headfile/isl_map_private.h
注释行数: 10
注释内容:
/* A "basic map" is a relation between two sets of variables,
 * called the "in" and "out" variables.
 * A "basic set" is a basic map with a zero-dimensional
 * domain.
 *
 * It is implemented as a set with two extra fields:
 * n_in is the number of in variables
 * n_out is the number of out variables
 * n_in + n_out should be equal to set.dim
 */
================================================================================

文件路径: ./include/isl/root_headfile/isl_map_private.h
注释行数: 11
注释内容:
/* A "map" is a (possibly disjoint) union of basic maps.
 * A "set" is a (possibly disjoint) union of basic sets.
 *
 * Currently, the isl_set structure is identical to the isl_map structure
 * and the library depends on this correspondence internally.
 * However, users should not depend on this correspondence.
 *
 * "cached_simple_hull" contains copies of the unshifted and shifted
 * simple hulls, if they have already been computed.  Otherwise,
 * the entries are NULL.
 */
================================================================================

文件路径: ./include/isl/root_headfile/isl_schedule_tree.h
注释行数: 40
注释内容:
/* A schedule (sub)tree.
 *
 * The leaves of a tree are not explicitly represented inside
 * the isl_schedule_tree, except when the tree consists of only a leaf.
 *
 * The "band" field is valid when type is isl_schedule_node_band.
 * The "context" field is valid when type is isl_schedule_node_context
 * and represents constraints on the flat product of the outer band nodes,
 * possibly introducing additional parameters.
 * The "domain" field is valid when type is isl_schedule_node_domain
 * and introduces the statement instances scheduled by the tree.
 *
 * The "contraction" and "expansion" fields are valid when type
 * is isl_schedule_node_expansion.
 * "expansion" expands the reaching domain elements to one or more
 * domain elements for the subtree.
 * "contraction" maps these elements back to the corresponding
 * reaching domain element.  It does not involve any domain constraints.
 *
 * The "extension" field is valid when the is isl_schedule_node_extension
 * maps outer schedule dimensions (the flat product of the outer band nodes)
 * to additional iteration domains.
 *
 * The "filter" field is valid when type is isl_schedule_node_filter
 * and represents the statement instances selected by the node.
 *
 * The "guard" field is valid when type is isl_schedule_node_guard
 * and represents constraints on the flat product of the outer band nodes
 * that need to be enforced by the outer nodes in the generated AST.
 *
 * The "mark" field is valid when type is isl_schedule_node_mark and
 * identifies the mark.
 *
 * The "children" field is valid for all types except
 * isl_schedule_node_leaf.  This field is NULL if there are
 * no children (except for the implicit leaves).
 *
 * anchored is set if the node or any of its descendants depends
 * on its position in the schedule tree.
 */
================================================================================

文件路径: ./include/isl/root_headfile/isl_multi_templ.h
注释行数: 10
注释内容:
/* A multiple expression with base expressions of type EL.
 *
 * "space" is the space in which the multiple expression lives.
 * "n" is the number of base expression and is equal
 * to the output or set dimension of "space".
 * "p" is an array of size "n" of base expressions.
 * The array is only accessible when n > 0.
 * "dom" is the explicit domain, if present
 * The explicit domain is only accessible when n == 0.
 */
================================================================================

文件路径: ./include/isl/root_headfile/isl_ast_build_private.h
注释行数: 134
注释内容:
/* An isl_ast_build represents the context in which AST is being
 * generated.  That is, it (mostly) contains information about outer
 * loops that can be used to simplify inner loops.
 *
 * "domain" represents constraints on the internal schedule domain,
 * corresponding to the context of the AST generation and the constraints
 * implied by the loops that have already been generated.
 * When an isl_ast_build is first created, outside any AST generation,
 * the domain is typically a parameter set.  It is only when a AST
 * generation phase is initiated that the domain of the isl_ast_build
 * is changed to refer to the internal schedule domain.
 * The domain then lives in a space of the form
 *
 *	S
 *
 *  or
 *
 *	[O -> S]
 *
 * O represents the loops generated in outer AST generations.
 * S represents the loops (both generated and to be generated)
 * of the current AST generation.
 * Both include eliminated loops.
 * "domain" is expected not to have any unknown divs because
 * it is used as the context argument in a call to isl_basic_set_gist
 * in isl_ast_build_compute_gist_basic_set.
 *
 * "depth" is equal to the number of loops that have already
 * been generated (including those in outer AST generations).
 * "outer_pos" is equal to the number of loops in outer AST generations.
 *
 * "generated" is a superset of "domain" corresponding to those
 * constraints that were either given by the user or that have
 * effectively been generated (as bounds on a for loop).
 *
 * "pending" is a superset of "domain" corresponding to the constraints
 * that still need to be generated (as guards), but that may end up
 * not getting generated if they are implied by any constraints
 * enforced by inner loops.
 *
 * "strides" contains the stride of each loop.  The number of elements
 * is equal to the number of dimensions in "domain".
 * "offsets" contains the offsets of strided loops.  If s is the stride
 * for a given dimension and f is the corresponding offset, then the
 * dimension takes on values
 *
 *	f + s a
 *
 * with a an integer.  For non-strided loops, the offset is zero.
 *
 * "iterators" contains the loop iterators of both generated and
 * to be generated loops.  The number of elements is at least as
 * large as the dimension of the internal schedule domain.  The
 * number may be larger, in which case the additional ids can be
 * used in a nested AST generation should the schedule be non-injective.
 *
 * "values" lives in the space
 *
 *	[O -> S] -> [O -> S]		(or S -> S)
 *
 * and expresses (if possible) loop iterators in terms of parameters
 * and outer loop iterators.  If the value of a given loop iterator
 * cannot be expressed as an affine expression (either because the iterator
 * attains multiple values or because the single value is a piecewise
 * affine expression), then it is expressed in "values" as being equal
 * to itself.
 *
 * "value" is the value of the loop iterator at the current depth.
 * It is NULL if it has not been computed yet or if the value of the
 * given loop iterator cannot be expressed as a piecewise affine expression
 * (because the iterator attains multiple values).
 *
 * "schedule_map" maps the internal schedule domain to the external schedule
 * domain.  It may be NULL if it hasn't been computed yet.
 * See isl_ast_build_get_schedule_map_multi_aff.
 *
 * "internal2input" maps the internal schedule domain to the original
 * input schedule domain.  In case of a schedule tree input, the original
 * input schedule domain consist of the flat product of all outer
 * band node spaces, including the current band node.
 * It may be NULL if there no longer is such a uniform mapping
 * (because different iterations have been rescheduled differently).
 *
 * "options" contains the AST build options in case we are generating
 * an AST from a flat schedule map.  When creating an AST from a schedule
 * tree, this field is ignored.
 *
 * The "create_leaf" callback is called for every leaf in the generated AST.
 * The callback is responsible for creating the node to be placed at those
 * leaves.  If this callback is not set, then isl will generated user
 * nodes with call expressions corresponding to an element of the domain.
 *
 * The "at_each_domain" callback is called on every node created to represent
 * an element of the domain.  Each of these nodes is a user node
 * with as expression a call expression.
 *
 * The "before_each_for" callback is called on each for node before
 * its children have been created.
 *
 * The "after_each_for" callback is called on each for node after
 * its children have been created.
 *
 * The "before_each_mark" callback is called before we handle the subtree
 * of an isl_schedule_node_mark node.
 *
 * The "after_each_mark" callback is called after we have handled the subtree
 * of an isl_schedule_node_mark node.
 *
 * "executed" contains the inverse schedule at this point
 * of the AST generation.
 * It is currently only used in isl_ast_build_get_schedule, which is
 * in turn only used by user code from within a callback.
 * The value is set right before we may be calling such a callback.
 *
 * "single_valued" is set if the current inverse schedule (which may or may
 * not be stored in "executed") is known to be single valued, specifically
 * an inverse schedule that was not (appeared not to be) single valued
 * is extended to a single valued inverse schedule.  This is mainly used
 * to avoid an infinite recursion when we fail to detect later on that
 * the extended inverse schedule is single valued.
 *
 * "node" points to the current band node in case we are generating
 * an AST from a schedule tree.  It may be NULL if we are not generating
 * an AST from a schedule tree or if we are not inside a band node.
 *
 * "loop_type" originally contains loop AST generation types for
 * the "n" members of "node" and it is updated (along with "n") when
 * a schedule dimension is inserted.
 * It is NULL if "node" is NULL.
 *
 * "isolated" is the piece of the schedule domain isolated by the isolate
 * option on the current band.  This set may be NULL if we have not checked
 * for the isolate option yet.
 */
================================================================================

文件路径: ./include/isl/root_headfile/isl_schedule_band.h
注释行数: 21
注释内容:
/* Information about a band within a schedule.
 *
 * n is the number of scheduling dimensions within the band.
 * coincident is an array of length n, indicating whether a scheduling dimension
 *	satisfies the coincidence constraints in the sense that
 *	the corresponding dependence distances are zero.
 * permutable is set if the band is permutable.
 * mupa is the partial schedule corresponding to this band.  The dimension
 *	of mupa is equal to n.
 * loop_type contains the loop AST generation types for the members
 * in the band.  It may be NULL, if all members are
 * of type isl_ast_loop_default.
 * isolate_loop_type contains the loop AST generation types for the members
 * in the band for the isolated part.  It may be NULL, if all members are
 * of type isl_ast_loop_default.
 * ast_build_options are the remaining AST build options associated
 * to the band.
 * anchored is set if the node depends on its position in the schedule tree.
 *	In particular, it is set if the AST build options include
 *	an isolate option.
 */
================================================================================

文件路径: ./include/isl/root_headfile/isl_output_private.h
注释行数: 11
注释内容:
/* Internal data structure for isl_print_space.
 *
 * latex is set if that is the output format.
 * print_dim (if not NULL) is called on each dimension.
 * user is set by the caller of print_space and may be used inside print_dim.
 *
 * space is the global space that is being printed.  This field is set by
 *	print_space.
 * type is the tuple of the global space that is currently being printed.
 *	This field is set by print_space.
 */
================================================================================

文件路径: ./include/isl/root_headfile/isl_ast_graft_private.h
注释行数: 15
注释内容:
/* Representation of part of an AST ("node") with some additional polyhedral
 * information about the tree.
 *
 * "guard" contains conditions that should still be enforced by
 * some ancestor of the current tree.  In particular, the already
 * generated tree assumes that these conditions hold, but may not
 * have enforced them itself.
 * The guard should not contain any unknown divs as it will be used
 * to generate an if condition.
 *
 * "enforced" expresses constraints that are already enforced by the for
 * nodes in the current tree and that therefore do not need to be enforced
 * by any ancestor.
 * The constraints only involve outer loop iterators.
 */
================================================================================

文件路径: ./include/isl/root_headfile/isl_tarjan.h
注释行数: 10
注释内容:
/* Structure for representing the graph being traversed
 * using Tarjan's algorithm.
 * len is the number of nodes
 * node is an array of nodes
 * stack contains the nodes on the path from the root to the current node
 * sp is the stack pointer
 * index is the index of the last node visited
 * order contains the elements of the components separated by -1
 * op represents the current position in order
 */
================================================================================

文件路径: ./include/isl/root_headfile/isl_int_sioimath.h
注释行数: 41
注释内容:
/* The type to represent integers optimized for small values. It is either a
 * pointer to an mp_int ( = mpz_t*; big representation) or an int32_t (small
 * represenation) with a discriminator at the least significant bit. In big
 * representation it will be always zero because of heap alignment. It is set
 * to 1 for small representation and use the 32 most significant bits for the
 * int32_t.
 *
 * Structure on 64 bit machines, with 8-byte aligment (3 bits):
 *
 * Big representation:
 * MSB                                                          LSB
 * |------------------------------------------------------------000
 * |                            mpz_t*                            |
 * |                           != NULL                            |
 *
 * Small representation:
 * MSB                           32                             LSB
 * |------------------------------|00000000000000000000000000000001
 * |          int32_t             |
 * |  2147483647 ... -2147483647  |
 *                                                                ^
 *                                                                |
 *                                                        discriminator bit
 *
 * On 32 bit machines isl_sioimath type is blown up to 8 bytes, i.e.
 * isl_sioimath is guaranteed to be at least 8 bytes. This is to ensure the
 * int32_t can be hidden in that type without data loss. In the future we might
 * optimize this to use 31 hidden bits in a 32 bit pointer. We may also use 63
 * bits on 64 bit machines, but this comes with the cost of additional overflow
 * checks because there is no standardized 128 bit integer we could expand to.
 *
 * We use native integer types and avoid union structures to avoid assumptions
 * on the machine's endianness.
 *
 * This implementation makes the following assumptions:
 * - long can represent any int32_t
 * - mp_small is signed long
 * - mp_usmall is unsigned long
 * - adresses returned by malloc are aligned to 2-byte boundaries (leastmost
 *   bit is zero)
 */
================================================================================

文件路径: ./include/isl/root_headfile/isl_int_sioimath.h
注释行数: 11
注释内容:
/* The negation of the smallest possible number in int32_t, INT32_MIN
 * (0x80000000u, -2147483648), cannot be represented in an int32_t, therefore
 * every operation that may produce this value needs to special-case it.
 * The operations are:
 * abs(INT32_MIN)
 * -INT32_MIN   (negation)
 * -1 * INT32_MIN (multiplication)
 * INT32_MIN/-1 (any division: divexact, fdiv, cdiv, tdiv)
 * To avoid checking these cases, we exclude INT32_MIN from small
 * representation.
 */
================================================================================

文件路径: ./include/isl/root_headfile/isl_int_sioimath.h
注释行数: 22
注释内容:
/* A common situation is to call an IMath function with at least one argument
 * that is currently in small representation or an integer parameter, i.e. a big
 * representation of the same number is required. Promoting the original
 * argument comes with multiple problems, such as modifying a read-only
 * argument, the responsibility of deallocation and the execution cost. Instead,
 * we make a copy by 'faking' the IMath internal structure.
 *
 * We reserve the maximum number of required digits on the stack to avoid heap
 * allocations.
 *
 * mp_digit can be uint32_t or uint16_t. This code must work for little and big
 * endian digits. The structure for an uint64_t argument and 32-bit mp_digits is
 * sketched below.
 *
 * |----------------------------|
 *            uint64_t
 *
 * |-------------||-------------|
 *    mp_digit        mp_digit
 *    digits[1]       digits[0]
 * Most sig digit  Least sig digit
 */
================================================================================

文件路径: ./include/isl/root_headfile/isl_int_sioimath.h
注释行数: 12
注释内容:
/* Convert a native integer to IMath's digit representation. A native integer
 * might be big- or little endian, but IMath always stores the least significant
 * digit in the lowest array indices.  memcpy therefore is not possible.
 *
 * We also have to consider that long and mp_digit can be of different sizes,
 * depending on the compiler (LP64, LLP64) and IMath's USE_64BIT_WORDS. This
 * macro should work for all of them.
 *
 * "used" is set to the number of written digits. It must be minimal (IMath
 * checks zeroness using the used field), but always at least one.  Also note
 * that the result of num>>(sizeof(num)*CHAR_BIT) is undefined.
 */
================================================================================

文件路径: ./include/isl/root_headfile/isl_printer_private.h
注释行数: 16
注释内容:
/* A printer to a file or a string.
 *
 * "dump" is set if the printing is performed from an isl_*_dump function.
 *
 * yaml_style is the YAML style in which the next elements should
 * be printed and may be either ISL_YAML_STYLE_BLOCK or ISL_YAML_STYLE_FLOW,
 * with ISL_YAML_STYLE_FLOW being the default.
 * yaml_state keeps track of the currently active YAML elements.
 * yaml_size is the size of this arrays, while yaml_depth
 * is the number of elements currently in use.
 * yaml_state may be NULL if no YAML printing is being performed.
 *
 * notes keeps track of arbitrary notes as a mapping between
 * name identifiers and note identifiers.  It may be NULL
 * if there are no notes yet.
 */
================================================================================

文件路径: ./include/isl/root_headfile/isl_tab.h
注释行数: 61
注释内容:
/* The tableau maintains equality relations.
 * Each column and each row is associated to a variable or a constraint.
 * The "value" of an inequality constraint is the value of the corresponding
 * slack variable.
 * The "row_var" and "col_var" arrays map column and row indices
 * to indices in the "var" and "con" arrays.  The elements of these
 * arrays maintain extra information about the variables and the constraints.
 * Each row expresses the corresponding row variable as an affine expression
 * of the column variables.
 * The first two columns in the matrix contain the common denominator of
 * the row and the numerator of the constant term.
 * If "M" is set, then the third column represents the "big parameter".
 * The third (M = 0) or fourth (M = 1) column
 * in the matrix is called column 0 with respect to the col_var array.
 * The sample value of the tableau is the value that assigns zero
 * to all the column variables and the constant term of each affine
 * expression to the corresponding row variable.
 * The operations on the tableau maintain the property that the sample
 * value satisfies the non-negativity constraints (usually on the slack
 * variables).
 *
 * The big parameter represents an arbitrarily big (and divisible)
 * positive number.  If present, then the sign of a row is determined
 * lexicographically, with the sign of the big parameter coefficient
 * considered first.  The big parameter is only used while
 * solving PILP problems.
 *
 * The first n_dead column variables have their values fixed to zero.
 * The corresponding tab_vars are flagged "is_zero".
 * Some of the rows that have have zero coefficients in all but
 * the dead columns are also flagged "is_zero".
 *
 * The first n_redundant rows correspond to inequality constraints
 * that are always satisfied for any value satisfying the non-redundant
 * rows.  The corresponding tab_vars are flagged "is_redundant".
 * A row variable that is flagged "is_zero" is also flagged "is_redundant"
 * since the constraint has been reduced to 0 = 0 and is therefore always
 * satisfied.
 *
 * There are "n_var" variables in total.  The first "n_param" of these
 * are called parameters and the last "n_div" of these are called divs.
 * The basic tableau operations makes no distinction between different
 * kinds of variables.  These special variables are only used while
 * solving PILP problems.
 *
 * Dead columns and redundant rows are detected on the fly.
 * However, the basic operations do not ensure that all dead columns
 * or all redundant rows are detected.
 * isl_tab_detect_implicit_equalities and isl_tab_detect_redundant can be used
 * to perform an exhaustive search for dead columns and redundant rows.
 *
 * The samples matrix contains "n_sample" integer points that have at some
 * point been elements satisfying the tableau.  The first "n_outside"
 * of them no longer satisfy the tableau.  They are kept because they
 * can be reinstated during rollback when the constraint that cut them
 * out is removed.  These samples are only maintained for the context
 * tableau while solving PILP problems.
 *
 * If "preserve" is set, then we want to keep all constraints in the
 * tableau, even if they turn out to be redundant.
 */
================================================================================

文件路径: ./include/isl/root_headfile/isl_schedule_node_private.h
注释行数: 16
注释内容:
/* An isl_schedule_node points to a particular location in a schedule tree.
 *
 * "schedule" is the schedule that the node is pointing to.
 * "ancestors" is a list of the n ancestors of the node
 * that is being pointed to.
 * The first ancestor is the root of "schedule", while the last ancestor
 * is the parent of the specified location.
 * "child_pos" is an array of child positions of the same length as "ancestors",
 * where ancestor i (i > 0) appears in child_pos[i - 1] of ancestor i - 1 and
 * "tree" appears in child_pos[n - 1] of ancestor n - 1.
 * "tree" is the subtree at the specified location.
 *
 * Note that the same isl_schedule_tree object may appear several times
 * in a schedule tree and therefore does not uniquely identify a position
 * in the schedule tree.
 */
================================================================================
