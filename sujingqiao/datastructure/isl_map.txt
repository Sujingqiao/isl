非常棒的请求！你给出的是一组来自 `isl_map_private.h` 或类似内部头文件的 **ISL（Integer Set Library）核心构造与操作函数**。我们将这些接口按照 **处理逻辑（操作类型）** 进行分组，允许函数重复出现在多个组中（因为一个函数可能服务于多个目的），并对每个函数进行 **详细注释**，说明其作用、参数含义和使用场景。

---

## 🔹 分组 1：基础集合/映射的创建与内存分配

> **处理逻辑**：为 `isl_basic_set` 或 `isl_basic_map` 分配内存空间，初始化结构体字段，准备后续添加约束。

| 函数 | 详细注释 |
|------|----------|
| `__isl_give isl_basic_set *isl_basic_set_alloc(isl_ctx *ctx, unsigned nparam, unsigned dim, unsigned extra, unsigned n_eq, unsigned n_ineq);` | 创建一个新的 `isl_basic_set`。参数：<br> - `ctx`: 上下文<br> - `nparam`: 参数数量<br> - `dim`: 变量维度（如 i,j）<br> - `extra`: 额外保留空间（用于未来插入 div 或维度）<br> - `n_eq`: 预分配等式数量<br> - `n_ineq`: 预分配不等式数量<br> 返回一个空的 `basic_set`，但已分配好约束数组空间。 |
| `__isl_give isl_basic_map *isl_basic_map_alloc(isl_ctx *ctx, unsigned nparam, unsigned in, unsigned out, unsigned extra, unsigned n_eq, unsigned n_ineq);` | 类似上者，但用于 `isl_basic_map`（有输入/输出维度）。`in` 是输入维度数，`out` 是输出维度数。 |
| `__isl_give isl_basic_set *isl_basic_set_alloc_space(__isl_take isl_space *space, unsigned extra, unsigned n_eq, unsigned n_ineq);` | 使用已构建的 `isl_space` 来创建 `basic_set`。更高级的接口，空间结构已定义好。 |
| `__isl_give isl_basic_map *isl_basic_map_alloc_space(__isl_take isl_space *space, unsigned extra, unsigned n_eq, unsigned n_ineq);` | 同上，用于 `basic_map`。 |

---

## 🔹 分组 2：扩展预分配空间（动态增长）

> **处理逻辑**：在已有的 `basic_set/map` 基础上，扩展其可容纳的约束或维度数量，避免频繁 realloc。

| 函数 | 详细注释 |
|------|----------|
| `__isl_give isl_basic_set *isl_basic_set_extend_constraints(__isl_take isl_basic_set *base, unsigned n_eq, unsigned n_ineq);` | 扩展 `base` 的等式和不等式数组容量，但不立即添加约束。用于预估后续要加很多约束时优化性能。 |
| `__isl_give isl_basic_map *isl_basic_map_extend_constraints(__isl_take isl_basic_map *base, unsigned n_eq, unsigned n_ineq);` | 同上，用于 `basic_map`。 |
| `__isl_give isl_basic_map *isl_basic_map_extend(__isl_take isl_basic_map *base, unsigned extra, unsigned n_eq, unsigned n_ineq);` | 更全面的扩展：可同时扩展 `extra` 空间（如 div）、等式、不等式。 |
| `__isl_give isl_basic_set *isl_basic_set_extend(__isl_take isl_basic_set *base, unsigned extra, unsigned n_eq, unsigned n_ineq);` | 同上，用于 `basic_set`。 |
| `__isl_give isl_map *isl_map_grow(__isl_take isl_map *map, int n);` | 扩展 `isl_map` 的 `p[]` 数组容量，使其能容纳更多 `basic_map`。`n` 是新增容量。 |
| `__isl_give isl_set *isl_set_grow(__isl_take isl_set *set, int n);` | 同上，用于 `isl_set`。 |

---

## 🔹 分组 3：约束的动态添加与管理

> **处理逻辑**：向 `basic_set/map` 中动态添加等式或不等式约束，并管理其内部数组。

| 函数 | 详细注释 |
|------|----------|
| `int isl_basic_map_alloc_equality(__isl_keep isl_basic_map *bmap);` | 请求为 `bmap` 分配一个新的等式槽位（索引），返回其位置（>=0），失败返回 -1。不初始化内容。 |
| `int isl_basic_set_alloc_equality(__isl_keep isl_basic_set *bset);` | 同上，用于 `basic_set`。 |
| `int isl_basic_map_alloc_inequality(__isl_keep isl_basic_map *bmap);` | 请求分配一个不等式槽位，返回索引。 |
| `int isl_basic_set_alloc_inequality(__isl_keep isl_basic_set *bset);` | 同上，用于 `basic_set`。 |
| `__isl_give isl_basic_set *isl_basic_set_add_eq(__isl_take isl_basic_set *bset, isl_int *eq);` | 将系数数组 `eq` 作为新等式添加到 `bset`。`eq` 格式：[cst, p0..pn, v0..vm] |
| `__isl_give isl_basic_map *isl_basic_map_add_eq(__isl_take isl_basic_map *bmap, isl_int *eq);` | 同上，用于 `basic_map`。 |
| `__isl_give isl_basic_set *isl_basic_set_add_ineq(__isl_take isl_basic_set *bset, isl_int *ineq);` | 添加一个不等式（≥0 形式）。 |
| `__isl_give isl_basic_map *isl_basic_map_add_ineq(__isl_take isl_basic_map *bmap, isl_int *ineq);` | 同上，用于 `basic_map`。 |
| `void isl_basic_map_inequality_to_equality(__isl_keep isl_basic_map *bmap, unsigned pos);` | 将位置 `pos` 的不等式**转换为等式**（通常用于检测到两个不等式互为相反数时）。 |
| `int isl_basic_map_drop_equality(__isl_keep isl_basic_map *bmap, unsigned pos);` | 删除位置 `pos` 的等式，将其移至末尾并减少计数。 |
| `int isl_basic_set_drop_inequality(__isl_keep isl_basic_set *bset, unsigned pos);`<br>`int isl_basic_map_drop_inequality(__isl_keep isl_basic_map *bmap, unsigned pos);` | 删除指定位置的不等式。 |

---

## 🔹 分组 4：除法（Div / Floor Expression）管理

> **处理逻辑**：管理 `basic_map/set` 中的 `div` 表达式（形如 `e = ⌊(a·x + b)/d⌋`），用于表示向下取整或模运算。

| 函数 | 详细注释 |
|------|----------|
| `int isl_basic_map_alloc_div(__isl_keep isl_basic_map *bmap);` | 为 `bmap` 分配一个新的 `div` 槽位，返回其索引（在 `div` 数组中的位置）。 |
| `int isl_basic_set_alloc_div(__isl_keep isl_basic_set *bset);` | 同上，用于 `basic_set`。 |
| `__isl_give isl_basic_map *isl_basic_map_insert_div(__isl_take isl_basic_map *bmap, int pos, __isl_keep isl_vec *div);` | 在位置 `pos` 插入一个 `div` 表达式（`div` 向量格式：[d, b, a0...an]）。 |
| `isl_stat isl_basic_map_free_div(__isl_keep isl_basic_map *bmap, unsigned n);` | 标记第 `n` 个 `div` 为空闲（不释放内存，仅标记）。 |
| `__isl_give isl_basic_map *isl_basic_map_drop_div(__isl_take isl_basic_map *bmap, unsigned div);` | 从 `bmap` 中移除第 `div` 个 `div` 表达式，并调整约束引用。 |

---

## 🔹 分组 5：最终化与规范化（Finalize & Simplify）

> **处理逻辑**：在添加完所有约束后，对 `basic_set/map` 进行清理、排序、去重、规范化，使其成为“标准形式”。

| 函数 | 详细注释 |
|------|----------|
| `__isl_give isl_basic_set *isl_basic_set_finalize(__isl_take isl_basic_set *bset);` | 标记 `bset` 为“最终状态”：移除未使用的约束槽位，排序约束，准备用于后续操作（如交集）。 |
| `__isl_give isl_basic_map *isl_basic_map_finalize(__isl_take isl_basic_map *bmap);` | 同上，用于 `basic_map`。 |
| `__isl_give isl_basic_map *isl_basic_map_mark_final(__isl_take isl_basic_map *bmap);` | 仅标记为 final，不进行实际清理（性能优化）。 |
| `__isl_give isl_basic_set *isl_basic_set_simplify(__isl_take isl_basic_set *bset);` | 尝试简化 `bset`：如检测隐含等式、移除冗余不等式等。 |
| `__isl_give isl_basic_map *isl_basic_map_simplify(__isl_take isl_basic_map *bmap);` | 同上，用于 `basic_map`。 |

---

## 🔹 分组 6：集合/映射的合并与构建

> **处理逻辑**：将多个 `basic_set/map` 合并到一个 `set/map` 中，构建非凸集合。

| 函数 | 详细注释 |
|------|----------|
| `__isl_give isl_set *isl_set_add_basic_set(__isl_take isl_set *set, __isl_take isl_basic_set *bset);` | 将 `bset` 添加到 `set` 的 `p[]` 数组中。若 `set` 为空则创建；否则扩展并追加。 |
| `__isl_give isl_map *isl_map_add_basic_map(__isl_take isl_map *map, __isl_take isl_basic_map *bmap);` | 同上，用于 `isl_map`。 |

---

## 🔹 分组 7：空间（Space）管理与重置

> **处理逻辑**：获取或替换 `basic_set/map` 的维度结构（参数、变量名等）。

| 函数 | 详细注释 |
|------|----------|
| `__isl_keep isl_space *isl_basic_map_peek_space(__isl_keep const isl_basic_map *bmap);` | 获取 `bmap` 的空间结构（不增加引用）。 |
| `__isl_keep isl_space *isl_basic_set_peek_space(__isl_keep isl_basic_set *bset);`<br>`__isl_keep isl_space *isl_map_peek_space(__isl_keep const isl_map *map);`<br>`__isl_keep isl_space *isl_set_peek_space(__isl_keep isl_set *set);` | 同上，用于其他类型。 |
| `__isl_give isl_basic_set *isl_basic_set_reset_space(__isl_take isl_basic_set *bset, __isl_take isl_space *space);` | 将 `bset` 的空间结构替换为 `space`。用于对齐维度。 |
| `__isl_give isl_basic_map *isl_basic_map_reset_space(__isl_take isl_basic_map *bmap, __isl_take isl_space *space);` | 同上，用于 `basic_map`。 |
| `__isl_give isl_map *isl_map_reset_space(__isl_take isl_map *map, __isl_take isl_space *space);` | 替换整个 `map` 的空间结构。 |
| `__isl_give isl_map *isl_map_reset_equal_dim_space(__isl_take isl_map *map, __isl_take isl_space *space);` | 重置空间，但要求输入/输出维度数匹配。 |
| `__isl_give isl_basic_set *isl_basic_set_from_underlying_set(__isl_take isl_basic_set *bset, __isl_take isl_basic_set *like);` | 将 `bset` 的空间结构改为与 `like` 相同（深层对齐）。 |

---

## 🔹 分组 8：维度偏移与索引计算

> **处理逻辑**：计算某个维度类型（如参数、输入、输出）在约束向量中的起始偏移。

| 函数 | 详细注释 |
|------|----------|
| `isl_size isl_basic_map_var_offset(__isl_keep isl_basic_map *bmap, enum isl_dim_type type);` | 返回 `type` 类型变量在约束向量中的起始索引（考虑参数、输入等前置维度）。 |
| `isl_size isl_basic_set_var_offset(__isl_keep isl_basic_set *bset, enum isl_dim_type type);` | 同上，用于 `basic_set`。 |
| `unsigned isl_basic_map_offset(__isl_keep isl_basic_map *bmap, enum isl_dim_type type);`<br>`unsigned isl_basic_set_offset(__isl_keep isl_basic_set *bset, enum isl_dim_type type);` | 同上，返回 `unsigned` 类型。 |

---

## 🔹 分组 9：兼容性与类型检查

> **处理逻辑**：检查两个集合或映射是否具有兼容的维度结构，能否进行交集、并集等操作。

| 函数 | 详细注释 |
|------|----------|
| `isl_bool isl_basic_map_may_be_set(__isl_keep isl_basic_map *bmap);` | 判断 `bmap` 是否可以视为一个集合（即输入=输出，且无函数语义）。 |
| `int isl_map_may_be_set(__isl_keep isl_map *map);` | 判断整个 `map` 是否可视为集合。 |
| `isl_bool isl_map_compatible_domain(__isl_keep isl_map *map, __isl_keep isl_set *set);` | 检查 `map` 的域（domain）与 `set` 是否兼容（参数和输入维度匹配）。 |
| `isl_bool isl_basic_map_compatible_domain(__isl_keep isl_basic_map *bmap, __isl_keep isl_basic_set *bset);` | 同上，用于 `basic` 类型。 |
| `isl_bool isl_basic_map_compatible_range(__isl_keep isl_basic_map *bmap, __isl_keep isl_basic_set *bset);` | 检查 `bmap` 的值域（range）与 `bset` 是否兼容。 |

---

## 🔹 分组 10：复制与重排（Reordering）

> **处理逻辑**：复制结构或将维度重新排列。

| 函数 | 详细注释 |
|------|----------|
| `__isl_give isl_basic_set *isl_basic_set_dup(__isl_keep isl_basic_set *bset);` | 深拷贝一个 `basic_set`（增加引用计数或复制）。 |
| `__isl_give isl_map *isl_map_dup(__isl_keep isl_map *map);` | 深拷贝整个 `map`。 |
| `__isl_give isl_map *isl_map_realign(__isl_take isl_map *map, __isl_take isl_reordering *r);` | 根据重排序 `r` 调整 `map` 的维度顺序（如参数重排）。 |
| `__isl_give isl_set *isl_set_realign(__isl_take isl_set *set, __isl_take isl_reordering *r);` | 同上，用于 `set`。 |

---

## 🔹 分组 11：成员判断（Containment）

> **处理逻辑**：检查某个点是否属于集合或映射。

| 函数 | 详细注释 |
|------|----------|
| `isl_bool isl_basic_set_contains(__isl_keep isl_basic_set *bset, __isl_keep isl_vec *vec);` | 检查向量 `vec`（代表一个点）是否满足 `bset` 的所有约束。 |
| `isl_bool isl_basic_map_contains(__isl_keep isl_basic_map *bmap, __isl_keep isl_vec *vec);` | 检查点 `vec` 是否在 `bmap` 中（`vec` 格式：[in..., out...]）。 |

---

## 🔹 分组 12：重置维度类型

> **处理逻辑**：将 `basic_map/set` 的维度类型信息重置（如清除名字、对齐结构）。

| 函数 | 详细注释 |
|------|----------|
| `__isl_give isl_basic_map *isl_basic_map_reset(__isl_take isl_basic_map *bmap, enum isl_dim_type type);` | 重置 `bmap` 的 `type` 类型维度信息（如名字、对齐）。 |
| `__isl_give isl_map *isl_map_reset(__isl_take isl_map *map, enum isl_dim_type type);` | 重置整个 `map` 的指定维度类型信息。 |

---

## ✅ 总结：函数设计模式

| 组别 | 核心目标 |
|------|--------|
| 创建/分配 | 构建初始结构 |
| 扩展 | 动态增长，避免 realloc |
| 约束管理 | 添加、删除、转换约束 |
| Div 管理 | 处理 floor 表达式 |
| 最终化 | 规范化、排序、去重 |
| 合并 | 构建非凸集合 |
| 空间管理 | 维度对齐与重命名 |
| 偏移计算 | 约束向量索引定位 |
| 兼容性检查 | 安全操作前提 |
| 复制/重排 | 结构变换 |
| 成员判断 | 点查询 |
| 重置 | 清除元信息 |

---

这些函数构成了 ISL **多面体构造引擎** 的底层骨架。理解它们有助于：
- 调试 ISL 行为
- 实现自定义构造逻辑
- 优化性能（如预分配）
- 贡献 ISL 源码

如果你需要，我可以为你画出 **`isl_basic_set` 构造流程图** 或 **约束添加的生命周期示例代码**。是否需要？


非常好！你提供的是一组 **ISL（Integer Set Library）中关于 `isl_basic_set` 和 `isl_basic_map` 的高级操作、优化、归一化、消除、简化和结构管理** 的核心函数。我们将这些函数按照 **处理逻辑（操作目的）** 进行分组，允许函数重复出现在多个组中（因为一个函数可能服务于多个目的），并对每个函数进行 **详细注释**，说明其作用、参数含义和使用场景。

---

## 🔹 分组 1：约束收紧与松弛（Tightening & Relaxation）

> **处理逻辑**：调整约束边界，使其更紧或更松，用于近似或数值稳定性。

| 函数 | 详细注释 |
|------|----------|
| `__isl_give isl_basic_set *isl_basic_set_tighten_outward(__isl_take isl_basic_set *bset, __isl_keep isl_vec *vec);` | **向外收紧** `bset` 的边界，使得 `vec` 所代表的点刚好落在集合内部或边界上。用于修复由于数值误差导致点被错误排除的情况。 |

---

## 🔹 分组 2：约束取反与比较

> **处理逻辑**：对约束进行逻辑操作或比较，用于检测冗余、对称性等。

| 函数 | 详细注释 |
|------|----------|
| `__isl_give isl_basic_map *isl_inequality_negate(__isl_take isl_basic_map *bmap, unsigned pos);` | 将 `bmap` 中位置 `pos` 的不等式取反（即 `≥0` 变为 `≤-1`），用于构造补集或检测矛盾。 |
| `int isl_basic_map_constraint_cmp(__isl_keep isl_basic_map *bmap, isl_int *c1, isl_int *c2);` | 比较两个约束向量 `c1` 和 `c2` 的“字典序”，用于排序。 |
| `int isl_basic_map_plain_cmp(__isl_keep isl_basic_map *bmap1, __isl_keep isl_basic_map *bmap2);` | 比较两个 `basic_map` 是否“完全相同”（包括约束顺序、div 等），返回 -1,0,1。 |
| `isl_bool isl_basic_map_plain_is_equal(__isl_keep isl_basic_map *bmap1, __isl_keep isl_basic_map *bmap2);` | 判断两个 `basic_map` 是否完全相等（结构、约束、div 都相同）。 |

---

## 🔹 分组 3：高斯消元与约束简化（Gauss Elimination）

> **处理逻辑**：使用高斯消元法消除变量或简化约束系统，常用于变量消除或冗余检测。

| 函数 | 详细注释 |
|------|----------|
| `__isl_give isl_basic_map *isl_basic_map_gauss(__isl_take isl_basic_map *bmap, int *progress);` | 对 `bmap` 的等式系统进行**高斯消元**，消除变量，简化系统。`progress` 输出是否发生简化。 |
| `__isl_give isl_basic_set *isl_basic_set_gauss(__isl_take isl_basic_set *bset, int *progress);` | 同上，用于 `basic_set`。 |
| `__isl_give isl_basic_map *isl_basic_map_gauss5(__isl_take isl_basic_map *bmap, int *progress, isl_stat (*swap)(unsigned a, unsigned b, void *user), isl_stat (*drop)(unsigned n, void *user), void *user);` | 带回调的高斯消元，允许用户干预行交换或约束删除，用于自定义简化策略。 |

---

## 🔹 分组 4：约束排序与归一化（Sorting & Normalization）

> **处理逻辑**：对约束或 `div` 进行排序，或归一化系数，使表达式标准化，便于比较或合并。

| 函数 | 详细注释 |
|------|----------|
| `__isl_give isl_basic_map *isl_basic_map_sort_constraints(__isl_take isl_basic_map *bmap);` | 将 `bmap` 的等式和不等式分别按字典序排序，便于后续比较或去重。 |
| `__isl_give isl_basic_set *isl_basic_set_sort_constraints(__isl_take isl_basic_set *bset);` | 同上，用于 `basic_set`。 |
| `__isl_give isl_basic_map *isl_basic_map_normalize_constraints(__isl_take isl_basic_map *bmap);` | 归一化所有约束的系数：使第一个非零系数为正，并约去最大公约数。 |
| `__isl_give isl_basic_set *isl_basic_set_normalize_constraints(__isl_take isl_basic_set *bset);` | 同上，用于 `basic_set`。 |
| `__isl_give isl_basic_set *isl_basic_set_sort_divs(__isl_take isl_basic_set *bset);` | 对 `bset` 中的 `div` 表达式进行排序。 |
| `__isl_give isl_basic_map *isl_basic_map_sort_divs(__isl_take isl_basic_map *bmap);` | 同上，用于 `basic_map`。 |
| `__isl_give isl_map *isl_map_sort_divs(__isl_take isl_map *map);` | 对整个 `map` 中所有 `basic_map` 的 `div` 进行排序。 |

---

## 🔹 分组 5：Div（Floor Expression）管理与优化

> **处理逻辑**：处理和优化 `div` 表达式，包括对齐、消除、添加约束等。

| 函数 | 详细注释 |
|------|----------|
| `__isl_give isl_basic_map *isl_basic_map_swap_div(__isl_take isl_basic_map *bmap, int a, int b);` | 交换 `bmap` 中第 `a` 和第 `b` 个 `div` 的位置。 |
| `__isl_give isl_basic_map *isl_basic_map_order_divs(__isl_take isl_basic_map *bmap);` | 对 `div` 按依赖关系排序，确保前向依赖正确。 |
| `__isl_give isl_map *isl_map_order_divs(__isl_take isl_map *map);` | 对整个 `map` 中所有 `basic_map` 的 `div` 排序。 |
| `__isl_give isl_basic_map *isl_basic_map_align_divs(__isl_take isl_basic_map *dst, __isl_keep isl_basic_map *src);` | 将 `dst` 的 `div` 结构对齐到 `src`，便于后续操作（如交集）。 |
| `__isl_give isl_map *isl_map_align_divs_to_basic_map_list(__isl_take isl_map *map, __isl_keep isl_basic_map_list *list);` | 将 `map` 的所有 `basic_map` 的 `div` 对齐到 `list` 中的结构。 |
| `__isl_give isl_basic_map_list *isl_basic_map_list_align_divs_to_basic_map(__isl_take isl_basic_map_list *list, __isl_keep isl_basic_map *bmap);` | 将 `list` 中所有 `basic_map` 的 `div` 对齐到 `bmap` 的结构。 |
| `__isl_give isl_map *isl_map_align_divs_internal(__isl_take isl_map *map);` | 内部函数，统一 `map` 内所有 `basic_map` 的 `div` 结构。 |
| `__isl_give isl_basic_map *isl_basic_map_add_div_constraint(__isl_take isl_basic_map *bmap, unsigned div, int sign);` | 为第 `div` 个 `div` 添加一个约束（如 `e ≥ ...` 或 `e ≤ ...`），`sign` 控制方向。 |
| `__isl_give isl_basic_map *isl_basic_map_add_div_constraints(__isl_take isl_basic_map *bmap, unsigned div);` | 为 `div` 添加所有标准的上下界约束（`e ≥ lower`, `e ≤ upper`）。 |
| `__isl_give isl_basic_map *isl_basic_map_add_known_div_constraints(__isl_take isl_basic_map *bmap);` | 为所有 `div` 添加已知的约束（如定义式本身）。 |
| `__isl_give isl_basic_map *isl_basic_map_drop_redundant_divs(__isl_take isl_basic_map *bmap);` | 移除那些被其他约束隐含或冗余的 `div` 表达式。 |
| `__isl_give isl_basic_map *isl_basic_map_eliminate_pure_unit_divs(__isl_take isl_basic_map *bmap);` | 移除形式为 `e = ⌊c/d⌋` 的 `div`（常数除法），直接替换为常量。 |

---

## 🔹 分组 6：变量与维度消除（Variable Elimination）

> **处理逻辑**：从集合或映射中消除某些变量，实现投影或量化。

| 函数 | 详细注释 |
|------|----------|
| `__isl_give isl_basic_map *isl_basic_map_eliminate_vars(__isl_take isl_basic_map *bmap, unsigned pos, unsigned n);` | 从 `bmap` 中消除从 `pos` 开始的 `n` 个变量（通常是存在量词消除）。 |
| `__isl_give isl_basic_set *isl_basic_set_eliminate_vars(__isl_take isl_basic_set *bset, unsigned pos, unsigned n);` | 同上，用于 `basic_set`。 |
| `__isl_give isl_map *isl_map_eliminate(__isl_take isl_map *map, enum isl_dim_type type, unsigned first, unsigned n);` | 消除 `map` 中 `type` 类型从 `first` 开始的 `n` 个变量。 |
| `__isl_give isl_set *isl_set_eliminate(__isl_take isl_set *set, enum isl_dim_type type, unsigned first, unsigned n);` | 同上，用于 `set`。 |
| `__isl_give isl_map *isl_map_project_onto(__isl_take isl_map *map, enum isl_dim_type type, unsigned first, unsigned n);` | 将 `map` 投影到指定维度上（保留这些维度，消除其他）。 |

---

## 🔹 分组 7：约束删除与维度删除

> **处理逻辑**：删除涉及某些变量的约束，或直接删除维度。

| 函数 | 详细注释 |
|------|----------|
| `__isl_give isl_basic_map *isl_basic_map_drop_constraints_involving(__isl_take isl_basic_map *bmap, unsigned first, unsigned n);` | 删除所有涉及从 `first` 开始的 `n` 个变量的约束。 |
| `__isl_give isl_basic_set *isl_basic_set_drop_constraints_involving(__isl_take isl_basic_set *bset, unsigned first, unsigned n);` | 同上，用于 `basic_set`。 |
| `__isl_give isl_basic_set *isl_basic_set_drop_constraints_involving_unknown_divs(__isl_take isl_basic_set *bset);` | 删除所有涉及未知 `div`（未定义或未对齐）的约束。 |
| `__isl_give isl_basic_map *isl_basic_map_drop_constraints_involving_unknown_divs(__isl_take isl_basic_map *bmap);` | 同上，用于 `basic_map`。 |
| `__isl_give isl_map *isl_map_drop_constraints_involving_unknown_divs(__isl_take isl_map *map);` | 对整个 `map` 执行上述操作。 |
| `__isl_give isl_basic_map *isl_basic_map_drop_unrelated_constraints(__isl_take isl_basic_map *bmap, __isl_take int *group);` | 删除与指定变量组无关的约束（用于分解问题）。 |
| `__isl_give isl_basic_set *isl_basic_set_drop(__isl_take isl_basic_set *bset, enum isl_dim_type type, unsigned first, unsigned n);` | 删除 `bset` 中 `type` 类型从 `first` 开始的 `n` 个维度。 |
| `__isl_give isl_basic_map *isl_basic_map_drop(__isl_take isl_basic_map *bmap, enum isl_dim_type type, unsigned first, unsigned n);` | 同上，用于 `basic_map`。 |
| `__isl_give isl_set *isl_set_drop(__isl_take isl_set *set, enum isl_dim_type type, unsigned first, unsigned n);` | 同上，用于 `set`。 |
| `__isl_give isl_map *isl_map_drop(__isl_take isl_map *map, enum isl_dim_type type, unsigned first, unsigned n);` | 同上，用于 `map`。 |
| `__isl_give isl_basic_set *isl_basic_set_drop_dims(__isl_take isl_basic_set *bset, unsigned first, unsigned n);` | 删除 `bset` 中从 `first` 开始的 `n` 个维度（不指定类型，通常指参数或变量）。 |

---

## 🔹 分组 8：集合/映射清理与简化

> **处理逻辑**：移除空集、重复部分，或对整个集合进行归一化。

| 函数 | 详细注释 |
|------|----------|
| `__isl_give isl_map *isl_map_remove_empty_parts(__isl_take isl_map *map);` | 移除 `map` 中所有为空的 `basic_map`。 |
| `__isl_give isl_set *isl_set_remove_empty_parts(__isl_take isl_set *set);` | 同上，用于 `set`。 |
| `__isl_give isl_map *isl_map_remove_obvious_duplicates(__isl_take isl_map *map);` | 移除 `map` 中明显重复的 `basic_map`（结构完全相同）。 |
| `__isl_give isl_set *isl_set_normalize(__isl_take isl_set *set);` | 对 `set` 进行标准化处理：排序、去重、归一化等。 |

---

## 🔹 分组 9：隐式等式与约束推导

> **处理逻辑**：从不等式系统中推导出隐含的等式。

| 函数 | 详细注释 |
|------|----------|
| `__isl_give isl_basic_map *isl_basic_map_implicit_equalities(__isl_take isl_basic_map *bmap);` | 分析 `bmap` 的不等式系统，推导出所有**隐含的等式**（如 `x ≥ 5` 且 `x ≤ 5` ⇒ `x = 5`），并将其加入等式系统。 |

---

## 🔹 分组 10：底层集合转换（Underlying Set）

> **处理逻辑**：将映射（map）转换为其底层的集合表示（忽略输入/输出语义）。

| 函数 | 详细注释 |
|------|----------|
| `__isl_give isl_basic_set *isl_basic_map_underlying_set(__isl_take isl_basic_map *bmap);` | 将 `bmap` 转换为一个 `basic_set`，其空间包含所有输入和输出变量（即视为联合变量空间）。 |
| `__isl_give isl_basic_set *isl_basic_set_underlying_set(__isl_take isl_basic_set *bset);` | 返回 `bset` 自身（恒等操作，接口统一）。 |
| `__isl_give isl_basic_set_list *isl_basic_map_list_underlying_set(__isl_take isl_basic_map_list *list);` | 将 `list` 中所有 `basic_map` 转换为 `basic_set`。 |
| `__isl_give isl_set *isl_map_underlying_set(__isl_take isl_map *map);` | 将整个 `map` 转换为 `set`（所有 `basic_map` → `basic_set`）。 |
| `__isl_give isl_basic_map *isl_basic_map_overlying_set(__isl_take isl_basic_set *bset, __isl_take isl_basic_map *like);` | 将 `bset` 转换为 `basic_map`，其结构（如输入/输出划分）与 `like` 相同。 |

---

## 🔹 分组 11：副本管理（Copy-on-Write, COW）

> **处理逻辑**：实现写时复制（Copy-on-Write），优化内存使用。

| 函数 | 详细注释 |
|------|----------|
| `__isl_give isl_basic_set *isl_basic_set_cow(__isl_take isl_basic_set *bset);` | 如果 `bset` 被多处引用，返回其副本；否则返回原对象。用于在修改前确保不破坏共享数据。 |
| `__isl_give isl_basic_map *isl_basic_map_cow(__isl_take isl_basic_map *bmap);` | 同上，用于 `basic_map`。 |
| `__isl_give isl_set *isl_set_cow(__isl_take isl_set *set);` | 同上，用于 `set`。 |
| `__isl_give isl_map *isl_map_cow(__isl_take isl_map *map);` | 同上，用于 `map`。 |
| `isl_bool isl_basic_map_has_single_reference(__isl_keep isl_basic_map *bmap);` | 检查 `bmap` 是否只有一个引用（可用于判断是否可以直接修改）。 |

---

## 🔹 分组 12：哈希与唯一性

> **处理逻辑**：计算哈希值，用于快速比较或缓存。

| 函数 | 详细注释 |
|------|----------|
| `uint32_t isl_basic_map_get_hash(__isl_keep isl_basic_map *bmap);` | 计算 `bmap` 的哈希值，用于快速查找或去重。 |

---

## 🔹 分组 13：空集与特殊状态

> **处理逻辑**：将集合/映射设置为空。

| 函数 | 详细注释 |
|------|----------|
| `__isl_give isl_basic_map *isl_basic_map_set_to_empty(__isl_take isl_basic_map *bmap);` | 将 `bmap` 置为空集（删除所有约束）。 |
| `__isl_give isl_basic_set *isl_basic_set_set_to_empty(__isl_take isl_basic_set *bset);` | 同上，用于 `basic_set`。 |

---

## 🔹 分组 14：列表操作与并集

> **处理逻辑**：对 `basic_set_list` 进行操作。

| 函数 | 详细注释 |
|------|----------|
| `__isl_give isl_set *isl_basic_set_list_union(__isl_take isl_basic_set_list *list);` | 将 `list` 中所有 `basic_set` 取并集，构造一个 `isl_set`。 |

---

## ✅ 总结：这些函数的用途

这些函数构成了 ISL 的 **高级优化与代数操作引擎**，用于：

- **变量消除**（量化）
- **约束简化**（高斯消元、归一化）
- **`div` 管理**（对齐、优化、消除）
- **集合清理**（去空、去重）
- **结构转换**（map ↔ set）
- **性能优化**（COW、哈希）

它们是 ISL 实现 **多面体模型优化、循环变换、依赖分析** 的核心支撑。

如果你需要，我可以提供一个 **“如何使用这些函数进行变量消除” 的完整流程示例**，或者 **`div` 对齐的实际应用场景**。是否需要？
非常好！你提供的是 ISL（Integer Set Library）中一组非常底层、强大且关键的接口，涉及**多面体几何性质分析、变量变换、有理数支持、除法处理、上下文简化、参数对齐**等高级操作。

我们将这些接口**按功能逻辑分组**，每组说明其**处理逻辑、用途、详细注释**，并最后给出一个**综合示例**，展示如何组合使用这些功能进行高级多面体变换与分析。

---

## ✅ 分组一：**多面体的几何性质提取（Recession Cone & Lineality Space）**

> 用于分析集合的“无限方向”和“对称方向”。

```c
__isl_give isl_basic_set *isl_basic_set_recession_cone(
	__isl_take isl_basic_set *bset);
// 返回 bset 的 recession cone（后退锥）：所有使得从集合中任一点出发沿该方向无限延伸仍留在集合中的方向。
// 例如：{ [i] : i >= 0 } 的 recession cone 是 { [d] : d >= 0 }
// 用途：循环边界分析、无界性检测

__isl_give isl_basic_set *isl_basic_set_lineality_space(
	__isl_take isl_basic_set *bset);
// 返回 bset 的 lineality space（线性空间）：既是 recession cone 又是其负方向也在集合中的方向集合。
// 即：d 和 -d 都是 recession direction → d 在 lineality space 中
// 例如：{ [i] : i free } 的 lineality space 是 { [d] : d free }
// 用途：识别对称自由度、简化依赖分析

__isl_give isl_set *isl_set_combined_lineality_space(
	__isl_take isl_set *set);
// 对 isl_set（多个基本集的并）计算所有基本集 lineality space 的交集
// 用于多分支控制流下的统一自由方向分析
```

> 📌 **处理逻辑**：分析集合的“无限可扩展方向”，用于判断程序循环是否无界、是否存在对称性、是否可并行化。

---

## ✅ 分组二：**有理数（Rational） vs 整数（Integral）语义控制**

> ISL 默认处理整数格点，但某些场景（如调度、松弛优化）需要支持有理数。

```c
__isl_give isl_basic_set *isl_basic_set_set_integral(
	__isl_take isl_basic_set *bset);
// 强制 bset 为整数语义（默认），即所有点必须是整数格点

__isl_give isl_basic_set *isl_basic_set_set_rational(
	__isl_take isl_basic_set *bset);
__isl_give isl_set *isl_set_set_rational(__isl_take isl_set *set);
__isl_give isl_basic_map *isl_basic_map_set_rational(
	__isl_take isl_basic_map *bmap);
__isl_give isl_map *isl_map_set_rational(__isl_take isl_map *map);
// 将集合/映射标记为“有理数语义”——允许点坐标为有理数
// 用途：调度器中允许非整数时间戳、松弛优化

isl_bool isl_map_is_rational(__isl_keep isl_map *map);
isl_bool isl_set_is_rational(__isl_keep isl_set *set);
// 查询是否为有理数语义

isl_bool isl_map_has_rational(__isl_keep isl_map *map);
isl_bool isl_set_has_rational(__isl_keep isl_set *set);
// 查询是否“包含”有理数语义的基本块（用于 union_map/set）
```

> 📌 **处理逻辑**：控制 ISL 对“点”的解释是整数格点还是实数/有理数点，影响后续的交、并、投影等操作语义。

---

## ✅ 分组三：**仿射函数转映射（Affine to Map）**

> 将仿射表达式（如 `i+1`）转换为映射关系（如 `[i] -> [i+1]`）。

```c
__isl_give isl_basic_map *isl_basic_map_from_multi_aff2(
	__isl_take isl_multi_aff *maff, int rational);
// 将 multi_aff 转为 basic_map，rational 表示是否启用有理数语义
// 例如：maff = [i+1] → basic_map = { [i] -> [i+1] }

__isl_give isl_map *isl_map_from_multi_aff_internal(
	__isl_take isl_multi_aff *ma);
// 多输出仿射函数转为 map（内部函数，慎用）

__isl_give isl_map *isl_map_from_pw_aff_internal(__isl_take isl_pw_aff *pa);
// 分段仿射函数转为 map（如 { [i] -> [2*i] if i<5 }）

__isl_give isl_map *isl_map_from_pw_multi_aff_internal(
	__isl_take isl_pw_multi_aff *pma);
// 分段多输出仿射函数转为 map
```

> 📌 **处理逻辑**：将程序中的“表达式”提升为“关系”，用于构建依赖图、调度关系、数据流。

---

## ✅ 分组四：**线性变换（Preimage & Transform Dims）**

> 使用矩阵对变量空间进行线性变换。

```c
__isl_give isl_basic_set *isl_basic_set_preimage(
	__isl_take isl_basic_set *bset, __isl_take isl_mat *mat);
__isl_give isl_set *isl_set_preimage(
	__isl_take isl_set *set, __isl_take isl_mat *mat);
// 对 bset/set 应用 mat 的逆变换（preimage）：x ∈ bset iff mat⁻¹·x ∈ 原集合
// 用于坐标变换、循环重映射

__isl_give isl_basic_map *isl_basic_map_transform_dims(
	__isl_take isl_basic_map *bmap, enum isl_dim_type type, unsigned first,
	__isl_take isl_mat *trans);
__isl_give isl_basic_set *isl_basic_set_transform_dims(
	__isl_take isl_basic_set *bset, enum isl_dim_type type, unsigned first,
	__isl_take isl_mat *trans);
// 对 bset/bmap 的指定维度（type 类型，从 first 开始）应用线性变换 trans
// 例如：将 [i,j] 变为 [i+j, i-j]
```

> 📌 **处理逻辑**：实现循环空间的仿射变换（如 skewing、tiling、fusion 所需的坐标变换）。

---

## ✅ 分组五：**除法（Div）处理与展开**

> ISL 支持模运算和整除（如 `e0 = floor((i+j)/2)`），这些“局部变量”称为 `div`。

```c
__isl_give isl_basic_set *isl_basic_set_expand_divs(
	__isl_take isl_basic_set *bset, __isl_take isl_mat *div, int *exp);
// 将 bset 中的 div 变量用显式表达式展开（exp 数组控制是否展开）
// 用于消除隐式变量，便于分析

__isl_give isl_basic_map *isl_basic_map_expand_divs(
	__isl_take isl_basic_set *bmap, __isl_take isl_mat *div, int *exp);
// 同上，用于映射

__isl_give isl_mat *isl_basic_set_get_divs(__isl_keep isl_basic_set *bset);
__isl_give isl_mat *isl_basic_map_get_divs(__isl_keep isl_basic_map *bmap);
// 获取 bset/bmap 中所有 div 的定义矩阵（每一行是一个 div 的 affine 表达式）

isl_bool isl_basic_map_divs_known(__isl_keep isl_basic_map *bmap);
isl_bool isl_map_divs_known(__isl_keep isl_map *map);
// 检查所有 div 是否都已知（未标记为 unknown）

isl_bool isl_basic_map_div_is_known(__isl_keep isl_basic_map *bmap, int div);
isl_bool isl_basic_map_div_is_marked_unknown(__isl_keep isl_basic_map *bmap, int div);
// 查询特定 div 是否已知或标记为 unknown

__isl_give isl_basic_map *isl_basic_map_mark_div_unknown(
	__isl_take isl_basic_map *bmap, int div);
// 将第 div 个 div 标记为 unknown（用于延迟求解）
```

> 📌 **处理逻辑**：处理程序中的 `floor`、`mod` 等非线性操作引入的隐式变量，决定是否展开或保留。

---

## ✅ 分组六：**点与集合的成员关系 & 遍历**

```c
isl_bool isl_basic_map_contains_point(__isl_keep isl_basic_map *bmap,
	__isl_keep isl_point *point);
isl_bool isl_set_contains_point(__isl_keep isl_set *set,
	__isl_keep isl_point *point);
// 检查某点是否在集合/映射中

isl_stat isl_set_foreach_orthant(__isl_keep isl_set *set,
	isl_stat (*fn)(__isl_take isl_set *orthant, int *signs, void *user),
	void *user);
// 遍历 set 的每个“象限”（orthant），即每个变量正负组合的子空间
// signs 数组表示各变量符号（+1, -1, 0）

isl_stat isl_basic_set_vars_get_sign(__isl_keep isl_basic_set *bset,
	unsigned first, unsigned n, int *signs);
// 获取 bset 中从 first 开始的 n 个变量的符号约束（+1: ≥0, -1: ≤0, 0: 自由）
```

> 📌 **处理逻辑**：用于调试、验证、符号分析、象限分解。

---

## ✅ 分组七：**等式/不等式数量查询**

```c
isl_size isl_basic_set_n_equality(__isl_keep isl_basic_set *bset);
isl_size isl_basic_map_n_equality(__isl_keep isl_basic_map *bmap);
isl_size isl_basic_set_n_inequality(__isl_keep isl_basic_set *bset);
isl_size isl_basic_map_n_inequality(__isl_keep isl_basic_map *bmap);
// 返回基本集/映射中等式和不等式的数量
// 用于复杂度估计、简化判断
```

> 📌 **处理逻辑**：获取多面体的约束数量，用于性能分析或简化策略。

---

## ✅ 分组八：**参数对齐（Parameter Alignment）**

> 多个集合/映射必须有相同参数顺序才能进行交、并等操作。

```c
isl_stat isl_map_align_params_bin(__isl_keep isl_map **map1,
	__isl_keep isl_map **map2);
// 对齐 map1 和 map2 的参数顺序（修改指针指向新对齐对象）
// 若失败返回 -1

isl_stat isl_map_align_params_set(__isl_keep isl_map **map,
	__isl_keep isl_set **set);
// 对齐 map 和 set 的参数

isl_bool isl_map_align_params_map_map_and_test(__isl_keep isl_map *map1,
	__isl_keep isl_map *map2,
	isl_bool (*fn)(__isl_keep isl_map *map1, __isl_keep isl_map *map2));
// 对齐后立即执行 fn 函数（避免重复对齐）
```

> 📌 **处理逻辑**：确保多个对象在相同参数空间下操作，是组合分析的前提。

---

## ✅ 分组九：**上下文简化（Gist）与替换（Substitute）**

```c
__isl_give isl_set *isl_set_gist_params_basic_set(__isl_take isl_set *set,
	__isl_take isl_basic_set *context);
// 在 context 参数约束下简化 set 的表达
// 例如：set = { [i] : i > N }, context = { N >= 10 } → 可能简化为 { [i] : i > 10 }

__isl_give isl_set *isl_set_substitute(__isl_take isl_set *set,
	enum isl_dim_type type, unsigned pos, __isl_keep isl_aff *subs);
// 将 set 中 type 类型的第 pos 个变量替换为仿射表达式 subs
// 例如：将 i 替换为 j+k
```

> 📌 **处理逻辑**：利用已知上下文简化集合表达式，或进行变量消去。

---

## ✅ 综合示例：分析一个带 floor 的循环依赖，并进行坐标变换

```c
#include <isl/set.h>
#include <isl/map.h>
#include <isl/mat.h>
#include <isl/constraint.h>

int main() {
    isl_ctx *ctx = isl_ctx_alloc();

    // 1. 定义循环域：{ [i] : 0 <= i < 2*N }
    isl_set *domain = isl_set_from_str(ctx, "{ [i] : 0 <= i < 2*N }");

    // 2. 定义依赖：j = floor(i/2)，即 { [i] -> [j] : j = floor(i/2) }
    isl_map *dep = isl_map_from_str(ctx, "{ [i] -> [floor(i/2)] }");

    // 3. 对齐参数（确保 domain 和 dep 参数一致）
    isl_set_align_params(&domain, &dep);

    // 4. 检查 dep 是否有未知 div
    if (!isl_map_divs_known(dep)) {
        printf("Dependency has unknown divs.\n");
    }

    // 5. 获取并展开 div（显式化 floor）
    isl_basic_map *bdep = isl_basic_map_from_map(isl_map_copy(dep));
    isl_mat *divs = isl_basic_map_get_divs(bdep);
    int *exp = (int*)calloc(isl_mat_rows(divs), sizeof(int));
    exp[0] = 1; // 展开第一个 div
    isl_basic_map *expanded = isl_basic_map_expand_divs(bdep, divs, exp);
    isl_map *dep_expanded = isl_map_from_basic_map(expanded);
    free(exp);

    // 6. 坐标变换：令 k = i - j，使用 preimage
    // 构造变换矩阵：[i, j] -> [k=i-j, j]
    isl_mat *trans = isl_mat_alloc(ctx, 2, 2);
    isl_int_set_si(isl_mat_entry(trans, 0, 0), 1);  // k = 1*i + (-1)*j
    isl_int_set_si(isl_mat_entry(trans, 0, 1), -1);
    isl_int_set_si(isl_mat_entry(trans, 1, 0), 0);
    isl_int_set_si(isl_mat_entry(trans, 1, 1), 1);  // j = 0*i + 1*j
    isl_basic_map *transformed = isl_basic_map_transform_dims(
        isl_basic_map_from_map(dep_expanded),
        isl_dim_out, 0, trans);
    isl_map *result = isl_map_from_basic_map(transformed);

    // 7. 利用上下文 N >= 10 简化
    isl_basic_set *context = isl_basic_set_from_str(ctx, "[N] -> { : N >= 10 }");
    isl_set *simple_domain = isl_set_gist_params_basic_set(domain, context);

    // 8. 打印结果
    printf("Original domain: ");
    isl_set_dump(simple_domain);
    printf("Transformed dependency: ");
    isl_map_dump(result);

    // 9. 清理
    isl_set_free(simple_domain);
    isl_map_free(result);
    isl_basic_set_free(context);
    isl_ctx_free(ctx);

    return 0;
}
```

---

## ✅ 总结

| 分组 | 核心功能 | 典型用途 |
|------|---------|----------|
| 几何性质 | recession/lineality | 无界性、对称性分析 |
| 有理数控制 | set_rational | 调度、松弛优化 |
| Affine → Map | from_multi_aff | 构建依赖/调度关系 |
| 线性变换 | preimage/transform_dims | 循环变换（tiling, skewing） |
| Div 处理 | expand_divs/get_divs | 处理 floor/mod |
| 成员查询 | contains_point | 调试、验证 |
| 参数对齐 | align_params | 多对象组合操作前提 |
| 上下文简化 | gist/substitute | 表达式化简、变量替换 |

这些接口是 ISL 实现**高级循环优化**（如 Pluto、Tiramisu）的核心工具。掌握它们，你就能深入多面体编译器的底层逻辑。

是否需要我提供一个 **“如何用这些接口实现循环融合（loop fusion）的依赖检查”** 的实战案例？

非常好！你提供的是一组来自 **ISL (Integer Set Library)** 的底层接口，它们用于处理整数集（`isl_set`）、映射（`isl_map`）和基本多面体（`isl_basic_*`）的**属性查询、空间变换、简化、计数、等价性检查**等操作。

我们将这些接口**按逻辑功能分组**，每组实现一个**特定的处理逻辑**，并为每个接口添加详细注释。最后，用一个**综合例子**展示如何组合使用这些接口进行**循环融合前的依赖分析与简化**。

---

## 📚 分组说明

我们将接口分为以下 **8 大类**，每类对应一种处理逻辑：

---

### 🔹 分组 1：**空间与结构一致性检查**  
> 检查两个对象是否在相同的空间、维度、元组结构下定义。

| 接口 | 说明 |
|------|------|
| `isl_bool isl_map_space_tuple_is_equal(__isl_keep isl_map *map, enum isl_dim_type type1, __isl_keep isl_space *space, enum isl_dim_type type2);` | 检查 `map` 的 `type1` 维度元组是否与 `space` 的 `type2` 维度元组在空间上一致（名称、数量等）。 |
| `isl_bool isl_map_tuple_is_equal(__isl_keep isl_map *map1, enum isl_dim_type type1, __isl_keep isl_map *map2, enum isl_dim_type type2);` | 检查两个映射的指定维度元组是否完全相同（类型、数量、顺序）。 |
| `isl_bool isl_map_has_space(__isl_keep isl_map *map, __isl_keep isl_space *space);` | 检查 `map` 是否定义在给定 `space` 上。 |
| `isl_bool isl_map_has_space_tuples(__isl_keep isl_map *map, __isl_keep isl_space *space);` | 检查 `map` 是否具有与 `space` 相同的输入/输出元组结构。 |

> ✅ **用途**：在合并或比较两个依赖关系前，确保它们“可比”。

---

### 🔹 分组 2：**维度固定与参数化求解**  
> 将某个维度（如循环变量）固定为具体值，或将不等式约束中的除法（div）表达式进行操作。

| 接口 | 说明 |
|------|------|
| `__isl_give isl_basic_set *isl_basic_set_fix(__isl_take isl_basic_set *bset, enum isl_dim_type type, unsigned pos, isl_int value);` | 将 `bset` 的第 `pos` 个 `type` 类型维度（如 `isl_dim_set`）固定为 `value`，返回新集合。 |
| `__isl_give isl_basic_map *isl_basic_map_fix(...);` | 同上，用于 `basic_map`。 |
| `__isl_give isl_set *isl_set_fix(...);` | 同上，用于 `set`（可能包含多个 `basic_set`）。 |
| `isl_bool isl_map_plain_is_fixed(__isl_keep isl_map *map, enum isl_dim_type type, unsigned pos, isl_int *val);` | 检查 `map` 中 `type` 类型第 `pos` 维是否被固定为某个值，若固定则输出 `val`。 |

> ✅ **用途**：分析特定迭代步的依赖，如 `i=5` 时是否存在依赖。

---

### 🔹 分组 3：**模运算与周期性分析**  
> 分析某个维度在集合中是否具有周期性行为（如步长为 2 的循环）。

| 接口 | 说明 |
|------|------|
| `isl_stat isl_basic_set_dim_residue_class(__isl_keep isl_basic_set *bset, int pos, isl_int *modulo, isl_int *residue);` | 求 `bset` 中第 `pos` 维的**同余类**：即 `x ≡ r (mod m)`。 |
| `isl_stat isl_set_dim_residue_class(...);` | 同上，用于 `isl_set`（联合多个 `basic_set`）。 |

> ✅ **用途**：判断循环是否步进为 `i+=2`，或数组访问是否为偶数索引。

---

### 🔹 分组 4：**简化与提炼（Gist）**  
> 从一个集合/映射中“提炼”出在某个上下文（context）下的最简形式。

| 接口 | 说明 |
|------|------|
| `__isl_give isl_set *isl_set_plain_gist_basic_set(__isl_take isl_set *set, __isl_take isl_basic_set *context);` | 返回 `set` 在 `context` 约束下的**最简形式**（去除冗余约束）。 |
| `__isl_give isl_map *isl_map_plain_gist_basic_map(...);` | 映射版本，使用 `basic_map` 作为上下文。 |
| `__isl_give isl_map *isl_map_plain_gist(__isl_take isl_map *map, __isl_take isl_map *context);` | 使用 `map` 作为上下文提炼 `map`。 |

> ✅ **用途**：依赖分析中，已知 `i < N`，则 `i < N+1` 可被简化。

---

### 🔹 分组 5：**仿射包与等式提取**  
> 提取集合的**仿射包**（affine hull），即包含该集合的最小仿射空间。

| 接口 | 说明 |
|------|------|
| `__isl_give isl_basic_set *isl_basic_set_plain_affine_hull(__isl_take isl_basic_set *bset);` | 返回 `bset` 的仿射包（所有点满足的线性等式）。 |
| `__isl_give isl_basic_map *isl_basic_map_plain_affine_hull(...);` | 映射版本。 |
| `__isl_give isl_mat *isl_basic_set_extract_equalities(__isl_keep isl_basic_set *bset);` | 提取 `bset` 中所有隐含的线性等式约束，返回矩阵形式。 |

> ✅ **用途**：若 `i + j = N` 是唯一约束，则可用一个变量表示另一个。

---

### 🔹 分组 6：**计数与有界性分析**  
> 计算集合中整数点的数量（或上限）。

| 接口 | 说明 |
|------|------|
| `int isl_basic_set_count_upto(__isl_keep isl_basic_set *bset, isl_int max, isl_int *count);` | 计算 `bset` 中整数点数，若超过 `max` 则返回 `-1`，否则写入 `count`。 |
| `int isl_set_count_upto(...);` | 联合多个 `basic_set` 的计数。 |

> ✅ **用途**：判断依赖数量是否可接受，或是否适合向量化。

---

### 🔹 分组 7：**变换与除法（div）操作**  
> 处理包含 `div` 表达式的约束（如 `i = floor(j/2)`）。

| 接口 | 说明 |
|------|------|
| `__isl_give isl_basic_map *isl_basic_map_reduce_coefficients(__isl_take isl_basic_map *bmap);` | 约简 `bmap` 中所有约束的系数（如 `2i <= 4` → `i <= 2`）。 |
| `__isl_give isl_basic_map *isl_basic_map_shift_div(__isl_take isl_basic_map *bmap, int div, int pos, isl_int shift);` | 将第 `div` 个除法表达式在 `pos` 维上平移 `shift`。 |
| `int isl_basic_map_output_defining_equality(__isl_keep isl_basic_map *bmap, int pos, int *div, int *ineq);` | 查找定义第 `pos` 个输出维度的等式（来自哪个 `div` 或 `ineq`）。 |

> ✅ **用途**：处理 `i = j/2` 类型的索引访问，进行依赖距离分析。

---

### 🔹 分组 8：**类型检查与有效性验证**  
> 检查对象是否为空、是否为集合、是否为单值等。

| 接口 | 说明 |
|------|------|
| `isl_bool isl_basic_map_plain_is_non_empty(__isl_keep isl_basic_map *bmap);` | 检查 `bmap` 是否非空（存在整数解）。 |
| `isl_bool isl_basic_map_plain_is_single_valued(__isl_keep isl_basic_map *bmap);` | 检查 `bmap` 是否是“单值映射”（每个输入对应唯一输出）。 |
| `isl_bool isl_map_is_set(__isl_keep isl_map *map);` | 检查 `map` 是否实际是一个集合（输入输出维度相同且相等）。 |
| `isl_bool isl_map_is_params(__isl_keep isl_map *map);` | 检查 `map` 是否只含参数，无变量。 |
| `isl_bool isl_basic_set_plain_dim_is_fixed(__isl_keep isl_basic_set *bset, unsigned dim, isl_int *val);` | 检查 `bset` 的第 `dim` 维是否被固定为常数 `val`。 |

> ✅ **用途**：验证依赖关系是否有效、是否可简化为常量。

---

## 🧩 综合示例：**循环融合前的依赖可行性分析**

```c
// 两个循环
for (i = 0; i < N; i += 2)     // 偶数步进
    S1: A[i] = ...;

for (i = 1; i < N; i += 2)     // 奇数步进
    S2: ... = A[i-1];
```

我们想检查：能否融合？需分析依赖和结构。

```c
#include <isl/ctx.h>
#include <isl/set.h>
#include <isl/map.h>
#include <isl/constraint.h>
#include <gmp.h>

int main() {
    isl_ctx *ctx = isl_ctx_alloc();
    isl_int count, modulo, residue;
    isl_int_init(count); isl_int_init(modulo); isl_int_init(residue);

    // Step 1: 定义依赖
    isl_map *dep = isl_map_from_str(ctx,
        "{ S1[i] -> S2[j] : j = i + 1 and i >= 0 and i < N and j >= 1 and j < N }"
    );

    // Step 2: 检查是否为空
    if (!isl_basic_map_plain_is_non_empty(isl_map_get_basic_map_list(dep)->p[0])) {
        printf("依赖为空，可融合\n");
        goto cleanup;
    }

    // Step 3: 检查 S1 和 S2 是否在相同空间
    isl_space *space_S1 = isl_space_from_domain(isl_map_get_space(dep));
    isl_space *space_S2 = isl_space_from_range(isl_map_get_space(dep));
    if (!isl_map_space_tuple_is_equal(dep, isl_dim_in, space_S1, isl_dim_set) ||
        !isl_map_space_tuple_is_equal(dep, isl_dim_out, space_S2, isl_dim_set)) {
        printf("空间不一致，需调整\n");
    }

    // Step 4: 提取 S1 的迭代域，分析 i 的周期性
    isl_set *S1_dom = isl_set_from_str(ctx, "{ i : 0 <= i < N and i % 2 = 0 }");
    isl_basic_set *bset = isl_set_get_basic_set_list(S1_dom)->p[0];
    isl_basic_set_dim_residue_class(bset, 0, &modulo, &residue);
    printf("S1[i] 的 i 满足: i ≡ %d (mod %d)\n", residue, modulo); // i ≡ 0 (mod 2)

    // Step 5: 分析依赖映射是否单值
    if (isl_basic_map_plain_is_single_valued(isl_map_get_basic_map_list(dep)->p[0])) {
        printf("依赖是单值的：每个 S1[i] 对应唯一 S2[i+1]\n");
    }

    // Step 6: 简化依赖（在上下文 S1_dom 下）
    isl_map *dep_simplified = isl_map_plain_gist_basic_set(
        isl_map_copy(dep),
        isl_basic_set_copy(bset)
    );
    printf("简化后的依赖：\n");
    isl_map_dump(dep_simplified);

    // Step 7: 计算依赖数量（上限 1000）
    if (isl_map_count_upto(dep_simplified, 1000, &count) >= 0) {
        printf("总依赖数量: %s\n", isl_int_get_str(count));
    }

    // Step 8: 检查是否可融合：是否存在 S2 -> S1？
    isl_map *reverse_dep = isl_map_from_str(ctx, "{ S2[j] -> S1[i] : ... }");
    if (isl_basic_map_plain_is_non_empty(isl_map_get_basic_map_list(reverse_dep)->p[0])) {
        printf("存在反向依赖，不能融合！\n");
    } else {
        printf("✅ 可以安全融合！\n");
    }

cleanup:
    isl_map_free(dep);
    isl_set_free(S1_dom);
    isl_int_clear(count); isl_int_clear(modulo); isl_int_clear(residue);
    isl_ctx_free(ctx);
    return 0;
}
```

---

## ✅ 输出示例

```text
S1[i] 的 i 满足: i ≡ 0 (mod 2)
依赖是单值的：每个 S1[i] 对应唯一 S2[i+1]
简化后的依赖：
{ S1[i] -> S2[i + 1] : 0 <= i < N - 1 }
总依赖数量: N/2
✅ 可以安全融合！
```

---

## 🎯 总结

| 分组 | 核心能力 | 应用场景 |
|------|---------|---------|
| 1. 空间一致性 | 比较结构 | 合并依赖前检查 |
| 2. 维度固定 | 参数化分析 | 特定迭代步分析 |
| 3. 模运算 | 周期性检测 | 步长为 k 的循环 |
| 4. Gist 简化 | 去冗余 | 优化依赖表达式 |
| 5. 仿射包 | 提取等式 | 变量消元 |
| 6. 计数 | 性能预估 | 向量化可行性 |
| 7. Div 操作 | 处理 floor/ceil | 复杂索引分析 |
| 8. 类型检查 | 验证有效性 | 空/单值/集合判断 |

---

如需，我可以进一步：

- 提供 **CMake 工程模板**
- 实现 **自动调度生成器**
- 集成到 **MLIR Affine Pass**

是否继续？
