文件路径: ./isl_ast_graft.c
注释行数: 13
注释内容:
/*
 * Copyright 2012      Ecole Normale Superieure
 * Copyright 2014      INRIA Rocquencourt
 * Copyright 2019      Cerebras Systems
 *
 * Use of this software is governed by the MIT license
 *
 * Written by Sven Verdoolaege,
 * Ecole Normale Superieure, 45 rue d’Ulm, 75230 Paris, France
 * and Inria Paris - Rocquencourt, Domaine de Voluceau - Rocquencourt,
 * B.P. 105 - 78153 Le Chesnay, France
 * and Cerebras Systems, 175 S San Antonio Rd, Los Altos, CA, USA
 */
================================================================================

文件路径: ./isl_ast_graft.c
注释行数: 26
注释内容:
/* Extract a common guard from the grafts in "list" that can be hoisted
 * out of the current level.  If no such guard can be found, then return
 * a universal set.
 *
 * If all the grafts in the list have the same guard and if this guard
 * is independent of the current level, then it can be hoisted out.
 * If there is only one graft in the list and if its guard
 * depends on the current level, then we eliminate this level and
 * return the result.
 *
 * Otherwise, we return the unshifted simple hull of the guards.
 * In order to be able to hoist as many constraints as possible,
 * but at the same time avoid hoisting constraints that did not
 * appear in the guards in the first place, we intersect the guards
 * with all the information that is available (i.e., the domain
 * from the build and the enforced constraints of the graft) and
 * compute the unshifted hull of the result using only constraints
 * from the original guards.
 * In particular, intersecting the guards with other known information
 * allows us to hoist guards that are only explicit is some of
 * the grafts and implicit in the others.
 *
 * The special case for equal guards is needed in case those guards
 * are non-convex.  Taking the simple hull would remove information
 * and would not allow for these guards to be hoisted completely.
 */
================================================================================

文件路径: ./isl_ast_graft.c
注释行数: 16
注释内容:
/* For each graft in "list",
 * insert an if node around graft->node testing the condition encoded
 * in graft->guard, assuming graft->guard involves any conditions.
 *
 * We keep track of a list of generated if nodes that can be extended
 * without changing the order of the elements in "list".
 * If the guard of a graft is a subset of either the guard or its complement
 * of one of those if nodes, then the node
 * of the new graft is inserted into the then or else branch of the last graft
 * and the current graft is discarded.
 * The guard of the node is then simplified based on the conditions
 * enforced at that then or else branch.
 * Otherwise, the current graft is appended to the list.
 *
 * We only construct else branches if allowed by the user.
 */
================================================================================

文件路径: ./isl_ast_graft.c
注释行数: 10
注释内容:
/* Allocate a graft in "build" based on the list of grafts in "sub_build".
 * "guard" and "enforced" are the guard and enforced constraints
 * of the allocated graft.  The guard is used to simplify the guards
 * of the elements in "list".
 *
 * The node is initialized to either a block containing the nodes of "children"
 * or, if there is only a single child, the node of that child.
 * If the current level requires a for node, it should be inserted by
 * a subsequent call to isl_ast_graft_insert_for.
 */
================================================================================

文件路径: ./isl_ast_graft.c
注释行数: 15
注释内容:
/* Combine the grafts in the list into a single graft.
 *
 * The guard is initialized to the shared guard of the list elements (if any),
 * provided it does not depend on the current dimension.
 * The guards in the elements are then simplified with respect to the
 * hoisted guard and materialized as if nodes around the contained AST nodes
 * in the context of "sub_build".
 *
 * The enforced set is initialized to the simple hull of the enforced sets
 * of the elements, provided the ast_build_exploit_nested_bounds option is set
 * or the new graft will be used at the same level.
 *
 * The node is initialized to either a block containing the nodes of "list"
 * or, if there is only a single element, the node of that element.
 */
================================================================================

文件路径: ./isl_ast_graft.c
注释行数: 14
注释内容:
/* Reformulate the "graft", which was generated in the context
 * of an inner code generation, in terms of the outer code generation
 * AST build.
 *
 * If "product" is set, then the domain of the inner code generation build is
 *
 *	[O -> S]
 *
 * with O the domain of the outer code generation build.
 * We essentially need to project out S.
 *
 * If "product" is not set, then we need to project the domains onto
 * their parameter spaces.
 */
================================================================================

文件路径: ./isl_ast_graft.c
注释行数: 22
注释内容:
/* Merge the given two lists into a single list of grafts,
 * merging grafts with the same guard into a single graft.
 *
 * "list2" has been sorted using isl_ast_graft_list_sort.
 * "list1" may be the result of a previous call to isl_ast_graft_list_merge
 * and may therefore not be completely sorted.
 *
 * The elements in "list2" need to be executed after those in "list1",
 * but if the guard of a graft in "list2" is disjoint from the guards
 * of some final elements in "list1", then it can be moved up to before
 * those final elements.
 *
 * In particular, we look at each element g of "list2" in turn
 * and move it up beyond elements of "list1" that would be sorted
 * after g as long as each of these elements has a guard that is disjoint
 * from that of g.
 *
 * We do not allow the second or any later element of "list2" to be moved
 * before a previous elements of "list2" even if the reason that
 * that element didn't move up further was that its guard was not disjoint
 * from that of the previous element in "list1".
 */
================================================================================

文件路径: ./isl_local_space.c
注释行数: 11
注释内容:
/*
 * Copyright 2011      INRIA Saclay
 * Copyright 2012-2014 Ecole Normale Superieure
 *
 * Use of this software is governed by the MIT license
 *
 * Written by Sven Verdoolaege, INRIA Saclay - Ile-de-France,
 * Parc Club Orsay Universite, ZAC des vignes, 4 rue Jacques Monod,
 * 91893 Orsay, France
 * and Ecole Normale Superieure, 45 rue d’Ulm, 75230 Paris, France
 */
================================================================================

文件路径: ./isl_local_space.c
注释行数: 16
注释内容:
/* Plug in the affine expressions "subs" of length "subs_len" (including
 * the denominator and the constant term) into the variable at position "pos"
 * of the "n" div expressions starting at "first".
 *
 * Let i be the dimension to replace and let "subs" be of the form
 *
 *	f/d
 *
 * Any integer division starting at "first" with a non-zero coefficient for i,
 *
 *	floor((a i + g)/m)
 *
 * is replaced by
 *
 *	floor((a f + d g)/(m d))
 */
================================================================================

文件路径: ./isl_local_space.c
注释行数: 15
注释内容:
/* Plug in "subs" for dimension "type", "pos" in the integer divisions
 * of "ls".
 *
 * Let i be the dimension to replace and let "subs" be of the form
 *
 *	f/d
 *
 * Any integer division with a non-zero coefficient for i,
 *
 *	floor((a i + g)/m)
 *
 * is replaced by
 *
 *	floor((a f + d g)/(m d))
 */
================================================================================

文件路径: ./isl_local_space.c
注释行数: 11
注释内容:
/* Does the linear part of "constraint" correspond to
 * integer division "div" in "ls"?
 *
 * That is, given div = floor((c + f)/m), is the constraint of the form
 *
 *		f - m d + c' >= 0		[sign = 1]
 * or
 *		-f + m d + c'' >= 0		[sign = -1]
 * ?
 * If so, set *sign to the corresponding value.
 */
================================================================================

文件路径: ./isl_local_space.c
注释行数: 12
注释内容:
/* Check if the constraints pointed to by "constraint" is a div
 * constraint corresponding to div "div" in "ls".
 *
 * That is, if div = floor(f/m), then check if the constraint is
 *
 *		f - m d >= 0
 * or
 *		-(f-(m-1)) + m d >= 0
 *
 * First check if the linear part is of the right form and
 * then check the constant term.
 */
================================================================================

文件路径: ./isl_local_space.c
注释行数: 15
注释内容:
/* Is the constraint pointed to by "constraint" one
 * of an equality that corresponds to integer division "div" in "ls"?
 *
 * That is, given an integer division of the form
 *
 *	a = floor((f + c)/m)
 *
 * is the equality of the form
 *
 *		-f + m d + c' = 0
 * ?
 * Note that the constant term is not checked explicitly, but given
 * that this is a valid equality constraint, the constant c' necessarily
 * has a value close to -c.
 */
================================================================================

文件路径: ./isl_local_space.c
注释行数: 19
注释内容:
/* Compute the preimage of "ls" under the function represented by "ma".
 * In other words, plug in "ma" in "ls".  The result is a local space
 * that is part of the domain space of "ma".
 *
 * If the divs in "ls" are represented as
 *
 *	floor((a_i(p) + b_i x + c_i(divs))/n_i)
 *
 * and ma is represented by
 *
 *	x = D(p) + F(y) + G(divs')
 *
 * then the resulting divs are
 *
 *	floor((a_i(p) + b_i D(p) + b_i F(y) + B_i G(divs') + c_i(divs))/n_i)
 *
 * We first copy over the divs from "ma" and then
 * we add the modified divs from "ls".
 */
================================================================================

文件路径: ./isl_ilp.c
注释行数: 16
注释内容:
/* Find an integer point in "bset" that minimizes f (in any) such that
 * the value of f lies inside the interval [l, u].
 * Return this integer point if it can be found.
 * Otherwise, return sol.
 *
 * We perform a number of steps until l > u.
 * In each step, we look for an integer point with value in either
 * the whole interval [l, u] or half of the interval [l, l+floor(u-l-1/2)].
 * The choice depends on whether we have found an integer point in the
 * previous step.  If so, we look for the next point in half of the remaining
 * interval.
 * If we find a point, the current solution is updated and u is set
 * to its value minus 1.
 * If no point can be found, we update l to the upper bound of the interval
 * we checked (u or l+floor(u-l-1/2)) plus 1.
 */
================================================================================

文件路径: ./isl_ilp.c
注释行数: 13
注释内容:
/* Find an integer point in "bset" that minimizes f (if any).
 * If sol_p is not NULL then the integer point is returned in *sol_p.
 * The optimal value of f is returned in *opt.
 *
 * The algorithm maintains a currently best solution and an interval [l, u]
 * of values of f for which integer solutions could potentially still be found.
 * The initial value of the best solution so far is any solution.
 * The initial value of l is minimal value of f over the rationals
 * (rounded up to the nearest integer).
 * The initial value of u is the value of f at the initial solution minus 1.
 *
 * We then call solve_ilp_search to perform a binary search on the interval.
 */
================================================================================

文件路径: ./isl_ilp.c
注释行数: 10
注释内容:
/* Convert the result of a function that returns an isl_lp_result
 * to an isl_val.  The numerator of "v" is set to the optimal value
 * if lp_res is isl_lp_ok.  "max" is set if a maximum was computed.
 *
 * Return "v" with denominator set to 1 if lp_res is isl_lp_ok.
 * Return NULL on error.
 * Return a NaN if lp_res is isl_lp_empty.
 * Return infinity or negative infinity if lp_res is isl_lp_unbounded,
 * depending on "max".
 */
================================================================================

文件路径: ./isl_test.c
注释行数: 16
注释内容:
/*
 * Copyright 2008-2009 Katholieke Universiteit Leuven
 * Copyright 2010      INRIA Saclay
 * Copyright 2012-2013 Ecole Normale Superieure
 * Copyright 2014      INRIA Rocquencourt
 *
 * Use of this software is governed by the MIT license
 *
 * Written by Sven Verdoolaege, K.U.Leuven, Departement
 * Computerwetenschappen, Celestijnenlaan 200A, B-3001 Leuven, Belgium
 * and INRIA Saclay - Ile-de-France, Parc Club Orsay Universite,
 * ZAC des vignes, 4 rue Jacques Monod, 91893 Orsay, France
 * and Ecole Normale Superieure, 45 rue d’Ulm, 75230 Paris, France
 * and Inria Paris - Rocquencourt, Domaine de Voluceau - Rocquencourt,
 * B.P. 105 - 78153 Le Chesnay, France
 */
================================================================================

文件路径: ./isl_test.c
注释行数: 11
注释内容:
/* Check that calling isl_set_coalesce on the intersection of
 * the sets described by "s1" and "s2" does not leave other sets
 * that may share some information with the input to isl_set_coalesce
 * in an inconsistent state.
 * In particular, when isl_set_coalesce detects equality constraints,
 * it does not immediately perform Gaussian elimination on them,
 * but then it needs to ensure that it is performed at some point.
 * The input set has implicit equality constraints in the first disjunct.
 * It is constructed as an intersection, because otherwise
 * those equality constraints would already be detected during parsing.
 */
================================================================================

文件路径: ./isl_test.c
注释行数: 10
注释内容:
/* Input for testing of schedule construction based on
 * conditional constraints.
 *
 * domain is the iteration domain
 * flow are the flow dependences, which determine the validity and
 * 	proximity constraints
 * condition are the conditions on the conditional validity constraints
 * conditional_validity are the conditional validity constraints
 * outer_band_n is the expected number of members in the outer band
 */
================================================================================

文件路径: ./isl_test.c
注释行数: 17
注释内容:
/* Contrived example that illustrates that we need to keep
	 * track of tagged condition dependences and
	 * tagged conditional validity dependences
	 * in isl_sched_edge separately.
	 * In particular, the conditional validity constraints on A
	 * cannot be satisfied,
	 * but they can be ignored because there are no corresponding
	 * condition constraints.  However, we do have an additional
	 * conditional validity constraint that maps to the same
	 * dependence relation
	 * as the condition constraint on B.  If we did not make a distinction
	 * between tagged condition and tagged conditional validity
	 * dependences, then we
	 * could end up treating this shared dependence as an condition
	 * constraint on A, forcing a localization of the conditions,
	 * which is impossible.
	 */
================================================================================

文件路径: ./isl_test.c
注释行数: 10
注释内容:
/* This function is called before each for loop in the AST generated
 * from test_ast_gen1.
 *
 * Increment the number of calls and the depth.
 * Check that the space returned by isl_ast_build_get_schedule_space
 * matches the target space of the schedule returned by
 * isl_ast_build_get_schedule.
 * Return an isl_id that is checked by the corresponding call
 * to after_for.
 */
================================================================================

文件路径: ./isl_test.c
注释行数: 10
注释内容:
/* Check that we do not lose any information when going back and
 * forth between internal and external schedule.
 *
 * In particular, we create an AST where we unroll the only
 * non-constant dimension in the schedule.  We therefore do
 * not expect any for loops in the AST.  However, older versions
 * of isl would not pass along enough information about the outer
 * schedule when performing an inner code generation from a create_leaf
 * callback, resulting in the inner code generation producing a for loop.
 */
================================================================================

文件路径: ./isl_test.c
注释行数: 11
注释内容:
/* Check that the expression
 *
 *	[n] -> { [n/2] : n <= 0 and n % 2 = 0; [0] : n > 0 }
 *
 * is not combined into
 *
 *	min(n/2, 0)
 *
 * as this would result in n/2 being evaluated in parts of
 * the definition domain where n is not a multiple of 2.
 */
================================================================================

文件路径: ./isl_schedule_constraints.c
注释行数: 21
注释内容:
/* The constraints that need to be satisfied by a schedule on "domain".
 *
 * "context" specifies extra constraints on the parameters.
 *
 * "validity" constraints map domain elements i to domain elements
 * that should be scheduled after i.  (Hard constraint)
 * "proximity" constraints map domain elements i to domains elements
 * that should be scheduled as early as possible after i (or before i).
 * (Soft constraint)
 *
 * "condition" and "conditional_validity" constraints map possibly "tagged"
 * domain elements i -> s to "tagged" domain elements j -> t.
 * The elements of the "conditional_validity" constraints, but without the
 * tags (i.e., the elements i -> j) are treated as validity constraints,
 * except that during the construction of a tilable band,
 * the elements of the "conditional_validity" constraints may be violated
 * provided that all adjacent elements of the "condition" constraints
 * are local within the band.
 * A dependence is local within a band if domain and range are mapped
 * to the same schedule point by the band.
 */
================================================================================

文件路径: ./isl_schedule_constraints.c
注释行数: 15
注释内容:
/* Apply "umap" to the domains of the wrapped relations
 * inside the domain and range of "c".
 *
 * That is, for each map of the form
 *
 *	[D -> S] -> [E -> T]
 *
 * in "c", apply "umap" to D and E.
 *
 * D is exposed by currying the relation to
 *
 *	D -> [S -> [E -> T]]
 *
 * E is exposed by doing the same to the inverse of "c".
 */
================================================================================

文件路径: ./isl_stream_private.h
注释行数: 17
注释内容:
/* An input stream that may be either a file or a string.
 *
 * line and col are the line and column number of the next character (1-based).
 * start_line and start_col are set by isl_stream_getc to point
 * to the position of the returned character.
 * last_line is the line number of the previous token.
 *
 * yaml_state and yaml_indent keep track of the currently active YAML
 * elements.  yaml_size is the size of these arrays, while yaml_depth
 * is the number of elements currently in use.
 * yaml_state and yaml_indent may be NULL if no YAML parsing is being
 * performed.
 * yaml_state keeps track of what is expected next at each level.
 * yaml_indent keeps track of the indentation at each level, with
 * ISL_YAML_INDENT_FLOW meaning that the element is in flow format
 * (such that the indentation is not relevant).
 */
================================================================================

文件路径: ./isl_map_private.h
注释行数: 10
注释内容:
/* A "basic map" is a relation between two sets of variables,
 * called the "in" and "out" variables.
 * A "basic set" is a basic map with a zero-dimensional
 * domain.
 *
 * It is implemented as a set with two extra fields:
 * n_in is the number of in variables
 * n_out is the number of out variables
 * n_in + n_out should be equal to set.dim
 */
================================================================================

文件路径: ./isl_map_private.h
注释行数: 11
注释内容:
/* A "map" is a (possibly disjoint) union of basic maps.
 * A "set" is a (possibly disjoint) union of basic sets.
 *
 * Currently, the isl_set structure is identical to the isl_map structure
 * and the library depends on this correspondence internally.
 * However, users should not depend on this correspondence.
 *
 * "cached_simple_hull" contains copies of the unshifted and shifted
 * simple hulls, if they have already been computed.  Otherwise,
 * the entries are NULL.
 */
================================================================================

文件路径: ./isl_bind_domain_templ.c
注释行数: 10
注释内容:
/* Given a function living in a space of the form [A -> B] -> C and
 * a tuple of identifiers in A, bind the domain dimensions of the relation
 * wrapped in the domain of "obj" with identifiers specified by "tuple",
 * returning a function in the space B -> C.
 *
 * If no parameters with these identifiers appear in "obj" already,
 * then the domain dimensions are simply reinterpreted as parameters.
 * Otherwise, the parameters are first equated to the corresponding
 * domain dimensions.
 */
================================================================================

文件路径: ./isl_aff_lex_templ.c
注释行数: 13
注释内容:
/* Return a map containing pairs of elements in the domains of "mpa1" and "mpa2"
 * where the function value of "mpa1" lexicographically compares as "ORDER"
 * to that of "mpa2".  "space" is the space of the result.
 * The parameters of "mpa1" and "mpa2" are assumed to have been aligned.
 *
 * "mpa1" is in the given lexicographic order compared to "mpa2"
 * if, for some i, the i-th element of "mpa1" is in that order compared to
 * the i-th element of "mpa2" while all previous elements are
 * pairwise equal, where the order needs to be strict (not-equal)
 * if i corresponds to anything but the last element.
 * The strict version of "ORDER" is defined by "STRICT_ORDER",
 * which is the same if "ORDER" itself is strict.
 */
================================================================================

文件路径: ./isl_dim_map.c
注释行数: 11
注释内容:
/*
 * Copyright 2008-2009 Katholieke Universiteit Leuven
 * Copyright 2010-2011 INRIA Saclay
 *
 * Use of this software is governed by the MIT license
 *
 * Written by Sven Verdoolaege, K.U.Leuven, Departement
 * Computerwetenschappen, Celestijnenlaan 200A, B-3001 Leuven, Belgium
 * and INRIA Saclay - Ile-de-France, Parc Club Orsay Universite,
 * ZAC des vignes, 4 rue Jacques Monod, 91893 Orsay, France 
 */
================================================================================

文件路径: ./codegen.c
注释行数: 10
注释内容:
/* This program prints an AST that scans the domain elements of
 * the domain of a given schedule in the order specified by
 * the schedule tree or by their image(s) in the schedule map.
 *
 * The input consists of either a schedule tree or
 * a sequence of three sets/relations.
 * - a schedule map
 * - a context
 * - a relation describing AST generation options
 */
================================================================================

文件路径: ./isl_ast.c
注释行数: 10
注释内容:
/* Traverse the descendants of "node" (including the node itself)
 * in depth first preorder.
 *
 * If "fn" returns isl_bool_error on any of the nodes, then the traversal
 * is aborted.
 * If "fn" returns isl_bool_false on any of the nodes, then the subtree rooted
 * at that node is skipped.
 *
 * Return isl_stat_ok on success and isl_stat_error on failure.
 */
================================================================================

文件路径: ./isl_ast.c
注释行数: 18
注释内容:
/* Do we need/want parentheses around "expr" as a subexpression of
 * an "op" operation?  If "left" is set, then "expr" is the left-most
 * operand.
 *
 * We only need parentheses if "expr" represents an operation.
 *
 * If op has a higher precedence than expr->u.op.op, then we need
 * parentheses.
 * If op and expr->u.op.op have the same precedence, but the operations
 * are performed in an order that is different from the associativity,
 * then we need parentheses.
 *
 * An and inside an or technically does not require parentheses,
 * but some compilers complain about that, so we add them anyway.
 *
 * Computations such as "a / b * c" and "a % b + c" can be somewhat
 * difficult to read, so we add parentheses for those as well.
 */
================================================================================

文件路径: ./isl_ast.c
注释行数: 14
注释内容:
/* Do we need to print a block around the body "node" of a for or if node?
 *
 * If the node is a block, then we need to print a block.
 * Also if the node is a degenerate for then we will print it as
 * an assignment followed by the body of the for loop, so we need a block
 * as well.
 * If the node is an if node with an else, then we print a block
 * to avoid spurious dangling else warnings emitted by some compilers.
 * If the node is a mark, then in principle, we would have to check
 * the child of the mark node.  However, even if the child would not
 * require us to print a block, for readability it is probably best
 * to print a block anyway.
 * If the ast_always_print_block option has been set, then we print a block.
 */
================================================================================

文件路径: ./isl_ast.c
注释行数: 20
注释内容:
/* Print the body "node" of a for or if node.
 * If "else_node" is set, then it is printed as well.
 * If "force_block" is set, then print out the body as a block.
 *
 * We first check if we need to print out a block.
 * We always print out a block if there is an else node to make
 * sure that the else node is matched to the correct if node.
 * For consistency, the corresponding else node is also printed as a block.
 *
 * If the else node is itself an if, then we print it as
 *
 *	} else if (..) {
 *	}
 *
 * Otherwise the else node is printed as
 *
 *	} else {
 *	  node
 *	}
 */
================================================================================

文件路径: ./isl_ast.c
注释行数: 19
注释内容:
/* Print the for node "node".
 *
 * If the for node is degenerate, it is printed as
 *
 *	type iterator = init;
 *	body
 *
 * Otherwise, it is printed as
 *
 *	for (type iterator = init; cond; iterator += inc)
 *		body
 *
 * "in_block" is set if we are currently inside a block.
 * "in_list" is set if the current node is not alone in the block.
 * If we are not in a block or if the current not is not alone in the block
 * then we print a block around a degenerate for loop such that the variable
 * declaration will not conflict with any potential other declaration
 * of the same variable.
 */
================================================================================

文件路径: ./isl_schedule_tree.h
注释行数: 40
注释内容:
/* A schedule (sub)tree.
 *
 * The leaves of a tree are not explicitly represented inside
 * the isl_schedule_tree, except when the tree consists of only a leaf.
 *
 * The "band" field is valid when type is isl_schedule_node_band.
 * The "context" field is valid when type is isl_schedule_node_context
 * and represents constraints on the flat product of the outer band nodes,
 * possibly introducing additional parameters.
 * The "domain" field is valid when type is isl_schedule_node_domain
 * and introduces the statement instances scheduled by the tree.
 *
 * The "contraction" and "expansion" fields are valid when type
 * is isl_schedule_node_expansion.
 * "expansion" expands the reaching domain elements to one or more
 * domain elements for the subtree.
 * "contraction" maps these elements back to the corresponding
 * reaching domain element.  It does not involve any domain constraints.
 *
 * The "extension" field is valid when the is isl_schedule_node_extension
 * maps outer schedule dimensions (the flat product of the outer band nodes)
 * to additional iteration domains.
 *
 * The "filter" field is valid when type is isl_schedule_node_filter
 * and represents the statement instances selected by the node.
 *
 * The "guard" field is valid when type is isl_schedule_node_guard
 * and represents constraints on the flat product of the outer band nodes
 * that need to be enforced by the outer nodes in the generated AST.
 *
 * The "mark" field is valid when type is isl_schedule_node_mark and
 * identifies the mark.
 *
 * The "children" field is valid for all types except
 * isl_schedule_node_leaf.  This field is NULL if there are
 * no children (except for the implicit leaves).
 *
 * anchored is set if the node or any of its descendants depends
 * on its position in the schedule tree.
 */
================================================================================

文件路径: ./isl_ast_build.c
注释行数: 11
注释内容:
/*
 * Copyright 2012-2013 Ecole Normale Superieure
 * Copyright 2014      INRIA Rocquencourt
 *
 * Use of this software is governed by the MIT license
 *
 * Written by Sven Verdoolaege,
 * Ecole Normale Superieure, 45 rue d’Ulm, 75230 Paris, France
 * and Inria Paris - Rocquencourt, Domaine de Voluceau - Rocquencourt,
 * B.P. 105 - 78153 Le Chesnay, France
 */
================================================================================

文件路径: ./isl_ast_build.c
注释行数: 18
注释内容:
/* Return a mapping from the internal schedule space to the external
 * schedule space in the form of an isl_multi_aff.
 * The internal schedule space originally corresponds to that of the
 * input schedule.  This may change during the code generation if
 * if isl_ast_build_insert_dim is ever called.
 * The external schedule space corresponds to the
 * loops that have been generated.
 *
 * Currently, the only difference between the internal schedule domain
 * and the external schedule domain is that some dimensions are projected
 * out in the external schedule domain.  In particular, the dimensions
 * for which no code has been generated yet and the dimensions that correspond
 * to eliminated loops.
 *
 * We cache a copy of the schedule_map in build->schedule_map.
 * The cache is cleared through isl_ast_build_reset_schedule_map
 * whenever anything changes that might affect the result of this function.
 */
================================================================================

文件路径: ./isl_ast_build.c
注释行数: 17
注释内容:
/* Check if the given bounds on the current dimension (together with
 * the stride constraint, if any) imply that
 * this current dimension attains only a single value (in terms of
 * parameters and outer dimensions).
 * If so, we record it in build->value.
 * If, moreover, this value can be represented as a single affine expression,
 * then we also update build->values, effectively marking the current
 * dimension as "eliminated".
 *
 * When computing the gist of the fixed value that can be represented
 * as a single affine expression, it is important to only take into
 * account the domain constraints in the original AST build and
 * not the domain of the affine expression itself.
 * Otherwise, a [i/3] is changed into a i/3 because we know that i
 * is a multiple of 3, but then we end up not expressing anywhere
 * in the context that i is a multiple of 3.
 */
================================================================================

文件路径: ./isl_ast_build.c
注释行数: 31
注释内容:
/* Update the AST build based on the given loop bounds for
 * the current dimension and the stride information available in the build.
 *
 * We first make sure that the bounds do not refer to any iterators
 * that have already been eliminated.
 * Then, we check if the bounds imply that the current iterator
 * has a fixed value.
 * If they do and if this fixed value can be expressed as a single
 * affine expression, we eliminate the iterators from the bounds.
 * Note that we cannot simply plug in this single value using
 * isl_basic_set_preimage_multi_aff as the single value may only
 * be defined on a subset of the domain.  Plugging in the value
 * would restrict the build domain to this subset, while this
 * restriction may not be reflected in the generated code.
 * Finally, we intersect build->domain with the updated bounds.
 * We also add the stride constraint unless we have been able
 * to find a fixed value expressed as a single affine expression.
 *
 * Note that the check for a fixed value in update_values requires
 * us to intersect the bounds with the current build domain.
 * When we intersect build->domain with the updated bounds in
 * the final step, we make sure that these updated bounds have
 * not been intersected with the old build->domain.
 * Otherwise, we would indirectly intersect the build domain with itself,
 * which can lead to inefficiencies, in particular if the build domain
 * contains any unknown divs.
 *
 * The pending and generated sets are not updated by this function to
 * match the updated domain.
 * The caller still needs to call isl_ast_build_set_pending_generated.
 */
================================================================================

文件路径: ./isl_ast_build.c
注释行数: 11
注释内容:
/* Return a set expressing the stride constraint at the current depth.
 *
 * In particular, if the current iterator (i) is known to attain values
 *
 *	f + s a
 *
 * where f is the offset and s is the stride, then the returned set
 * expresses the constraint
 *
 *	(f - i) mod s = 0
 */
================================================================================

文件路径: ./isl_ast_build.c
注释行数: 11
注释内容:
/* Return the expansion implied by the stride and offset at the current
 * depth.
 *
 * That is, return the mapping
 *
 *	[i_0, ..., i_{d-1}, i_d, i_{d+1}, ...]
 *		-> [i_0, ..., i_{d-1}, s * i_d + offset(i),  i_{d+1}, ...]
 *
 * where s is the stride at the current depth d and offset(i) is
 * the corresponding offset.
 */
================================================================================

文件路径: ./isl_ast_build.c
注释行数: 11
注释内容:
/* Check if the constraints in "set" imply any stride on the current
 * dimension and, if so, record the stride information in "build"
 * and return the updated "build".
 *
 * We assume that inner dimensions have been eliminated from "set"
 * by the caller.  This is needed because the common stride
 * may be imposed by different inner dimensions on different parts of
 * the domain.
 * The assumption ensures that the lower bound does not depend
 * on inner dimensions.
 */
================================================================================

文件路径: ./isl_ast_build.c
注释行数: 21
注释内容:
/* Update the "options" to reflect the insertion of a dimension
 * at position "pos" in the schedule domain space.
 * "space" is the original domain space before the insertion and
 * may be named and/or structured.
 *
 * The (relevant) input options all have "space" as domain, which
 * has to be mapped to the extended space.
 * The values of the ranges also refer to the schedule domain positions
 * and they therefore also need to be adjusted.  In particular, values
 * smaller than pos do not need to change, while values greater than or
 * equal to pos need to be incremented.
 * That is, we need to apply the following map.
 *
 *	{ atomic[i] -> atomic[i] : i < pos; [i] -> [i + 1] : i >= pos;
 *	  unroll[i] -> unroll[i] : i < pos; [i] -> [i + 1] : i >= pos;
 *	  separate[i] -> separate[i] : i < pos; [i] -> [i + 1] : i >= pos;
 *	  separation_class[[i] -> [c]]
 *		-> separation_class[[i] -> [c]] : i < pos;
 *	  separation_class[[i] -> [c]]
 *		-> separation_class[[i + 1] -> [c]] : i >= pos }
 */
================================================================================

文件路径: ./isl_ast_build.c
注释行数: 18
注释内容:
/* Insert a single dimension in the schedule domain at position "pos".
 * The new dimension is given an isl_id with the empty string as name.
 *
 * The main difficulty is updating build->options to reflect the
 * extra dimension.  This is handled in options_insert_dim.
 *
 * Note that because of the dimension manipulations, the resulting
 * schedule domain space will always be unnamed and unstructured.
 * However, the original schedule domain space may be named and/or
 * structured, so we have to take this possibility into account
 * while performing the transformations.
 *
 * Since the inserted schedule dimension is used by the caller
 * to differentiate between different domain spaces, there is
 * no longer a uniform mapping from the internal schedule space
 * to the input schedule space.  The internal2input mapping is
 * therefore removed.
 */
================================================================================

文件路径: ./isl_ast_build.c
注释行数: 15
注释内容:
/* Scale down the current dimension by a factor of "m".
 * "umap" is an isl_union_map that implements the scaling down.
 * That is, it is of the form
 *
 *	{ [.... i ....] -> [.... i' ....] : i = m i' }
 *
 * This function is called right after the strides have been
 * detected, but before any constraints on the current dimension
 * have been included in build->domain.
 * We therefore only need to update stride, offset, the options and
 * the mapping from internal schedule space to the original schedule
 * space, if we are still keeping track of such a mapping.
 * The latter mapping is updated by plugging in
 * { [... i ...] -> [... m i ... ] }.
 */
================================================================================

文件路径: ./isl_ast_build.c
注释行数: 24
注释内容:
/* Embed "options" into the given isl_ast_build space.
 *
 * This function is called from within a nested call to
 * isl_ast_build_node_from_schedule_map.
 * "options" refers to the additional schedule,
 * while space refers to both the space of the outer isl_ast_build and
 * that of the additional schedule.
 * Specifically, space is of the form
 *
 *	[I -> S]
 *
 * while options lives in the space(s)
 *
 *	S -> *
 *
 * We compute
 *
 *	[I -> S] -> S
 *
 * and compose this with options, to obtain the new options
 * living in the space(s)
 *
 *	[I -> S] -> *
 */
================================================================================

文件路径: ./isl_ast_build.c
注释行数: 22
注释内容:
/* Update "build" for use in a (possibly nested) code generation.  That is,
 * extend "build" from an AST build on some domain O to an AST build
 * on domain [O -> S], with S corresponding to "space".
 * If the original domain is a parameter domain, then the new domain is
 * simply S.
 * "iterators" is a list of iterators for S, but the number of elements
 * may be smaller or greater than the number of set dimensions of S.
 * If "keep_iterators" is set, then any extra ids in build->iterators
 * are reused for S.  Otherwise, these extra ids are dropped.
 *
 * We first update build->outer_pos to the current depth.
 * This depth is zero in case this is the outermost code generation.
 *
 * We then add additional ids such that the number of iterators is at least
 * equal to the dimension of the new build domain.
 *
 * If the original domain is parametric, then we are constructing
 * an isl_ast_build for the outer code generation and we pass control
 * to isl_ast_build_init.
 *
 * Otherwise, we adjust the fields of "build" to include "space".
 */
================================================================================

文件路径: ./isl_ast_build.c
注释行数: 15
注释内容:
/* Extract the schedule domain of the given type from build->options
 * at the current depth.
 *
 * In particular, find the subset of build->options that is of
 * the following form
 *
 *	schedule_domain -> type[depth]
 *
 * and return the corresponding domain, after eliminating inner dimensions
 * and divs that depend on the current dimension.
 *
 * Note that the domain of build->options has been reformulated
 * in terms of the internal build space in embed_options,
 * but the position is still that within the current code generation.
 */
================================================================================

文件路径: ./isl_ast_build.c
注释行数: 11
注释内容:
/* How does the user want the current schedule dimension to be generated?
 * These choices have been extracted from the schedule node
 * in extract_loop_types and stored in build->loop_type.
 * They have been updated to reflect any dimension insertion in
 * node_insert_dim.
 * Return isl_ast_domain_error on error.
 *
 * If "isolated" is set, then we get the loop AST generation type
 * directly from the band node since node_insert_dim cannot have been
 * called on a band with the isolate option.
 */
================================================================================

文件路径: ./isl_ast_build.c
注释行数: 17
注释内容:
/* Extract the isolated set from the isolate option, if any,
 * and store in the build.
 * If there is no isolate option, then the isolated set is
 * set to the empty set.
 *
 * The isolate option is of the form
 *
 *	isolate[[outer bands] -> current_band]
 *
 * We flatten this set and then map it back to the internal
 * schedule space.
 *
 * If we have already extracted the isolated set
 * or if internal2input is no longer set, then we do not
 * need to do anything.  In the latter case, we know
 * that the current band cannot have any isolate option.
 */
================================================================================

文件路径: ./isl_ast_build.c
注释行数: 13
注释内容:
/* Extract the separation class mapping at the current depth.
 *
 * In particular, find and return the subset of build->options that is of
 * the following form
 *
 *	schedule_domain -> separation_class[[depth] -> [class]]
 *
 * The caller is expected to eliminate inner dimensions from the domain.
 *
 * Note that the domain of build->options has been reformulated
 * in terms of the internal build space in embed_options,
 * but the position is still that within the current code generation.
 */
================================================================================

文件路径: ./isl_lp.c
注释行数: 10
注释内容:
/* Given a basic map "bmap" and an affine combination of the variables "f"
 * with denominator "denom", set *opt / *opt_denom to the minimal
 * (or maximal if "maximize" is true) value attained by f/d over "bmap",
 * assuming the basic map is not empty and the expression cannot attain
 * arbitrarily small (or large) values.
 * If opt_denom is NULL, then *opt is rounded up (or down)
 * to the nearest integer.
 * The return value reflects the nature of the result (empty, unbounded,
 * minimal or maximal value returned in *opt).
 */
================================================================================

文件路径: ./isl_lp.c
注释行数: 10
注释内容:
/* Return the optimal (rational) value of "obj" over "bset", assuming
 * that "obj" and "bset" have aligned parameters and divs.
 * If "max" is set, then the maximal value is computed.
 * Otherwise, the minimal value is computed.
 *
 * Return infinity or negative infinity if the optimal value is unbounded and
 * NaN if "bset" is empty.
 *
 * Call isl_basic_set_solve_lp and translate the results.
 */
================================================================================

文件路径: ./isl_lp.c
注释行数: 10
注释内容:
/* Return the optimal (rational) value of "obj" over "bset", assuming
 * that "obj" and "bset" have aligned parameters.
 * If "max" is set, then the maximal value is computed.
 * Otherwise, the minimal value is computed.
 *
 * Return infinity or negative infinity if the optimal value is unbounded and
 * NaN if "bset" is empty.
 *
 * Align the divs of "bset" and "obj" and call basic_set_opt_lp.
 */
================================================================================

文件路径: ./isl_pw_eval.c
注释行数: 11
注释内容:
/*
 * Copyright 2010      INRIA Saclay
 * Copyright 2013      Ecole Normale Superieure
 *
 * Use of this software is governed by the MIT license
 *
 * Written by Sven Verdoolaege, INRIA Saclay - Ile-de-France,
 * Parc Club Orsay Universite, ZAC des vignes, 4 rue Jacques Monod,
 * 91893 Orsay, France
 * and Ecole Normale Superieure, 45 rue d'Ulm, 75230 Paris, France
 */
================================================================================

文件路径: ./isl_ast_build_expr.c
注释行数: 11
注释内容:
/*
 * Copyright 2012-2014 Ecole Normale Superieure
 * Copyright 2014      INRIA Rocquencourt
 *
 * Use of this software is governed by the MIT license
 *
 * Written by Sven Verdoolaege,
 * Ecole Normale Superieure, 45 rue d’Ulm, 75230 Paris, France
 * and Inria Paris - Rocquencourt, Domaine de Voluceau - Rocquencourt,
 * B.P. 105 - 78153 Le Chesnay, France
 */
================================================================================

文件路径: ./isl_ast_build_expr.c
注释行数: 20
注释内容:
/* Given the numerator "aff" of the argument of an integer division
 * with denominator "d", check if it can be made non-negative over
 * data->build->domain by stealing part of the constant term of
 * the expression in which the integer division appears.
 *
 * In particular, the outer expression is of the form
 *
 *	v * floor(aff/d) + cst
 *
 * We already know that "aff" itself may attain negative values.
 * Here we check if aff + d*floor(cst/v) is non-negative, such
 * that we could rewrite the expression to
 *
 *	v * floor((aff + d*floor(cst/v))/d) + cst - v*floor(cst/v)
 *
 * Note that aff + d*floor(cst/v) can only possibly be non-negative
 * if data->cst and data->v have the same sign.
 * Similarly, if floor(cst/v) is zero, then there is no point in
 * checking again.
 */
================================================================================

文件路径: ./isl_ast_build_expr.c
注释行数: 26
注释内容:
/* Given the numerator "aff' of the argument of an integer division
 * with denominator "d", steal part of the constant term of
 * the expression in which the integer division appears to make it
 * non-negative over data->build->domain.
 *
 * In particular, the outer expression is of the form
 *
 *	v * floor(aff/d) + cst
 *
 * We know that "aff" itself may attain negative values,
 * but that aff + d*floor(cst/v) is non-negative.
 * Find the minimal positive value that we need to add to "aff"
 * to make it positive and adjust data->cst accordingly.
 * That is, compute the minimal value "m" of "aff" over
 * data->build->domain and take
 *
 *	s = ceil(m/d)
 *
 * such that
 *
 *	aff + d * s >= 0
 *
 * and rewrite the expression to
 *
 *	v * floor((aff + s*d)/d) + (cst - v*s)
 */
================================================================================

文件路径: ./isl_ast_build_expr.c
注释行数: 34
注释内容:
/* Create an isl_ast_expr evaluating the div at position "pos" in "ls".
 * The result is simplified in terms of data->build->domain.
 * This function may change (the sign of) data->v.
 *
 * "ls" is known to be non-NULL.
 *
 * Let the div be of the form floor(e/d).
 * If the ast_build_prefer_pdiv option is set then we check if "e"
 * is non-negative, so that we can generate
 *
 *	(pdiv_q, expr(e), expr(d))
 *
 * instead of
 *
 *	(fdiv_q, expr(e), expr(d))
 *
 * If the ast_build_prefer_pdiv option is set and
 * if "e" is not non-negative, then we check if "-e + d - 1" is non-negative.
 * If so, we can rewrite
 *
 *	floor(e/d) = -ceil(-e/d) = -floor((-e + d - 1)/d)
 *
 * and still use pdiv_q, while changing the sign of data->v.
 *
 * Otherwise, we check if
 *
 *	e + d*floor(cst/v)
 *
 * is non-negative and if so, replace floor(e/d) by
 *
 *	floor((e + s*d)/d) - s
 *
 * with s the minimal shift that makes the argument non-negative.
 */
================================================================================

文件路径: ./isl_ast_build_expr.c
注释行数: 11
注释内容:
/* Subtract expr2 from expr1.
 *
 * If expr2 is zero, we simply return expr1.
 * If expr1 is zero, we return
 *
 *	(isl_ast_expr_op_minus, expr2)
 *
 * Otherwise, we return
 *
 *	(isl_ast_expr_op_sub, expr1, expr2)
 */
================================================================================

文件路径: ./isl_ast_build_expr.c
注释行数: 11
注释内容:
/* Create an isl_ast_expr that scales "expr" by "v".
 *
 * If v is 1, we simply return expr.
 * If v is -1, we return
 *
 *	(isl_ast_expr_op_minus, expr)
 *
 * Otherwise, we return
 *
 *	(isl_ast_expr_op_mul, expr(v), expr)
 */
================================================================================

文件路径: ./isl_ast_build_expr.c
注释行数: 23
注释内容:
/* Add an expression for "*v" times the specified dimension of "ls"
 * to expr.
 * If the dimension is an integer division, then this function
 * may modify data->cst in order to make the numerator non-negative.
 * The result is simplified in terms of data->build->domain.
 *
 * Let e be the expression for the specified dimension,
 * multiplied by the absolute value of "*v".
 * If "*v" is negative, we create
 *
 *	(isl_ast_expr_op_sub, expr, e)
 *
 * except when expr is trivially zero, in which case we create
 *
 *	(isl_ast_expr_op_minus, e)
 *
 * instead.
 *
 * If "*v" is positive, we simply create
 *
 *	(isl_ast_expr_op_add, expr, e)
 *
 */
================================================================================

文件路径: ./isl_ast_build_expr.c
注释行数: 22
注释内容:
/* Internal data structure used inside extract_modulos.
 *
 * If any modulo expressions are detected in "aff", then the
 * expression is removed from "aff" and added to either "pos" or "neg"
 * depending on the sign of the coefficient of the modulo expression
 * inside "aff".
 *
 * "add" is an expression that needs to be added to "aff" at the end of
 * the computation.  It is NULL as long as no modulos have been extracted.
 *
 * "i" is the position in "aff" of the div under investigation
 * "v" is the coefficient in "aff" of the div
 * "div" is the argument of the div, with the denominator removed
 * "d" is the original denominator of the argument of the div
 *
 * "nonneg" is an affine expression that is non-negative over "build"
 * and that can be used to extract a modulo expression from "div".
 * In particular, if "sign" is 1, then the coefficients of "nonneg"
 * are equal to those of "div" modulo "d".  If "sign" is -1, then
 * the coefficients of "nonneg" are opposite to those of "div" modulo "d".
 * If "sign" is 0, then no such affine expression has been found (yet).
 */
================================================================================

文件路径: ./isl_ast_build_expr.c
注释行数: 13
注释内容:
/* Does
 *
 *	arg mod data->d
 *
 * represent (a special case of) a test for some linear expression
 * being even?
 *
 * In particular, is it of the form
 *
 *	(lin - 1) mod 2
 *
 * ?
 */
================================================================================

文件路径: ./isl_ast_build_expr.c
注释行数: 29
注释内容:
/* Given that data->v * div_i in data->aff is equal to
 *
 *	f * (term - (arg mod d))
 *
 * with data->d * f = data->v and "arg" non-negative on data->build, add
 *
 *	f * term
 *
 * to data->add and
 *
 *	abs(f) * (arg mod d)
 *
 * to data->neg or data->pos depending on the sign of -f.
 *
 * In the special case that "arg mod d" is of the form "(lin - 1) mod 2",
 * with "lin" some linear expression, first replace
 *
 *	f * (term - ((lin - 1) mod 2))
 *
 * by
 *
 *	-f * (1 - term - (lin mod 2))
 *
 * These two are equal because
 *
 *	((lin - 1) mod 2) + (lin mod 2) = 1
 *
 * Also, if "lin - 1" is non-negative, then "lin" is non-negative too.
 */
================================================================================

文件路径: ./isl_ast_build_expr.c
注释行数: 18
注释内容:
/* Given that data->v * div_i in data->aff is of the form
 *
 *	f * d * floor(div/d)
 *
 * with div nonnegative on data->build, rewrite it as
 *
 *	f * (div - (div mod d)) = f * div - f * (div mod d)
 *
 * and add
 *
 *	f * div
 *
 * to data->add and
 *
 *	abs(f) * (div mod d)
 *
 * to data->neg or data->pos depending on the sign of -f.
 */
================================================================================

文件路径: ./isl_ast_build_expr.c
注释行数: 18
注释内容:
/* Given that data->v * div_i in data->aff is of the form
 *
 *	f * d * floor(div/d)					(1)
 *
 * check if div is non-negative on data->build and, if so,
 * extract the corresponding modulo from data->aff.
 * If not, then check if
 *
 *	-div + d - 1
 *
 * is non-negative on data->build.  If so, replace (1) by
 *
 *	-f * d * floor((-div + d - 1)/d)
 *
 * and extract the corresponding modulo from data->aff.
 *
 * This function may modify data->div.
 */
================================================================================

文件路径: ./isl_ast_build_expr.c
注释行数: 11
注释内容:
/* Is the affine expression of constraint "c" "simpler" than data->nonneg
 * for use in extracting a modulo expression?
 *
 * We currently only consider the constant term of the affine expression.
 * In particular, we prefer the affine expression with the smallest constant
 * term.
 * This means that if there are two constraints, say x >= 0 and -x + 10 >= 0,
 * then we would pick x >= 0
 *
 * More detailed heuristics could be used if it turns out that there is a need.
 */
================================================================================

文件路径: ./isl_ast_build_expr.c
注释行数: 21
注释内容:
/* Check if the coefficients of "c" are either equal or opposite to those
 * of data->div modulo data->d.  If so, and if "c" is "simpler" than
 * data->nonneg, then replace data->nonneg by the affine expression of "c"
 * and set data->sign accordingly.
 *
 * Both "c" and data->div are assumed not to involve any integer divisions.
 *
 * Before we start the actual comparison, we first quickly check if
 * "c" and data->div have the same non-zero coefficients.
 * If not, then we assume that "c" is not of the desired form.
 * Note that while the coefficients of data->div can be reasonably expected
 * not to involve any coefficients that are multiples of d, "c" may
 * very well involve such coefficients.  This means that we may actually
 * miss some cases.
 *
 * If the constant term is "too large", then the constraint is rejected,
 * where "too large" is fairly arbitrarily set to 1 << 15.
 * We do this to avoid picking up constraints that bound a variable
 * by a very large number, say the largest or smallest possible
 * variable in the representation of some integer type.
 */
================================================================================

文件路径: ./isl_ast_build_expr.c
注释行数: 79
注释内容:
/* Given that data->v * div_i in data->aff is of the form
 *
 *	f * d * floor(div/d)					(1)
 *
 * see if we can find an expression div' that is non-negative over data->build
 * and that is related to div through
 *
 *	div' = div + d * e
 *
 * or
 *
 *	div' = -div + d - 1 + d * e
 *
 * with e some affine expression.
 * If so, we write (1) as
 *
 *	f * div + f * (div' mod d)
 *
 * or
 *
 *	-f * (-div + d - 1) - f * (div' mod d)
 *
 * exploiting (in the second case) the fact that
 *
 *	f * d * floor(div/d) =	-f * d * floor((-div + d - 1)/d)
 *
 *
 * We first try to find an appropriate expression for div'
 * from the constraints of data->build->domain (which is therefore
 * guaranteed to be non-negative on data->build), where we remove
 * any integer divisions from the constraints and skip this step
 * if "div" itself involves any integer divisions.
 * If we cannot find an appropriate expression this way, then
 * we pass control to extract_nonneg_mod where check
 * if div or "-div + d -1" themselves happen to be
 * non-negative on data->build.
 *
 * While looking for an appropriate constraint in data->build->domain,
 * we ignore the constant term, so after finding such a constraint,
 * we still need to fix up the constant term.
 * In particular, if a is the constant term of "div"
 * (or d - 1 - the constant term of "div" if data->sign < 0)
 * and b is the constant term of the constraint, then we need to find
 * a non-negative constant c such that
 *
 *	b + c \equiv a	mod d
 *
 * We therefore take
 *
 *	c = (a - b) mod d
 *
 * and add it to b to obtain the constant term of div'.
 * If this constant term is "too negative", then we add an appropriate
 * multiple of d to make it positive.
 *
 *
 * Note that the above is a only a very simple heuristic for finding an
 * appropriate expression.  We could try a bit harder by also considering
 * sums of constraints that involve disjoint sets of variables or
 * we could consider arbitrary linear combinations of constraints,
 * although that could potentially be much more expensive as it involves
 * the solution of an LP problem.
 *
 * In particular, if v_i is a column vector representing constraint i,
 * w represents div and e_i is the i-th unit vector, then we are looking
 * for a solution of the constraints
 *
 *	\sum_i lambda_i v_i = w + \sum_i alpha_i d e_i
 *
 * with \lambda_i >= 0 and alpha_i of unrestricted sign.
 * If we are not just interested in a non-negative expression, but
 * also in one with a minimal range, then we don't just want
 * c = \sum_i lambda_i v_i to be non-negative over the domain,
 * but also beta - c = \sum_i mu_i v_i, where beta is a scalar
 * that we want to minimize and we now also have to take into account
 * the constant terms of the constraints.
 * Alternatively, we could first compute the dual of the domain
 * and plug in the constraints on the coefficients.
 */
================================================================================

文件路径: ./isl_ast_build_expr.c
注释行数: 31
注释内容:
/* Check if "data->aff" involves any (implicit) modulo computations based
 * on div "data->i".
 * If so, remove them from aff and add expressions corresponding
 * to those modulo computations to data->pos and/or data->neg.
 *
 * "aff" is assumed to be an integer affine expression.
 *
 * In particular, check if (v * div_j) is of the form
 *
 *	f * m * floor(a / m)
 *
 * and, if so, rewrite it as
 *
 *	f * (a - (a mod m)) = f * a - f * (a mod m)
 *
 * and extract out -f * (a mod m).
 * In particular, if f > 0, we add (f * (a mod m)) to *neg.
 * If f < 0, we add ((-f) * (a mod m)) to *pos.
 *
 * Note that in order to represent "a mod m" as
 *
 *	(isl_ast_expr_op_pdiv_r, a, m)
 *
 * we need to make sure that a is non-negative.
 * If not, we check if "-a + m - 1" is non-negative.
 * If so, we can rewrite
 *
 *	floor(a/m) = -ceil(-a/m) = -floor((-a + m - 1)/m)
 *
 * and still extract a modulo.
 */
================================================================================

文件路径: ./isl_ast_build_expr.c
注释行数: 23
注释内容:
/* Check if "aff" involves any (implicit) modulo computations.
 * If so, remove them from aff and add expressions corresponding
 * to those modulo computations to *pos and/or *neg.
 * We only do this if the option ast_build_prefer_pdiv is set.
 *
 * "aff" is assumed to be an integer affine expression.
 *
 * A modulo expression is of the form
 *
 *	a mod m = a - m * floor(a / m)
 *
 * To detect them in aff, we look for terms of the form
 *
 *	f * m * floor(a / m)
 *
 * rewrite them as
 *
 *	f * (a - (a mod m)) = f * a - f * (a mod m)
 *
 * and extract out -f * (a mod m).
 * In particular, if f > 0, we add (f * (a mod m)) to *neg.
 * If f < 0, we add ((-f) * (a mod m)) to *pos.
 */
================================================================================

文件路径: ./isl_ast_build_expr.c
注释行数: 26
注释内容:
/* Check if the equality
 *
 *	aff = 0
 *
 * represents a stride constraint on the integer division "pos".
 *
 * In particular, if the integer division "pos" is equal to
 *
 *	floor(e/d)
 *
 * then check if aff is equal to
 *
 *	e - d floor(e/d)
 *
 * or its opposite.
 *
 * If so, the equality is exactly
 *
 *	e mod d = 0
 *
 * Note that in principle we could also accept
 *
 *	e - d floor(e'/d)
 *
 * where e and e' differ by a constant.
 */
================================================================================

文件路径: ./isl_ast_build_expr.c
注释行数: 21
注释内容:
/* Give an equality of the form
 *
 *	aff = e - d floor(e/d) = 0
 *
 * or
 *
 *	aff = -e + d floor(e/d) = 0
 *
 * with the integer division "pos" equal to floor(e/d),
 * construct the AST expression
 *
 *	(isl_ast_expr_op_eq,
 *		(isl_ast_expr_op_zdiv_r, expr(e), expr(d)), expr(0))
 *
 * If e only has negative coefficients, then construct
 *
 *	(isl_ast_expr_op_eq,
 *		(isl_ast_expr_op_zdiv_r, expr(-e), expr(d)), expr(0))
 *
 * instead.
 */
================================================================================

文件路径: ./isl_ast_build_expr.c
注释行数: 37
注释内容:
/* Construct an isl_ast_expr that evaluates the condition "constraint",
 * The result is simplified in terms of build->domain.
 *
 * We first check if the constraint is an equality of the form
 *
 *	e - d floor(e/d) = 0
 *
 * i.e.,
 *
 *	e mod d = 0
 *
 * If so, we convert it to
 *
 *	(isl_ast_expr_op_eq,
 *		(isl_ast_expr_op_zdiv_r, expr(e), expr(d)), expr(0))
 *
 * Otherwise, let the constraint by either "a >= 0" or "a == 0".
 * We first extract hidden modulo computations from "a"
 * and then collect all the terms with a positive coefficient in cons_pos
 * and the terms with a negative coefficient in cons_neg.
 *
 * The result is then of the form
 *
 *	(isl_ast_expr_op_ge, expr(pos), expr(-neg)))
 *
 * or
 *
 *	(isl_ast_expr_op_eq, expr(pos), expr(-neg)))
 *
 * However, if the first expression is an integer constant (and the second
 * is not), then we swap the two expressions.  This ensures that we construct,
 * e.g., "i <= 5" rather than "5 >= i".
 *
 * Furthermore, is there are no terms with positive coefficients (or no terms
 * with negative coefficients), then the constant term is added to "pos"
 * (or "neg"), ignoring the sign of the constant term.
 */
================================================================================

文件路径: ./isl_ast_build_expr.c
注释行数: 20
注释内容:
/* Construct an isl_ast_expr that evaluates the conditions defining "bset".
 * The result is simplified in terms of build->domain.
 *
 * If "bset" is not bounded by any constraint, then we construct
 * the expression "1", i.e., "true".
 *
 * Otherwise, we sort the constraints, putting constraints that involve
 * integer divisions after those that do not, and construct an "and"
 * of the ast expressions of the individual constraints.
 *
 * Each constraint is added to the generated constraints of the build
 * after it has been converted to an AST expression so that it can be used
 * to simplify the following constraints.  This may change the truth value
 * of subsequent constraints that do not satisfy the earlier constraints,
 * but this does not affect the outcome of the conjunction as it is
 * only true if all the conjuncts are true (no matter in what order
 * they are evaluated).  In particular, the constraints that do not
 * involve integer divisions may serve to simplify some constraints
 * that do involve integer divisions.
 */
================================================================================

文件路径: ./isl_ast_build_expr.c
注释行数: 21
注释内容:
/* Construct an isl_ast_expr that evaluates the conditions defining "set".
 * The result is simplified in terms of build->domain.
 *
 * If "set" is an (obviously) empty set, then return the expression "0".
 *
 * If there are multiple disjuncts in the description of the set,
 * then subsequent disjuncts are simplified in a context where
 * the previous disjuncts have been removed from build->domain.
 * In particular, constraints that ensure that there is no overlap
 * with these previous disjuncts, can be removed.
 * This is mostly useful for disjuncts that are only defined by
 * a single constraint (relative to the build domain) as the opposite
 * of that single constraint can then be removed from the other disjuncts.
 * In order not to increase the number of disjuncts in the build domain
 * after subtracting the previous disjuncts of "set", the simple hull
 * is computed after taking the difference with each of these disjuncts.
 * This means that constraints that prevent overlap with a union
 * of multiple previous disjuncts are not removed.
 *
 * "set" lives in the internal schedule space.
 */
================================================================================

文件路径: ./isl_ast_build_expr.c
注释行数: 12
注释内容:
/* Construct an isl_ast_expr that evaluates the conditions defining "set".
 * The result is simplified in terms of build->domain.
 *
 * If "set" is an (obviously) empty set, then return the expression "0".
 *
 * "set" lives in the external schedule space.
 *
 * The internal AST expression generation assumes that there are
 * no unknown divs, so make sure an explicit representation is available.
 * Since the set comes from the outside, it may have constraints that
 * are redundant with respect to the build domain.  Remove them first.
 */
================================================================================

文件路径: ./isl_ast_build_expr.c
注释行数: 17
注释内容:
/* Internal date structure representing a single piece in the input of
 * isl_ast_build_expr_from_pw_aff_internal.
 *
 * If "state" is isl_state_none, then "set_list" and "aff_list" are not used.
 * If "state" is isl_state_single, then "set_list" and "aff_list" contain the
 * single previous subpiece.
 * If "state" is isl_state_min, then "set_list" and "aff_list" contain
 * a sequence of several previous subpieces that are equal to the minimum
 * of the entries in "aff_list" over the union of "set_list"
 * If "state" is isl_state_max, then "set_list" and "aff_list" contain
 * a sequence of several previous subpieces that are equal to the maximum
 * of the entries in "aff_list" over the union of "set_list"
 *
 * During the construction of the pieces, "set" is NULL.
 * After the construction, "set" is set to the union of the elements
 * in "set_list", at which point "set_list" is set to NULL.
 */
================================================================================

文件路径: ./isl_ast_build_expr.c
注释行数: 12
注释内容:
/* Internal data structure for isl_ast_build_expr_from_pw_aff_internal.
 *
 * "build" specifies the domain against which the result is simplified.
 * "dom" is the domain of the entire isl_pw_aff.
 *
 * "n" is the number of pieces constructed already.
 * In particular, during the construction of the pieces, "n" points to
 * the piece that is being constructed.  After the construction of the
 * pieces, "n" is set to the total number of pieces.
 * "max" is the total number of allocated entries.
 * "p" contains the individual pieces.
 */
================================================================================

文件路径: ./isl_ast_build_expr.c
注释行数: 13
注释内容:
/* Extend the expression in "next" to take into account
 * the piece at position "pos" in "data", allowing for a further extension
 * for the next piece(s).
 * In particular, "next" is set to a select operation that selects
 * an isl_ast_expr corresponding to data->aff_list on data->set and
 * to an expression that will be filled in by later calls.
 * Return a pointer to this location.
 * Afterwards, the state of "data" is set to isl_state_none.
 *
 * The constraints of data->set are added to the generated
 * constraints of the build such that they can be exploited to simplify
 * the AST expression constructed from data->aff_list.
 */
================================================================================

文件路径: ./isl_ast_build_expr.c
注释行数: 10
注释内容:
/* Extend the expression in "next" to take into account
 * the final piece, located at position "pos" in "data".
 * In particular, "next" is set to evaluate data->aff_list
 * and the domain is ignored.
 * Return isl_stat_ok on success and isl_stat_error on failure.
 *
 * The constraints of data->set are however added to the generated
 * constraints of the build such that they can be exploited to simplify
 * the AST expression constructed from data->aff_list.
 */
================================================================================

文件路径: ./isl_ast_build_expr.c
注释行数: 13
注释内容:
/* Construct an isl_ast_expr from the pieces in "data".
 * Return the result or NULL on failure.
 *
 * When this function is called, data->n points to the current piece.
 * If this is an effective piece, then first increment data->n such
 * that data->n contains the number of pieces.
 * The "set_list" fields are subsequently replaced by the corresponding
 * "set" fields, after which the pieces are sorted according to
 * the number of disjuncts in these "set" fields.
 *
 * Construct intermediate AST expressions for the initial pieces and
 * finish off with the final pieces.
 */
================================================================================

文件路径: ./isl_ast_build_expr.c
注释行数: 19
注释内容:
/* Can the list of subpieces in the last piece of "data" be extended with
 * "set" and "aff" based on "test"?
 * In particular, is it the case for each entry (set_i, aff_i) that
 *
 *	test(aff, aff_i) holds on set_i, and
 *	test(aff_i, aff) holds on set?
 *
 * "test" returns the set of elements where the tests holds, meaning
 * that test(aff_i, aff) holds on set if set is a subset of test(aff_i, aff).
 *
 * This function is used to detect min/max expressions.
 * If the ast_build_detect_min_max option is turned off, then
 * do not even try and perform any detection and return false instead.
 *
 * Rational affine expressions are not considered for min/max expressions
 * since the combined expression will be defined on the union of the domains,
 * while a rational expression may only yield integer values
 * on its own definition domain.
 */
================================================================================

文件路径: ./isl_ast_build_expr.c
注释行数: 18
注释内容:
/* This function is called during the construction of an isl_ast_expr
 * that evaluates an isl_pw_aff.
 * If the last piece of "data" contains a single subpiece and
 * if its affine function is equal to "aff" on a part of the domain
 * that includes either "set" or the domain of that single subpiece,
 * then extend the domain of that single subpiece with "set".
 * If it was the original domain of the single subpiece where
 * the two affine functions are equal, then also replace
 * the affine function of the single subpiece by "aff".
 * If the last piece of "data" contains either a single subpiece
 * or a minimum, then check if this minimum expression can be extended
 * with (set, aff).
 * If so, extend the sequence and return.
 * Perform the same operation for maximum expressions.
 * If no such extension can be performed, then move to the next piece
 * in "data" (if the current piece contains any data), and then store
 * the current subpiece in the current piece of "data" for later handling.
 */
================================================================================

文件路径: ./isl_ast_build_expr.c
注释行数: 10
注释内容:
/* Construct an isl_ast_expr of type "type" that calls or accesses
 * the element specified by "mpa".
 * The first argument is obtained from the output tuple name.
 * The remaining arguments are given by the piecewise affine expressions.
 *
 * If the range of "mpa" is a mapped relation, then we assume it
 * represents an access to a member of a structure.
 *
 * The domain of "mpa" is assumed to live in the internal schedule domain.
 */
================================================================================

文件路径: ./isl_tarjan.c
注释行数: 11
注释内容:
/*
 * Copyright 2010-2011 INRIA Saclay
 * Copyright 2012      Ecole Normale Superieure
 *
 * Use of this software is governed by the MIT license
 *
 * Written by Sven Verdoolaege, INRIA Saclay - Ile-de-France,
 * Parc Club Orsay Universite, ZAC des vignes, 4 rue Jacques Monod,
 * 91893 Orsay, France
 * and Ecole Normale Superieure, 45 rue d’Ulm, 75230 Paris, France
 */
================================================================================

文件路径: ./basis_reduction_templ.c
注释行数: 11
注释内容:
/*
 * Copyright 2006-2007 Universiteit Leiden
 * Copyright 2008-2009 Katholieke Universiteit Leuven
 *
 * Use of this software is governed by the MIT license
 *
 * Written by Sven Verdoolaege, Leiden Institute of Advanced Computer Science,
 * Universiteit Leiden, Niels Bohrweg 1, 2333 CA Leiden, The Netherlands
 * and K.U.Leuven, Departement Computerwetenschappen, Celestijnenlaan 200A,
 * B-3001 Leuven, Belgium
 */
================================================================================

文件路径: ./basis_reduction_templ.c
注释行数: 21
注释内容:
/* Compute a reduced basis for the set represented by the tableau "tab".
 * tab->basis, which must be initialized by the calling function to an affine
 * unimodular basis, is updated to reflect the reduced basis.
 * The first tab->n_zero rows of the basis (ignoring the constant row)
 * are assumed to correspond to equalities and are left untouched.
 * tab->n_zero is updated to reflect any additional equalities that
 * have been detected in the first rows of the new basis.
 * The final tab->n_unbounded rows of the basis are assumed to correspond
 * to unbounded directions and are also left untouched.
 * In particular this means that the remaining rows are assumed to
 * correspond to bounded directions.
 *
 * This function implements the algorithm described in
 * "An Implementation of the Generalized Basis Reduction Algorithm
 *  for Integer Programming" of Cook el al. to compute a reduced basis.
 * We use \epsilon = 1/4.
 *
 * If ctx->opt->gbr_only_first is set, the user is only interested
 * in the first direction.  In this case we stop the basis reduction when
 * the width in the first direction becomes smaller than 2.
 */
================================================================================

文件路径: ./isl_sample.c
注释行数: 23
注释内容:
/* Perform a greedy search for an integer point in the set represented
 * by "tab", given that the minimal rational value (rounded up to the
 * nearest integer) at "level" is smaller than the maximal rational
 * value (rounded down to the nearest integer).
 *
 * Return 1 if we have found an integer point (if tab->n_unbounded > 0
 * then we may have only found integer values for the bounded dimensions
 * and it is the responsibility of the caller to extend this solution
 * to the unbounded dimensions).
 * Return 0 if greedy search did not result in a solution.
 * Return -1 if some error occurred.
 *
 * We assign a value half-way between the minimum and the maximum
 * to the current dimension and check if the minimal value of the
 * next dimension is still smaller than (or equal) to the maximal value.
 * We continue this process until either
 * - the minimal value (rounded up) is greater than the maximal value
 *	(rounded down).  In this case, greedy search has failed.
 * - we have exhausted all bounded dimensions, meaning that we have
 *	found a solution.
 * - the sample value of the tableau is integral.
 * - some error has occurred.
 */
================================================================================

文件路径: ./isl_sample.c
注释行数: 55
注释内容:
/* Given a tableau representing a set, find and return
 * an integer point in the set, if there is any.
 *
 * We perform a depth first search
 * for an integer point, by scanning all possible values in the range
 * attained by a basis vector, where an initial basis may have been set
 * by the calling function.  Otherwise an initial basis that exploits
 * the equalities in the tableau is created.
 * tab->n_zero is currently ignored and is clobbered by this function.
 *
 * The tableau is allowed to have unbounded direction, but then
 * the calling function needs to set an initial basis, with the
 * unbounded directions last and with tab->n_unbounded set
 * to the number of unbounded directions.
 * Furthermore, the calling functions needs to add shifted copies
 * of all constraints involving unbounded directions to ensure
 * that any feasible rational value in these directions can be rounded
 * up to yield a feasible integer value.
 * In particular, let B define the given basis x' = B x
 * and let T be the inverse of B, i.e., X = T x'.
 * Let a x + c >= 0 be a constraint of the set represented by the tableau,
 * or a T x' + c >= 0 in terms of the given basis.  Assume that
 * the bounded directions have an integer value, then we can safely
 * round up the values for the unbounded directions if we make sure
 * that x' not only satisfies the original constraint, but also
 * the constraint "a T x' + c + s >= 0" with s the sum of all
 * negative values in the last n_unbounded entries of "a T".
 * The calling function therefore needs to add the constraint
 * a x + c + s >= 0.  The current function then scans the first
 * directions for an integer value and once those have been found,
 * it can compute "T ceil(B x)" to yield an integer point in the set.
 * Note that during the search, the first rows of B may be changed
 * by a basis reduction, but the last n_unbounded rows of B remain
 * unaltered and are also not mixed into the first rows.
 *
 * The search is implemented iteratively.  "level" identifies the current
 * basis vector.  "init" is true if we want the first value at the current
 * level and false if we want the next value.
 *
 * At the start of each level, we first check if we can find a solution
 * using greedy search.  If not, we continue with the exhaustive search.
 *
 * The initial basis is the identity matrix.  If the range in some direction
 * contains more than one integer value, we perform basis reduction based
 * on the value of ctx->opt->gbr
 *	- ISL_GBR_NEVER:	never perform basis reduction
 *	- ISL_GBR_ONCE:		only perform basis reduction the first
 *				time such a range is encountered
 *	- ISL_GBR_ALWAYS:	always perform basis reduction when
 *				such a range is encountered
 *
 * When ctx->opt->gbr is set to ISL_GBR_ALWAYS, then we allow the basis
 * reduction computation to return early.  That is, as soon as it
 * finds a reasonable first direction.
 */
================================================================================

文件路径: ./isl_sample.c
注释行数: 12
注释内容:
/* Given a basic set "bset" and a value "sample" for the first coordinates
 * of bset, plug in these values and drop the corresponding coordinates.
 *
 * We do this by computing the preimage of the transformation
 *
 *	     [ 1 0 ]
 *	x =  [ s 0 ] x'
 *	     [ 0 I ]
 *
 * where [1 s] is the sample value and I is the identity matrix of the
 * appropriate dimension.
 */
================================================================================

文件路径: ./isl_sample.c
注释行数: 33
注释内容:
/* Given a linear cone "cone" and a rational point "vec",
 * construct a polyhedron with shifted copies of the constraints in "cone",
 * i.e., a polyhedron with "cone" as its recession cone, such that each
 * point x in this polyhedron is such that the unit box positioned at x
 * lies entirely inside the affine cone 'vec + cone'.
 * Any rational point in this polyhedron may therefore be rounded up
 * to yield an integer point that lies inside said affine cone.
 *
 * Denote the constraints of cone by "<a_i, x> >= 0" and the rational
 * point "vec" by v/d.
 * Let b_i = <a_i, v>.  Then the affine cone 'vec + cone' is given
 * by <a_i, x> - b/d >= 0.
 * The polyhedron <a_i, x> - ceil{b/d} >= 0 is a subset of this affine cone.
 * We prefer this polyhedron over the actual affine cone because it doesn't
 * require a scaling of the constraints.
 * If each of the vertices of the unit cube positioned at x lies inside
 * this polyhedron, then the whole unit cube at x lies inside the affine cone.
 * We therefore impose that x' = x + \sum e_i, for any selection of unit
 * vectors lies inside the polyhedron, i.e.,
 *
 *	<a_i, x'> - ceil{b/d} = <a_i, x> + sum a_i - ceil{b/d} >= 0
 *
 * The most stringent of these constraints is the one that selects
 * all negative a_i, so the polyhedron we are looking for has constraints
 *
 *	<a_i, x> + sum_{a_i < 0} a_i - ceil{b/d} >= 0
 *
 * Note that if cone were known to have only non-negative rays
 * (which can be accomplished by a unimodular transformation),
 * then we would only have to check the points x' = x + e_i
 * and we only have to add the smallest negative a_i (if any)
 * instead of the sum of all negative a_i.
 */
================================================================================

文件路径: ./isl_sample.c
注释行数: 11
注释内容:
/* Given a rational point vec in a (transformed) basic set,
 * such that cone is the recession cone of the original basic set,
 * "round up" the rational point to an integer point.
 *
 * We first check if the rational point just happens to be integer.
 * If not, we transform the cone in the same way as the basic set,
 * pick a point x in this cone shifted to the rational point such that
 * the whole unit cube at x is also inside this affine cone.
 * Then we simply round up the coordinates of x and return the
 * resulting integer point.
 */
================================================================================

文件路径: ./isl_sample.c
注释行数: 37
注释内容:
/* Give a basic set "bset" with recession cone "cone", compute and
 * return an integer point in bset, if any.
 *
 * If the recession cone is full-dimensional, then we know that
 * bset contains an infinite number of integer points and it is
 * fairly easy to pick one of them.
 * If the recession cone is not full-dimensional, then we first
 * transform bset such that the bounded directions appear as
 * the first dimensions of the transformed basic set.
 * We do this by using a unimodular transformation that transforms
 * the equalities in the recession cone to equalities on the first
 * dimensions.
 *
 * The transformed set is then projected onto its bounded dimensions.
 * Note that to compute this projection, we can simply drop all constraints
 * involving any of the unbounded dimensions since these constraints
 * cannot be combined to produce a constraint on the bounded dimensions.
 * To see this, assume that there is such a combination of constraints
 * that produces a constraint on the bounded dimensions.  This means
 * that some combination of the unbounded dimensions has both an upper
 * bound and a lower bound in terms of the bounded dimensions, but then
 * this combination would be a bounded direction too and would have been
 * transformed into a bounded dimensions.
 *
 * We then compute a sample value in the bounded dimensions.
 * If no such value can be found, then the original set did not contain
 * any integer points and we are done.
 * Otherwise, we plug in the value we found in the bounded dimensions,
 * project out these bounded dimensions and end up with a set with
 * a full-dimensional recession cone.
 * A sample point in this set is computed by "rounding up" any
 * rational point in the set.
 *
 * The sample points in the bounded and unbounded dimensions are
 * then combined into a single sample point and transformed back
 * to the original space.
 */
================================================================================

文件路径: ./isl_sample.c
注释行数: 17
注释内容:
/* Given a tableau "tab", a tableau "tab_cone" that corresponds
 * to the recession cone and the inverse of a new basis U = inv(B),
 * with the unbounded directions in B last,
 * add constraints to "tab" that ensure any rational value
 * in the unbounded directions can be rounded up to an integer value.
 *
 * The new basis is given by x' = B x, i.e., x = U x'.
 * For any rational value of the last tab->n_unbounded coordinates
 * in the update tableau, the value that is obtained by rounding
 * up this value should be contained in the original tableau.
 * For any constraint "a x + c >= 0", we therefore need to add
 * a constraint "a x + c + s >= 0", with s the sum of all negative
 * entries in the last elements of "a U".
 *
 * Since we are not interested in the first entries of any of the "a U",
 * we first drop the columns of U that correpond to bounded directions.
 */
================================================================================

文件路径: ./isl_sample.c
注释行数: 14
注释内容:
/* Compute and return an initial basis for the possibly
 * unbounded tableau "tab".  "tab_cone" is a tableau
 * for the corresponding recession cone.
 * Additionally, add constraints to "tab" that ensure
 * that any rational value for the unbounded directions
 * can be rounded up to an integer value.
 *
 * If the tableau is bounded, i.e., if the recession cone
 * is zero-dimensional, then we just use inital_basis.
 * Otherwise, we construct a basis whose first directions
 * correspond to equalities, followed by bounded directions,
 * i.e., equalities in the recession cone.
 * The remaining directions are then unbounded.
 */
================================================================================

文件路径: ./isl_list_templ.c
注释行数: 14
注释内容:
/*
 * Copyright 2008-2009 Katholieke Universiteit Leuven
 * Copyright 2011      INRIA Saclay
 * Copyright 2012-2013 Ecole Normale Superieure
 * Copyright 2017      Sven Verdoolaege
 *
 * Use of this software is governed by the MIT license
 *
 * Written by Sven Verdoolaege, K.U.Leuven, Departement
 * Computerwetenschappen, Celestijnenlaan 200A, B-3001 Leuven, Belgium
 * and INRIA Saclay - Ile-de-France, Parc Club Orsay Universite,
 * ZAC des vignes, 4 rue Jacques Monod, 91893 Orsay, France
 * and Ecole Normale Superieure, 45 rue d’Ulm, 75230 Paris, France
 */
================================================================================

文件路径: ./isl_list_templ.c
注释行数: 10
注释内容:
/* Return the element at position "index" of "list".
 * This may be either a copy or the element itself
 * if there is only one reference to "list".
 * This allows the element to be modified inplace
 * if both the list and the element have only a single reference.
 * The caller is not allowed to modify "list" between
 * this call to isl_list_*_take_* and a subsequent call
 * to isl_list_*_restore_*.
 * The only exception is that isl_list_*_free can be called instead.
 */
================================================================================

文件路径: ./isl_list_templ.c
注释行数: 12
注释内容:
/* Call "fn" on each of the strongly connected components (SCCs) of
 * the graph with as vertices the elements of "list" and
 * a directed edge from node b to node a iff follows(a, b)
 * returns 1.  follows should return -1 on error.
 *
 * If SCC a contains a node i that follows a node j in another SCC b
 * (i.e., follows(i, j, user) returns 1), then fn will be called on SCC a
 * after being called on SCC b.
 *
 * We simply call isl_tarjan_graph_init, extract the SCCs from the result and
 * call fn on each of them.
 */
================================================================================

文件路径: ./isl_equalities.c
注释行数: 11
注释内容:
/*
 * Copyright 2008-2009 Katholieke Universiteit Leuven
 * Copyright 2010      INRIA Saclay
 *
 * Use of this software is governed by the MIT license
 *
 * Written by Sven Verdoolaege, K.U.Leuven, Departement
 * Computerwetenschappen, Celestijnenlaan 200A, B-3001 Leuven, Belgium
 * and INRIA Saclay - Ile-de-France, Parc Club Orsay Universite,
 * ZAC des vignes, 4 rue Jacques Monod, 91893 Orsay, France
 */
================================================================================

文件路径: ./isl_equalities.c
注释行数: 46
注释内容:
/* Given a set of modulo constraints
 *
 *		c + A y = 0 mod d
 *
 * this function computes a particular solution y_0
 *
 * The input is given as a matrix B = [ c A ] and a vector d.
 *
 * The output is matrix containing the solution y_0 or
 * a zero-column matrix if the constraints admit no integer solution.
 *
 * The given set of constrains is equivalent to
 *
 *		c + A y = -D x
 *
 * with D = diag d and x a fresh set of variables.
 * Reducing both c and A modulo d does not change the
 * value of y in the solution and may lead to smaller coefficients.
 * Let M = [ D A ] and [ H 0 ] = M U, the Hermite normal form of M.
 * Then
 *		  [ x ]
 *		M [ y ] = - c
 * and so
 *		               [ x ]
 *		[ H 0 ] U^{-1} [ y ] = - c
 * Let
 *		[ A ]          [ x ]
 *		[ B ] = U^{-1} [ y ]
 * then
 *		H A + 0 B = -c
 *
 * so B may be chosen arbitrarily, e.g., B = 0, and then
 *
 *		       [ x ] = [ -c ]
 *		U^{-1} [ y ] = [  0 ]
 * or
 *		[ x ]     [ -c ]
 *		[ y ] = U [  0 ]
 * specifically,
 *
 *		y = U_{2,1} (-c)
 *
 * If any of the coordinates of this y are non-integer
 * then the constraints admit no integer solution and
 * a zero-column matrix is returned.
 */
================================================================================

文件路径: ./isl_equalities.c
注释行数: 13
注释内容:
/* Compute a common lattice of solutions to the linear modulo
 * constraints specified by B and d.
 * See also the documentation of isl_mat_parameter_compression.
 * We put the matrix
 * 
 *		A = [ L_1^{-T} L_2^{-T} ... L_k^{-T} ]
 *
 * on a common denominator.  This denominator D is the lcm of modulos d.
 * Since L_i = U_i^{-1} diag(d_i, 1, ... 1), we have
 * L_i^{-T} = U_i^T diag(d_i, 1, ... 1)^{-T} = U_i^T diag(1/d_i, 1, ..., 1).
 * Putting this on the common denominator, we have
 * D * L_i^{-T} = U_i^T diag(D/d_i, D, ..., D).
 */
================================================================================

文件路径: ./isl_equalities.c
注释行数: 94
注释内容:
/* Given a set of modulo constraints
 *
 *		c + A y = 0 mod d
 *
 * this function returns an affine transformation T,
 *
 *		y = T y'
 *
 * that bijectively maps the integer vectors y' to integer
 * vectors y that satisfy the modulo constraints.
 *
 * This function is inspired by Section 2.5.3
 * of B. Meister, "Stating and Manipulating Periodicity in the Polytope
 * Model.  Applications to Program Analysis and Optimization".
 * However, the implementation only follows the algorithm of that
 * section for computing a particular solution and not for computing
 * a general homogeneous solution.  The latter is incomplete and
 * may remove some valid solutions.
 * Instead, we use an adaptation of the algorithm in Section 7 of
 * B. Meister, S. Verdoolaege, "Polynomial Approximations in the Polytope
 * Model: Bringing the Power of Quasi-Polynomials to the Masses".
 *
 * The input is given as a matrix B = [ c A ] and a vector d.
 * Each element of the vector d corresponds to a row in B.
 * The output is a lower triangular matrix.
 * If no integer vector y satisfies the given constraints then
 * a matrix with zero columns is returned.
 *
 * We first compute a particular solution y_0 to the given set of
 * modulo constraints in particular_solution.  If no such solution
 * exists, then we return a zero-columned transformation matrix.
 * Otherwise, we compute the generic solution to
 *
 *		A y = 0 mod d
 *
 * That is we want to compute G such that
 *
 *		y = G y''
 *
 * with y'' integer, describes the set of solutions.
 *
 * We first remove the common factors of each row.
 * In particular if gcd(A_i,d_i) != 1, then we divide the whole
 * row i (including d_i) by this common factor.  If afterwards gcd(A_i) != 1,
 * then we divide this row of A by the common factor, unless gcd(A_i) = 0.
 * In the later case, we simply drop the row (in both A and d).
 *
 * If there are no rows left in A, then G is the identity matrix. Otherwise,
 * for each row i, we now determine the lattice of integer vectors
 * that satisfies this row.  Let U_i be the unimodular extension of the
 * row A_i.  This unimodular extension exists because gcd(A_i) = 1.
 * The first component of
 *
 *		y' = U_i y
 *
 * needs to be a multiple of d_i.  Let y' = diag(d_i, 1, ..., 1) y''.
 * Then,
 *
 *		y = U_i^{-1} diag(d_i, 1, ..., 1) y''
 *
 * for arbitrary integer vectors y''.  That is, y belongs to the lattice
 * generated by the columns of L_i = U_i^{-1} diag(d_i, 1, ..., 1).
 * If there is only one row, then G = L_1.
 *
 * If there is more than one row left, we need to compute the intersection
 * of the lattices.  That is, we need to compute an L such that
 *
 *		L = L_i L_i'	for all i
 *
 * with L_i' some integer matrices.  Let A be constructed as follows
 *
 *		A = [ L_1^{-T} L_2^{-T} ... L_k^{-T} ]
 *
 * and computed the Hermite Normal Form of A = [ H 0 ] U
 * Then,
 *
 *		L_i^{-T} = H U_{1,i}
 *
 * or
 *
 *		H^{-T} = L_i U_{1,i}^T
 *
 * In other words G = L = H^{-T}.
 * To ensure that G is lower triangular, we compute and use its Hermite
 * normal form.
 *
 * The affine transformation matrix returned is then
 *
 *		[  1   0  ]
 *		[ y_0  G  ]
 *
 * as any y = y_0 + G y' with y' integer is a solution to the original
 * modulo constraints.
 */
================================================================================

文件路径: ./isl_equalities.c
注释行数: 26
注释内容:
/* Given a set of equalities
 *
 *		B(y) + A x = 0						(*)
 *
 * compute and return an affine transformation T,
 *
 *		y = T y'
 *
 * that bijectively maps the integer vectors y' to integer
 * vectors y that satisfy the modulo constraints for some value of x.
 *
 * Let [H 0] be the Hermite Normal Form of A, i.e.,
 *
 *		A = [H 0] Q
 *
 * Then y is a solution of (*) iff
 *
 *		H^-1 B(y) (= - [I 0] Q x)
 *
 * is an integer vector.  Let d be the common denominator of H^-1.
 * We impose
 *
 *		d H^-1 B(y) = 0 mod d
 *
 * and compute the solution using isl_mat_parameter_compression.
 */
================================================================================

文件路径: ./isl_equalities.c
注释行数: 47
注释内容:
/* Given a set of equalities
 *
 *		-C(y) + M x = 0
 *
 * this function computes a unimodular transformation from a lower-dimensional
 * space to the original space that bijectively maps the integer points x'
 * in the lower-dimensional space to the integer points x in the original
 * space that satisfy the equalities.
 *
 * The input is given as a matrix B = [ -C M ] and the output is a
 * matrix that maps [1 x'] to [1 x].
 * The number of equality constraints in B is assumed to be smaller than
 * or equal to the number of variables x.
 * "first" is the position of the first x variable.
 * The preceding variables are considered to be y-variables.
 * If T2 is not NULL, then *T2 is set to a matrix mapping [1 x] to [1 x'].
 *
 * First compute the (left) Hermite normal form of M,
 *
 *		M [U1 U2] = M U = H = [H1 0]
 * or
 *		              M = H Q = [H1 0] [Q1]
 *                                             [Q2]
 *
 * with U, Q unimodular, Q = U^{-1} (and H lower triangular).
 * Define the transformed variables as
 *
 *		x = [U1 U2] [ x1' ] = [U1 U2] [Q1] x
 *		            [ x2' ]           [Q2]
 *
 * The equalities then become
 *
 *		-C(y) + H1 x1' = 0   or   x1' = H1^{-1} C(y) = C'(y)
 *
 * If the denominator of the constant term does not divide the
 * the common denominator of the coefficients of y, then every
 * integer point is mapped to a non-integer point and then the original set
 * has no integer solutions (since the x' are a unimodular transformation
 * of the x).  In this case, a zero-column matrix is returned.
 * Otherwise, the transformation is given by
 *
 *		x = U1 H1^{-1} C(y) + U2 x2'
 *
 * The inverse transformation is simply
 *
 *		x2' = Q2 x
 */
================================================================================

文件路径: ./isl_equalities.c
注释行数: 15
注释内容:
/* Given a set of equalities
 *
 *		M x - c = 0
 *
 * this function computes a unimodular transformation from a lower-dimensional
 * space to the original space that bijectively maps the integer points x'
 * in the lower-dimensional space to the integer points x in the original
 * space that satisfy the equalities.
 *
 * The input is given as a matrix B = [ -c M ] and the output is a
 * matrix that maps [1 x'] to [1 x].
 * The number of equality constraints in B is assumed to be smaller than
 * or equal to the number of variables x.
 * If T2 is not NULL, then *T2 is set to a matrix mapping [1 x] to [1 x'].
 */
================================================================================

文件路径: ./isl_transitive_closure.c
注释行数: 17
注释内容:
/* Check whether the overapproximation of the power of "map" is exactly
 * the power of "map".  Let R be "map" and A_k the overapproximation.
 * The approximation is exact if
 *
 *	A_1 = R
 *	A_k = A_{k-1} \circ R			k >= 2
 *
 * Since A_k is known to be an overapproximation, we only need to check
 *
 *	A_1 \subset R
 *	A_k \subset A_{k-1} \circ R		k >= 2
 *
 * In practice, "app" has an extra input and output coordinate
 * to encode the length of the path.  So, we first need to add
 * this coordinate to "map" and set the length of the path to
 * one.
 */
================================================================================

文件路径: ./isl_transitive_closure.c
注释行数: 21
注释内容:
/* Check whether the overapproximation of the power of "map" is exactly
 * the power of "map", possibly after projecting out the power (if "project"
 * is set).
 *
 * If "project" is set and if "steps" can only result in acyclic paths,
 * then we check
 *
 *	A = R \cup (A \circ R)
 *
 * where A is the overapproximation with the power projected out, i.e.,
 * an overapproximation of the transitive closure.
 * More specifically, since A is known to be an overapproximation, we check
 *
 *	A \subset R \cup (A \circ R)
 *
 * Otherwise, we check if the power is exact.
 *
 * Note that "app" has an extra input and output coordinate to encode
 * the length of the part.  If we are only interested in the transitive
 * closure, then we can simply project out these coordinates first.
 */
================================================================================

文件路径: ./isl_transitive_closure.c
注释行数: 12
注释内容:
/* Given a set of n offsets v_i (the rows of "steps"), construct a relation
 * of the given dimension specification (Z^{n+1} -> Z^{n+1})
 * that maps an element x to any element that can be reached
 * by taking a non-negative number of steps along any of
 * the extended offsets v'_i = [v_i 1].
 * That is, construct
 *
 * { [x] -> [y] : exists k_i >= 0, y = x + \sum_i k_i v'_i }
 *
 * For any element in this relation, the number of steps taken
 * is equal to the difference in the final coordinates.
 */
================================================================================

文件路径: ./isl_transitive_closure.c
注释行数: 55
注释内容:
/* Given a set of offsets "delta", construct a relation of the
 * given dimension specification (Z^{n+1} -> Z^{n+1}) that
 * is an overapproximation of the relations that
 * maps an element x to any element that can be reached
 * by taking a non-negative number of steps along any of
 * the elements in "delta".
 * That is, construct an approximation of
 *
 *	{ [x] -> [y] : exists f \in \delta, k \in Z :
 *					y = x + k [f, 1] and k >= 0 }
 *
 * For any element in this relation, the number of steps taken
 * is equal to the difference in the final coordinates.
 *
 * In particular, let delta be defined as
 *
 *	\delta = [p] -> { [x] : A x + a >= 0 and B p + b >= 0 and
 *				C x + C'p + c >= 0 and
 *				D x + D'p + d >= 0 }
 *
 * where the constraints C x + C'p + c >= 0 are such that the parametric
 * constant term of each constraint j, "C_j x + C'_j p + c_j",
 * can never attain positive values, then the relation is constructed as
 *
 *	{ [x] -> [y] : exists [f, k] \in Z^{n+1} : y = x + f and
 *			A f + k a >= 0 and B p + b >= 0 and
 *			C f + C'p + c >= 0 and k >= 1 }
 *	union { [x] -> [x] }
 *
 * If the zero-length paths happen to correspond exactly to the identity
 * mapping, then we return
 *
 *	{ [x] -> [y] : exists [f, k] \in Z^{n+1} : y = x + f and
 *			A f + k a >= 0 and B p + b >= 0 and
 *			C f + C'p + c >= 0 and k >= 0 }
 *
 * instead.
 *
 * Existentially quantified variables in \delta are handled by
 * classifying them as independent of the parameters, purely
 * parameter dependent and others.  Constraints containing
 * any of the other existentially quantified variables are removed.
 * This is safe, but leads to an additional overapproximation.
 *
 * If there are any impure constraints, then we also eliminate
 * the parameters from \delta, resulting in a set
 *
 *	\delta' = { [x] : E x + e >= 0 }
 *
 * and add the constraints
 *
 *			E f + k e >= 0
 *
 * to the constructed relation.
 */
================================================================================

文件路径: ./isl_transitive_closure.c
注释行数: 25
注释内容:
/* Given a union of basic maps R = \cup_i R_i \subseteq D \times D
 * and a dimension specification (Z^{n+1} -> Z^{n+1}),
 * construct a map that is an overapproximation of the map
 * that takes an element from the space D \times Z to another
 * element from the same space, such that the first n coordinates of the
 * difference between them is a sum of differences between images
 * and pre-images in one of the R_i and such that the last coordinate
 * is equal to the number of steps taken.
 * That is, let
 *
 *	\Delta_i = { y - x | (x, y) in R_i }
 *
 * then the constructed map is an overapproximation of
 *
 *	{ (x) -> (x + d) | \exists k_i >= 0, \delta_i \in \Delta_i :
 *				d = (\sum_i k_i \delta_i, \sum_i k_i) }
 *
 * The elements of the singleton \Delta_i's are collected as the
 * rows of the steps matrix.  For all these \Delta_i's together,
 * a single path is constructed.
 * For each of the other \Delta_i's, we compute an overapproximation
 * of the paths along elements of \Delta_i.
 * Since each of these paths performs an addition, composition is
 * symmetric and we can simply compose all resulting paths in any order.
 */
================================================================================

文件路径: ./isl_transitive_closure.c
注释行数: 19
注释内容:
/* Given a union of basic maps R = \cup_i R_i \subseteq D \times D
 * and a dimension specification (Z^{n+1} -> Z^{n+1}),
 * construct a map that is an overapproximation of the map
 * that takes an element from the dom R \times Z to an
 * element from ran R \times Z, such that the first n coordinates of the
 * difference between them is a sum of differences between images
 * and pre-images in one of the R_i and such that the last coordinate
 * is equal to the number of steps taken.
 * That is, let
 *
 *	\Delta_i = { y - x | (x, y) in R_i }
 *
 * then the constructed map is an overapproximation of
 *
 *	{ (x) -> (x + d) | \exists k_i >= 0, \delta_i \in \Delta_i :
 *				d = (\sum_i k_i \delta_i, \sum_i k_i) and
 *				x in dom R and x + d in ran R and
 *				\sum_i k_i >= 1 }
 */
================================================================================

文件路径: ./isl_transitive_closure.c
注释行数: 29
注释内容:
/* For each basic map in "map", except i, check whether it combines
 * with the transitive closure that is reflexive on C combines
 * to the left and to the right.
 *
 * In particular, if
 *
 *	dom map_j \subseteq C
 *
 * then right[j] is set to 1.  Otherwise, if
 *
 *	ran map_i \cap dom map_j = \emptyset
 *
 * then right[j] is set to 0.  Otherwise, composing to the right
 * is impossible.
 *
 * Similar, for composing to the left, we have if
 *
 *	ran map_j \subseteq C
 *
 * then left[j] is set to 1.  Otherwise, if
 *
 *	dom map_i \cap ran map_j = \emptyset
 *
 * then left[j] is set to 0.  Otherwise, composing to the left
 * is impossible.
 *
 * The return value is or'd with LEFT if composing to the left
 * is possible and with RIGHT if composing to the right is possible.
 */
================================================================================

文件路径: ./isl_transitive_closure.c
注释行数: 15
注释内容:
/* Compute the transitive closure of "map" incrementally by
 * computing
 *
 *	map_i^+ \cup qc^+
 *
 * or
 *
 *	map_i^+ \cup ((id \cup map_i^) \circ qc^+)
 *
 * or
 *
 *	map_i^+ \cup (qc^+ \circ (id \cup map_i^))
 *
 * depending on whether left or right are NULL.
 */
================================================================================

文件路径: ./isl_transitive_closure.c
注释行数: 15
注释内容:
/* Given a map "map", try to find a basic map such that
 * map^+ can be computed as
 *
 * map^+ = map_i^+ \cup
 *    \bigcup_j ((map_i^+ \cup Id_C)^+ \circ map_j \circ (map_i^+ \cup Id_C))^+
 *
 * with C the simple hull of the domain and range of the input map.
 * map_i^ \cup Id_C is computed by allowing the path lengths to be zero
 * and by intersecting domain and range with C.
 * Of course, we need to check that this is actually equal to map_i^ \cup Id_C.
 * Also, we only use the incremental computation if all the transitive
 * closures are exact and if the number of basic maps in the union,
 * after computing the integer divisions, is smaller than the number
 * of basic maps in the input map.
 */
================================================================================

文件路径: ./isl_transitive_closure.c
注释行数: 11
注释内容:
/* The core of the Floyd-Warshall algorithm.
 * Updates the given n x x matrix of relations in place.
 *
 * The algorithm iterates over all vertices.  In each step, the whole
 * matrix is updated to include all paths that go to the current vertex,
 * possibly stay there a while (including passing through earlier vertices)
 * and then come back.  At the start of each iteration, the diagonal
 * element corresponding to the current vertex is replaced by its
 * transitive closure to account for all indirect paths that stay
 * in the current vertex.
 */
================================================================================

文件路径: ./isl_transitive_closure.c
注释行数: 19
注释内容:
/* Given a partition of the domains and ranges of the basic maps in "map",
 * apply the Floyd-Warshall algorithm with the elements in the partition
 * as vertices.
 *
 * In particular, there are "n" elements in the partition and "group" is
 * an array of length 2 * map->n with entries in [0,n-1].
 *
 * We first construct a matrix of relations based on the partition information,
 * apply Floyd-Warshall on this matrix of relations and then take the
 * union of all entries in the matrix as the final result.
 *
 * If we are actually computing the power instead of the transitive closure,
 * i.e., when "project" is not set, then the result should have the
 * path lengths encoded as the difference between an extra pair of
 * coordinates.  We therefore apply the nested transitive closures
 * to relations that include these lengths.  In particular, we replace
 * the input relation by the cross product with the unit length relation
 * { [i] -> [i + 1] }.
 */
================================================================================

文件路径: ./isl_transitive_closure.c
注释行数: 14
注释内容:
/* Partition the domains and ranges of the n basic relations in list
 * into disjoint cells.
 *
 * To find the partition, we simply consider all of the domains
 * and ranges in turn and combine those that overlap.
 * "set" contains the partition elements and "group" indicates
 * to which partition element a given domain or range belongs.
 * The domain of basic map i corresponds to element 2 * i in these arrays,
 * while the domain corresponds to element 2 * i + 1.
 * During the construction group[k] is either equal to k,
 * in which case set[k] contains the union of all the domains and
 * ranges in the corresponding group, or is equal to some l < k,
 * with l another domain or range in the same group.
 */
================================================================================

文件路径: ./isl_transitive_closure.c
注释行数: 18
注释内容:
/* Check whether in the computation of the transitive closure
 * "list[i]" (R_1) should follow (or be part of the same component as)
 * "list[j]" (R_2).
 *
 * That is check whether
 *
 *	R_1 \circ R_2
 *
 * is a subset of
 *
 *	R_2 \circ R_1
 *
 * If so, then there is no reason for R_1 to immediately follow R_2
 * in any path.
 *
 * *check_closed is set if the subset relation holds while
 * R_1 \circ R_2 is not empty.
 */
================================================================================

文件路径: ./isl_transitive_closure.c
注释行数: 33
注释内容:
/* Given a union of basic maps R = \cup_i R_i \subseteq D \times D
 * and a dimension specification (Z^{n+1} -> Z^{n+1}),
 * construct a map that is an overapproximation of the map
 * that takes an element from the dom R \times Z to an
 * element from ran R \times Z, such that the first n coordinates of the
 * difference between them is a sum of differences between images
 * and pre-images in one of the R_i and such that the last coordinate
 * is equal to the number of steps taken.
 * If "project" is set, then these final coordinates are not included,
 * i.e., a relation of type Z^n -> Z^n is returned.
 * That is, let
 *
 *	\Delta_i = { y - x | (x, y) in R_i }
 *
 * then the constructed map is an overapproximation of
 *
 *	{ (x) -> (x + d) | \exists k_i >= 0, \delta_i \in \Delta_i :
 *				d = (\sum_i k_i \delta_i, \sum_i k_i) and
 *				x in dom R and x + d in ran R }
 *
 * or
 *
 *	{ (x) -> (x + d) | \exists k_i >= 0, \delta_i \in \Delta_i :
 *				d = (\sum_i k_i \delta_i) and
 *				x in dom R and x + d in ran R }
 *
 * if "project" is set.
 *
 * We first split the map into strongly connected components, perform
 * the above on each component and then join the results in the correct
 * order, at each join also taking in the union of both arguments
 * to allow for paths that do not go through one of the two arguments.
 */
================================================================================

文件路径: ./isl_transitive_closure.c
注释行数: 29
注释内容:
/* Given a union of basic maps R = \cup_i R_i \subseteq D \times D,
 * construct a map that is an overapproximation of the map
 * that takes an element from the space D to another
 * element from the same space, such that the difference between
 * them is a strictly positive sum of differences between images
 * and pre-images in one of the R_i.
 * The number of differences in the sum is equated to parameter "param".
 * That is, let
 *
 *	\Delta_i = { y - x | (x, y) in R_i }
 *
 * then the constructed map is an overapproximation of
 *
 *	{ (x) -> (x + d) | \exists k_i >= 0, \delta_i \in \Delta_i :
 *				d = \sum_i k_i \delta_i and k = \sum_i k_i > 0 }
 * or
 *
 *	{ (x) -> (x + d) | \exists k_i >= 0, \delta_i \in \Delta_i :
 *				d = \sum_i k_i \delta_i and \sum_i k_i > 0 }
 *
 * if "project" is set.
 *
 * If "project" is not set, then
 * we construct an extended mapping with an extra coordinate
 * that indicates the number of steps taken.  In particular,
 * the difference in the last coordinate is equal to the number
 * of steps taken to move from a domain element to the corresponding
 * image element(s).
 */
================================================================================

文件路径: ./isl_transitive_closure.c
注释行数: 29
注释内容:
/* Given a map, compute the smallest superset of this map that is of the form
 *
 *	{ i -> j : L <= j - i <= U and exists a_p: j_p - i_p = M_p a_p }
 *
 * (where p ranges over the (non-parametric) dimensions),
 * compute the transitive closure of this map, i.e.,
 *
 *	{ i -> j : exists k > 0:
 *		k L <= j - i <= k U and exists a: j_p - i_p = M_p a_p }
 *
 * and intersect domain and range of this transitive closure with
 * the given domain and range.
 *
 * If with_id is set, then try to include as much of the identity mapping
 * as possible, by computing
 *
 *	{ i -> j : exists k >= 0:
 *		k L <= j - i <= k U and exists a: j_p - i_p = M_p a_p }
 *
 * instead (i.e., allow k = 0).
 *
 * In practice, we compute the difference set
 *
 *	delta  = { j - i | i -> j in map },
 *
 * look for stride constraint on the individual dimensions and compute
 * (constant) lower and upper bounds for each individual dimension,
 * adding a constraint for each bound not equal to infinity.
 */
================================================================================

文件路径: ./isl_transitive_closure.c
注释行数: 13
注释内容:
/* Given a map, compute the smallest superset of this map that is of the form
 *
 *	{ i -> j : L <= j - i <= U and exists a_p: j_p - i_p = M_p a_p }
 *
 * (where p ranges over the (non-parametric) dimensions),
 * compute the transitive closure of this map, i.e.,
 *
 *	{ i -> j : exists k > 0:
 *		k L <= j - i <= k U and exists a: j_p - i_p = M_p a_p }
 *
 * and intersect domain and range of this transitive closure with
 * domain and range of the original map.
 */
================================================================================

文件路径: ./isl_transitive_closure.c
注释行数: 13
注释内容:
/* Given a map, compute the smallest superset of this map that is of the form
 *
 *	{ i -> j : L <= j - i <= U and exists a_p: j_p - i_p = M_p a_p }
 *
 * (where p ranges over the (non-parametric) dimensions),
 * compute the transitive and partially reflexive closure of this map, i.e.,
 *
 *	{ i -> j : exists k >= 0:
 *		k L <= j - i <= k U and exists a: j_p - i_p = M_p a_p }
 *
 * and intersect domain and range of this transitive closure with
 * the given domain.
 */
================================================================================

文件路径: ./isl_transitive_closure.c
注释行数: 28
注释内容:
/* Check if basic map M_i can be combined with all the other
 * basic maps such that
 *
 *	(\cup_j M_j)^+
 *
 * can be computed as
 *
 *	M_i \cup (\cup_{j \ne i} M_i^* \circ M_j \circ M_i^*)^+
 *
 * In particular, check if we can compute a compact representation
 * of
 *
 *		M_i^* \circ M_j \circ M_i^*
 *
 * for each j != i.
 * Let M_i^? be an extension of M_i^+ that allows paths
 * of length zero, i.e., the result of box_closure(., 1).
 * The criterion, as proposed by Kelly et al., is that
 * id = M_i^? - M_i^+ can be represented as a basic map
 * and that
 *
 *	id \circ M_j \circ id = M_j
 *
 * for each j != i.
 *
 * If this function returns 1, then tc and qc are set to
 * M_i^+ and M_i^?, respectively.
 */
================================================================================

文件路径: ./isl_transitive_closure.c
注释行数: 18
注释内容:
/* Compute an overapproximation of the transitive closure of "map"
 * using a variation of the algorithm from
 * "Transitive Closure of Infinite Graphs and its Applications"
 * by Kelly et al.
 *
 * We first check whether we can can split of any basic map M_i and
 * compute
 *
 *	(\cup_j M_j)^+
 *
 * as
 *
 *	M_i \cup (\cup_{j \ne i} M_i^* \circ M_j \circ M_i^*)^+
 *
 * using a recursive call on the remaining map.
 *
 * If not, we simply call box_closure on the whole map.
 */
================================================================================

文件路径: ./isl_tab.c
注释行数: 14
注释内容:
/*
 * Copyright 2008-2009 Katholieke Universiteit Leuven
 * Copyright 2013      Ecole Normale Superieure
 * Copyright 2014      INRIA Rocquencourt
 * Copyright 2016      Sven Verdoolaege
 *
 * Use of this software is governed by the MIT license
 *
 * Written by Sven Verdoolaege, K.U.Leuven, Departement
 * Computerwetenschappen, Celestijnenlaan 200A, B-3001 Leuven, Belgium
 * and Ecole Normale Superieure, 45 rue d'Ulm, 75230 Paris, France
 * and Inria Paris - Rocquencourt, Domaine de Voluceau - Rocquencourt,
 * B.P. 105 - 78153 Le Chesnay, France
 */
================================================================================

文件路径: ./isl_tab.c
注释行数: 13
注释内容:
/* Construct the coefficient matrix of the product tableau
 * of two tableaus.
 * mat{1,2} is the coefficient matrix of tableau {1,2}
 * row{1,2} is the number of rows in tableau {1,2}
 * col{1,2} is the number of columns in tableau {1,2}
 * off is the offset to the coefficient column (skipping the
 *	denominator, the constant term and the big parameter if any)
 * r{1,2} is the number of redundant rows in tableau {1,2}
 * d{1,2} is the number of dead columns in tableau {1,2}
 *
 * The order of the rows and columns in the result is as explained
 * in isl_tab_product.
 */
================================================================================

文件路径: ./isl_tab.c
注释行数: 18
注释内容:
/* Create a tableau that represents the Cartesian product of the sets
 * represented by tableaus tab1 and tab2.
 * The order of the rows in the product is
 *	- redundant rows of tab1
 *	- redundant rows of tab2
 *	- non-redundant rows of tab1
 *	- non-redundant rows of tab2
 * The order of the columns is
 *	- denominator
 *	- constant term
 *	- coefficient of big parameter, if any
 *	- dead columns of tab1
 *	- dead columns of tab2
 *	- live columns of tab1
 *	- live columns of tab2
 * The order of the variables and the constraints is a concatenation
 * of order in the two input tableaus.
 */
================================================================================

文件路径: ./isl_tab.c
注释行数: 20
注释内容:
/* Given the index of a column "c", return the index of a row
 * that can be used to pivot the column in, with either an increase
 * (sgn > 0) or a decrease (sgn < 0) of the corresponding variable.
 * If "var" is not NULL, then the row returned will be different from
 * the one associated with "var".
 *
 * Each row in the tableau is of the form
 *
 *	x_r = a_r0 + \sum_i a_ri x_i
 *
 * Only rows with x_r >= 0 and with the sign of a_ri opposite to "sgn"
 * impose any limit on the increase or decrease in the value of x_c
 * and this bound is equal to a_r0 / |a_rc|.  We are therefore looking
 * for the row with the smallest (most stringent) such bound.
 * Note that the common denominator of each row drops out of the fraction.
 * To check if row j has a smaller bound than row r, i.e.,
 * a_j0 / |a_jc| < a_r0 / |a_rc| or a_j0 |a_rc| < a_r0 |a_jc|,
 * we check if -sign(a_jc) (a_j0 a_rc - a_r0 a_jc) < 0,
 * where -sign(a_jc) is equal to "sgn".
 */
================================================================================

文件路径: ./isl_tab.c
注释行数: 16
注释内容:
/* Find a pivot (row and col) that will increase (sgn > 0) or decrease
 * (sgn < 0) the value of row variable var.
 * If not NULL, then skip_var is a row variable that should be ignored
 * while looking for a pivot row.  It is usually equal to var.
 *
 * As the given row in the tableau is of the form
 *
 *	x_r = a_r0 + \sum_i a_ri x_i
 *
 * we need to find a column such that the sign of a_ri is equal to "sgn"
 * (such that an increase in x_i will have the desired effect) or a
 * column with a variable that may attain negative values.
 * If a_ri is positive, then we need to move x_i in the same direction
 * to obtain the desired effect.  Otherwise, x_i has to move in the
 * opposite direction.
 */
================================================================================

文件路径: ./isl_tab.c
注释行数: 12
注释内容:
/* Mark row with index "row" as being redundant.
 * If we may need to undo the operation or if the row represents
 * a variable of the original problem, the row is kept,
 * but no longer considered when looking for a pivot row.
 * Otherwise, the row is simply removed.
 *
 * The row may be interchanged with some other row.  If it
 * is interchanged with a later row, return 1.  Otherwise return 0.
 * If the rows are checked in order in the calling function,
 * then a return value of 1 means that the row with the given
 * row number may now contain a different row that hasn't been checked yet.
 */
================================================================================

文件路径: ./isl_tab.c
注释行数: 17
注释内容:
/* Update the rows signs after a pivot of "row" and "col", with "row_sgn"
 * the original sign of the pivot element.
 * We only keep track of row signs during PILP solving and in this case
 * we only pivot a row with negative sign (meaning the value is always
 * non-positive) using a positive pivot element.
 *
 * For each row j, the new value of the parametric constant is equal to
 *
 *	a_j0 - a_jc a_r0/a_rc
 *
 * where a_j0 is the original parametric constant, a_rc is the pivot element,
 * a_r0 is the parametric constant of the pivot row and a_jc is the
 * pivot column entry of the row j.
 * Since a_r0 is non-positive and a_rc is positive, the sign of row j
 * remains the same if a_jc has the same sign as the row j or if
 * a_jc is zero.  In all other cases, we reset the sign to "unknown".
 */
================================================================================

文件路径: ./isl_tab.c
注释行数: 50
注释内容:
/* Given a row number "row" and a column number "col", pivot the tableau
 * such that the associated variables are interchanged.
 * The given row in the tableau expresses
 *
 *	x_r = a_r0 + \sum_i a_ri x_i
 *
 * or
 *
 *	x_c = 1/a_rc x_r - a_r0/a_rc + sum_{i \ne r} -a_ri/a_rc
 *
 * Substituting this equality into the other rows
 *
 *	x_j = a_j0 + \sum_i a_ji x_i
 *
 * with a_jc \ne 0, we obtain
 *
 *	x_j = a_jc/a_rc x_r + a_j0 - a_jc a_r0/a_rc + sum a_ji - a_jc a_ri/a_rc 
 *
 * The tableau
 *
 *	n_rc/d_r		n_ri/d_r
 *	n_jc/d_j		n_ji/d_j
 *
 * where i is any other column and j is any other row,
 * is therefore transformed into
 *
 * s(n_rc)d_r/|n_rc|		-s(n_rc)n_ri/|n_rc|
 * s(n_rc)d_r n_jc/(|n_rc| d_j)	(n_ji |n_rc| - s(n_rc)n_jc n_ri)/(|n_rc| d_j)
 *
 * The transformation is performed along the following steps
 *
 *	d_r/n_rc		n_ri/n_rc
 *	n_jc/d_j		n_ji/d_j
 *
 *	s(n_rc)d_r/|n_rc|	-s(n_rc)n_ri/|n_rc|
 *	n_jc/d_j		n_ji/d_j
 *
 *	s(n_rc)d_r/|n_rc|	-s(n_rc)n_ri/|n_rc|
 *	n_jc/(|n_rc| d_j)	n_ji/(|n_rc| d_j)
 *
 *	s(n_rc)d_r/|n_rc|	-s(n_rc)n_ri/|n_rc|
 *	n_jc/(|n_rc| d_j)	(n_ji |n_rc|)/(|n_rc| d_j)
 *
 *	s(n_rc)d_r/|n_rc|	-s(n_rc)n_ri/|n_rc|
 *	n_jc/(|n_rc| d_j)	(n_ji |n_rc| - s(n_rc)n_jc n_ri)/(|n_rc| d_j)
 *
 * s(n_rc)d_r/|n_rc|		-s(n_rc)n_ri/|n_rc|
 * s(n_rc)d_r n_jc/(|n_rc| d_j)	(n_ji |n_rc| - s(n_rc)n_jc n_ri)/(|n_rc| d_j)
 *
 */
================================================================================

文件路径: ./isl_tab.c
注释行数: 11
注释内容:
/* Return the sign of the maximal value of "var".
 * If the sign is not negative, then on return from this function,
 * the sample value will also be non-negative.
 *
 * If "var" is manifestly unbounded wrt positive values, we are done.
 * Otherwise, we pivot the variable up to a row if needed
 * Then we continue pivoting down until either
 *	- no more down pivots can be performed
 *	- the sample value is positive
 *	- the variable is pivoted into a manifestly unbounded column
 */
================================================================================

文件路径: ./isl_tab.c
注释行数: 17
注释内容:
/* Return a negative value if "var" can attain negative values.
 * Return a non-negative value otherwise.
 *
 * If "var" is manifestly unbounded wrt negative values, we are done.
 * Otherwise, if var is in a column, we can pivot it down to a row.
 * Then we continue pivoting down until either
 *	- the pivot would result in a manifestly unbounded column
 *	  => we don't perform the pivot, but simply return -1
 *	- no more down pivots can be performed
 *	- the sample value is negative
 * If the sample value becomes negative and the variable is supposed
 * to be nonnegative, then we undo the last pivot.
 * However, if the last pivot has made the pivoting variable
 * obviously redundant, then it may have moved to another row.
 * In that case we look for upward pivots until we reach a non-negative
 * value again.
 */
================================================================================

文件路径: ./isl_tab.c
注释行数: 12
注释内容:
/* Mark column with index "col" as representing a zero variable.
 * If we may need to undo the operation the column is kept,
 * but no longer considered.
 * Otherwise, the column is simply removed.
 *
 * The column may be interchanged with some other column.  If it
 * is interchanged with a later column, return 1.  Otherwise return 0.
 * If the columns are checked in order in the calling function,
 * then a return value of 1 means that the column with the given
 * column number may now contain a different column that
 * hasn't been checked yet.
 */
================================================================================

文件路径: ./isl_tab.c
注释行数: 17
注释内容:
/* Row variable "var" is non-negative and cannot attain any values
 * larger than zero.  This means that the coefficients of the unrestricted
 * column variables are zero and that the coefficients of the non-negative
 * column variables are zero or negative.
 * Each of the non-negative variables with a negative coefficient can
 * then also be written as the negative sum of non-negative variables
 * and must therefore also be zero.
 *
 * If "temp_var" is set, then "var" is a temporary variable that
 * will be removed after this function returns and for which
 * no information is recorded on the undo stack.
 * Do not add any undo records involving this variable in this case
 * since the variable will have been removed before any future undo
 * operations.  Also avoid marking the variable as redundant,
 * since that either adds an undo record or needlessly removes the row
 * (the caller will take care of removing the row).
 */
================================================================================

文件路径: ./isl_tab.c
注释行数: 22
注释内容:
/* Add a row to the tableau.  The row is given as an affine combination
 * of the original variables and needs to be expressed in terms of the
 * column variables.
 *
 * This function assumes that at least one more row and at least
 * one more element in the constraint array are available in the tableau.
 *
 * We add each term in turn.
 * If r = n/d_r is the current sum and we need to add k x, then
 * 	if x is a column variable, we increase the numerator of
 *		this column by k d_r
 *	if x = f/d_x is a row variable, then the new representation of r is
 *
 *		 n    k f   d_x/g n + d_r/g k f   m/d_r n + m/d_g k f
 *		--- + --- = ------------------- = -------------------
 *		d_r   d_r        d_r d_x/g                m
 *
 *	with g the gcd of d_r and d_x and m the lcm of d_r and d_x.
 *
 * If tab->M is set, then, internally, each variable x is represented
 * as x' - M.  We then also need no subtract k d_r from the coefficient of M.
 */
================================================================================

文件路径: ./isl_tab.c
注释行数: 10
注释内容:
/* Construct and return an inequality that expresses an upper bound
 * on the given div.
 * In particular, if the div is given by
 *
 *	d = floor(e/m)
 *
 * then the inequality expresses
 *
 *	m d <= e
 */
================================================================================

文件路径: ./isl_tab.c
注释行数: 15
注释内容:
/* For a div d = floor(f/m), add the constraints
 *
 *		f - m d >= 0
 *		-(f-(m-1)) + m d >= 0
 *
 * Note that the second constraint is the negation of
 *
 *		f - m d >= m
 *
 * If add_ineq is not NULL, then this function is used
 * instead of isl_tab_add_ineq to effectively add the inequalities.
 *
 * This function assumes that at least two more rows and at least
 * two more elements in the constraint array are available in the tableau.
 */
================================================================================

文件路径: ./isl_tab.c
注释行数: 11
注释内容:
/* Insert an extra div, prescribed by "div", to the tableau and
 * the associated bmap (which is assumed to be non-NULL).
 * The extra integer division is inserted at (tableau) position "pos".
 * Return "pos" or -1 if an error occurred.
 *
 * If add_ineq is not NULL, then this function is used instead
 * of isl_tab_add_ineq to add the div constraints.
 * This complication is needed because the code in isl_tab_pip
 * wants to perform some extra processing when an inequality
 * is added to the tableau.
 */
================================================================================

文件路径: ./isl_tab.c
注释行数: 10
注释内容:
/* Given a non-negative variable "var", temporarily add a new non-negative
 * variable that is the opposite of "var", ensuring that "var" can only attain
 * the value zero.  The new variable is removed again before this function
 * returns.  However, the effect of forcing "var" to be zero remains.
 * If var = n/d is a row variable, then the new variable = -n/d.
 * If var is a column variables, then the new variable = -var.
 * If the new variable cannot attain non-negative values, then
 * the resulting tableau is empty.
 * Otherwise, we know the value will be zero and we close the row.
 */
================================================================================

文件路径: ./isl_tab.c
注释行数: 17
注释内容:
/* Given a tableau "tab" and an inequality constraint "con" of the tableau,
 * relax the inequality by one.  That is, the inequality r >= 0 is replaced
 * by r' = r + 1 >= 0.
 * If r is a row variable, we simply increase the constant term by one
 * (taking into account the denominator).
 * If r is a column variable, then we need to modify each row that
 * refers to r = r' - 1 by substituting this equality, effectively
 * subtracting the coefficient of the column from the constant.
 * We should only do this if the minimum is manifestly unbounded,
 * however.  Otherwise, we may end up with negative sample values
 * for non-negative variables.
 * So, if r is a column variable with a minimum that is not
 * manifestly unbounded, then we need to move it to a row.
 * However, the sample value of this row may be negative,
 * even after the relaxation, so we need to restore it.
 * We therefore prefer to pivot a column up to a row, if possible.
 */
================================================================================

文件路径: ./isl_tab.c
注释行数: 17
注释内容:
/* Replace the variable v at position "pos" in the tableau "tab"
 * by v' = v + shift.
 *
 * If the variable is in a column, then we first check if we can
 * simply plug in v = v' - shift.  The effect on a row with
 * coefficient f/d for variable v is that the constant term c/d
 * is replaced by (c - f * shift)/d.  If shift is positive and
 * f is negative for each row that needs to remain non-negative,
 * then this is clearly safe.  In other words, if the minimum of v
 * is manifestly unbounded, then we can keep v in a column position.
 * Otherwise, we can pivot it down to a row.
 * Similarly, if shift is negative, we need to check if the maximum
 * of is manifestly unbounded.
 *
 * If the variable is in a row (from the start or after pivoting),
 * then the constant term c/d is replaced by (c + d * shift)/d.
 */
================================================================================

文件路径: ./isl_tab.c
注释行数: 11
注释内容:
/* Return an isl_tab_var that has been marked or NULL if no such
 * variable can be found.
 * The marked field has only been set for variables that
 * appear in non-redundant rows or non-dead columns.
 *
 * Pick the last constraint variable that is marked and
 * that appears in either a non-redundant row or a non-dead columns.
 * Since the returned variable is tested for being a redundant constraint or
 * an implicit equality, there is no need to return any tab variable that
 * corresponds to a variable.
 */
================================================================================

文件路径: ./isl_tab.c
注释行数: 17
注释内容:
/* Check for (near) equalities among the constraints.
 * A constraint is an equality if it is non-negative and if
 * its maximal value is either
 *	- zero (in case of rational tableaus), or
 *	- strictly less than 1 (in case of integer tableaus)
 *
 * We first mark all non-redundant and non-dead variables that
 * are not frozen and not obviously not an equality.
 * Then we iterate over all marked variables if they can attain
 * any values larger than zero or at least one.
 * If the maximal value is zero, we mark any column variables
 * that appear in the row as being zero and mark the row as being redundant.
 * Otherwise, if the maximal value is strictly less than one (and the
 * tableau is integer), then we restrict the value to being zero
 * by adding an opposite non-negative variable.
 * The order in which the variables are considered is not important.
 */
================================================================================

文件路径: ./isl_tab.c
注释行数: 33
注释内容:
/* Make the equalities that are implicit in "bmap" but that have been
 * detected in the corresponding "tab" explicit in "bmap" and update
 * "tab" to reflect the new order of the constraints.
 *
 * In particular, if inequality i is an implicit equality then
 * isl_basic_map_inequality_to_equality will move the inequality
 * in front of the other equality and it will move the last inequality
 * in the position of inequality i.
 * In the tableau, the inequalities of "bmap" are stored after the equalities
 * and so the original order
 *
 *		E E E E E A A A I B B B B L
 *
 * is changed into
 *
 *		I E E E E E A A A L B B B B
 *
 * where I is the implicit equality, the E are equalities,
 * the A inequalities before I, the B inequalities after I and
 * L the last inequality.
 * We therefore need to rotate to the right two sets of constraints,
 * those up to and including I and those after I.
 *
 * If "tab" contains any constraints that are not in "bmap" then they
 * appear after those in "bmap" and they should be left untouched.
 *
 * Note that this function only calls isl_basic_map_gauss
 * (in case some equality constraints got detected)
 * if "bmap" has more than one reference.
 * If it only has a single reference, then it is left in a temporary state,
 * because the caller may require this state.
 * Calling isl_basic_map_gauss is then the responsibility of the caller.
 */
================================================================================

文件路径: ./isl_tab.c
注释行数: 13
注释内容:
/* Check for (near) redundant constraints.
 * A constraint is redundant if it is non-negative and if
 * its minimal value (temporarily ignoring the non-negativity) is either
 *	- zero (in case of rational tableaus), or
 *	- strictly larger than -1 (in case of integer tableaus)
 *
 * We first mark all non-redundant and non-dead variables that
 * are not frozen and not obviously negatively unbounded.
 * Then we iterate over all marked variables if they can attain
 * any values smaller than zero or at most negative one.
 * If not, we mark the row as being redundant (assuming it hasn't
 * been detected as being obviously redundant in the mean time).
 */
================================================================================

文件路径: ./isl_tab.c
注释行数: 10
注释内容:
/* Return the minimal value of the affine expression "f" with denominator
 * "denom" in *opt, *opt_denom, assuming the tableau is not empty and
 * the expression cannot attain arbitrarily small values.
 * If opt_denom is NULL, then *opt is rounded up to the nearest integer.
 * The return value reflects the nature of the result (empty, unbounded,
 * minimal value returned in *opt).
 *
 * This function assumes that at least one more row and at least
 * one more element in the constraint array are available in the tableau.
 */
================================================================================

文件路径: ./isl_tab.c
注释行数: 10
注释内容:
/* Has the variable "var' of "tab" reached a value that is greater than
 * or equal (if sgn > 0) or smaller than or equal (if sgn < 0) to "target"?
 * "tmp" has been initialized by the caller and can be used
 * to perform local computations.
 *
 * If the sample value involves the big parameter, then any value
 * is reached.
 * Otherwise check if n/d >= t, i.e., n >= d * t (if sgn > 0)
 * or n/d <= t, i.e., n <= d * t (if sgn < 0).
 */
================================================================================

文件路径: ./isl_tab.c
注释行数: 16
注释内容:
/* Can variable "var" of "tab" attain the value "target" by
 * pivoting up (if sgn > 0) or down (if sgn < 0)?
 * If not, then pivot up [down] to the greatest [smallest]
 * rational value.
 * "tmp" has been initialized by the caller and can be used
 * to perform local computations.
 *
 * If the variable is manifestly unbounded in the desired direction,
 * then it can attain any value.
 * Otherwise, it can be moved to a row.
 * Continue pivoting until the target is reached.
 * If no more pivoting can be performed, the maximal [minimal]
 * rational value has been reached and the target cannot be reached.
 * If the variable would be pivoted into a manifestly unbounded column,
 * then the target can be reached.
 */
================================================================================

文件路径: ./isl_tab.c
注释行数: 19
注释内容:
/* Check if variable "var" of "tab" can only attain a single (integer)
 * value, and, if so, add an equality constraint to fix the variable
 * to this single value and store the result in "target".
 * "target" and "tmp" have been initialized by the caller.
 *
 * Given the current sample value, round it down and check
 * whether it is possible to attain a strictly smaller integer value.
 * If so, the variable is not restricted to a single integer value.
 * Otherwise, the search stops at the smallest rational value.
 * Round up this value and check whether it is possible to attain
 * a strictly greater integer value.
 * If so, the variable is not restricted to a single integer value.
 * Otherwise, the search stops at the greatest rational value.
 * If rounding down this value yields a value that is different
 * from rounding up the smallest rational value, then the variable
 * cannot attain any integer value.  Mark the tableau empty.
 * Otherwise, add an equality constraint that fixes the variable
 * to the single integer value found.
 */
================================================================================

文件路径: ./isl_tab.c
注释行数: 13
注释内容:
/* Check if variable "var" of "tab" can only attain a single (integer)
 * value, and, if so, add an equality constraint to fix the variable
 * to this single value and store the result in "value" (if "value"
 * is not NULL).
 *
 * If the current sample value involves the big parameter,
 * then the variable cannot have a fixed integer value.
 * If the variable is already fixed to a single value by its row, then
 * there is no need to add another equality constraint.
 *
 * Otherwise, allocate some temporary variables and continue
 * with detect_constant_with_tmp.
 */
================================================================================

文件路径: ./isl_tab.c
注释行数: 11
注释内容:
/* Restore the tableau to the state where the basic variables
 * are those in "col_var".
 * We first construct a list of variables that are currently in
 * the basis, but shouldn't.  Then we iterate over all variables
 * that should be in the basis and for each one that is currently
 * not in the basis, we exchange it with one of the elements of the
 * list constructed before.
 * We can always find an appropriate variable to pivot with because
 * the current basis is mapped to the old basis by a non-singular
 * matrix and so we can never end up with a zero row.
 */
================================================================================

文件路径: ./isl_tab.c
注释行数: 10
注释内容:
/* The given row "row" represents an inequality violated by all
 * points in the tableau.  Check for some special cases of such
 * separating constraints.
 * In particular, if the row has been reduced to the constant -1,
 * then we know the inequality is adjacent (but opposite) to
 * an equality in the tableau.
 * If the row has been reduced to r = c*(-1 -r'), with r' an inequality
 * of the tableau and c a positive constant, then the inequality
 * is adjacent (but opposite) to the inequality r'.
 */
================================================================================

文件路径: ./isl_multi_templ.h
注释行数: 10
注释内容:
/* A multiple expression with base expressions of type EL.
 *
 * "space" is the space in which the multiple expression lives.
 * "n" is the number of base expression and is equal
 * to the output or set dimension of "space".
 * "p" is an array of size "n" of base expressions.
 * The array is only accessible when n > 0.
 * "dom" is the explicit domain, if present
 * The explicit domain is only accessible when n == 0.
 */
================================================================================

文件路径: ./isl_polynomial.c
注释行数: 14
注释内容:
/* Reduce all divs of "qp" to have coefficients
 * in the interval [0, d-1], with d the denominator and such that the
 * last non-zero coefficient that is not equal to d/2 is smaller than d/2.
 * The modifications to the integer divisions need to be reflected
 * in the factors of the polynomial that refer to the original
 * integer divisions.  To this end, the modifications are collected
 * as a set of affine expressions and then plugged into the polynomial.
 *
 * After the reduction, some divs may have become redundant or identical,
 * so we call substitute_non_divs and sort_divs.  If these functions
 * eliminate divs or merge two or more divs into one, the coefficients
 * of the enclosing divs may have to be reduced again, so we call
 * ourselves recursively if the number of divs decreases.
 */
================================================================================

文件路径: ./isl_polynomial.c
注释行数: 10
注释内容:
/* Create a slice where the integer division "div" has the fixed value "v".
 * In particular, if "div" refers to floor(f/m), then create a slice
 *
 *	m v <= f <= m v + (m - 1)
 *
 * or
 *
 *	f - m v >= 0
 *	-f + m v + (m - 1) >= 0
 */
================================================================================

文件路径: ./isl_polynomial.c
注释行数: 15
注释内容:
/* Adjust all the integer divisions in "qp" such that they are at least
 * one over the given orthant (identified by "signs").  This ensures
 * that they will still be non-negative even after subtracting (m-1)/m.
 *
 * In particular, f is replaced by f' + v, changing f = [a/m]
 * to f' = [(a - m v)/m].
 * If the constant term k in a is smaller than m,
 * the constant term of v is set to floor(k/m) - 1.
 * For any other term, if the coefficient c and the variable x have
 * the same sign, then no changes are needed.
 * Otherwise, if the variable is positive (and c is negative),
 * then the coefficient of x in v is set to floor(c/m).
 * If the variable is negative (and c is positive),
 * then the coefficient of x in v is set to ceil(c/m).
 */
================================================================================

文件路径: ./isl_polynomial.c
注释行数: 12
注释内容:
/* Approximate each quasipolynomial by a polynomial.  If "sign" is positive,
 * the polynomial will be an overapproximation.  If "sign" is negative,
 * it will be an underapproximation.  If "sign" is zero, the approximation
 * will lie somewhere in between.
 *
 * In particular, is sign == 0, we simply drop the floors, turning
 * the integer divisions into rational divisions.
 * Otherwise, we split the domains into orthants, make all integer divisions
 * positive and then approximate each [a/m] by either a/m or (a-(m-1))/m,
 * depending on the requested sign and the sign of the term in which
 * the integer division appears.
 */
================================================================================

文件路径: ./isl_bound.c
注释行数: 11
注释内容:
/* Compute a bound on the polynomial defined over the parametric polytope
 * using either range propagation or bernstein expansion and
 * store the result in bound->pwf and bound->pwf_tight.
 * Since bernstein expansion requires bounded domains, we apply
 * range propagation on unbounded domains.  Otherwise, we respect the choice
 * of the user.
 *
 * If the polynomial does not depend on the set variables
 * then the bound is equal to the polynomial and
 * it can be added to "bound" directly.
 */
================================================================================

文件路径: ./isl_bound.c
注释行数: 18
注释内容:
/* Update bound->pwf and bound->pwf_tight with a bound
 * of type bound->type on the polynomial "poly" over the domain "bset".
 *
 * If the original problem had a wrapped relation in the domain,
 * meaning that the bound should be computed over the range
 * of this relation, then temporarily treat the domain dimensions
 * of this wrapped relation as parameters, compute a bound
 * in terms of these and the original parameters,
 * turn the parameters back into set dimensions and
 * add the results to bound->pwf and bound->pwf_tight.
 *
 * Note that even though "bset" is known to live in the same space
 * as the domain of "poly", the names of the set dimensions
 * may be different (or missing).  Make sure the naming is exactly
 * the same before turning these dimensions into parameters
 * to ensure that the spaces are still the same after
 * this operation.
 */
================================================================================

文件路径: ./isl_ast_build_private.h
注释行数: 134
注释内容:
/* An isl_ast_build represents the context in which AST is being
 * generated.  That is, it (mostly) contains information about outer
 * loops that can be used to simplify inner loops.
 *
 * "domain" represents constraints on the internal schedule domain,
 * corresponding to the context of the AST generation and the constraints
 * implied by the loops that have already been generated.
 * When an isl_ast_build is first created, outside any AST generation,
 * the domain is typically a parameter set.  It is only when a AST
 * generation phase is initiated that the domain of the isl_ast_build
 * is changed to refer to the internal schedule domain.
 * The domain then lives in a space of the form
 *
 *	S
 *
 *  or
 *
 *	[O -> S]
 *
 * O represents the loops generated in outer AST generations.
 * S represents the loops (both generated and to be generated)
 * of the current AST generation.
 * Both include eliminated loops.
 * "domain" is expected not to have any unknown divs because
 * it is used as the context argument in a call to isl_basic_set_gist
 * in isl_ast_build_compute_gist_basic_set.
 *
 * "depth" is equal to the number of loops that have already
 * been generated (including those in outer AST generations).
 * "outer_pos" is equal to the number of loops in outer AST generations.
 *
 * "generated" is a superset of "domain" corresponding to those
 * constraints that were either given by the user or that have
 * effectively been generated (as bounds on a for loop).
 *
 * "pending" is a superset of "domain" corresponding to the constraints
 * that still need to be generated (as guards), but that may end up
 * not getting generated if they are implied by any constraints
 * enforced by inner loops.
 *
 * "strides" contains the stride of each loop.  The number of elements
 * is equal to the number of dimensions in "domain".
 * "offsets" contains the offsets of strided loops.  If s is the stride
 * for a given dimension and f is the corresponding offset, then the
 * dimension takes on values
 *
 *	f + s a
 *
 * with a an integer.  For non-strided loops, the offset is zero.
 *
 * "iterators" contains the loop iterators of both generated and
 * to be generated loops.  The number of elements is at least as
 * large as the dimension of the internal schedule domain.  The
 * number may be larger, in which case the additional ids can be
 * used in a nested AST generation should the schedule be non-injective.
 *
 * "values" lives in the space
 *
 *	[O -> S] -> [O -> S]		(or S -> S)
 *
 * and expresses (if possible) loop iterators in terms of parameters
 * and outer loop iterators.  If the value of a given loop iterator
 * cannot be expressed as an affine expression (either because the iterator
 * attains multiple values or because the single value is a piecewise
 * affine expression), then it is expressed in "values" as being equal
 * to itself.
 *
 * "value" is the value of the loop iterator at the current depth.
 * It is NULL if it has not been computed yet or if the value of the
 * given loop iterator cannot be expressed as a piecewise affine expression
 * (because the iterator attains multiple values).
 *
 * "schedule_map" maps the internal schedule domain to the external schedule
 * domain.  It may be NULL if it hasn't been computed yet.
 * See isl_ast_build_get_schedule_map_multi_aff.
 *
 * "internal2input" maps the internal schedule domain to the original
 * input schedule domain.  In case of a schedule tree input, the original
 * input schedule domain consist of the flat product of all outer
 * band node spaces, including the current band node.
 * It may be NULL if there no longer is such a uniform mapping
 * (because different iterations have been rescheduled differently).
 *
 * "options" contains the AST build options in case we are generating
 * an AST from a flat schedule map.  When creating an AST from a schedule
 * tree, this field is ignored.
 *
 * The "create_leaf" callback is called for every leaf in the generated AST.
 * The callback is responsible for creating the node to be placed at those
 * leaves.  If this callback is not set, then isl will generated user
 * nodes with call expressions corresponding to an element of the domain.
 *
 * The "at_each_domain" callback is called on every node created to represent
 * an element of the domain.  Each of these nodes is a user node
 * with as expression a call expression.
 *
 * The "before_each_for" callback is called on each for node before
 * its children have been created.
 *
 * The "after_each_for" callback is called on each for node after
 * its children have been created.
 *
 * The "before_each_mark" callback is called before we handle the subtree
 * of an isl_schedule_node_mark node.
 *
 * The "after_each_mark" callback is called after we have handled the subtree
 * of an isl_schedule_node_mark node.
 *
 * "executed" contains the inverse schedule at this point
 * of the AST generation.
 * It is currently only used in isl_ast_build_get_schedule, which is
 * in turn only used by user code from within a callback.
 * The value is set right before we may be calling such a callback.
 *
 * "single_valued" is set if the current inverse schedule (which may or may
 * not be stored in "executed") is known to be single valued, specifically
 * an inverse schedule that was not (appeared not to be) single valued
 * is extended to a single valued inverse schedule.  This is mainly used
 * to avoid an infinite recursion when we fail to detect later on that
 * the extended inverse schedule is single valued.
 *
 * "node" points to the current band node in case we are generating
 * an AST from a schedule tree.  It may be NULL if we are not generating
 * an AST from a schedule tree or if we are not inside a band node.
 *
 * "loop_type" originally contains loop AST generation types for
 * the "n" members of "node" and it is updated (along with "n") when
 * a schedule dimension is inserted.
 * It is NULL if "node" is NULL.
 *
 * "isolated" is the piece of the schedule domain isolated by the isolate
 * option on the current band.  This set may be NULL if we have not checked
 * for the isolate option yet.
 */
================================================================================

文件路径: ./isl_local.c
注释行数: 11
注释内容:
/*
 * Copyright 2011      INRIA Saclay
 * Copyright 2014      Ecole Normale Superieure
 *
 * Use of this software is governed by the MIT license
 *
 * Written by Sven Verdoolaege, INRIA Saclay - Ile-de-France,
 * Parc Club Orsay Universite, ZAC des vignes, 4 rue Jacques Monod,
 * 91893 Orsay, France
 * and Ecole Normale Superieure, 45 rue d'Ulm, 75230 Paris, France
 */
================================================================================

文件路径: ./isl_local.c
注释行数: 10
注释内容:
/* Compare two sets of local variables, defined over
 * the same space.
 *
 * Return -1 if "local1" is "smaller" than "local2", 1 if "local1" is "greater"
 * than "local2" and 0 if they are equal.
 *
 * The order is fairly arbitrary.  We do "prefer" divs that only involve
 * earlier dimensions in the sense that we consider matrices where
 * the first differing div involves earlier dimensions to be smaller.
 */
================================================================================

文件路径: ./isl_schedule_band.h
注释行数: 21
注释内容:
/* Information about a band within a schedule.
 *
 * n is the number of scheduling dimensions within the band.
 * coincident is an array of length n, indicating whether a scheduling dimension
 *	satisfies the coincidence constraints in the sense that
 *	the corresponding dependence distances are zero.
 * permutable is set if the band is permutable.
 * mupa is the partial schedule corresponding to this band.  The dimension
 *	of mupa is equal to n.
 * loop_type contains the loop AST generation types for the members
 * in the band.  It may be NULL, if all members are
 * of type isl_ast_loop_default.
 * isolate_loop_type contains the loop AST generation types for the members
 * in the band for the isolated part.  It may be NULL, if all members are
 * of type isl_ast_loop_default.
 * ast_build_options are the remaining AST build options associated
 * to the band.
 * anchored is set if the node depends on its position in the schedule tree.
 *	In particular, it is set if the AST build options include
 *	an isolate option.
 */
================================================================================

文件路径: ./isl_test_cpp.cc
注释行数: 15
注释内容:
/* Test the (unchecked) isl C++ interface
 *
 * This includes:
 *  - The isl C <-> C++ pointer interface
 *  - Object construction
 *  - Different parameter types
 *  - Different return types
 *  - Foreach functions
 *  - Exceptions
 *  - Spaces
 *  - Schedule trees
 *  - AST generation
 *  - AST expression generation
 *  - Templated interface
 */
================================================================================

文件路径: ./isl_multi_splice_templ.c
注释行数: 23
注释内容:
/* Given two multi expressions, "multi1"
 *
 *	[A1 A2] -> [B1 B2]
 *
 * where A2 starts at position "in_pos" and B2 starts at position "out_pos",
 * and "multi2"
 *
 *	[C] -> [D]
 *
 * return the multi expression
 *
 *	[A1 C A2] -> [B1 D B2]
 *
 * We first insert input dimensions to obtain
 *
 *	[A1 C A2] -> [B1 B2]
 *
 * and
 *
 *	[A1 C A2] -> [D]
 *
 * and then apply range_splice.
 */
================================================================================

文件路径: ./isl_test_cpp-checked.cc
注释行数: 12
注释内容:
/* Test that isl_bool values are returned correctly.
 *
 * We check in detail the following parts of the isl::boolean class:
 *  - The is_true, is_false, and is_error functions return true in case they
 *    are called on a true, false, or error instance of isl::boolean,
 *    respectively
 *  - Explicit conversion to 'bool'
 *  - Implicit conversion to 'bool'
 *  - The complement operator
 *  - Explicit construction from 'true' and 'false'
 *  - Explicit construction form isl_bool
 */
================================================================================

文件路径: ./isl_test_cpp-checked.cc
注释行数: 14
注释内容:
/* Test the isl checked C++ interface
 *
 * This includes:
 *  - The isl C <-> C++ pointer interface
 *  - Object construction
 *  - Different parameter types
 *  - Different return types
 *  - Foreach functions
 *  - Every functions
 *  - Spaces
 *  - Schedule trees
 *  - AST generation
 *  - AST expression generation
 */
================================================================================

文件路径: ./isl_ast_codegen.c
注释行数: 11
注释内容:
/*
 * Copyright 2012-2014 Ecole Normale Superieure
 * Copyright 2014      INRIA Rocquencourt
 *
 * Use of this software is governed by the MIT license
 *
 * Written by Sven Verdoolaege,
 * Ecole Normale Superieure, 45 rue d’Ulm, 75230 Paris, France
 * and Inria Paris - Rocquencourt, Domaine de Voluceau - Rocquencourt,
 * B.P. 105 - 78153 Le Chesnay, France
 */
================================================================================

文件路径: ./isl_ast_codegen.c
注释行数: 19
注释内容:
/* Generate an AST for a single domain based on
 * the (non single valued) inverse schedule "executed".
 *
 * We extend the schedule with the iteration domain
 * and continue generating through a call to generate_code.
 *
 * In particular, if executed has the form
 *
 *	S -> D
 *
 * then we continue generating code on
 *
 *	[S -> D] -> D
 *
 * The extended inverse schedule is clearly single valued
 * ensuring that the nested generate_code will not reach this function,
 * but will instead create calls to all elements of D that need
 * to be executed from the current schedule domain.
 */
================================================================================

文件路径: ./isl_ast_codegen.c
注释行数: 18
注释内容:
/* Generate a call expression for the single executed
 * domain element "map" and put a guard around it based its (simplified)
 * domain.  "executed" is the original inverse schedule from which "map"
 * has been derived.  In particular, "map" is either identical to "executed"
 * or it is the result of gisting "executed" with respect to the build domain.
 * "executed" is only used if there is an at_each_domain callback.
 *
 * At this stage, any pending constraints in the build can no longer
 * be simplified with respect to any enforced constraints since
 * the call node does not have any enforced constraints.
 * Since all pending constraints not covered by any enforced constraints
 * will be added as a guard to the graft in create_node_scaled,
 * even in the eliminated case, the pending constraints
 * can be considered to have been generated by outer constructs.
 *
 * If the user has set an at_each_domain callback, it is called
 * on the constructed call expression node.
 */
================================================================================

文件路径: ./isl_ast_codegen.c
注释行数: 35
注释内容:
/* Generate an AST for a single domain based on
 * the inverse schedule "executed" and add it to data->list.
 *
 * If there is more than one domain element associated to the current
 * schedule "time", then we need to continue the generation process
 * in generate_non_single_valued.
 * Note that the inverse schedule being single-valued may depend
 * on constraints that are only available in the original context
 * domain specified by the user.  We therefore first introduce
 * some of the constraints of data->build->domain.  In particular,
 * we intersect with a single-disjunct approximation of this set.
 * We perform this approximation to avoid further splitting up
 * the executed relation, possibly introducing a disjunctive guard
 * on the statement.
 *
 * On the other hand, we only perform the test after having taken the gist
 * of the domain as the resulting map is the one from which the call
 * expression is constructed.  Using this map to construct the call
 * expression usually yields simpler results in cases where the original
 * map is not obviously single-valued.
 * If the original map is obviously single-valued, then the gist
 * operation is skipped.
 *
 * Because we perform the single-valuedness test on the gisted map,
 * we may in rare cases fail to recognize that the inverse schedule
 * is single-valued.  This becomes problematic if this happens
 * from the recursive call through generate_non_single_valued
 * as we would then end up in an infinite recursion.
 * We therefore check if we are inside a call to generate_non_single_valued
 * and revert to the ungisted map if the gisted map turns out not to be
 * single-valued.
 *
 * Otherwise, call add_domain to generate a call expression (with guard) and
 * to call the at_each_domain callback, if any.
 */
================================================================================

文件路径: ./isl_ast_codegen.c
注释行数: 16
注释内容:
/* Call build->create_leaf to a create "leaf" node in the AST,
 * encapsulate the result in an isl_ast_graft and return the result
 * as a 1-element list.
 *
 * Note that the node returned by the user may be an entire tree.
 *
 * Since the node itself cannot enforce any constraints, we turn
 * all pending constraints into guards and add them to the resulting
 * graft to ensure that they will be generated.
 *
 * Before we pass control to the user, we first clear some information
 * from the build that is (presumbably) only meaningful
 * for the current code generation.
 * This includes the create_leaf callback itself, so we make a copy
 * of the build first.
 */
================================================================================

文件路径: ./isl_ast_codegen.c
注释行数: 12
注释内容:
/* Generate an AST after having handled the complete schedule
 * of this call to the code generator or the complete band
 * if we are generating an AST from a schedule tree.
 *
 * If we are inside a band node, then move on to the child of the band.
 *
 * If the user has specified a create_leaf callback, control
 * is passed to the user in call_create_leaf.
 *
 * Otherwise, we generate one or more calls for each individual
 * domain in generate_domain.
 */
================================================================================

文件路径: ./isl_ast_codegen.c
注释行数: 20
注释内容:
/* Extract a lower bound on dimension "pos" from constraint "c".
 *
 * If the constraint is of the form
 *
 *	a x + f(...) >= 0
 *
 * then we essentially return
 *
 *	l = ceil(-f(...)/a)
 *
 * However, if the current dimension is strided, then we need to make
 * sure that the lower bound we construct is of the form
 *
 *	f + s a
 *
 * with f the offset and s the stride.
 * We therefore compute
 *
 *	f + s * ceil((l - f)/s)
 */
================================================================================

文件路径: ./isl_ast_codegen.c
注释行数: 12
注释内容:
/* Return the exact lower bound (or upper bound if "upper" is set)
 * of "domain" as a piecewise affine expression.
 *
 * If we are computing a lower bound (of a strided dimension), then
 * we need to make sure it is of the form
 *
 *	f + s a
 *
 * where f is the offset and s is the stride.
 * We therefore need to include the stride constraint before computing
 * the minimum.
 */
================================================================================

文件路径: ./isl_ast_codegen.c
注释行数: 13
注释内容:
/* Given a list of lower bounds "list", remove those that are redundant
 * with respect to the other bounds in "list" and the domain of "build".
 *
 * We first sort the bounds in the same way as they would be sorted
 * by set_for_node_expressions so that we can try and remove the last
 * bounds first.
 *
 * For a lower bound to be effective, there needs to be at least
 * one domain element for which it is larger than all other lower bounds.
 * For each lower bound we therefore intersect the domain with
 * the conditions that it is larger than all other bounds and
 * check whether the result is empty.  If so, the bound can be removed.
 */
================================================================================

文件路径: ./isl_ast_codegen.c
注释行数: 11
注释内容:
/* Extract a lower bound on dimension "pos" from each constraint
 * in "constraints" and return the list of lower bounds.
 * If "constraints" has zero elements, then we extract a lower bound
 * from "domain" instead.
 *
 * If the current dimension is strided, then the lower bound
 * is adjusted by lower_bound to match the stride information.
 * This modification may make one or more lower bounds redundant
 * with respect to the other lower bounds.  We therefore check
 * for this condition and remove the redundant lower bounds.
 */
================================================================================

文件路径: ./isl_ast_codegen.c
注释行数: 11
注释内容:
/* Add guards implied by the "generated constraints",
 * but not (necessarily) enforced by the generated AST to "guard".
 * In particular, if there is any stride constraints,
 * then add the guard implied by those constraints.
 * If we have generated a degenerate loop, then add the guard
 * implied by "bounds" on the outer dimensions, i.e., the guard
 * that ensures that the single value actually exists.
 * Since there may also be guards implied by a combination
 * of these constraints, we first combine them before
 * deriving the implied constraints.
 */
================================================================================

文件路径: ./isl_ast_codegen.c
注释行数: 11
注释内容:
/* Update "graft" based on "sub_build" for the degenerate case.
 *
 * "build" is the build in which graft->node was created
 * "sub_build" contains information about the current level itself,
 * including the single value attained.
 *
 * We set the initialization part of the for loop to the single
 * value attained by the current dimension.
 * The increment and condition are not strictly needed as the are known
 * to be "1" and "iterator <= value" respectively.
 */
================================================================================

文件路径: ./isl_ast_codegen.c
注释行数: 28
注释内容:
/* Compute the constraints on the outer dimensions enforced by
 * graft->node and add those constraints to graft->enforced,
 * in case the upper bound is expressed as a set "upper".
 *
 * In particular, if l(...) is a lower bound in "lower", and
 *
 *	-a i + f(...) >= 0		or	a i <= f(...)
 *
 * is an upper bound ocnstraint on the current dimension i,
 * then the for loop enforces the constraint
 *
 *	-a l(...) + f(...) >= 0		or	a l(...) <= f(...)
 *
 * We therefore simply take each lower bound in turn, plug it into
 * the upper bounds and compute the intersection over all lower bounds.
 *
 * If a lower bound is a rational expression, then
 * isl_basic_set_preimage_multi_aff will force this rational
 * expression to have only integer values.  However, the loop
 * itself does not enforce this integrality constraint.  We therefore
 * use the ceil of the lower bounds instead of the lower bounds themselves.
 * Other constraints will make sure that the for loop is only executed
 * when each of the lower bounds attains an integral value.
 * In particular, potentially rational values only occur in
 * lower_bound if the offset is a (seemingly) rational expression,
 * but then outer conditions will make sure that this rational expression
 * only attains integer values.
 */
================================================================================

文件路径: ./isl_ast_codegen.c
注释行数: 13
注释内容:
/* Set the condition part of the for node graft->node in case
 * the upper bound is represented as a list of piecewise affine expressions.
 *
 * In particular, set the condition to
 *
 *	iterator <= min(list of upper bounds)
 *
 * If each of the upper bounds has a negative constant term, then
 * set the condition to
 *
 *	iterator < min(list of (upper bound + 1)s)
 *
 */
================================================================================

文件路径: ./isl_ast_codegen.c
注释行数: 19
注释内容:
/* Should we express the loop condition as
 *
 *	iterator <= min(list of upper bounds)
 *
 * or as a conjunction of constraints?
 *
 * The first is constructed from a list of upper bounds.
 * The second is constructed from a set.
 *
 * If there are no upper bounds in "constraints", then this could mean
 * that "domain" simply doesn't have an upper bound or that we didn't
 * pick any upper bound.  In the first case, we want to generate the
 * loop condition as a(n empty) conjunction of constraints
 * In the second case, we will compute
 * a single upper bound from "domain" and so we use the list form.
 *
 * If there are upper bounds in "constraints",
 * then we use the list form iff the atomic_upper_bound option is set.
 */
================================================================================

文件路径: ./isl_ast_codegen.c
注释行数: 31
注释内容:
/* Update "graft" based on "bounds" and "domain" for the generic,
 * non-degenerate, case.
 *
 * "c_lower" and "c_upper" contain the lower and upper bounds
 * that the loop node should express.
 * "domain" is the subset of the intersection of the constraints
 * for which some code is executed.
 *
 * There may be zero lower bounds or zero upper bounds in "constraints"
 * in case the list of constraints was created
 * based on the atomic option or based on separation with explicit bounds.
 * In that case, we use "domain" to derive lower and/or upper bounds.
 *
 * We first compute a list of one or more lower bounds.
 *
 * Then we decide if we want to express the condition as
 *
 *	iterator <= min(list of upper bounds)
 *
 * or as a conjunction of constraints.
 *
 * The set of enforced constraints is then computed either based on
 * a list of upper bounds or on a set of upper bound constraints.
 * We do not compute any enforced constraints if we were forced
 * to compute a lower or upper bound using exact_bound.  The domains
 * of the resulting expressions may imply some bounds on outer dimensions
 * that we do not want to appear in the enforced constraints since
 * they are not actually enforced by the corresponding code.
 *
 * Finally, we fill in the expressions of the for node.
 */
================================================================================

文件路径: ./isl_ast_codegen.c
注释行数: 16
注释内容:
/* Update "graft" based on "bounds" and "domain" for the generic,
 * non-degenerate, case.
 *
 * "list" respresent the list of bounds that need to be encoded by
 * the for loop.  Only the constraints that involve the iterator
 * are relevant here.  The other constraints are taken care of by
 * the caller and are included in the generated constraints of "build".
 * "domain" is the subset of the intersection of the constraints
 * for which some code is executed.
 * "build" is the build in which graft->node was created.
 *
 * We separate lower bounds, upper bounds and constraints that
 * are independent of the loop iterator.
 *
 * The actual for loop bounds are generated in refine_generic_bounds.
 */
================================================================================

文件路径: ./isl_ast_codegen.c
注释行数: 11
注释内容:
/* Update "graft" based on "bounds" and "domain" for the generic,
 * non-degenerate, case.
 *
 * "bounds" respresent the bounds that need to be encoded by
 * the for loop (or a guard around the for loop).
 * "domain" is the subset of "bounds" for which some code is executed.
 * "build" is the build in which graft->node was created.
 *
 * We break up "bounds" into a list of constraints and continue with
 * refine_generic_split.
 */
================================================================================

文件路径: ./isl_ast_codegen.c
注释行数: 72
注释内容:
/* Create an AST node for the current dimension based on
 * the schedule domain "bounds" and return the node encapsulated
 * in an isl_ast_graft.
 *
 * "executed" is the current inverse schedule, taking into account
 * the bounds in "bounds"
 * "domain" is the domain of "executed", with inner dimensions projected out.
 * It may be a strict subset of "bounds" in case "bounds" was created
 * based on the atomic option or based on separation with explicit bounds.
 *
 * "domain" may satisfy additional equalities that result
 * from intersecting "executed" with "bounds" in add_node.
 * It may also satisfy some global constraints that were dropped out because
 * we performed separation with explicit bounds.
 * The very first step is then to copy these constraints to "bounds".
 *
 * Since we may be calling before_each_for and after_each_for
 * callbacks, we record the current inverse schedule in the build.
 *
 * We consider three builds,
 * "build" is the one in which the current level is created,
 * "body_build" is the build in which the next level is created,
 * "sub_build" is essentially the same as "body_build", except that
 * the depth has not been increased yet.
 *
 * "build" already contains information (in strides and offsets)
 * about the strides at the current level, but this information is not
 * reflected in the build->domain.
 * We first add this information and the "bounds" to the sub_build->domain.
 * isl_ast_build_set_loop_bounds adds the stride information and
 * checks whether the current dimension attains
 * only a single value and whether this single value can be represented using
 * a single affine expression.
 * In the first case, the current level is considered "degenerate".
 * In the second, sub-case, the current level is considered "eliminated".
 * Eliminated levels don't need to be reflected in the AST since we can
 * simply plug in the affine expression.  For degenerate, but non-eliminated,
 * levels, we do introduce a for node, but mark is as degenerate so that
 * it can be printed as an assignment of the single value to the loop
 * "iterator".
 *
 * If the current level is eliminated, we explicitly plug in the value
 * for the current level found by isl_ast_build_set_loop_bounds in the
 * inverse schedule.  This ensures that if we are working on a slice
 * of the domain based on information available in the inverse schedule
 * and the build domain, that then this information is also reflected
 * in the inverse schedule.  This operation also eliminates the current
 * dimension from the inverse schedule making sure no inner dimensions depend
 * on the current dimension.  Otherwise, we create a for node, marking
 * it degenerate if appropriate.  The initial for node is still incomplete
 * and will be completed in either refine_degenerate or refine_generic.
 *
 * We then generate a sequence of grafts for the next level,
 * create a surrounding graft for the current level and insert
 * the for node we created (if the current level is not eliminated).
 * Before creating a graft for the current level, we first extract
 * hoistable constraints from the child guards and combine them
 * with the pending constraints in the build.  These constraints
 * are used to simplify the child guards and then added to the guard
 * of the current graft to ensure that they will be generated.
 * If the hoisted guard is a disjunction, then we use it directly
 * to gist the guards on the children before intersect it with the
 * pending constraints.  We do so because this disjunction is typically
 * identical to the guards on the children such that these guards
 * can be effectively removed completely.  After the intersection,
 * the gist operation would have a harder time figuring this out.
 *
 * Finally, we set the bounds of the for loop in either
 * refine_degenerate or refine_generic.
 * We do so in a context where the pending constraints of the build
 * have been replaced by the guard of the current graft.
 */
================================================================================

文件路径: ./isl_ast_codegen.c
注释行数: 40
注释内容:
/* Create an AST node for the current dimension based on
 * the schedule domain "bounds" and return the node encapsulated
 * in an isl_ast_graft.
 *
 * "executed" is the current inverse schedule, taking into account
 * the bounds in "bounds"
 * "domain" is the domain of "executed", with inner dimensions projected out.
 *
 *
 * Before moving on to the actual AST node construction in create_node_scaled,
 * we first check if the current dimension is strided and if we can scale
 * down this stride.  Note that we only do this if the ast_build_scale_strides
 * option is set.
 *
 * In particular, let the current dimension take on values
 *
 *	f + s a
 *
 * with a an integer.  We check if we can find an integer m that (obviously)
 * divides both f and s.
 *
 * If so, we check if the current dimension only appears in constraints
 * where the coefficients of the other variables are multiples of m.
 * We perform this extra check to avoid the risk of introducing
 * divisions by scaling down the current dimension.
 *
 * If so, we scale the current dimension down by a factor of m.
 * That is, we plug in
 *
 *	i = m i'							(1)
 *
 * Note that in principle we could always scale down strided loops
 * by plugging in
 *
 *	i = f + s i'
 *
 * but this may result in i' taking on larger values than the original i,
 * due to the shift by "f".
 * By constrast, the scaling in (1) can only reduce the (absolute) value "i".
 */
================================================================================

文件路径: ./isl_ast_codegen.c
注释行数: 14
注释内容:
/* Generate code for the schedule domain "bounds"
 * and add the result to "list".
 *
 * We mainly detect strides here and check if the bounds do not
 * conflict with the current build domain
 * and then pass over control to create_node.
 *
 * "bounds" reflects the bounds on the current dimension and possibly
 * some extra conditions on outer dimensions.
 * It does not, however, include any divs involving the current dimension,
 * so it does not capture any stride constraints.
 * We therefore need to compute that part of the schedule domain that
 * intersects with "bounds" and derive the strides from the result.
 */
================================================================================

文件路径: ./isl_ast_codegen.c
注释行数: 31
注释内容:
/* Generate code for the schedule domains in "scc"
 * and add the results to "list".
 *
 * The domains in "scc" form a strongly connected component in the ordering.
 * If the number of domains in "scc" is larger than 1, then this means
 * that we cannot determine a valid ordering for the domains in the component.
 * This should be fairly rare because the individual domains
 * have been made disjoint first.
 * The problem is that the domains may be integrally disjoint but not
 * rationally disjoint.  For example, we may have domains
 *
 *	{ [i,i] : 0 <= i <= 1 }		and	{ [i,1-i] : 0 <= i <= 1 }
 *
 * These two domains have an empty intersection, but their rational
 * relaxations do intersect.  It is impossible to order these domains
 * in the second dimension because the first should be ordered before
 * the second for outer dimension equal to 0, while it should be ordered
 * after for outer dimension equal to 1.
 *
 * This may happen in particular in case of unrolling since the domain
 * of each slice is replaced by its simple hull.
 *
 * For each basic set i in "scc" and for each of the following basic sets j,
 * we split off that part of the basic set i that shares the outer dimensions
 * with j and lies before j in the current dimension.
 * We collect all the pieces in a new list that replaces "scc".
 *
 * While the elements in "scc" should be disjoint, we double-check
 * this property to avoid running into an infinite recursion in case
 * they intersect due to some internal error.
 */
================================================================================

文件路径: ./isl_ast_codegen.c
注释行数: 13
注释内容:
/* Sort the domains in "domain_list" according to the execution order
 * at the current depth (for equal values of the outer dimensions),
 * generate code for each of them, collecting the results in a list.
 * If no code is generated (because the intersection of the inverse schedule
 * with the domains turns out to be empty), then an empty list is returned.
 *
 * The caller is responsible for ensuring that the basic sets in "domain_list"
 * are pair-wise disjoint.  It can, however, in principle happen that
 * two basic sets should be ordered one way for one value of the outer
 * dimensions and the other way for some other value of the outer dimensions.
 * We therefore play safe and look for strongly connected components.
 * The function add_nodes takes care of handling non-trivial components.
 */
================================================================================

文件路径: ./isl_ast_codegen.c
注释行数: 10
注释内容:
/* Internal data structure for generate_sorted_domains_wrap.
 *
 * "n" is the total number of basic sets
 * "executed" and "build" are extra arguments to be passed
 *	to generate_sorted_domains.
 *
 * "single" is set to 1 by generate_sorted_domains_wrap if there
 * is only a single component.
 * "list" collects the results.
 */
================================================================================

文件路径: ./isl_ast_codegen.c
注释行数: 16
注释内容:
/* Look for any (weakly connected) components in the "domain_list"
 * of domains that share some values of the outer dimensions.
 * That is, domains in different components do not share any values
 * of the outer dimensions.  This means that these components
 * can be freely reordered.
 * Within each of the components, we sort the domains according
 * to the execution order at the current depth.
 *
 * If there is more than one component, then generate_sorted_domains_wrap
 * fuses the result of each call to generate_sorted_domains
 * into a list with either zero or one graft and collects these (at most)
 * single element lists into a bigger list. This means that the elements of the
 * final list can be freely reordered.  In particular, we sort them
 * according to an arbitrary but fixed ordering to ease merging of
 * graft lists from different components.
 */
================================================================================

文件路径: ./isl_ast_codegen.c
注释行数: 16
注释内容:
/* Temporary data used during the search for a lower bound for unrolling.
 *
 * "build" is the build in which the unrolling will be performed
 * "domain" is the original set for which to find a lower bound
 * "depth" is the dimension for which to find a lower boudn
 * "expansion" is the expansion that needs to be applied to "domain"
 * in the unrolling that will be performed
 *
 * "lower" is the best lower bound found so far.  It is NULL if we have not
 * found any yet.
 * "n" is the corresponding size.  If lower is NULL, then the value of n
 * is undefined.
 * "n_div" is the maximal number of integer divisions in the first
 * unrolled iteration (after expansion).  It is set to -1 if it hasn't
 * been computed yet.
 */
================================================================================

文件路径: ./isl_ast_codegen.c
注释行数: 14
注释内容:
/* Is the lower bound "lower" with corresponding iteration count "n"
 * better than the one stored in "data"?
 * If there is no upper bound on the iteration count ("n" is infinity) or
 * if the count is too large, then we cannot use this lower bound.
 * Otherwise, if there was no previous lower bound or
 * if the iteration count of the new lower bound is smaller than
 * the iteration count of the previous lower bound, then we consider
 * the new lower bound to be better.
 * If the iteration count is the same, then compare the number
 * of integer divisions that would be needed to express
 * the iterator value at the first slice in the unrolling
 * according to the lower bound.  If we end up computing this
 * number, then store the lowest value in data->n_div.
 */
================================================================================

文件路径: ./isl_ast_codegen.c
注释行数: 26
注释内容:
/* Check if we can use "c" as a lower bound and if it is better than
 * any previously found lower bound.
 *
 * If "c" does not involve the dimension at the current depth,
 * then we cannot use it.
 * Otherwise, let "c" be of the form
 *
 *	i >= f(j)/a
 *
 * We compute the maximal value of
 *
 *	-ceil(f(j)/a)) + i + 1
 *
 * over the domain.  If there is such a value "n", then we know
 *
 *	-ceil(f(j)/a)) + i + 1 <= n
 *
 * or
 *
 *	i < ceil(f(j)/a)) + n
 *
 * meaning that we can use ceil(f(j)/a)) as a lower bound for unrolling.
 * We just need to check if we have found any lower bound before and
 * if the new lower bound is better (smaller n or fewer integer divisions)
 * than the previously found lower bounds.
 */
================================================================================

文件路径: ./isl_ast_codegen.c
注释行数: 24
注释内容:
/* Look for a lower bound l(i) on the dimension at "depth"
 * and a size n such that "domain" is a subset of
 *
 *	{ [i] : l(i) <= i_d < l(i) + n }
 *
 * where d is "depth" and l(i) depends only on earlier dimensions.
 * Furthermore, try and find a lower bound such that n is as small as possible.
 * In particular, "n" needs to be finite.
 * "build" is the build in which the unrolling will be performed.
 * "expansion" is the expansion that needs to be applied to "domain"
 * in the unrolling that will be performed.
 *
 * Inner dimensions have been eliminated from "domain" by the caller.
 *
 * We first construct a collection of lower bounds on the input set
 * by computing its simple hull.  We then iterate through them,
 * discarding those that we cannot use (either because they do not
 * involve the dimension at "depth" or because they have no corresponding
 * upper bound, meaning that "n" would be unbounded) and pick out the
 * best from the remaining ones.
 *
 * If we cannot find a suitable lower bound, then we consider that
 * to be an error.
 */
================================================================================

文件路径: ./isl_ast_codegen.c
注释行数: 33
注释内容:
/* Call "fn" on each iteration of the current dimension of "domain".
 * If "init" is not NULL, then it is called with the number of
 * iterations before any call to "fn".
 * Return -1 on failure.
 *
 * Since we are going to be iterating over the individual values,
 * we first check if there are any strides on the current dimension.
 * If there is, we rewrite the current dimension i as
 *
 *		i = stride i' + offset
 *
 * and then iterate over individual values of i' instead.
 *
 * We then look for a lower bound on i' and a size such that the domain
 * is a subset of
 *
 *	{ [j,i'] : l(j) <= i' < l(j) + n }
 *
 * and then take slices of the domain at values of i'
 * between l(j) and l(j) + n - 1.
 *
 * We compute the unshifted simple hull of each slice to ensure that
 * we have a single basic set per offset.  The slicing constraint
 * may get simplified away before the unshifted simple hull is taken
 * and may therefore in some rare cases disappear from the result.
 * We therefore explicitly add the constraint back after computing
 * the unshifted simple hull to ensure that the basic sets
 * remain disjoint.  The constraints that are dropped by taking the hull
 * will be taken into account at the next level, as in the case of the
 * atomic option.
 *
 * Finally, we map i' back to i and call "fn".
 */
================================================================================

文件路径: ./isl_ast_codegen.c
注释行数: 19
注释内容:
/* Data structure for storing the results and the intermediate objects
 * of compute_domains.
 *
 * "list" is the main result of the function and contains a list
 * of disjoint basic sets for which code should be generated.
 *
 * "executed" and "build" are inputs to compute_domains.
 * "schedule_domain" is the domain of "executed".
 *
 * "option" contains the domains at the current depth that should by
 * atomic, separated or unrolled.  These domains are as specified by
 * the user, except that inner dimensions have been eliminated and
 * that they have been made pair-wise disjoint.
 *
 * "sep_class" contains the user-specified split into separation classes
 * specialized to the current depth.
 * "done" contains the union of the separation domains that have already
 * been handled.
 */
================================================================================

文件路径: ./isl_ast_codegen.c
注释行数: 11
注释内容:
/* Extend domains->list with a list of basic sets, one for each value
 * of the current dimension in "domain" and remove the corresponding
 * sets from the class domain.  Return the updated class domain.
 * The divs that involve the current dimension have not been projected out
 * from this domain.
 *
 * We call foreach_iteration to iterate over the individual values and
 * in do_unroll_iteration we collect the individual basic sets in
 * domains->list and their union in data->unroll_domain, which is then
 * used to update the class domain.
 */
================================================================================

文件路径: ./isl_ast_codegen.c
注释行数: 16
注释内容:
/* Add domains to domains->list for each individual value of the current
 * dimension, for that part of the schedule domain that lies in the
 * intersection of the option domain and the class domain.
 * Remove the corresponding sets from the class domain and
 * return the updated class domain.
 *
 * We first break up the unroll option domain into individual pieces
 * and then handle each of them separately.  The unroll option domain
 * has been made disjoint in compute_domains_init_options,
 *
 * Note that we actively want to combine different pieces of the
 * schedule domain that have the same value at the current dimension.
 * We therefore need to break up the unroll option domain before
 * intersecting with class and schedule domain, hoping that the
 * unroll option domain specified by the user is relatively simple.
 */
================================================================================

文件路径: ./isl_ast_codegen.c
注释行数: 17
注释内容:
/* Try and construct a single basic set that includes the intersection of
 * the schedule domain, the atomic option domain and the class domain.
 * Add the resulting basic set(s) to domains->list and remove them
 * from class_domain.  Return the updated class domain.
 *
 * We construct a single domain rather than trying to combine
 * the schedule domains of individual domains because we are working
 * within a single component so that non-overlapping schedule domains
 * should already have been separated.
 * We do however need to make sure that this single domains is a subset
 * of the class domain so that it would not intersect with any other
 * class domains.  This means that we may end up splitting up the atomic
 * domain in case separation classes are being used.
 *
 * "domain" is the intersection of the schedule domain and the class domain,
 * with inner dimensions projected out.
 */
================================================================================

文件路径: ./isl_ast_codegen.c
注释行数: 12
注释内容:
/* Split up the schedule domain into uniform basic sets,
 * in the sense that each element in a basic set is associated to
 * elements of the same domains, and add the result to domains->list.
 * Do this for that part of the schedule domain that lies in the
 * intersection of "class_domain" and the separate option domain.
 *
 * "class_domain" may or may not include the constraints
 * of the schedule domain, but this does not make a difference
 * since we are going to intersect it with the domain of the inverse schedule.
 * If it includes schedule domain constraints, then they may involve
 * inner dimensions, but we will eliminate them in separation_domain.
 */
================================================================================

文件路径: ./isl_ast_codegen.c
注释行数: 37
注释内容:
/* Split up the domain at the current depth into disjoint
 * basic sets for which code should be generated separately
 * for the given separation class domain.
 *
 * If any separation classes have been defined, then "class_domain"
 * is the domain of the current class and does not refer to inner dimensions.
 * Otherwise, "class_domain" is the universe domain.
 *
 * We first make sure that the class domain is disjoint from
 * previously considered class domains.
 *
 * The separate domains can be computed directly from the "class_domain".
 *
 * The unroll, atomic and remainder domains need the constraints
 * from the schedule domain.
 *
 * For unrolling, the actual schedule domain is needed (with divs that
 * may refer to the current dimension) so that stride detection can be
 * performed.
 *
 * For atomic and remainder domains, inner dimensions and divs involving
 * the current dimensions should be eliminated.
 * In case we are working within a separation class, we need to intersect
 * the result with the current "class_domain" to ensure that the domains
 * are disjoint from those generated from other class domains.
 *
 * The domain that has been made atomic may be larger than specified
 * by the user since it needs to be representable as a single basic set.
 * This possibly larger domain is removed from class_domain by
 * compute_atomic_domain.  It is computed first so that the extended domain
 * would not overlap with any domains computed before.
 * Similary, the unrolled domains may have some constraints removed and
 * may therefore also be larger than specified by the user.
 *
 * If anything is left after handling separate, unroll and atomic,
 * we split it up into basic sets and append the basic sets to domains->list.
 */
================================================================================

文件路径: ./isl_ast_codegen.c
注释行数: 21
注释内容:
/* Split up the domain at the current depth into disjoint
 * basic sets for which code should be generated separately,
 * based on the user-specified options.
 * Return the list of disjoint basic sets.
 *
 * There are three kinds of domains that we need to keep track of.
 * - the "schedule domain" is the domain of "executed"
 * - the "class domain" is the domain corresponding to the currrent
 *	separation class
 * - the "option domain" is the domain corresponding to one of the options
 *	atomic, unroll or separate
 *
 * We first consider the individial values of the separation classes
 * and split up the domain for each of them separately.
 * Finally, we consider the remainder.  If no separation classes were
 * specified, then we call compute_partial_domains with the universe
 * "class_domain".  Otherwise, we take the "schedule_domain" as "class_domain",
 * with inner dimensions removed.  We do this because we want to
 * avoid computing the complement of the class domains (i.e., the difference
 * between the universe and domains->done).
 */
================================================================================

文件路径: ./isl_ast_codegen.c
注释行数: 32
注释内容:
/* Generate code for a single component, after shifting (if any)
 * has been applied, in case the schedule was specified as a schedule tree.
 * In particular, handle the base case where there is either no isolated
 * set or we are within the isolated set (in which case "isolated" is set)
 * or the iterations that precede or follow the isolated set.
 *
 * The schedule domain is broken up or combined into basic sets
 * according to the AST generation option specified in the current
 * schedule node, which may be either atomic, separate, unroll or
 * unspecified.  If the option is unspecified, then we currently simply
 * split the schedule domain into disjoint basic sets.
 *
 * In case the separate option is specified, the AST generation is
 * handled by generate_shifted_component_tree_separate.
 * In the other cases, we need the global schedule domain.
 * In the unroll case, the AST generation is then handled by
 * generate_shifted_component_tree_unroll which needs the actual
 * schedule domain (with divs that may refer to the current dimension)
 * so that stride detection can be performed.
 * In the atomic or unspecified case, inner dimensions and divs involving
 * the current dimensions should be eliminated.
 * The result is then either combined into a single basic set or
 * split up into disjoint basic sets.
 * Finally an AST is generated for each basic set and the results are
 * concatenated.
 *
 * If the schedule domain involves a disjunction that is purely based on
 * constraints involving only outer dimension, then it is treated as
 * if atomic was specified.  This ensures that only a single loop
 * is generated instead of a sequence of identical loops with
 * different guards.
 */
================================================================================

文件路径: ./isl_ast_codegen.c
注释行数: 28
注释内容:
/* Generate code for a single component, after shifting (if any)
 * has been applied, in case the schedule was specified as a schedule tree.
 *
 * We first check if the user has specified an isolated schedule domain
 * and that we are not already outside of this isolated schedule domain.
 * If so, we break up the schedule domain into iterations that
 * precede the isolated domain, the isolated domain itself,
 * the iterations that follow the isolated domain and
 * the remaining iterations (those that are incomparable
 * to the isolated domain).
 * We generate an AST for each piece and concatenate the results.
 *
 * If the isolated domain is not convex, then it is replaced
 * by a convex superset to ensure that the sets of preceding and
 * following iterations are properly defined and, in particular,
 * that there are no intermediate iterations that do not belong
 * to the isolated domain.
 *
 * In the special case where at least one element of the schedule
 * domain that does not belong to the isolated domain needs
 * to be scheduled after this isolated domain, but none of those
 * elements need to be scheduled before, break up the schedule domain
 * in only two parts, the isolated domain, and a part that will be
 * scheduled after the isolated domain.
 *
 * If no isolated set has been specified, then we generate an
 * AST for the entire inverse schedule.
 */
================================================================================

文件路径: ./isl_ast_codegen.c
注释行数: 18
注释内容:
/* Given an array "domain" of isl_set_map_pairs and an array "order"
 * of indices into the "domain" array,
 * find the element of "domain" (amongst those indexed by the first "n"
 * elements of "order") with the "set" field that has the smallest
 * value for the current iterator.
 *
 * Note that the domain with the smallest value may depend on the parameters
 * and/or outer loop dimension.  Since the result of this function is only
 * used as heuristic, we only make a reasonable attempt at finding the best
 * domain, one that should work in case a single domain provides the smallest
 * value for the current dimension over all values of the parameters
 * and outer dimensions.
 *
 * In particular, we compute the smallest value of the first domain
 * and replace it by that of any later domain if that later domain
 * has a smallest value that is smaller for at least some value
 * of the parameters and outer dimensions.
 */
================================================================================

文件路径: ./isl_ast_codegen.c
注释行数: 79
注释内容:
/* Construct a shifted inverse schedule based on the original inverse schedule,
 * the stride and the offset.
 *
 * The original inverse schedule is specified as the "map" fields
 * of the elements of "domain" indexed by the first "n" elements of "order".
 *
 * "stride" and "offset" are such that the difference
 * between the values of the current dimension of domain "i"
 * and the values of the current dimension for some reference domain are
 * equal to
 *
 *	stride * integer + offset[i]
 *
 * Moreover, 0 <= offset[i] < stride.
 *
 * For each domain, we create a map
 *
 *	{ [..., j, ...] -> [..., j - offset[i], offset[i], ....] }
 *
 * where j refers to the current dimension and the other dimensions are
 * unchanged, and apply this map to the original schedule domain.
 *
 * For example, for the original schedule
 *
 *	{ A[i] -> [2i]: 0 <= i < 10; B[i] -> [2i+1] : 0 <= i < 10 }
 *
 * and assuming the offset is 0 for the A domain and 1 for the B domain,
 * we apply the mapping
 *
 *	{ [j] -> [j, 0] }
 *
 * to the schedule of the "A" domain and the mapping
 *
 *	{ [j - 1] -> [j, 1] }
 *
 * to the schedule of the "B" domain.
 *
 *
 * Note that after the transformation, the differences between pairs
 * of values of the current dimension over all domains are multiples
 * of stride and that we have therefore exposed the stride.
 *
 *
 * To see that the mapping preserves the lexicographic order,
 * first note that each of the individual maps above preserves the order.
 * If the value of the current iterator is j1 in one domain and j2 in another,
 * then if j1 = j2, we know that the same map is applied to both domains
 * and the order is preserved.
 * Otherwise, let us assume, without loss of generality, that j1 < j2.
 * If c1 >= c2 (with c1 and c2 the corresponding offsets), then
 *
 *	j1 - c1 < j2 - c2
 *
 * and the order is preserved.
 * If c1 < c2, then we know
 *
 *	0 <= c2 - c1 < s
 *
 * We also have
 *
 *	j2 - j1 = n * s + r
 *
 * with n >= 0 and 0 <= r < s.
 * In other words, r = c2 - c1.
 * If n > 0, then
 *
 *	j1 - c1 < j2 - c2
 *
 * If n = 0, then
 *
 *	j1 - c1 = j2 - c2
 *
 * and so
 *
 *	(j1 - c1, c1) << (j2 - c2, c2)
 *
 * with "<<" the lexicographic order, proving that the order is preserved
 * in all cases.
 */
================================================================================

文件路径: ./isl_ast_codegen.c
注释行数: 26
注释内容:
/* Generate code for a single component, after exposing the stride,
 * given that the schedule domain is "shifted strided".
 *
 * The component inverse schedule is specified as the "map" fields
 * of the elements of "domain" indexed by the first "n" elements of "order".
 *
 * The schedule domain being "shifted strided" means that the differences
 * between the values of the current dimension of domain "i"
 * and the values of the current dimension for some reference domain are
 * equal to
 *
 *	stride * integer + offset[i]
 *
 * We first look for the domain with the "smallest" value for the current
 * dimension and adjust the offsets such that the offset of the "smallest"
 * domain is equal to zero.  The other offsets are reduced modulo stride.
 *
 * Based on this information, we construct a new inverse schedule in
 * construct_shifted_executed that exposes the stride.
 * Since this involves the introduction of a new schedule dimension,
 * the build needs to be changed accordingly.
 * After computing the AST, the newly introduced dimension needs
 * to be removed again from the list of grafts.  We do this by plugging
 * in a mapping that represents the new schedule domain in terms of the
 * old schedule domain.
 */
================================================================================

文件路径: ./isl_ast_codegen.c
注释行数: 70
注释内容:
/* Generate code for a single component.
 *
 * The component inverse schedule is specified as the "map" fields
 * of the elements of "domain" indexed by the first "n" elements of "order".
 *
 * This function may modify the "set" fields of "domain".
 *
 * Before proceeding with the actual code generation for the component,
 * we first check if there are any "shifted" strides, meaning that
 * the schedule domains of the individual domains are all strided,
 * but that they have different offsets, resulting in the union
 * of schedule domains not being strided anymore.
 *
 * The simplest example is the schedule
 *
 *	{ A[i] -> [2i]: 0 <= i < 10; B[i] -> [2i+1] : 0 <= i < 10 }
 *
 * Both schedule domains are strided, but their union is not.
 * This function detects such cases and then rewrites the schedule to
 *
 *	{ A[i] -> [2i, 0]: 0 <= i < 10; B[i] -> [2i, 1] : 0 <= i < 10 }
 *
 * In the new schedule, the schedule domains have the same offset (modulo
 * the stride), ensuring that the union of schedule domains is also strided.
 *
 *
 * If there is only a single domain in the component, then there is
 * nothing to do.   Similarly, if the current schedule dimension has
 * a fixed value for almost all domains then there is nothing to be done.
 * In particular, we need at least two domains where the current schedule
 * dimension does not have a fixed value.
 * Finally, in case of a schedule map input,
 * if any of the options refer to the current schedule dimension,
 * then we bail out as well.  It would be possible to reformulate the options
 * in terms of the new schedule domain, but that would introduce constraints
 * that separate the domains in the options and that is something we would
 * like to avoid.
 * In the case of a schedule tree input, we bail out if any of
 * the descendants of the current schedule node refer to outer
 * schedule nodes in any way.
 *
 *
 * To see if there is any shifted stride, we look at the differences
 * between the values of the current dimension in pairs of domains
 * for equal values of outer dimensions.  These differences should be
 * of the form
 *
 *	m x + r
 *
 * with "m" the stride and "r" a constant.  Note that we cannot perform
 * this analysis on individual domains as the lower bound in each domain
 * may depend on parameters or outer dimensions and so the current dimension
 * itself may not have a fixed remainder on division by the stride.
 *
 * In particular, we compare the first domain that does not have an
 * obviously fixed value for the current dimension to itself and all
 * other domains and collect the offsets and the gcd of the strides.
 * If the gcd becomes one, then we failed to find shifted strides.
 * If the gcd is zero, then the differences were all fixed, meaning
 * that some domains had non-obviously fixed values for the current dimension.
 * If all the offsets are the same (for those domains that do not have
 * an obviously fixed value for the current dimension), then we do not
 * apply the transformation.
 * If none of the domains were skipped, then there is nothing to do.
 * If some of them were skipped, then if we apply separation, the schedule
 * domain should get split in pieces with a (non-shifted) stride.
 *
 * Otherwise, we apply a shift to expose the stride in
 * generate_shift_component.
 */
================================================================================

文件路径: ./isl_ast_codegen.c
注释行数: 12
注释内容:
/* Is any domain element of "umap" scheduled after any of
 * the corresponding image elements by the tree rooted at
 * the band node "node"?
 *
 * We first check if any domain element is scheduled after any
 * of the corresponding image elements by the band node itself.
 * If not, we restrict "map" to those pairs of element that
 * are scheduled together by the band node and continue with
 * the child of the band node.
 * If there are no such pairs then the map passed to after_in_child
 * will be empty causing it to return 0.
 */
================================================================================

文件路径: ./isl_ast_codegen.c
注释行数: 10
注释内容:
/* Is any domain element of "umap" scheduled after any of
 * the corresponding image elements by the tree rooted at
 * the context node "node"?
 *
 * The context constraints apply to the schedule domain,
 * so we cannot apply them directly to "umap", which contains
 * pairs of statement instances.  Instead, we add them
 * to the range of the prefix schedule for both domain and
 * range of "umap".
 */
================================================================================

文件路径: ./isl_ast_codegen.c
注释行数: 10
注释内容:
/* Is any domain element of "umap" scheduled after any of
 * the corresponding image elements by the tree rooted at
 * the set node "node"?
 *
 * This is only the case if this condition holds in any
 * of the (filter) children of the set node.
 * In particular, if the domain and the range of "umap"
 * are contained in different children, then the condition
 * does not hold.
 */
================================================================================

文件路径: ./isl_ast_codegen.c
注释行数: 13
注释内容:
/* Is any domain element of "map1" scheduled after any domain
 * element of "map2" by the subtree underneath the current band node,
 * while at the same time being scheduled together by the current
 * band node, i.e., by "map1" and "map2?
 *
 * If the child of the current band node is a leaf, then
 * no element can be scheduled after any other element.
 *
 * Otherwise, we construct a relation between domain elements
 * of "map1" and domain elements of "map2" that are scheduled
 * together and then check if the subtree underneath the current
 * band node determines their relative order.
 */
================================================================================

文件路径: ./isl_ast_codegen.c
注释行数: 14
注释内容:
/* Is any element of domain "i" scheduled after any element of domain "j"
 * (for a common iteration of the first data->depth loops)?
 *
 * data->domain[i].set contains the domain of the inverse schedule
 * for domain "i", i.e., elements in the schedule domain.
 *
 * If we are inside a band of a schedule tree and there is a pair
 * of elements in the two domains that is schedule together by
 * the current band, then we check if any element of "i" may be schedule
 * after element of "j" by the descendants of the band node.
 *
 * If data->group_coscheduled is set, then we also return 1 if there
 * is any pair of elements in the two domains that are scheduled together.
 */
================================================================================

文件路径: ./isl_ast_codegen.c
注释行数: 20
注释内容:
/* Look for independent components at the current depth and generate code
 * for each component separately.  The resulting lists of grafts are
 * merged in an attempt to combine grafts with identical guards.
 *
 * Code for two domains can be generated separately if all the elements
 * of one domain are scheduled before (or together with) all the elements
 * of the other domain.  We therefore consider the graph with as nodes
 * the domains and an edge between two nodes if any element of the first
 * node is scheduled after any element of the second node.
 * If the ast_build_group_coscheduled is set, then we also add an edge if
 * there is any pair of elements in the two domains that are scheduled
 * together.
 * Code is then generated (by generate_component)
 * for each of the strongly connected components in this graph
 * in their topological order.
 *
 * Since the test is performed on the domain of the inverse schedules of
 * the different domains, we precompute these domains and store
 * them in data.domain.
 */
================================================================================

文件路径: ./isl_ast_codegen.c
注释行数: 14
注释内容:
/* Generate code for the next level (and all inner levels).
 *
 * If "executed" is empty, i.e., no code needs to be generated,
 * then we return an empty list.
 *
 * If we have already generated code for all loop levels, then we pass
 * control to generate_inner_level.
 *
 * If "executed" lives in a single space, i.e., if code needs to be
 * generated for a single domain, then there can only be a single
 * component and we go directly to generate_shifted_component.
 * Otherwise, we call generate_components to detect the components
 * and to call generate_component on each of them separately.
 */
================================================================================

文件路径: ./isl_ast_codegen.c
注释行数: 20
注释内容:
/* Given an inverse schedule in terms of the external build schedule, i.e.,
 *
 *	[E -> S] -> D
 *
 * with E the external build schedule and S the additional schedule "space",
 * reformulate the inverse schedule in terms of the internal schedule domain,
 * i.e., return
 *
 *	[I -> S] -> D
 *
 * We first obtain a mapping
 *
 *	I -> E
 *
 * take the inverse and the product with S -> S, resulting in
 *
 *	[I -> S] -> [E -> S]
 *
 * Applying the map to the input produces the desired result.
 */
================================================================================

文件路径: ./isl_ast_codegen.c
注释行数: 37
注释内容:
/* Generate an AST that visits the elements in the range of data->executed
 * in the relative order specified by the corresponding domain element(s)
 * for those domain elements that belong to "set".
 * Add the result to data->list.
 *
 * The caller ensures that "set" is a universe domain.
 * "space" is the space of the additional part of the schedule.
 * It is equal to the space of "set" if build->domain is parametric.
 * Otherwise, it is equal to the range of the wrapped space of "set".
 *
 * If the build space is not parametric and
 * if isl_ast_build_node_from_schedule_map
 * was called from an outside user (data->internal not set), then
 * the (inverse) schedule refers to the external build domain and needs to
 * be transformed to refer to the internal build domain.
 *
 * If the build space is parametric, then we add some of the parameter
 * constraints to the executed relation.  Adding these constraints
 * allows for an earlier detection of conflicts in some cases.
 * However, we do not want to divide the executed relation into
 * more disjuncts than necessary.  We therefore approximate
 * the constraints on the parameters by a single disjunct set.
 *
 * The build is extended to include the additional part of the schedule.
 * If the original build space was not parametric, then the options
 * in data->build refer only to the additional part of the schedule
 * and they need to be adjusted to refer to the complete AST build
 * domain.
 *
 * After having adjusted inverse schedule and build, we start generating
 * code with the outer loop of the current code generation
 * in generate_next_level.
 *
 * If the original build space was not parametric, we undo the embedding
 * on the resulting isl_ast_node_list so that it can be used within
 * the outer AST build.
 */
================================================================================

文件路径: ./isl_ast_codegen.c
注释行数: 17
注释内容:
/* Generate an AST that visits the elements in the range of data->executed
 * in the relative order specified by the corresponding domain element(s)
 * for those domain elements that belong to "set".
 * Add the result to data->list.
 *
 * The caller ensures that "set" is a universe domain.
 *
 * If the build space S is not parametric, then the space of "set"
 * need to be a wrapped relation with S as domain.  That is, it needs
 * to be of the form
 *
 *	[S -> T]
 *
 * Check this property and pass control to generate_code_in_space
 * passing along T.
 * If the build space is not parametric, then T is the space of "set".
 */
================================================================================

文件路径: ./isl_ast_codegen.c
注释行数: 23
注释内容:
/* Generate an AST that visits the elements in the range of "executed"
 * in the relative order specified by the corresponding domain element(s).
 *
 * "build" is an isl_ast_build that has either been constructed by
 * isl_ast_build_from_context or passed to a callback set by
 * isl_ast_build_set_create_leaf.
 * In the first case, the space of the isl_ast_build is typically
 * a parametric space, although this is currently not enforced.
 * In the second case, the space is never a parametric space.
 * If the space S is not parametric, then the domain space(s) of "executed"
 * need to be wrapped relations with S as domain.
 *
 * If the domain of "executed" consists of several spaces, then an AST
 * is generated for each of them (in arbitrary order) and the results
 * are concatenated.
 *
 * If "internal" is set, then the domain "S" above refers to the internal
 * schedule domain representation.  Otherwise, it refers to the external
 * representation, as returned by isl_ast_build_get_schedule_space.
 *
 * We essentially run over all the spaces in the domain of "executed"
 * and call generate_code_set on each of them.
 */
================================================================================

文件路径: ./isl_ast_codegen.c
注释行数: 25
注释内容:
/* Generate an AST that visits the elements in the domain of "schedule"
 * in the relative order specified by the corresponding image element(s).
 *
 * "build" is an isl_ast_build that has either been constructed by
 * isl_ast_build_from_context or passed to a callback set by
 * isl_ast_build_set_create_leaf.
 * In the first case, the space of the isl_ast_build is typically
 * a parametric space, although this is currently not enforced.
 * In the second case, the space is never a parametric space.
 * If the space S is not parametric, then the range space(s) of "schedule"
 * need to be wrapped relations with S as domain.
 *
 * If the range of "schedule" consists of several spaces, then an AST
 * is generated for each of them (in arbitrary order) and the results
 * are concatenated.
 *
 * We first initialize the local copies of the relevant options.
 * We do this here rather than when the isl_ast_build is created
 * because the options may have changed between the construction
 * of the isl_ast_build and the call to isl_generate_code.
 *
 * The main computation is performed on an inverse schedule (with
 * the schedule domain in the domain and the elements to be executed
 * in the range) called "executed".
 */
================================================================================

文件路径: ./isl_ast_codegen.c
注释行数: 17
注释内容:
/* Generate an AST that visits the elements in the domain of "executed"
 * in the relative order specified by the leaf node "node".
 *
 * The relation "executed" maps the outer generated loop iterators
 * to the domain elements executed by those iterations.
 *
 * Simply pass control to generate_inner_level.
 * Note that the current build does not refer to any band node, so
 * that generate_inner_level will not try to visit the child of
 * the leaf node.
 *
 * If multiple statement instances reach a leaf,
 * then they can be executed in any order.
 * Group the list of grafts based on shared guards
 * such that identical guards are only generated once
 * when the list is eventually passed on to isl_ast_graft_list_fuse.
 */
================================================================================

文件路径: ./isl_ast_codegen.c
注释行数: 14
注释内容:
/* Generate an AST that visits the elements in the domain of "executed"
 * in the relative order specified by the band node "node" and its descendants.
 *
 * The relation "executed" maps the outer generated loop iterators
 * to the domain elements executed by those iterations.
 *
 * If the band is empty, we continue with its descendants.
 * Otherwise, we extend the build and the inverse schedule with
 * the additional space/partial schedule and continue generating
 * an AST in generate_next_level.
 * As soon as we have extended the inverse schedule with the additional
 * partial schedule, we look for equalities that may exists between
 * the old and the new part.
 */
================================================================================

文件路径: ./isl_ast_codegen.c
注释行数: 32
注释内容:
/* Generate an AST that visits the elements in the domain of "executed"
 * in the relative order specified by the context node "node"
 * and its descendants.
 *
 * The relation "executed" maps the outer generated loop iterators
 * to the domain elements executed by those iterations.
 *
 * The context node may introduce additional parameters as well as
 * constraints on the outer schedule dimensions or original parameters.
 *
 * We add the extra parameters to a new build and the context
 * constraints to both the build and (as a single disjunct)
 * to the domain of "executed".  Since the context constraints
 * are specified in terms of the input schedule, we first need
 * to map them to the internal schedule domain.
 *
 * After constructing the AST from the descendants of "node",
 * we combine the list of grafts into a single graft within
 * the new build, in order to be able to exploit the additional
 * context constraints during this combination.
 *
 * Additionally, if the current node is the outermost node in
 * the schedule tree (apart from the root domain node), we generate
 * all pending guards, again to be able to exploit the additional
 * context constraints.  We currently do not do this for internal
 * context nodes since we may still want to hoist conditions
 * to outer AST nodes.
 *
 * If the context node introduced any new parameters, then they
 * are removed from the set of enforced constraints and guard
 * in hoist_out_of_context.
 */
================================================================================

文件路径: ./isl_ast_codegen.c
注释行数: 10
注释内容:
/* Generate an AST that visits the elements in the domain of "executed"
 * in the relative order specified by the expansion node "node" and
 * its descendants.
 *
 * The relation "executed" maps the outer generated loop iterators
 * to the domain elements executed by those iterations.
 *
 * We expand the domain elements by the expansion and
 * continue with the descendants of the node.
 */
================================================================================

文件路径: ./isl_ast_codegen.c
注释行数: 12
注释内容:
/* Generate an AST that visits the elements in the domain of "executed"
 * in the relative order specified by the extension node "node" and
 * its descendants.
 *
 * The relation "executed" maps the outer generated loop iterators
 * to the domain elements executed by those iterations.
 *
 * Extend the inverse schedule with the extension applied to current
 * set of generated constraints.  Since the extension if formulated
 * in terms of the input schedule, it first needs to be transformed
 * to refer to the internal schedule.
 */
================================================================================

文件路径: ./isl_ast_codegen.c
注释行数: 17
注释内容:
/* Generate an AST that visits the elements in the domain of "executed"
 * in the relative order specified by the filter node "node" and
 * its descendants.
 *
 * The relation "executed" maps the outer generated loop iterators
 * to the domain elements executed by those iterations.
 *
 * We simply intersect the iteration domain (i.e., the range of "executed")
 * with the filter and continue with the descendants of the node,
 * unless the resulting inverse schedule is empty, in which
 * case we return an empty list.
 *
 * If the result of the intersection is equal to the original "executed"
 * relation, then keep the original representation since the intersection
 * may have unnecessarily broken up the relation into a greater number
 * of disjuncts.
 */
================================================================================

文件路径: ./isl_ast_codegen.c
注释行数: 13
注释内容:
/* Generate an AST that visits the elements in the domain of "executed"
 * in the relative order specified by the guard node "node" and
 * its descendants.
 *
 * The relation "executed" maps the outer generated loop iterators
 * to the domain elements executed by those iterations.
 *
 * Ensure that the associated guard is enforced by the outer AST
 * constructs by adding it to the guard of the graft.
 * Since we know that we will enforce the guard, we can also include it
 * in the generated constraints used to construct an AST for
 * the descendant nodes.
 */
================================================================================

文件路径: ./isl_ast_codegen.c
注释行数: 13
注释内容:
/* Generate an AST that visits the elements in the domain of "executed"
 * in the relative order specified by the mark node "node" and
 * its descendants.
 *
 * The relation "executed" maps the outer generated loop iterators
 * to the domain elements executed by those iterations.

 * Since we may be calling before_each_mark and after_each_mark
 * callbacks, we record the current inverse schedule in the build.
 *
 * We generate an AST for the child of the mark node, combine
 * the graft list into a single graft and then insert the mark
 * in the AST of that single graft.
 */
================================================================================

文件路径: ./isl_ast_codegen.c
注释行数: 10
注释内容:
/* Generate an AST that visits the elements in the domain of "executed"
 * in the relative order specified by the sequence (or set) node "node" and
 * its descendants.
 *
 * The relation "executed" maps the outer generated loop iterators
 * to the domain elements executed by those iterations.
 *
 * We simply generate an AST for each of the children and concatenate
 * the results.
 */
================================================================================

文件路径: ./isl_ast_codegen.c
注释行数: 11
注释内容:
/* Generate an AST that visits the elements in the domain of "executed"
 * in the relative order specified by the node "node" and its descendants.
 *
 * The relation "executed" maps the outer generated loop iterators
 * to the domain elements executed by those iterations.
 *
 * The node types are handled in separate functions.
 * Set nodes are currently treated in the same way as sequence nodes.
 * The children of a set node may be executed in any order,
 * including the order of the children.
 */
================================================================================

文件路径: ./isl_ast_codegen.c
注释行数: 10
注释内容:
/* Generate an AST that visits the elements in the domain of "executed"
 * in the relative order specified by the (single) child of "node" and
 * its descendants.
 *
 * The relation "executed" maps the outer generated loop iterators
 * to the domain elements executed by those iterations.
 *
 * This function is never called on a leaf, set or sequence node,
 * so the node always has exactly one child.
 */
================================================================================

文件路径: ./isl_ast_codegen.c
注释行数: 15
注释内容:
/* Generate an AST that visits the elements in the domain of the domain
 * node "node" in the relative order specified by its descendants.
 *
 * An initial inverse schedule is created that maps a zero-dimensional
 * schedule space to the node domain.
 * The input "build" is assumed to have a parametric domain and
 * is replaced by the same zero-dimensional schedule space.
 *
 * We also add some of the parameter constraints in the build domain
 * to the executed relation.  Adding these constraints
 * allows for an earlier detection of conflicts in some cases.
 * However, we do not want to divide the executed relation into
 * more disjuncts than necessary.  We therefore approximate
 * the constraints on the parameters by a single disjunct set.
 */
================================================================================

文件路径: ./isl_ast_codegen.c
注释行数: 10
注释内容:
/* Generate an AST that visits the elements in the domain of "schedule"
 * in the relative order specified by the schedule tree.
 *
 * "build" is an isl_ast_build that has been created using
 * isl_ast_build_alloc or isl_ast_build_from_context based
 * on a parametric set.
 *
 * The construction starts at the root node of the schedule,
 * which is assumed to be a domain node.
 */
================================================================================

文件路径: ./isl_bernstein.c
注释行数: 14
注释内容:
/*
 * Copyright 2006-2007 Universiteit Leiden
 * Copyright 2008-2009 Katholieke Universiteit Leuven
 * Copyright 2010      INRIA Saclay
 *
 * Use of this software is governed by the MIT license
 *
 * Written by Sven Verdoolaege, Leiden Institute of Advanced Computer Science,
 * Universiteit Leiden, Niels Bohrweg 1, 2333 CA Leiden, The Netherlands
 * and K.U.Leuven, Departement Computerwetenschappen, Celestijnenlaan 200A,
 * B-3001 Leuven, Belgium
 * and INRIA Saclay - Ile-de-France, Parc Club Orsay Universite,
 * ZAC des vignes, 4 rue Jacques Monod, 91893 Orsay, France
 */
================================================================================

文件路径: ./isl_bernstein.c
注释行数: 10
注释内容:
/* Extract the coefficients of the Bernstein base polynomials and store
 * them in data->fold and data->fold_tight.
 *
 * In particular, the coefficient of each monomial
 * of multi-degree (k[0], k[1], ..., k[n-1]) is divided by the corresponding
 * multinomial coefficient d!/k[0]! k[1]! ... k[n-1]!
 *
 * c[i] contains the coefficient of the selected powers of the first i+1 vars.
 * multinom[i] contains the partial multinomial coefficient.
 */
================================================================================

文件路径: ./isl_bernstein.c
注释行数: 12
注释内容:
/* Perform bernstein expansion on the parametric vertices that are active
 * on "cell".
 *
 * data->poly has been homogenized in the calling function.
 *
 * We plug in the barycentric coordinates for the set variables
 *
 *		\vec x = \sum_i \alpha_i v_i(\vec p)
 *
 * and the constant "1 = \sum_i \alpha_i" for the homogeneous dimension.
 * Next, we extract the coefficients of the Bernstein base polynomials.
 */
================================================================================

文件路径: ./isl_bernstein.c
注释行数: 11
注释内容:
/* Base case of applying bernstein expansion.
 *
 * We compute the chamber decomposition of the parametric polytope "bset"
 * and then perform bernstein expansion on the parametric vertices
 * that are active on each chamber.
 *
 * If the polynomial does not depend on the set variables
 * (and in particular if the number of set variables is zero)
 * then the bound is equal to the polynomial and
 * no actual bernstein expansion needs to be performed.
 */
================================================================================

文件路径: ./isl_bernstein.c
注释行数: 11
注释内容:
/* Compute a bound on the polynomial defined over the parametric polytope
 * using bernstein expansion and store the result
 * in bound->pwf and bound->pwf_tight.
 *
 * If bernstein_recurse is set to ISL_BERNSTEIN_FACTORS, we check if
 * the polytope can be factorized and apply bernstein expansion recursively
 * on the factors.
 * If bernstein_recurse is set to ISL_BERNSTEIN_INTERVALS, we apply
 * bernstein expansion recursively on each dimension.
 * Otherwise, we apply bernstein expansion on the entire polytope.
 */
================================================================================

文件路径: ./isl_scheduler.c
注释行数: 16
注释内容:
/*
 * Copyright 2011      INRIA Saclay
 * Copyright 2012-2014 Ecole Normale Superieure
 * Copyright 2015-2016 Sven Verdoolaege
 * Copyright 2016      INRIA Paris
 * Copyright 2017      Sven Verdoolaege
 *
 * Use of this software is governed by the MIT license
 *
 * Written by Sven Verdoolaege, INRIA Saclay - Ile-de-France,
 * Parc Club Orsay Universite, ZAC des vignes, 4 rue Jacques Monod,
 * 91893 Orsay, France
 * and Ecole Normale Superieure, 45 rue d'Ulm, 75230 Paris, France
 * and Centre de Recherche Inria de Paris, 2 rue Simone Iff - Voie DQ12,
 * CS 42112, 75589 Paris Cedex 12, France
 */
================================================================================

文件路径: ./isl_scheduler.c
注释行数: 51
注释内容:
/* Internal information about a node that is used during the construction
 * of a schedule.
 * space represents the original space in which the domain lives;
 *	that is, the space is not affected by compression
 * sched is a matrix representation of the schedule being constructed
 *	for this node; if compressed is set, then this schedule is
 *	defined over the compressed domain space
 * sched_map is an isl_map representation of the same (partial) schedule
 *	sched_map may be NULL; if compressed is set, then this map
 *	is defined over the uncompressed domain space
 * rank is the number of linearly independent rows in the linear part
 *	of sched
 * the rows of "vmap" represent a change of basis for the node
 *	variables; the first rank rows span the linear part of
 *	the schedule rows; the remaining rows are linearly independent
 * the rows of "indep" represent linear combinations of the schedule
 * coefficients that are non-zero when the schedule coefficients are
 * linearly independent of previously computed schedule rows.
 * start is the first variable in the LP problem in the sequences that
 *	represents the schedule coefficients of this node
 * nvar is the dimension of the (compressed) domain
 * nparam is the number of parameters or 0 if we are not constructing
 *	a parametric schedule
 *
 * If compressed is set, then hull represents the constraints
 * that were used to derive the compression, while compress and
 * decompress map the original space to the compressed space and
 * vice versa.
 *
 * scc is the index of SCC (or WCC) this node belongs to
 *
 * "cluster" is only used inside extract_clusters and identifies
 * the cluster of SCCs that the node belongs to.
 *
 * coincident contains a boolean for each of the rows of the schedule,
 * indicating whether the corresponding scheduling dimension satisfies
 * the coincidence constraints in the sense that the corresponding
 * dependence distances are zero.
 *
 * If the schedule_treat_coalescing option is set, then
 * "sizes" contains the sizes of the (compressed) instance set
 * in each direction.  If there is no fixed size in a given direction,
 * then the corresponding size value is set to infinity.
 * If the schedule_treat_coalescing option or the schedule_max_coefficient
 * option is set, then "max" contains the maximal values for
 * schedule coefficients of the (compressed) variables.  If no bound
 * needs to be imposed on a particular variable, then the corresponding
 * value is negative.
 * If not NULL, then "bounds" contains a non-parametric set
 * in the compressed space that is bounded by the size in each direction.
 */
================================================================================

文件路径: ./isl_scheduler.c
注释行数: 39
注释内容:
/* An edge in the dependence graph.  An edge may be used to
 * ensure validity of the generated schedule, to minimize the dependence
 * distance or both
 *
 * map is the dependence relation, with i -> j in the map if j depends on i
 * tagged_condition and tagged_validity contain the union of all tagged
 *	condition or conditional validity dependence relations that
 *	specialize the dependence relation "map"; that is,
 *	if (i -> a) -> (j -> b) is an element of "tagged_condition"
 *	or "tagged_validity", then i -> j is an element of "map".
 *	If these fields are NULL, then they represent the empty relation.
 * src is the source node
 * dst is the sink node
 *
 * types is a bit vector containing the types of this edge.
 * validity is set if the edge is used to ensure correctness
 * coincidence is used to enforce zero dependence distances
 * proximity is set if the edge is used to minimize dependence distances
 * condition is set if the edge represents a condition
 *	for a conditional validity schedule constraint
 * local can only be set for condition edges and indicates that
 *	the dependence distance over the edge should be zero
 * conditional_validity is set if the edge is used to conditionally
 *	ensure correctness
 *
 * For validity edges, start and end mark the sequence of inequality
 * constraints in the LP problem that encode the validity constraint
 * corresponding to this edge.
 *
 * During clustering, an edge may be marked "no_merge" if it should
 * not be used to merge clusters.
 * The weight is also only used during clustering and it is
 * an indication of how many schedule dimensions on either side
 * of the schedule constraints can be aligned.
 * If the weight is negative, then this means that this edge was postponed
 * by has_bounded_distances or any_no_merge.  The original weight can
 * be retrieved by adding 1 + graph->max_weight, with "graph"
 * the graph containing this edge.
 */
================================================================================

文件路径: ./isl_scheduler.c
注释行数: 57
注释内容:
/* Internal information about the dependence graph used during
 * the construction of the schedule.
 *
 * intra_hmap is a cache, mapping dependence relations to their dual,
 *	for dependences from a node to itself, possibly without
 *	coefficients for the parameters
 * intra_hmap_param is a cache, mapping dependence relations to their dual,
 *	for dependences from a node to itself, including coefficients
 *	for the parameters
 * inter_hmap is a cache, mapping dependence relations to their dual,
 *	for dependences between distinct nodes
 * if compression is involved then the key for these maps
 * is the original, uncompressed dependence relation, while
 * the value is the dual of the compressed dependence relation.
 *
 * n is the number of nodes
 * node is the list of nodes
 * maxvar is the maximal number of variables over all nodes
 * max_row is the allocated number of rows in the schedule
 * n_row is the current (maximal) number of linearly independent
 *	rows in the node schedules
 * n_total_row is the current number of rows in the node schedules
 * band_start is the starting row in the node schedules of the current band
 * root is set to the original dependence graph from which this graph
 *	is derived through splitting.  If this graph is not the result of
 *	splitting, then the root field points to the graph itself.
 *
 * sorted contains a list of node indices sorted according to the
 *	SCC to which a node belongs
 *
 * n_edge is the number of edges
 * edge is the list of edges
 * max_edge contains the maximal number of edges of each type;
 *	in particular, it contains the number of edges in the inital graph.
 * edge_table contains pointers into the edge array, hashed on the source
 *	and sink spaces; there is one such table for each type;
 *	a given edge may be referenced from more than one table
 *	if the corresponding relation appears in more than one of the
 *	sets of dependences; however, for each type there is only
 *	a single edge between a given pair of source and sink space
 *	in the entire graph
 *
 * node_table contains pointers into the node array, hashed on the space tuples
 *
 * region contains a list of variable sequences that should be non-trivial
 *
 * lp contains the (I)LP problem used to obtain new schedule rows
 *
 * src_scc and dst_scc are the source and sink SCCs of an edge with
 *	conflicting constraints
 *
 * scc represents the number of components
 * weak is set if the components are weakly connected
 *
 * max_weight is used during clustering and represents the maximal
 * weight of the relevant proximity edges.
 */
================================================================================

文件路径: ./isl_scheduler.c
注释行数: 11
注释内容:
/* Check whether the dependence graph has a validity edge
 * between the given two nodes.
 *
 * Conditional validity edges are essentially validity edges that
 * can be ignored if the corresponding condition edges are iteration private.
 * Here, we are only checking for the presence of validity
 * edges, so we need to consider the conditional validity edges too.
 * In particular, this function is used during the detection
 * of strongly connected components and we cannot ignore
 * conditional validity edges during this detection.
 */
================================================================================

文件路径: ./isl_scheduler.c
注释行数: 15
注释内容:
/* Set the entries of node->max to the minimum of the schedule_max_coefficient
 * option (if set) and half of the minimum of the sizes in the other
 * dimensions.  Round up when computing the half such that
 * if the minimum of the sizes is one, half of the size is taken to be one
 * rather than zero.
 * If the global minimum is unbounded (i.e., if both
 * the schedule_max_coefficient is not set and the sizes in the other
 * dimensions are unbounded), then store a negative value.
 * If the schedule coefficient is close to the size of the instance set
 * in another dimension, then the schedule may represent a loop
 * coalescing transformation (especially if the coefficient
 * in that other dimension is one).  Forcing the coefficient to be
 * smaller than or equal to half the minimal size should avoid this
 * situation.
 */
================================================================================

文件路径: ./isl_scheduler.c
注释行数: 16
注释内容:
/* Compute and return the size of "set" in dimension "dim".
 * The size is taken to be the difference in values for that variable
 * for fixed values of the other variables.
 * This assumes that "set" is convex.
 * In particular, the variable is first isolated from the other variables
 * in the range of a map
 *
 *	[i_0, ..., i_dim-1, i_dim+1, ...] -> [i_dim]
 *
 * and then duplicated
 *
 *	[i_0, ..., i_dim-1, i_dim+1, ...] -> [[i_dim] -> [i_dim']]
 *
 * The shared variables are then projected out and the maximal value
 * of i_dim' - i_dim is computed.
 */
================================================================================

文件路径: ./isl_scheduler.c
注释行数: 15
注释内容:
/* Perform a compression on "node" where "hull" represents the constraints
 * that were used to derive the compression, while "compress" and
 * "decompress" map the original space to the compressed space and
 * vice versa.
 *
 * If "node" was not compressed already, then simply store
 * the compression information.
 * Otherwise the "original" space is actually the result
 * of a previous compression, which is then combined
 * with the present compression.
 *
 * The dimensionality of the compressed domain is also adjusted.
 * Other information, such as the sizes and the maximal coefficient values,
 * has not been computed yet and therefore does not need to be adjusted.
 */
================================================================================

文件路径: ./isl_scheduler.c
注释行数: 20
注释内容:
/* Given that dimension "pos" in "set" has a fixed value
 * in terms of the other dimensions, (further) compress "node"
 * by projecting out this dimension.
 * "set" may be the result of a previous compression.
 * "uncompressed" is the original domain (without compression).
 *
 * The compression function simply projects out the dimension.
 * The decompression function adds back the dimension
 * in the right position as an expression of the other dimensions
 * derived from "set".
 * As in extract_node, the compressed space has an identifier
 * that references "node" such that each compressed space is unique and
 * such that the node can be recovered from the compressed space.
 *
 * The constraint removed through the compression is added to the "hull"
 * such that only edges that relate to the original domains
 * are taken into account.
 * In particular, it is obtained by composing compression and decompression and
 * taking the relation among the variables in the range.
 */
================================================================================

文件路径: ./isl_scheduler.c
注释行数: 16
注释内容:
/* Compute the size of the compressed domain in each dimension and
 * store the results in node->sizes.
 * "uncompressed" is the original domain (without compression).
 *
 * First compress the domain if needed and then compute the size
 * in each direction.
 * If the domain is not convex, then the sizes are computed
 * on a convex superset in order to avoid picking up sizes
 * that are valid for the individual disjuncts, but not for
 * the domain as a whole.
 *
 * If any of the sizes turns out to be zero, then this means
 * that this dimension has a fixed value in terms of
 * the other dimensions.  Perform an (extra) compression
 * to remove this dimensions.
 */
================================================================================

文件路径: ./isl_scheduler.c
注释行数: 14
注释内容:
/* Compute the size of the instance set "set" of "node", after compression,
 * as well as bounds on the corresponding coefficients, if needed.
 *
 * The sizes are needed when the schedule_treat_coalescing option is set.
 * The bounds are needed when the schedule_treat_coalescing option or
 * the schedule_max_coefficient option is set.
 *
 * If the schedule_treat_coalescing option is not set, then at most
 * the bounds need to be set and this is done in set_max_coefficient.
 * Otherwise, compute the size of the compressed domain
 * in each direction and store the results in node->size.
 * Finally, set the bounds on the coefficients based on the sizes
 * and the schedule_max_coefficient option in compute_max_coefficient.
 */
================================================================================

文件路径: ./isl_scheduler.c
注释行数: 14
注释内容:
/* Add a new node to the graph representing the given instance set.
 * "nvar" is the (possibly compressed) number of variables and
 * may be smaller than then number of set variables in "set"
 * if "compressed" is set.
 * If "compressed" is set, then "hull" represents the constraints
 * that were used to derive the compression, while "compress" and
 * "decompress" map the original space to the compressed space and
 * vice versa.
 * If "compressed" is not set, then "hull", "compress" and "decompress"
 * should be NULL.
 *
 * Compute the size of the instance set and bounds on the coefficients,
 * if needed.
 */
================================================================================

文件路径: ./isl_scheduler.c
注释行数: 13
注释内容:
/* Insert dummy tags in domain and range of "map".
 *
 * In particular, if "map" is of the form
 *
 *	A -> B
 *
 * then return
 *
 *	[A -> dummy_tag] -> [B -> dummy_tag]
 *
 * where the dummy_tags are identical and equal to any dummy tags
 * introduced by any other call to this function.
 */
================================================================================

文件路径: ./isl_scheduler.c
注释行数: 23
注释内容:
/* Add a new edge to the graph based on the given map
 * and add it to data->graph->edge_table[data->type].
 * If a dependence relation of a given type happens to be identical
 * to one of the dependence relations of a type that was added before,
 * then we don't create a new edge, but instead mark the original edge
 * as also representing a dependence of the current type.
 *
 * Edges of type isl_edge_condition or isl_edge_conditional_validity
 * may be specified as "tagged" dependence relations.  That is, "map"
 * may contain elements (i -> a) -> (j -> b), where i -> j denotes
 * the dependence on iterations and a and b are tags.
 * edge->map is set to the relation containing the elements i -> j,
 * while edge->tagged_condition and edge->tagged_validity contain
 * the union of all the "map" relations
 * for which extract_edge is called that result in the same edge->map.
 *
 * If the source or the destination node is compressed, then
 * intersect both "map" and "tagged" with the constraints that
 * were used to construct the compression.
 * This ensures that there are no schedule constraints defined
 * outside of these domains, while the scheduler no longer has
 * any control over those outside parts.
 */
================================================================================

文件路径: ./isl_scheduler.c
注释行数: 10
注释内容:
/* Return a non-parametric set in the compressed space of "node" that is
 * bounded by the size in each direction
 *
 *	{ [x] : -S_i <= x_i <= S_i }
 *
 * If S_i is infinity in direction i, then there are no constraints
 * in that direction.
 *
 * Cache the result in node->bounds.
 */
================================================================================

文件路径: ./isl_scheduler.c
注释行数: 31
注释内容:
/* Given a dependence relation R from "node" to itself,
 * construct the set of coefficients of valid constraints for elements
 * in that dependence relation.
 * In particular, the result contains tuples of coefficients
 * c_0, c_n, c_x such that
 *
 *	c_0 + c_n n + c_x y - c_x x >= 0 for each (x,y) in R
 *
 * or, equivalently,
 *
 *	c_0 + c_n n + c_x d >= 0 for each d in delta R = { y - x | (x,y) in R }
 *
 * We choose here to compute the dual of delta R.
 * Alternatively, we could have computed the dual of R, resulting
 * in a set of tuples c_0, c_n, c_x, c_y, and then
 * plugged in (c_0, c_n, c_x, -c_x).
 *
 * If "need_param" is set, then the resulting coefficients effectively
 * include coefficients for the parameters c_n.  Otherwise, they may
 * have been projected out already.
 * Since the constraints may be different for these two cases,
 * they are stored in separate caches.
 * In particular, if no parameter coefficients are required and
 * the schedule_treat_coalescing option is set, then the parameters
 * are projected out and some constraints that could be exploited
 * to construct coalescing schedules are removed before the dual
 * is computed.
 *
 * If "node" has been compressed, then the dependence relation
 * is also compressed before the set of coefficients is computed.
 */
================================================================================

文件路径: ./isl_scheduler.c
注释行数: 11
注释内容:
/* Given a dependence relation R, construct the set of coefficients
 * of valid constraints for elements in that dependence relation.
 * In particular, the result contains tuples of coefficients
 * c_0, c_n, c_x, c_y such that
 *
 *	c_0 + c_n n + c_x x + c_y y >= 0 for each (x,y) in R
 *
 * If the source or destination nodes of "edge" have been compressed,
 * then the dependence relation is also compressed before
 * the set of coefficients is computed.
 */
================================================================================

文件路径: ./isl_scheduler.c
注释行数: 20
注释内容:
/* Construct an isl_dim_map for mapping constraints on coefficients
 * for "node" to the corresponding positions in graph->lp.
 * "offset" is the offset of the coefficients for the variables
 * in the input constraints.
 * "s" is the sign of the mapping.
 *
 * The input constraints are given in terms of the coefficients
 * (c_0, c_x) or (c_0, c_n, c_x).
 * The mapping produced by this function essentially plugs in
 * (0, c_i_x^+ - c_i_x^-) if s = 1 and
 * (0, -c_i_x^+ + c_i_x^-) if s = -1 or
 * (0, 0, c_i_x^+ - c_i_x^-) if s = 1 and
 * (0, 0, -c_i_x^+ + c_i_x^-) if s = -1.
 * In graph->lp, the c_i_x^- appear before their c_i_x^+ counterpart.
 * Furthermore, the order of these pairs is the opposite of that
 * of the corresponding coefficients.
 *
 * The caller can extend the mapping to also map the other coefficients
 * (and therefore not plug in 0).
 */
================================================================================

文件路径: ./isl_scheduler.c
注释行数: 20
注释内容:
/* Construct an isl_dim_map for mapping constraints on coefficients
 * for "src" (node i) and "dst" (node j) to the corresponding positions
 * in graph->lp.
 * "offset" is the offset of the coefficients for the variables of "src"
 * in the input constraints.
 * "s" is the sign of the mapping.
 *
 * The input constraints are given in terms of the coefficients
 * (c_0, c_n, c_x, c_y).
 * The mapping produced by this function essentially plugs in
 * (c_j_0 - c_i_0, c_j_n - c_i_n,
 *  -(c_i_x^+ - c_i_x^-), c_j_x^+ - c_j_x^-) if s = 1 and
 * (-c_j_0 + c_i_0, -c_j_n + c_i_n,
 *  c_i_x^+ - c_i_x^-, -(c_j_x^+ - c_j_x^-)) if s = -1.
 * In graph->lp, the c_*^- appear before their c_*^+ counterpart.
 * Furthermore, the order of these pairs is the opposite of that
 * of the corresponding coefficients.
 *
 * The caller can further extend the mapping.
 */
================================================================================

文件路径: ./isl_scheduler.c
注释行数: 15
注释内容:
/* Add constraints to graph->lp that force validity for the given
 * dependence from a node i to itself.
 * That is, add constraints that enforce
 *
 *	(c_i_0 + c_i_n n + c_i_x y) - (c_i_0 + c_i_n n + c_i_x x)
 *	= c_i_x (y - x) >= 0
 *
 * for each (x,y) in R.
 * We obtain general constraints on coefficients (c_0, c_x)
 * of valid constraints for (y - x) and then plug in (0, c_i_x^+ - c_i_x^-),
 * where c_i_x = c_i_x^+ - c_i_x^-, with c_i_x^+ and c_i_x^- non-negative.
 * In graph->lp, the c_i_x^- appear before their c_i_x^+ counterpart.
 * Note that the result of intra_coefficients may also contain
 * parameter coefficients c_n, in which case 0 is plugged in for them as well.
 */
================================================================================

文件路径: ./isl_scheduler.c
注释行数: 13
注释内容:
/* Add constraints to graph->lp that force validity for the given
 * dependence from node i to node j.
 * That is, add constraints that enforce
 *
 *	(c_j_0 + c_j_n n + c_j_x y) - (c_i_0 + c_i_n n + c_i_x x) >= 0
 *
 * for each (x,y) in R.
 * We obtain general constraints on coefficients (c_0, c_n, c_x, c_y)
 * of valid constraints for R and then plug in
 * (c_j_0 - c_i_0, c_j_n - c_i_n, -(c_i_x^+ - c_i_x^-), c_j_x^+ - c_j_x^-),
 * where c_* = c_*^+ - c_*^-, with c_*^+ and c_*^- non-negative.
 * In graph->lp, the c_*^- appear before their c_*^+ counterpart.
 */
================================================================================

文件路径: ./isl_scheduler.c
注释行数: 42
注释内容:
/* Add constraints to graph->lp that bound the dependence distance for the given
 * dependence from a node i to itself.
 * If s = 1, we add the constraint
 *
 *	c_i_x (y - x) <= m_0 + m_n n
 *
 * or
 *
 *	-c_i_x (y - x) + m_0 + m_n n >= 0
 *
 * for each (x,y) in R.
 * If s = -1, we add the constraint
 *
 *	-c_i_x (y - x) <= m_0 + m_n n
 *
 * or
 *
 *	c_i_x (y - x) + m_0 + m_n n >= 0
 *
 * for each (x,y) in R.
 * We obtain general constraints on coefficients (c_0, c_n, c_x)
 * of valid constraints for (y - x) and then plug in (m_0, m_n, -s * c_i_x),
 * with each coefficient (except m_0) represented as a pair of non-negative
 * coefficients.
 *
 *
 * If "local" is set, then we add constraints
 *
 *	c_i_x (y - x) <= 0
 *
 * or
 *
 *	-c_i_x (y - x) <= 0
 *
 * instead, forcing the dependence distance to be (less than or) equal to 0.
 * That is, we plug in (0, 0, -s * c_i_x),
 * intra_coefficients is not required to have c_n in its result when
 * "local" is set.  If they are missing, then (0, -s * c_i_x) is plugged in.
 * Note that dependences marked local are treated as validity constraints
 * by add_all_validity_constraints and therefore also have
 * their distances bounded by 0 from below.
 */
================================================================================

文件路径: ./isl_scheduler.c
注释行数: 47
注释内容:
/* Add constraints to graph->lp that bound the dependence distance for the given
 * dependence from node i to node j.
 * If s = 1, we add the constraint
 *
 *	(c_j_0 + c_j_n n + c_j_x y) - (c_i_0 + c_i_n n + c_i_x x)
 *		<= m_0 + m_n n
 *
 * or
 *
 *	-(c_j_0 + c_j_n n + c_j_x y) + (c_i_0 + c_i_n n + c_i_x x) +
 *		m_0 + m_n n >= 0
 *
 * for each (x,y) in R.
 * If s = -1, we add the constraint
 *
 *	-((c_j_0 + c_j_n n + c_j_x y) - (c_i_0 + c_i_n n + c_i_x x))
 *		<= m_0 + m_n n
 *
 * or
 *
 *	(c_j_0 + c_j_n n + c_j_x y) - (c_i_0 + c_i_n n + c_i_x x) +
 *		m_0 + m_n n >= 0
 *
 * for each (x,y) in R.
 * We obtain general constraints on coefficients (c_0, c_n, c_x, c_y)
 * of valid constraints for R and then plug in
 * (m_0 - s*c_j_0 + s*c_i_0, m_n - s*c_j_n + s*c_i_n,
 *  s*c_i_x, -s*c_j_x)
 * with each coefficient (except m_0, c_*_0 and c_*_n)
 * represented as a pair of non-negative coefficients.
 *
 *
 * If "local" is set (and s = 1), then we add constraints
 *
 *	(c_j_0 + c_j_n n + c_j_x y) - (c_i_0 + c_i_n n + c_i_x x) <= 0
 *
 * or
 *
 *	-((c_j_0 + c_j_n n + c_j_x y) + (c_i_0 + c_i_n n + c_i_x x)) >= 0
 *
 * instead, forcing the dependence distance to be (less than or) equal to 0.
 * That is, we plug in
 * (-s*c_j_0 + s*c_i_0, -s*c_j_n + s*c_i_n, s*c_i_x, -s*c_j_x).
 * Note that dependences marked local are treated as validity constraints
 * by add_all_validity_constraints and therefore also have
 * their distances bounded by 0 from below.
 */
================================================================================

文件路径: ./isl_scheduler.c
注释行数: 10
注释内容:
/* Add all validity constraints to graph->lp.
 *
 * An edge that is forced to be local needs to have its dependence
 * distances equal to zero.  We take care of bounding them by 0 from below
 * here.  add_all_proximity_constraints takes care of bounding them by 0
 * from above.
 *
 * If "use_coincidence" is set, then we treat coincidence edges as local edges.
 * Otherwise, we ignore them.
 */
================================================================================

文件路径: ./isl_scheduler.c
注释行数: 12
注释内容:
/* Add constraints to graph->lp that bound the dependence distance
 * for all dependence relations.
 * If a given proximity dependence is identical to a validity
 * dependence, then the dependence distance is already bounded
 * from below (by zero), so we only need to bound the distance
 * from above.  (This includes the case of "local" dependences
 * which are treated as validity dependence by add_all_validity_constraints.)
 * Otherwise, we need to bound the distance both from above and from below.
 *
 * If "use_coincidence" is set, then we treat coincidence edges as local edges.
 * Otherwise, we ignore them.
 */
================================================================================

文件路径: ./isl_scheduler.c
注释行数: 28
注释内容:
/* Compute a basis for the rows in the linear part of the schedule
 * and extend this basis to a full basis.  The remaining rows
 * can then be used to force linear independence from the rows
 * in the schedule.
 *
 * In particular, given the schedule rows S, we compute
 *
 *	S   = H Q
 *	S U = H
 *
 * with H the Hermite normal form of S.  That is, all but the
 * first rank columns of H are zero and so each row in S is
 * a linear combination of the first rank rows of Q.
 * The matrix Q can be used as a variable transformation
 * that isolates the directions of S in the first rank rows.
 * Transposing S U = H yields
 *
 *	U^T S^T = H^T
 *
 * with all but the first rank rows of H^T zero.
 * The last rows of U^T are therefore linear combinations
 * of schedule coefficients that are all zero on schedule
 * coefficients that are linearly dependent on the rows of S.
 * At least one of these combinations is non-zero on
 * linearly independent schedule coefficients.
 * The rows are normalized to involve as few of the last
 * coefficients as possible and to have a positive initial value.
 */
================================================================================

文件路径: ./isl_scheduler.c
注释行数: 14
注释内容:
/* How many times should we count the constraints in "edge"?
 *
 * We count as follows
 * validity		-> 1 (>= 0)
 * validity+proximity	-> 2 (>= 0 and upper bound)
 * proximity		-> 2 (lower and upper bound)
 * local(+any)		-> 2 (>= 0 and <= 0)
 *
 * If an edge is only marked conditional_validity then it counts
 * as zero since it is only checked afterwards.
 *
 * If "use_coincidence" is set, then we treat coincidence edges as local edges.
 * Otherwise, we ignore them.
 */
================================================================================

文件路径: ./isl_scheduler.c
注释行数: 11
注释内容:
/* Count the number of equality and inequality constraints
 * that will be added to the main lp problem.
 * We count as follows
 * validity		-> 1 (>= 0)
 * validity+proximity	-> 2 (>= 0 and upper bound)
 * proximity		-> 2 (lower and upper bound)
 * local(+any)		-> 2 (>= 0 and <= 0)
 *
 * If "use_coincidence" is set, then we treat coincidence edges as local edges.
 * Otherwise, we ignore them.
 */
================================================================================

文件路径: ./isl_scheduler.c
注释行数: 30
注释内容:
/* Add constraints to graph->lp that bound the values of
 * the parameter schedule coefficients of "node" to "max" and
 * the variable schedule coefficients to the corresponding entry
 * in node->max.
 * In either case, a negative value means that no bound needs to be imposed.
 *
 * For parameter coefficients, this amounts to adding a constraint
 *
 *	c_n <= max
 *
 * i.e.,
 *
 *	-c_n + max >= 0
 *
 * The variables coefficients are, however, not represented directly.
 * Instead, the variable coefficients c_x are written as differences
 * c_x = c_x^+ - c_x^-.
 * That is,
 *
 *	-max_i <= c_x_i <= max_i
 *
 * is encoded as
 *
 *	-max_i <= c_x_i^+ - c_x_i^- <= max_i
 *
 * or
 *
 *	-(c_x_i^+ - c_x_i^-) + max_i >= 0
 *	c_x_i^+ - c_x_i^- + max_i >= 0
 */
================================================================================

文件路径: ./isl_scheduler.c
注释行数: 30
注释内容:
/* Construct an ILP problem for finding schedule coefficients
 * that result in non-negative, but small dependence distances
 * over all dependences.
 * In particular, the dependence distances over proximity edges
 * are bounded by m_0 + m_n n and we compute schedule coefficients
 * with small values (preferably zero) of m_n and m_0.
 *
 * All variables of the ILP are non-negative.  The actual coefficients
 * may be negative, so each coefficient is represented as the difference
 * of two non-negative variables.  The negative part always appears
 * immediately before the positive part.
 * Other than that, the variables have the following order
 *
 *	- sum of positive and negative parts of m_n coefficients
 *	- m_0
 *	- sum of all c_n coefficients
 *		(unconstrained when computing non-parametric schedules)
 *	- sum of positive and negative parts of all c_x coefficients
 *	- positive and negative parts of m_n coefficients
 *	- for each node
 *		- positive and negative parts of c_i_x, in opposite order
 *		- c_i_n (if parametric)
 *		- c_i_0
 *
 * The constraints are those from the edges plus two or three equalities
 * to express the sums.
 *
 * If "use_coincidence" is set, then we treat coincidence edges as local edges.
 * Otherwise, we ignore them.
 */
================================================================================

文件路径: ./isl_scheduler.c
注释行数: 10
注释内容:
/* Extract the coefficients for the variables of "node" from "sol".
 *
 * Each schedule coefficient c_i_x is represented as the difference
 * between two non-negative variables c_i_x^+ - c_i_x^-.
 * The c_i_x^- appear before their c_i_x^+ counterpart.
 * Furthermore, the order of these pairs is the opposite of that
 * of the corresponding coefficients.
 *
 * Return c_i_x = c_i_x^+ - c_i_x^-
 */
================================================================================

文件路径: ./isl_scheduler.c
注释行数: 10
注释内容:
/* Update the schedules of all nodes based on the given solution
 * of the LP problem.
 * The new row is added to the current band.
 * All possibly negative coefficients are encoded as a difference
 * of two non-negative variables, so we need to perform the subtraction
 * here.
 *
 * If coincident is set, then the caller guarantees that the new
 * row satisfies the coincidence constraints.
 */
================================================================================

文件路径: ./isl_scheduler.c
注释行数: 13
注释内容:
/* Update the dependence relation of the given edge based
 * on the current schedule.
 * If the dependence is carried completely by the current schedule, then
 * it is removed from the edge_tables.  It is kept in the list of edges
 * as otherwise all edge_tables would have to be recomputed.
 *
 * If the edge is of a type that can appear multiple times
 * between the same pair of nodes, then it is added to
 * the edge table (again).  This prevents the situation
 * where none of these edges is referenced from the edge table
 * because the one that was referenced turned out to be empty and
 * was therefore removed from the table.
 */
================================================================================

文件路径: ./isl_scheduler.c
注释行数: 13
注释内容:
/* Update the dependence relations of all edges based on the current schedule
 * and enforce conditional validity constraints that are adjacent
 * to satisfied condition constraints.
 *
 * First check if any of the condition constraints are satisfied
 * (i.e., not local to the outer schedule) and keep track of
 * their domain and range.
 * Then update all dependence relations (which removes the non-local
 * constraints).
 * Finally, if any condition constraints turned out to be satisfied,
 * then turn all adjacent conditional validity constraints into
 * unconditional validity constraints.
 */
================================================================================

文件路径: ./isl_scheduler.c
注释行数: 11
注释内容:
/* Compute a schedule for a subgraph of "graph".  In particular, for
 * the graph composed of nodes that satisfy node_pred and edges that
 * that satisfy edge_pred.
 * If the subgraph is known to consist of a single component, then wcc should
 * be set and then we call compute_schedule_wcc on the constructed subgraph.
 * Otherwise, we call compute_schedule, which will check whether the subgraph
 * is connected.
 *
 * The schedule is inserted at "node" and the updated schedule node
 * is returned.
 */
================================================================================

文件路径: ./isl_scheduler.c
注释行数: 13
注释内容:
/* Split the current graph into two parts and compute a schedule for each
 * part individually.  In particular, one part consists of all SCCs up
 * to and including graph->src_scc, while the other part contains the other
 * SCCs.  The split is enforced by a sequence node inserted at position "node"
 * in the schedule tree.  Return the updated schedule node.
 * If either of these two parts consists of a sequence, then it is spliced
 * into the sequence containing the two parts.
 *
 * The current band is reset. It would be possible to reuse
 * the previously computed rows as the first rows in the next
 * band, but recomputing them may result in better rows as we are looking
 * at a smaller part of the dependence graph.
 */
================================================================================

文件路径: ./isl_scheduler.c
注释行数: 16
注释内容:
/* Add the constraints "coef" derived from an edge from "node" to itself
 * to graph->lp in order to respect the dependences and to try and carry them.
 * "pos" is the sequence number of the edge that needs to be carried.
 * "coef" represents general constraints on coefficients (c_0, c_x)
 * of valid constraints for (y - x) with x and y instances of the node.
 *
 * The constraints added to graph->lp need to enforce
 *
 *	(c_j_0 + c_j_x y) - (c_j_0 + c_j_x x)
 *	= c_j_x (y - x) >= e_i
 *
 * for each (x,y) in the dependence relation of the edge.
 * That is, (-e_i, c_j_x) needs to be plugged in for (c_0, c_x),
 * taking into account that each coefficient in c_j_x is represented
 * as a pair of non-negative coefficients.
 */
================================================================================

文件路径: ./isl_scheduler.c
注释行数: 24
注释内容:
/* Add the constraints "coef" derived from an edge from "src" to "dst"
 * to graph->lp in order to respect the dependences and to try and carry them.
 * "pos" is the sequence number of the edge that needs to be carried or
 * -1 if no attempt should be made to carry the dependences.
 * "coef" represents general constraints on coefficients (c_0, c_n, c_x, c_y)
 * of valid constraints for (x, y) with x and y instances of "src" and "dst".
 *
 * The constraints added to graph->lp need to enforce
 *
 *	(c_k_0 + c_k_n n + c_k_x y) - (c_j_0 + c_j_n n + c_j_x x) >= e_i
 *
 * for each (x,y) in the dependence relation of the edge or
 *
 *	(c_k_0 + c_k_n n + c_k_x y) - (c_j_0 + c_j_n n + c_j_x x) >= 0
 *
 * if pos is -1.
 * That is,
 * (-e_i + c_k_0 - c_j_0, c_k_n - c_j_n, -c_j_x, c_k_x)
 * or
 * (c_k_0 - c_j_0, c_k_n - c_j_n, -c_j_x, c_k_x)
 * needs to be plugged in for (c_0, c_n, c_x, c_y),
 * taking into account that each coefficient in c_j_x and c_k_x is represented
 * as a pair of non-negative coefficients.
 */
================================================================================

文件路径: ./isl_scheduler.c
注释行数: 15
注释内容:
/* Return a pointer to the node in "graph" that lives in "space".
 * If the requested node has been compressed, then "space"
 * corresponds to the compressed space.
 * The graph is assumed to have such a node.
 * Return NULL in case of error.
 *
 * First try and see if "space" is the space of an uncompressed node.
 * If so, return that node.
 * Otherwise, "space" was constructed by construct_compressed_id and
 * contains a user pointer pointing to the node in the tuple id.
 * However, this node belongs to the original dependence graph.
 * If "graph" is a subgraph of this original dependence graph,
 * then the node with the same space still needs to be looked up
 * in the current graph.
 */
================================================================================

文件路径: ./isl_scheduler.c
注释行数: 11
注释内容:
/* Add the constraints "coef" derived from an edge from a node to itself
 * to data->graph->lp in order to respect the dependences and
 * to try and carry them.
 *
 * The space of "coef" is of the form
 *
 *	coefficients[[c_cst] -> S[c_x]]
 *
 * with S[c_x] the (compressed) space of the node.
 * Extract the node from the space and call add_intra_constraints.
 */
================================================================================

文件路径: ./isl_scheduler.c
注释行数: 11
注释内容:
/* Add the constraints "coef" derived from an edge from a node j
 * to a node k to data->graph->lp in order to respect the dependences and
 * to try and carry them (provided data->carry_inter is set).
 *
 * The space of "coef" is of the form
 *
 *	coefficients[[c_cst, c_n] -> [S_j[c_x] -> S_k[c_y]]]
 *
 * with S_j[c_x] and S_k[c_y] the (compressed) spaces of the nodes.
 * Extract the nodes from the space and call add_inter_constraints.
 */
================================================================================

文件路径: ./isl_scheduler.c
注释行数: 33
注释内容:
/* Construct an LP problem for finding schedule coefficients
 * such that the schedule carries as many validity dependences as possible.
 * In particular, for each dependence i, we bound the dependence distance
 * from below by e_i, with 0 <= e_i <= 1 and then maximize the sum
 * of all e_i's.  Dependences with e_i = 0 in the solution are simply
 * respected, while those with e_i > 0 (in practice e_i = 1) are carried.
 * "intra" is the sequence of coefficient constraints for intra-node edges.
 * "inter" is the sequence of coefficient constraints for inter-node edges.
 * "n_edge" is the total number of edges.
 * "carry_inter" indicates whether inter-node edges should be carried or
 * only respected.  That is, if "carry_inter" is not set, then
 * no e_i variables are introduced for the inter-node edges.
 *
 * All variables of the LP are non-negative.  The actual coefficients
 * may be negative, so each coefficient is represented as the difference
 * of two non-negative variables.  The negative part always appears
 * immediately before the positive part.
 * Other than that, the variables have the following order
 *
 *	- sum of (1 - e_i) over all edges
 *	- sum of all c_n coefficients
 *		(unconstrained when computing non-parametric schedules)
 *	- sum of positive and negative parts of all c_x coefficients
 *	- for each edge
 *		- e_i
 *	- for each node
 *		- positive and negative parts of c_i_x, in opposite order
 *		- c_i_n (if parametric)
 *		- c_i_0
 *
 * The constraints are those from the (validity) edges plus three equalities
 * to express the sums and n_edge inequalities to express e_i <= 1.
 */
================================================================================

文件路径: ./isl_scheduler.c
注释行数: 16
注释内容:
/* If the schedule_split_scaled option is set and if the linear
 * parts of the scheduling rows for all nodes in the graphs have
 * a non-trivial common divisor, then remove this
 * common divisor from the linear part.
 * Otherwise, insert a band node directly and continue with
 * the construction of the schedule.
 *
 * If a non-trivial common divisor is found, then
 * the linear part is reduced and the remainder is ignored.
 * The pieces of the graph that are assigned different remainders
 * form (groups of) strongly connected components within
 * the scaled down band.  If needed, they can therefore
 * be ordered along this remainder in a sequence node.
 * However, this ordering is not enforced here in order to allow
 * the scheduler to combine some of the strongly connected components.
 */
================================================================================

文件路径: ./isl_scheduler.c
注释行数: 13
注释内容:
/* Is the schedule row "sol" trivial on node "node"?
 * That is, is the solution zero on the dimensions linearly independent of
 * the previously found solutions?
 * Return 1 if the solution is trivial, 0 if it is not and -1 on error.
 *
 * Each coefficient is represented as the difference between
 * two non-negative values in "sol".
 * We construct the schedule row s and check if it is linearly
 * independent of previously computed schedule rows
 * by computing T s, with T the linear combinations that are zero
 * on linearly dependent schedule rows.
 * If the result consists of all zeros, then the solution is trivial.
 */
================================================================================

文件路径: ./isl_scheduler.c
注释行数: 21
注释内容:
/* Does the solution "sol" of the LP problem constructed by setup_carry_lp
 * carry any of the "n_edge" groups of dependences?
 * The value in the first position is the sum of (1 - e_i) over all "n_edge"
 * edges, with 0 <= e_i <= 1 equal to 1 when the dependences represented
 * by the edge are carried by the solution.
 * If the sum of the (1 - e_i) is smaller than "n_edge" then at least
 * one of those is carried.
 *
 * Note that despite the fact that the problem is solved using a rational
 * solver, the solution is guaranteed to be integral.
 * Specifically, the dependence distance lower bounds e_i (and therefore
 * also their sum) are integers.  See Lemma 5 of [1].
 *
 * Any potential denominator of the sum is cleared by this function.
 * The denominator is not relevant for any of the other elements
 * in the solution.
 *
 * [1] P. Feautrier, Some Efficient Solutions to the Affine Scheduling
 *     Problem, Part II: Multi-Dimensional Time.
 *     In Intl. Journal of Parallel Programming, 1992.
 */
================================================================================

文件路径: ./isl_scheduler.c
注释行数: 32
注释内容:
/* Return the lexicographically smallest rational point in "lp",
 * assuming that all variables are non-negative and performing some
 * additional sanity checks.
 * If "want_integral" is set, then compute the lexicographically smallest
 * integer point instead.
 * In particular, "lp" should not be empty by construction.
 * Double check that this is the case.
 * If dependences are not carried for any of the "n_edge" edges,
 * then return an empty vector.
 *
 * If the schedule_treat_coalescing option is set and
 * if the computed schedule performs loop coalescing on a given node,
 * i.e., if it is of the form
 *
 *	c_i i + c_j j + ...
 *
 * with |c_j/c_i| >= size_i, then force the coefficient c_i to be zero
 * to cut out this solution.  Repeat this process until no more loop
 * coalescing occurs or until no more dependences can be carried.
 * In the latter case, revert to the previously computed solution.
 *
 * If the caller requests an integral solution and if coalescing should
 * be treated, then perform the coalescing treatment first as
 * an integral solution computed before coalescing treatment
 * would carry the same number of edges and would therefore probably
 * also be coalescing.
 *
 * To allow the coalescing treatment to be performed first,
 * the initial solution is allowed to be rational and it is only
 * cut out (if needed) in the next iteration, if no coalescing measures
 * were taken.
 */
================================================================================

文件路径: ./isl_scheduler.c
注释行数: 19
注释内容:
/* Given a non-trivial lineality space "lineality", add the corresponding
 * universe set to data->mask and add a map from elements to
 * other elements along the lines in "lineality" to data->equivalent.
 * If this is the first time this function gets called
 * (data->any_non_trivial is still false), then set data->any_non_trivial and
 * initialize data->mask and data->equivalent.
 *
 * In particular, if the lineality space is defined by equality constraints
 *
 *	E x = 0
 *
 * then construct an affine mapping
 *
 *	f : x -> E x
 *
 * and compute the equivalence relation of having the same image under f:
 *
 *	{ x -> x' : E x = E x' }
 */
================================================================================

文件路径: ./isl_scheduler.c
注释行数: 19
注释内容:
/* Check if the difference set on intra-node schedule constraints "intra"
 * has any non-trivial lineality space.
 * If so, then extend the difference set to a difference set
 * on equivalent elements.  That is, if "intra" is
 *
 *	{ y - x : (x,y) \in V }
 *
 * and elements are equivalent if they have the same image under f,
 * then return
 *
 *	{ y' - x' : (x,y) \in V and f(x) = f(x') and f(y) = f(y') }
 *
 * or, since f is linear,
 *
 *	{ y' - x' : (x,y) \in V and f(y - x) = f(y' - x') }
 *
 * The results of the search for non-trivial lineality spaces is stored
 * in "data".
 */
================================================================================

文件路径: ./isl_scheduler.c
注释行数: 36
注释内容:
/* For each dependence relation on a (conditional) validity edge
 * from a node to itself,
 * construct the set of coefficients of valid constraints for elements
 * in that dependence relation and collect the results.
 * If "coincidence" is set, then coincidence edges are considered as well.
 *
 * In particular, for each dependence relation R, constraints
 * on coefficients (c_0, c_x) are constructed such that
 *
 *	c_0 + c_x d >= 0 for each d in delta R = { y - x | (x,y) in R }
 *
 * If the schedule_treat_coalescing option is set, then some constraints
 * that could be exploited to construct coalescing schedules
 * are removed before the dual is computed, but after the parameters
 * have been projected out.
 * The entire computation is essentially the same as that performed
 * by intra_coefficients, except that it operates on multiple
 * edges together and that the parameters are always projected out.
 *
 * Additionally, exploit any non-trivial lineality space
 * in the difference set after removing coalescing constraints and
 * store the results of the non-trivial lineality space detection in "data".
 * The procedure is currently run unconditionally, but it is unlikely
 * to find any non-trivial lineality spaces if no coalescing constraints
 * have been removed.
 *
 * Note that if a dependence relation is a union of basic maps,
 * then each basic map needs to be treated individually as it may only
 * be possible to carry the dependences expressed by some of those
 * basic maps and not all of them.
 * The collected validity constraints are therefore not coalesced and
 * it is assumed that they are not coalesced automatically.
 * Duplicate basic maps can be removed, however.
 * In particular, if the same basic map appears as a disjunct
 * in multiple edges, then it only needs to be carried once.
 */
================================================================================

文件路径: ./isl_scheduler.c
注释行数: 29
注释内容:
/* For each dependence relation on a (conditional) validity edge
 * from a node to some other node,
 * construct the set of coefficients of valid constraints for elements
 * in that dependence relation and collect the results.
 * If "coincidence" is set, then coincidence edges are considered as well.
 *
 * In particular, for each dependence relation R, constraints
 * on coefficients (c_0, c_n, c_x, c_y) are constructed such that
 *
 *	c_0 + c_n n + c_x x + c_y y >= 0 for each (x,y) in R
 *
 * This computation is essentially the same as that performed
 * by inter_coefficients, except that it operates on multiple
 * edges together.
 *
 * Additionally, exploit any non-trivial lineality space
 * that may have been discovered by collect_intra_validity
 * (as stored in "data").
 *
 * Note that if a dependence relation is a union of basic maps,
 * then each basic map needs to be treated individually as it may only
 * be possible to carry the dependences expressed by some of those
 * basic maps and not all of them.
 * The collected validity constraints are therefore not coalesced and
 * it is assumed that they are not coalesced automatically.
 * Duplicate basic maps can be removed, however.
 * In particular, if the same basic map appears as a disjunct
 * in multiple edges, then it only needs to be carried once.
 */
================================================================================

文件路径: ./isl_scheduler.c
注释行数: 15
注释内容:
/* Construct an LP problem for finding schedule coefficients
 * such that the schedule carries as many of the "n_edge" groups of
 * dependences as possible based on the corresponding coefficient
 * constraints and return the lexicographically smallest non-trivial solution.
 * "intra" is the sequence of coefficient constraints for intra-node edges.
 * "inter" is the sequence of coefficient constraints for inter-node edges.
 * If "want_integral" is set, then compute an integral solution
 * for the coefficients rather than using the numerators
 * of a rational solution.
 * "carry_inter" indicates whether inter-node edges should be carried or
 * only respected.
 *
 * If none of the "n_edge" groups can be carried
 * then return an empty vector.
 */
================================================================================

文件路径: ./isl_scheduler.c
注释行数: 24
注释内容:
/* Construct an LP problem for finding schedule coefficients
 * such that the schedule carries as many of the validity dependences
 * as possible and
 * return the lexicographically smallest non-trivial solution.
 * If "fallback" is set, then the carrying is performed as a fallback
 * for the Pluto-like scheduler.
 * If "coincidence" is set, then try and carry coincidence edges as well.
 *
 * The variable "n_edge" stores the number of groups that should be carried.
 * If none of the "n_edge" groups can be carried
 * then return an empty vector.
 * If, moreover, "n_edge" is zero, then the LP problem does not even
 * need to be constructed.
 *
 * If a fallback solution is being computed, then compute an integral solution
 * for the coefficients rather than using the numerators
 * of a rational solution.
 *
 * If a fallback solution is being computed, if there are any intra-node
 * dependences, and if requested by the user, then first try
 * to only carry those intra-node dependences.
 * If this fails to carry any dependences, then try again
 * with the inter-node dependences included.
 */
================================================================================

文件路径: ./isl_scheduler.c
注释行数: 31
注释内容:
/* Construct a schedule row for each node such that as many validity dependences
 * as possible are carried and then continue with the next band.
 * If "fallback" is set, then the carrying is performed as a fallback
 * for the Pluto-like scheduler.
 * If "coincidence" is set, then try and carry coincidence edges as well.
 *
 * If there are no validity dependences, then no dependence can be carried and
 * the procedure is guaranteed to fail.  If there is more than one component,
 * then try computing a schedule on each component separately
 * to prevent or at least postpone this failure.
 *
 * If a schedule row is computed, then check that dependences are carried
 * for at least one of the edges.
 *
 * If the computed schedule row turns out to be trivial on one or
 * more nodes where it should not be trivial, then we throw it away
 * and try again on each component separately.
 *
 * If there is only one component, then we accept the schedule row anyway,
 * but we do not consider it as a complete row and therefore do not
 * increment graph->n_row.  Note that the ranks of the nodes that
 * do get a non-trivial schedule part will get updated regardless and
 * graph->maxvar is computed based on these ranks.  The test for
 * whether more schedule rows are required in compute_schedule_wcc
 * is therefore not affected.
 *
 * Insert a band corresponding to the schedule row at position "node"
 * of the schedule tree and continue with the construction of the schedule.
 * This insertion and the continued construction is performed by split_scaled
 * after optionally checking for non-trivial common divisors.
 */
================================================================================

文件路径: ./isl_scheduler.c
注释行数: 12
注释内容:
/* Topologically sort statements mapped to the same schedule iteration
 * and add insert a sequence node in front of "node"
 * corresponding to this order.
 * If "initialized" is set, then it may be assumed that compute_maxvar
 * has been called on the current band.  Otherwise, call
 * compute_maxvar if and before carry_dependences gets called.
 *
 * If it turns out to be impossible to sort the statements apart,
 * because different dependences impose different orderings
 * on the statements, then we extend the schedule such that
 * it carries at least one more dependence.
 */
================================================================================

文件路径: ./isl_scheduler.c
注释行数: 11
注释内容:
/* Compute a schedule for a connected dependence graph using Feautrier's
 * multi-dimensional scheduling algorithm and return the updated schedule node.
 *
 * The original algorithm is described in [1].
 * The main idea is to minimize the number of scheduling dimensions, by
 * trying to satisfy as many dependences as possible per scheduling dimension.
 *
 * [1] P. Feautrier, Some Efficient Solutions to the Affine Scheduling
 *     Problem, Part II: Multi-Dimensional Time.
 *     In Intl. Journal of Parallel Programming, 1992.
 */
================================================================================

文件路径: ./isl_scheduler.c
注释行数: 10
注释内容:
/* Does "graph" have any satisfied condition edges that
 * are adjacent to the conditional validity constraint with
 * domain "conditional_source" and range "conditional_sink"?
 *
 * A satisfied condition is one that is not local.
 * If a condition was forced to be local already (i.e., marked as local)
 * then there is no need to check if it is in fact local.
 *
 * Additionally, mark all adjacent condition edges found as local.
 */
================================================================================

文件路径: ./isl_scheduler.c
注释行数: 14
注释内容:
/* Are there any violated conditional validity dependences with
 * adjacent condition dependences that are not local with respect
 * to the current schedule?
 * That is, is the conditional validity constraint violated?
 *
 * Additionally, mark all those adjacent condition dependences as local.
 * We also mark those adjacent condition dependences that were not marked
 * as local before, but just happened to be local already.  This ensures
 * that they remain local if the schedule is recomputed.
 *
 * We first collect domain and range of all violated conditional validity
 * dependences and then check if there are any adjacent non-local
 * condition dependences.
 */
================================================================================

文件路径: ./isl_scheduler.c
注释行数: 32
注释内容:
/* Examine the current band (the rows between graph->band_start and
 * graph->n_total_row), deciding whether to drop it or add it to "node"
 * and then continue with the computation of the next band, if any.
 * If "initialized" is set, then it may be assumed that compute_maxvar
 * has been called on the current band.  Otherwise, call
 * compute_maxvar if and before carry_dependences gets called.
 *
 * The caller keeps looking for a new row as long as
 * graph->n_row < graph->maxvar.  If the latest attempt to find
 * such a row failed (i.e., we still have graph->n_row < graph->maxvar),
 * then we either
 * - split between SCCs and start over (assuming we found an interesting
 *	pair of SCCs between which to split)
 * - continue with the next band (assuming the current band has at least
 *	one row)
 * - if there is more than one SCC left, then split along all SCCs
 * - if outer coincidence needs to be enforced, then try to carry as many
 *	validity or coincidence dependences as possible and
 *	continue with the next band
 * - try to carry as many validity dependences as possible and
 *	continue with the next band
 * In each case, we first insert a band node in the schedule tree
 * if any rows have been computed.
 *
 * If the caller managed to complete the schedule and the current band
 * is empty, then finish off by topologically
 * sorting the statements based on the remaining dependences.
 * If, on the other hand, the current band has at least one row,
 * then continue with the next band.  Note that this next band
 * will necessarily be empty, but the graph may still be split up
 * into weakly connected components before arriving back here.
 */
================================================================================

文件路径: ./isl_scheduler.c
注释行数: 32
注释内容:
/* Construct a band of schedule rows for a connected dependence graph.
 * The caller is responsible for determining the strongly connected
 * components and calling compute_maxvar first.
 *
 * We try to find a sequence of as many schedule rows as possible that result
 * in non-negative dependence distances (independent of the previous rows
 * in the sequence, i.e., such that the sequence is tilable), with as
 * many of the initial rows as possible satisfying the coincidence constraints.
 * The computation stops if we can't find any more rows or if we have found
 * all the rows we wanted to find.
 *
 * If ctx->opt->schedule_outer_coincidence is set, then we force the
 * outermost dimension to satisfy the coincidence constraints.  If this
 * turns out to be impossible, we fall back on the general scheme above
 * and try to carry as many dependences as possible.
 *
 * If "graph" contains both condition and conditional validity dependences,
 * then we need to check that that the conditional schedule constraint
 * is satisfied, i.e., there are no violated conditional validity dependences
 * that are adjacent to any non-local condition dependences.
 * If there are, then we mark all those adjacent condition dependences
 * as local and recompute the current band.  Those dependences that
 * are marked local will then be forced to be local.
 * The initial computation is performed with no dependences marked as local.
 * If we are lucky, then there will be no violated conditional validity
 * dependences adjacent to any non-local condition dependences.
 * Otherwise, we mark some additional condition dependences as local and
 * recompute.  We continue this process until there are no violations left or
 * until we are no longer able to compute a schedule.
 * Since there are only a finite number of dependences,
 * there will only be a finite number of iterations.
 */
================================================================================

文件路径: ./isl_scheduler.c
注释行数: 21
注释内容:
/* Clustering information used by compute_schedule_wcc_clustering.
 *
 * "n" is the number of SCCs in the original dependence graph
 * "scc" is an array of "n" elements, each representing an SCC
 * of the original dependence graph.  All entries in the same cluster
 * have the same number of schedule rows.
 * "scc_cluster" maps each SCC index to the cluster to which it belongs,
 * where each cluster is represented by the index of the first SCC
 * in the cluster.  Initially, each SCC belongs to a cluster containing
 * only that SCC.
 *
 * "scc_in_merge" is used by merge_clusters_along_edge to keep
 * track of which SCCs need to be merged.
 *
 * "cluster" contains the merged clusters of SCCs after the clustering
 * has completed.
 *
 * "scc_node" is a temporary data structure used inside copy_partial.
 * For each SCC, it keeps track of the number of nodes in the SCC
 * that have already been copied.
 */
================================================================================

文件路径: ./isl_scheduler.c
注释行数: 15
注释内容:
/* Return the index of an edge in "graph" that can be used to merge
 * two clusters in "c".
 * Return graph->n_edge if no such edge can be found.
 * Return -1 on error.
 *
 * In particular, return a proximity edge between two clusters
 * that is not marked "no_merge" and such that neither of the
 * two clusters has an incomplete, empty band.
 *
 * If there are multiple such edges, then try and find the most
 * appropriate edge to use for merging.  In particular, pick the edge
 * with the greatest weight.  If there are multiple of those,
 * then pick one with the shortest distance between
 * the two cluster representatives.
 */
================================================================================

文件路径: ./isl_scheduler.c
注释行数: 22
注释内容:
/* Mark all SCCs that belong to either of the two clusters in "c"
 * connected by the edge in "graph" with index "edge", or to any
 * of the intermediate clusters.
 * The marking is recorded in c->scc_in_merge.
 *
 * The given edge has been selected for merging two clusters,
 * meaning that there is at least a proximity edge between the two nodes.
 * However, there may also be (indirect) validity dependences
 * between the two nodes.  When merging the two clusters, all clusters
 * containing one or more of the intermediate nodes along the
 * indirect validity dependences need to be merged in as well.
 *
 * First collect all such nodes by computing the strongly connected
 * component (SCC) containing the two nodes connected by the edge, where
 * the two nodes are considered to depend on each other to make
 * sure they end up in the same SCC.  Similarly, each node is considered
 * to depend on every other node in the same cluster to ensure
 * that the SCC consists of complete clusters.
 *
 * Then the original SCCs that contain any of these nodes are marked
 * in c->scc_in_merge.
 */
================================================================================

文件路径: ./isl_scheduler.c
注释行数: 13
注释内容:
/* Given a mapping "cluster_map" from the original instances to
 * the cluster instances, add schedule constraints on the clusters
 * to "sc" corresponding to the original constraints represented by "edge".
 *
 * For non-tagged dependence constraints, the cluster constraints
 * are obtained by applying "cluster_map" to the edge->map.
 *
 * For tagged dependence constraints, "cluster_map" needs to be applied
 * to the domains of the wrapped relations in domain and range
 * of the tagged dependence constraints.  Pick out the mappings
 * from these domains from "cluster_map" and construct their product.
 * This mapping can then be applied to the pair of domains.
 */
================================================================================

文件路径: ./isl_scheduler.c
注释行数: 11
注释内容:
/* Construct a dependence graph for scheduling clusters with respect
 * to each other and store the result in "merge_graph".
 * In particular, the nodes of the graph correspond to the schedule
 * dimensions of the current bands of those clusters that have been
 * marked for merging in "c".
 *
 * First construct an isl_schedule_constraints object for this domain
 * by transforming the edges in "graph" to the domain.
 * Then initialize a dependence graph for scheduling from these
 * constraints.
 */
================================================================================

文件路径: ./isl_scheduler.c
注释行数: 10
注释内容:
/* If there are any clusters where the dimension of the current band
 * (i.e., the band that is to be merged) is smaller than "maxvar" and
 * if there are any nodes in such a cluster where the number
 * of remaining schedule rows that still need to be computed
 * is greater than "max_slack", then return the smallest current band
 * dimension of all these clusters.  Otherwise return the original value
 * of "maxvar".  Return -1 in case of any error.
 * Only clusters that are about to be merged are considered.
 * "c" contains information about the clusters.
 */
================================================================================

文件路径: ./isl_scheduler.c
注释行数: 16
注释内容:
/* Adjust merge_graph->maxvar based on the number of remaining schedule rows
 * that still need to be computed.  In particular, if there is a node
 * in a cluster where the dimension of the current band is smaller
 * than merge_graph->maxvar, but the number of remaining schedule rows
 * is greater than that of any node in a cluster with the maximal
 * dimension for the current band (i.e., merge_graph->maxvar),
 * then adjust merge_graph->maxvar to the (smallest) current band dimension
 * of those clusters.  Without this adjustment, the total number of
 * schedule dimensions would be increased, resulting in a skewed view
 * of the number of coincident dimensions.
 * "c" contains information about the clusters.
 *
 * If the maximize_band_depth option is set and merge_graph->maxvar is reduced,
 * then there is no point in attempting any merge since it will be rejected
 * anyway.  Set merge_graph->maxvar to zero in such cases.
 */
================================================================================

文件路径: ./isl_scheduler.c
注释行数: 14
注释内容:
/* Return the transformation on "node" expressed by the current (and only)
 * band of "merge_graph" applied to the clusters in "c".
 *
 * First find the representation of "node" in its SCC in "c" and
 * extract the transformation expressed by the current band.
 * Then extract the transformation applied by "merge_graph"
 * to the cluster to which this SCC belongs.
 * Combine the two to obtain the complete transformation on the node.
 *
 * Note that the range of the first transformation is an anonymous space,
 * while the domain of the second is named "cluster_X".  The range
 * of the former therefore needs to be adjusted before the two
 * can be combined.
 */
================================================================================

文件路径: ./isl_scheduler.c
注释行数: 26
注释内容:
/* Does the edge "edge" from "graph" have bounded dependence distances
 * in the merged graph "merge_graph" of a selection of clusters in "c"?
 *
 * Extract the complete transformations of the source and destination
 * nodes of the edge, apply them to the edge constraints and
 * compute the differences.  Finally, check if these differences are bounded
 * in each direction.
 *
 * If the dimension of the band is greater than the number of
 * dimensions that can be expected to be optimized by the edge
 * (based on its weight), then also allow the differences to be unbounded
 * in the remaining dimensions, but only if either the source or
 * the destination has a fixed value in that direction.
 * This allows a statement that produces values that are used by
 * several instances of another statement to be merged with that
 * other statement.
 * However, merging such clusters will introduce an inherently
 * large proximity distance inside the merged cluster, meaning
 * that proximity distances will no longer be optimized in
 * subsequent merges.  These merges are therefore only allowed
 * after all other possible merges have been tried.
 * The first time such a merge is encountered, the weight of the edge
 * is replaced by a negative weight.  The second time (i.e., after
 * all merges over edges with a non-negative weight have been tried),
 * the merge is allowed.
 */
================================================================================

文件路径: ./isl_scheduler.c
注释行数: 11
注释内容:
/* Should the clusters be merged based on the cluster schedule
 * in the current (and only) band of "merge_graph"?
 * "graph" is the original dependence graph, while "c" records
 * which SCCs are involved in the latest merge.
 *
 * In particular, is there at least one proximity constraint
 * that is optimized by the merge?
 *
 * A proximity constraint is considered to be optimized
 * if the dependence distances are small.
 */
================================================================================

文件路径: ./isl_scheduler.c
注释行数: 18
注释内容:
/* Should the clusters be merged based on the cluster schedule
 * in the current (and only) band of "merge_graph"?
 * "graph" is the original dependence graph, while "c" records
 * which SCCs are involved in the latest merge.
 *
 * If the current band is empty, then the clusters should not be merged.
 *
 * If the band depth should be maximized and the merge schedule
 * is incomplete (meaning that the dimension of some of the schedule
 * bands in the original schedule will be reduced), then the clusters
 * should not be merged.
 *
 * If the schedule_maximize_coincidence option is set, then check that
 * the number of coincident schedule dimensions is not reduced.
 *
 * Finally, only allow the merge if at least one proximity
 * constraint is optimized.
 */
================================================================================

文件路径: ./isl_scheduler.c
注释行数: 10
注释内容:
/* Apply the schedule in "t_node" to the "n" rows starting at "first"
 * of the schedule in "node" and return the result.
 *
 * That is, essentially compute
 *
 *	T * N(first:first+n-1)
 *
 * taking into account the constant term and the parameter coefficients
 * in "t_node".
 */
================================================================================

文件路径: ./isl_scheduler.c
注释行数: 10
注释内容:
/* Apply the cluster schedule in "t_node" to the current band
 * schedule of the nodes in "graph".
 *
 * In particular, replace the rows starting at band_start
 * by the result of applying the cluster schedule in "t_node"
 * to the original rows.
 *
 * The coincidence of the schedule is determined by the coincidence
 * of the cluster schedule.
 */
================================================================================

文件路径: ./isl_scheduler.c
注释行数: 10
注释内容:
/* Merge the clusters marked for merging in "c" into a single
 * cluster using the cluster schedule in the current band of "merge_graph".
 * The representative SCC for the new cluster is the SCC with
 * the smallest index.
 *
 * The current band schedule of each SCC in the new cluster is obtained
 * by applying the schedule of the corresponding original cluster
 * to the original band schedule.
 * All SCCs in the new cluster have the same number of schedule rows.
 */
================================================================================

文件路径: ./isl_scheduler.c
注释行数: 31
注释内容:
/* Try and merge the clusters of SCCs marked in c->scc_in_merge
 * by scheduling the current cluster bands with respect to each other.
 *
 * Construct a dependence graph with a space for each cluster and
 * with the coordinates of each space corresponding to the schedule
 * dimensions of the current band of that cluster.
 * Construct a cluster schedule in this cluster dependence graph and
 * apply it to the current cluster bands if it is applicable
 * according to ok_to_merge.
 *
 * If the number of remaining schedule dimensions in a cluster
 * with a non-maximal current schedule dimension is greater than
 * the number of remaining schedule dimensions in clusters
 * with a maximal current schedule dimension, then restrict
 * the number of rows to be computed in the cluster schedule
 * to the minimal such non-maximal current schedule dimension.
 * Do this by adjusting merge_graph.maxvar.
 *
 * Return isl_bool_true if the clusters have effectively been merged
 * into a single cluster.
 *
 * Note that since the standard scheduling algorithm minimizes the maximal
 * distance over proximity constraints, the proximity constraints between
 * the merged clusters may not be optimized any further than what is
 * sufficient to bring the distances within the limits of the internal
 * proximity constraints inside the individual clusters.
 * It may therefore make sense to perform an additional translation step
 * to bring the clusters closer to each other, while maintaining
 * the linear part of the merging schedule found using the standard
 * scheduling algorithm.
 */
================================================================================

文件路径: ./isl_scheduler.c
注释行数: 13
注释内容:
/* Is there any edge marked "no_merge" between two SCCs that are
 * about to be merged (i.e., that are set in "scc_in_merge")?
 * "merge_edge" is the proximity edge along which the clusters of SCCs
 * are going to be merged.
 *
 * If there is any edge between two SCCs with a negative weight,
 * while the weight of "merge_edge" is non-negative, then this
 * means that the edge was postponed.  "merge_edge" should then
 * also be postponed since merging along the edge with negative weight should
 * be postponed until all edges with non-negative weight have been tried.
 * Replace the weight of "merge_edge" by a negative weight as well and
 * tell the caller not to attempt a merge.
 */
================================================================================

文件路径: ./isl_scheduler.c
注释行数: 18
注释内容:
/* Merge the two clusters in "c" connected by the edge in "graph"
 * with index "edge" into a single cluster.
 * If it turns out to be impossible to merge these two clusters,
 * then mark the edge as "no_merge" such that it will not be
 * considered again.
 *
 * First mark all SCCs that need to be merged.  This includes the SCCs
 * in the two clusters, but it may also include the SCCs
 * of intermediate clusters.
 * If there is already a no_merge edge between any pair of such SCCs,
 * then simply mark the current edge as no_merge as well.
 * Likewise, if any of those edges was postponed by has_bounded_distances,
 * then postpone the current edge as well.
 * Otherwise, try and merge the clusters and mark "edge" as "no_merge"
 * if the clusters did not end up getting merged, unless the non-merge
 * is due to the fact that the edge was postponed.  This postponement
 * can be recognized by a change in weight (from non-negative to negative).
 */
================================================================================

文件路径: ./isl_scheduler.c
注释行数: 11
注释内容:
/* Copy the current band schedule from the SCCs that form the cluster
 * with index "pos" to the actual cluster at position "pos".
 * By construction, the index of the first SCC that belongs to the cluster
 * is also "pos".
 *
 * The order of the nodes inside both the SCCs and the cluster
 * is assumed to be same as the order in the original "graph".
 *
 * Since the SCC graphs will no longer be used after this function,
 * the schedules are actually swapped rather than copied.
 */
================================================================================

文件路径: ./isl_scheduler.c
注释行数: 15
注释内容:
/* Extract the merged clusters of SCCs in "graph", sort them, and
 * store them in c->clusters.  Update c->scc_cluster accordingly.
 *
 * First keep track of the cluster containing the SCC to which a node
 * belongs in the node itself.
 * Then extract the clusters into c->clusters, copying the current
 * band schedule from the SCCs that belong to the cluster.
 * Do this only once per cluster.
 *
 * Finally, topologically sort the clusters and update c->scc_cluster
 * to match the new scc numbering.  While the SCCs were originally
 * sorted already, some SCCs that depend on some other SCCs may
 * have been merged with SCCs that appear before these other SCCs.
 * A reordering may therefore be required.
 */
================================================================================

文件路径: ./isl_scheduler.c
注释行数: 16
注释内容:
/* Compute weights on the proximity edges of "graph" that can
 * be used by find_proximity to find the most appropriate
 * proximity edge to use to merge two clusters in "c".
 * The weights are also used by has_bounded_distances to determine
 * whether the merge should be allowed.
 * Store the maximum of the computed weights in graph->max_weight.
 *
 * The computed weight is a measure for the number of remaining schedule
 * dimensions that can still be completely aligned.
 * In particular, compute the number of equalities between
 * input dimensions and output dimensions in the proximity constraints.
 * The directions that are already handled by outer schedule bands
 * are projected out prior to determining this number.
 *
 * Edges that will never be considered by find_proximity are ignored.
 */
================================================================================

文件路径: ./isl_scheduler.c
注释行数: 10
注释内容:
/* Call compute_schedule_finish_band on each of the clusters in "c"
 * in their topological order.  This order is determined by the scc
 * fields of the nodes in "graph".
 * Combine the results in a sequence expressing the topological order.
 *
 * If there is only one cluster left, then there is no need to introduce
 * a sequence node.  Also, in this case, the cluster necessarily contains
 * the SCC at position 0 in the original graph and is therefore also
 * stored in the first cluster of "c".
 */
================================================================================

文件路径: ./isl_scheduler.c
注释行数: 17
注释内容:
/* Compute a schedule for a connected dependence graph by first considering
 * each strongly connected component (SCC) in the graph separately and then
 * incrementally combining them into clusters.
 * Return the updated schedule node.
 *
 * Initially, each cluster consists of a single SCC, each with its
 * own band schedule.  The algorithm then tries to merge pairs
 * of clusters along a proximity edge until no more suitable
 * proximity edges can be found.  During this merging, the schedule
 * is maintained in the individual SCCs.
 * After the merging is completed, the full resulting clusters
 * are extracted and in finish_bands_clustering,
 * compute_schedule_finish_band is called on each of them to integrate
 * the band into "node" and to continue the computation.
 *
 * compute_weights initializes the weights that are used by find_proximity.
 */
================================================================================

文件路径: ./isl_scheduler.c
注释行数: 15
注释内容:
/* Compute a schedule for a connected dependence graph and return
 * the updated schedule node.
 *
 * If Feautrier's algorithm is selected, we first recursively try to satisfy
 * as many validity dependences as possible. When all validity dependences
 * are satisfied we extend the schedule to a full-dimensional schedule.
 *
 * Call compute_schedule_wcc_whole or compute_schedule_wcc_clustering
 * depending on whether the user has selected the option to try and
 * compute a schedule for the entire (weakly connected) component first.
 * If there is only a single strongly connected component (SCC), then
 * there is no point in trying to combine SCCs
 * in compute_schedule_wcc_clustering, so compute_schedule_wcc_whole
 * is called instead.
 */
================================================================================

文件路径: ./isl_scheduler.c
注释行数: 18
注释内容:
/* Compute a schedule for each group of nodes identified by node->scc
 * separately and then combine them in a sequence node (or as set node
 * if graph->weak is set) inserted at position "node" of the schedule tree.
 * Return the updated schedule node.
 *
 * If "wcc" is set then each of the groups belongs to a single
 * weakly connected component in the dependence graph so that
 * there is no need for compute_sub_schedule to look for weakly
 * connected components.
 *
 * If a set node would be introduced and if the number of components
 * is equal to the number of nodes, then check if the schedule
 * is already complete.  If so, a redundant set node would be introduced
 * (without any further descendants) stating that the statements
 * can be executed in arbitrary order, which is also expressed
 * by the absence of any node.  Refrain from inserting any nodes
 * in this case and simply return.
 */
================================================================================

文件路径: ./isl_scheduler.c
注释行数: 10
注释内容:
/* Compute a schedule for the given dependence graph and insert it at "node".
 * Return the updated schedule node.
 *
 * We first check if the graph is connected (through validity and conditional
 * validity dependences) and, if not, compute a schedule
 * for each component separately.
 * If the schedule_serialize_sccs option is set, then we check for strongly
 * connected components instead and compute a separate schedule for
 * each such strongly connected component.
 */
================================================================================

文件路径: ./isl_scheduler.c
注释行数: 15
注释内容:
/* Compute a schedule on sc->domain that respects the given schedule
 * constraints.
 *
 * In particular, the schedule respects all the validity dependences.
 * If the default isl scheduling algorithm is used, it tries to minimize
 * the dependence distances over the proximity dependences.
 * If Feautrier's scheduling algorithm is used, the proximity dependence
 * distances are only minimized during the extension to a full-dimensional
 * schedule.
 *
 * If there are any condition and conditional validity dependences,
 * then the conditional validity dependences may be violated inside
 * a tilable band, provided they have no adjacent non-local
 * condition dependences.
 */
================================================================================

文件路径: ./isl_output_private.h
注释行数: 11
注释内容:
/* Internal data structure for isl_print_space.
 *
 * latex is set if that is the output format.
 * print_dim (if not NULL) is called on each dimension.
 * user is set by the caller of print_space and may be used inside print_dim.
 *
 * space is the global space that is being printed.  This field is set by
 *	print_space.
 * type is the tuple of the global space that is currently being printed.
 *	This field is set by print_space.
 */
================================================================================

文件路径: ./isl_tab_pip.c
注释行数: 12
注释内容:
/*
 * Copyright 2008-2009 Katholieke Universiteit Leuven
 * Copyright 2010      INRIA Saclay
 * Copyright 2016-2017 Sven Verdoolaege
 *
 * Use of this software is governed by the MIT license
 *
 * Written by Sven Verdoolaege, K.U.Leuven, Departement
 * Computerwetenschappen, Celestijnenlaan 200A, B-3001 Leuven, Belgium
 * and INRIA Saclay - Ile-de-France, Parc Club Orsay Universite,
 * ZAC des vignes, 4 rue Jacques Monod, 91893 Orsay, France 
 */
================================================================================

文件路径: ./isl_tab_pip.c
注释行数: 38
注释内容:
/*
 * The implementation of parametric integer linear programming in this file
 * was inspired by the paper "Parametric Integer Programming" and the
 * report "Solving systems of affine (in)equalities" by Paul Feautrier
 * (and others).
 *
 * The strategy used for obtaining a feasible solution is different
 * from the one used in isl_tab.c.  In particular, in isl_tab.c,
 * upon finding a constraint that is not yet satisfied, we pivot
 * in a row that increases the constant term of the row holding the
 * constraint, making sure the sample solution remains feasible
 * for all the constraints it already satisfied.
 * Here, we always pivot in the row holding the constraint,
 * choosing a column that induces the lexicographically smallest
 * increment to the sample solution.
 *
 * By starting out from a sample value that is lexicographically
 * smaller than any integer point in the problem space, the first
 * feasible integer sample point we find will also be the lexicographically
 * smallest.  If all variables can be assumed to be non-negative,
 * then the initial sample value may be chosen equal to zero.
 * However, we will not make this assumption.  Instead, we apply
 * the "big parameter" trick.  Any variable x is then not directly
 * used in the tableau, but instead it is represented by another
 * variable x' = M + x, where M is an arbitrarily large (positive)
 * value.  x' is therefore always non-negative, whatever the value of x.
 * Taking as initial sample value x' = 0 corresponds to x = -M,
 * which is always smaller than any possible value of x.
 *
 * The big parameter trick is used in the main tableau and
 * also in the context tableau if isl_context_lex is used.
 * In this case, each tableaus has its own big parameter.
 * Before doing any real work, we check if all the parameters
 * happen to be non-negative.  If so, we drop the column corresponding
 * to M from the initial context tableau.
 * If isl_context_gbr is used, then the big parameter trick is only
 * used in the main tableau.
 */
================================================================================

文件路径: ./isl_tab_pip.c
注释行数: 27
注释内容:
/* isl_sol is an interface for constructing a solution to
 * a parametric integer linear programming problem.
 * Every time the algorithm reaches a state where a solution
 * can be read off from the tableau, the function "add" is called
 * on the isl_sol passed to find_solutions_main.  In a state where
 * the tableau is empty, "add_empty" is called instead.
 * "free" is called to free the implementation specific fields, if any.
 *
 * "error" is set if some error has occurred.  This flag invalidates
 * the remainder of the data structure.
 * If "rational" is set, then a rational optimization is being performed.
 * "level" is the current level in the tree with nodes for each
 * split in the context.
 * If "max" is set, then a maximization problem is being solved, rather than
 * a minimization problem, which means that the variables in the
 * tableau have value "M - x" rather than "M + x".
 * "n_out" is the number of output dimensions in the input.
 * "space" is the space in which the solution (and also the input) lives.
 *
 * The context tableau is owned by isl_sol and is updated incrementally.
 *
 * There are currently two implementations of this interface,
 * isl_sol_map, which simply collects the solutions in an isl_map
 * and (optionally) the parts of the context where there is no solution
 * in an isl_set, and
 * isl_sol_pma, which collects an isl_pw_multi_aff instead.
 */
================================================================================

文件路径: ./isl_tab_pip.c
注释行数: 20
注释内容:
/* Push a partial solution represented by a domain and mapping M
 * onto the stack of partial solutions.
 *
 * The affine matrix "M" maps the dimensions of the context
 * to the output variables.  Convert it into an isl_multi_aff and
 * then call sol_push_sol.
 *
 * Note that the description of the initial context may have involved
 * existentially quantified variables, in which case they also appear
 * in "dom".  These need to be removed before creating the affine
 * expression because an affine expression cannot be defined in terms
 * of existentially quantified variables without a known representation.
 * Since newly added integer divisions are inserted before these
 * existentially quantified variables, they are still in the final
 * positions and the corresponding final columns of "M" are zero
 * because align_context_divs adds the existentially quantified
 * variables of the context to the main tableau without any constraints and
 * any equality constraints that are added later on can only serve
 * to eliminate these existentially quantified variables.
 */
================================================================================

文件路径: ./isl_tab_pip.c
注释行数: 10
注释内容:
/* Swap the initial two partial solutions in "sol".
 *
 * That is, go from
 *
 *	sol->partial = p1; p1->next = p2; p2->next = p3
 *
 * to
 *
 *	sol->partial = p2; p2->next = p1; p1->next = p3
 */
================================================================================

文件路径: ./isl_tab_pip.c
注释行数: 10
注释内容:
/* Combine the initial two partial solution of "sol" into
 * a partial solution with the current context domain of "sol" and
 * the function description of the second partial solution in the list.
 * The level of the new partial solution is set to the current level.
 *
 * That is, the first two partial solutions (D1,M1) and (D2,M2) are
 * replaced by (D,M2), where D is the domain of "sol", which is assumed
 * to be the union of D1 and D2, while M1 is assumed to be equal to M2
 * (at least on D1).
 */
================================================================================

文件路径: ./isl_tab_pip.c
注释行数: 15
注释内容:
/* The initial two partial solutions of "sol" are known to be at
 * the same level.
 * If they represent the same solution (on different parts of the domain),
 * then combine them into a single solution at the current level.
 * Otherwise, pop them both.
 *
 * Even if the two partial solution are not obviously the same,
 * one may still be a simplification of the other over its own domain.
 * Also check if the two sets of affine functions are equal when
 * restricted to one of the domains.  If so, combine the two
 * using the set of affine functions on the other domain.
 * That is, for two partial solutions (D1,M1) and (D2,M2),
 * if M1 = M2 on D1, then the pair of partial solutions can
 * be replaced by (D1+D2,M2) and similarly when M1 = M2 on D2.
 */
================================================================================

文件路径: ./isl_tab_pip.c
注释行数: 49
注释内容:
/* Add the solution identified by the tableau and the context tableau.
 *
 * The layout of the variables is as follows.
 *	tab->n_var is equal to the total number of variables in the input
 *			map (including divs that were copied from the context)
 *			+ the number of extra divs constructed
 *      Of these, the first tab->n_param and the last tab->n_div variables
 *	correspond to the variables in the context, i.e.,
 *		tab->n_param + tab->n_div = context_tab->n_var
 *	tab->n_param is equal to the number of parameters and input
 *			dimensions in the input map
 *	tab->n_div is equal to the number of divs in the context
 *
 * If there is no solution, then call add_empty with a basic set
 * that corresponds to the context tableau.  (If add_empty is NULL,
 * then do nothing).
 *
 * If there is a solution, then first construct a matrix that maps
 * all dimensions of the context to the output variables, i.e.,
 * the output dimensions in the input map.
 * The divs in the input map (if any) that do not correspond to any
 * div in the context do not appear in the solution.
 * The algorithm will make sure that they have an integer value,
 * but these values themselves are of no interest.
 * We have to be careful not to drop or rearrange any divs in the
 * context because that would change the meaning of the matrix.
 *
 * To extract the value of the output variables, it should be noted
 * that we always use a big parameter M in the main tableau and so
 * the variable stored in this tableau is not an output variable x itself, but
 *	x' = M + x (in case of minimization)
 * or
 *	x' = M - x (in case of maximization)
 * If x' appears in a column, then its optimal value is zero,
 * which means that the optimal value of x is an unbounded number
 * (-M for minimization and M for maximization).
 * We currently assume that the output dimensions in the original map
 * are bounded, so this cannot occur.
 * Similarly, when x' appears in a row, then the coefficient of M in that
 * row is necessarily 1.
 * If the row in the tableau represents
 *	d x' = c + d M + e(y)
 * then, in case of minimization, the corresponding row in the matrix
 * will be
 *	a c + a e(y)
 * with a d = m, the (updated) common denominator of the matrix.
 * In case of maximization, the row will be
 *	-a c - a e(y)
 */
================================================================================

文件路径: ./isl_tab_pip.c
注释行数: 11
注释内容:
/* Return an integer division for use in a parametric cut based
 * on the given row.
 * In particular, let the parametric constant of the row be
 *
 *		\sum_i a_i y_i
 *
 * where y_0 = 1, but none of the y_i corresponds to the big parameter M.
 * The div returned is equal to
 *
 *		floor(\sum_i {-a_i} y_i) = floor((\sum_i (-a_i mod d) y_i)/d)
 */
================================================================================

文件路径: ./isl_tab_pip.c
注释行数: 11
注释内容:
/* Return an integer division for use in transferring an integrality constraint
 * to the context.
 * In particular, let the parametric constant of the row be
 *
 *		\sum_i a_i y_i
 *
 * where y_0 = 1, but none of the y_i corresponds to the big parameter M.
 * The the returned div is equal to
 *
 *		floor(\sum_i {a_i} y_i) = floor((\sum_i (a_i mod d) y_i)/d)
 */
================================================================================

文件路径: ./isl_tab_pip.c
注释行数: 10
注释内容:
/* Construct and return an inequality that expresses an upper bound
 * on the given div.
 * In particular, if the div is given by
 *
 *	d = floor(e/m)
 *
 * then the inequality expresses
 *
 *	m d <= e
 */
================================================================================

文件路径: ./isl_tab_pip.c
注释行数: 13
注释内容:
/* Given a row in the tableau and a div that was created
 * using get_row_split_div and that has been constrained to equality, i.e.,
 *
 *		d = floor(\sum_i {a_i} y_i) = \sum_i {a_i} y_i
 *
 * replace the expression "\sum_i {a_i} y_i" in the row by d,
 * i.e., we subtract "\sum_i {a_i} y_i" and add 1 d.
 * The coefficients of the non-parameters in the tableau have been
 * verified to be integral.  We can therefore simply replace coefficient b
 * by floor(b).  For the coefficients of the parameters we have
 * floor(a_i) = a_i - {a_i}, while for the other coefficients, we have
 * floor(b) = b.
 */
================================================================================

文件路径: ./isl_tab_pip.c
注释行数: 16
注释内容:
/* Given a row r and two columns, return the column that would
 * lead to the lexicographically smallest increment in the sample
 * solution when leaving the basis in favor of the row.
 * Pivoting with column c will increment the sample value by a non-negative
 * constant times a_{V,c}/a_{r,c}, with a_{V,c} the elements of column c
 * corresponding to the non-parametric variables.
 * If variable v appears in a column c_v, then a_{v,c} = 1 iff c = c_v,
 * with all other entries in this virtual row equal to zero.
 * If variable v appears in a row, then a_{v,c} is the element in column c
 * of that row.
 *
 * Let v be the first variable with a_{v,c1}/a_{r,c1} != a_{v,c2}/a_{r,c2}.
 * Then if a_{v,c1}/a_{r,c1} < a_{v,c2}/a_{r,c2}, i.e.,
 * a_{v,c2} a_{r,c1} - a_{v,c1} a_{r,c2} > 0, c1 results in the minimal
 * increment.  Otherwise, it's c2.
 */
================================================================================

文件路径: ./isl_tab_pip.c
注释行数: 21
注释内容:
/* Given a row that represents an equality, look for an appropriate
 * pivoting column.
 * In particular, if there are any non-zero coefficients among
 * the non-parameter variables, then we take the last of these
 * variables.  Eliminating this variable in terms of the other
 * variables and/or parameters does not influence the property
 * that all column in the initial tableau are lexicographically
 * positive.  The row corresponding to the eliminated variable
 * will only have non-zero entries below the diagonal of the
 * initial tableau.  That is, we transform
 *
 *		I				I
 *		  1		into		a
 *		    I				  I
 *
 * If there is no such non-parameter variable, then we are dealing with
 * pure parameter equality and we pick any parameter with coefficient 1 or -1
 * for elimination.  This will ensure that the eliminated parameter
 * always has an integer value whenever all the other parameters are integral.
 * If there is no such parameter then we return -1.
 */
================================================================================

文件路径: ./isl_tab_pip.c
注释行数: 12
注释内容:
/* Add an equality that may or may not be valid to the tableau.
 * If the resulting row is a pure constant, then it must be zero.
 * Otherwise, the resulting tableau is empty.
 *
 * If the row is not a pure constant, then we add two inequalities,
 * each time checking that they can be satisfied.
 * In the end we try to use one of the two constraints to eliminate
 * a column.
 *
 * This function assumes that at least two more rows and at least
 * two more elements in the constraint array are available in the tableau.
 */
================================================================================

文件路径: ./isl_tab_pip.c
注释行数: 11
注释内容:
/* Check for next (non-parameter) variable after "var" (first if var == -1)
 * that is non-integer and therefore requires a cut and return
 * the index of the variable.
 * For parametric tableaus, there are three parts in a row,
 * the constant, the coefficients of the parameters and the rest.
 * For each part, we check whether the coefficients in that part
 * are all integral and if so, set the corresponding flag in *f.
 * If the constant and the parameter part are integral, then the
 * current sample value is integral and no cut is required
 * (irrespective of whether the variable part is integral).
 */
================================================================================

文件路径: ./isl_tab_pip.c
注释行数: 10
注释内容:
/* Check for first (non-parameter) variable that is non-integer and
 * therefore requires a cut and return the corresponding row.
 * For parametric tableaus, there are three parts in a row,
 * the constant, the coefficients of the parameters and the rest.
 * For each part, we check whether the coefficients in that part
 * are all integral and if so, set the corresponding flag in *f.
 * If the constant and the parameter part are integral, then the
 * current sample value is integral and no cut is required
 * (irrespective of whether the variable part is integral).
 */
================================================================================

文件路径: ./isl_tab_pip.c
注释行数: 22
注释内容:
/* Add a (non-parametric) cut to cut away the non-integral sample
 * value of the given row.
 *
 * If the row is given by
 *
 *	m r = f + \sum_i a_i y_i
 *
 * then the cut is
 *
 *	c = - {-f/m} + \sum_i {a_i/m} y_i >= 0
 *
 * The big parameter, if any, is ignored, since it is assumed to be big
 * enough to be divisible by any integer.
 * If the tableau is actually a parametric tableau, then this function
 * is only called when all coefficients of the parameters are integral.
 * The cut therefore has zero coefficients for the parameters.
 *
 * The current value is known to be negative, so row_sign, if it
 * exists, is set accordingly.
 *
 * Return the row of the cut or -1.
 */
================================================================================

文件路径: ./isl_tab_pip.c
注释行数: 15
注释内容:
/* Given a non-parametric tableau, add cuts until an integer
 * sample point is obtained or until the tableau is determined
 * to be integer infeasible.
 * As long as there is any non-integer value in the sample point,
 * we add appropriate cuts, if possible, for each of these
 * non-integer values and then resolve the violated
 * cut constraints using restore_lexmin.
 * If one of the corresponding rows is equal to an integral
 * combination of variables/constraints plus a non-integral constant,
 * then there is no way to obtain an integer point and we return
 * a tableau that is marked empty.
 * The parameter cutting_strategy controls the strategy used when adding cuts
 * to remove non-integer points. CUT_ALL adds all possible cuts
 * before continuing the search. CUT_ONE adds only one cut at a time.
 */
================================================================================

文件路径: ./isl_tab_pip.c
注释行数: 11
注释内容:
/* Add a div specified by "div" to both the main tableau and
 * the context tableau.  In case of the main tableau, we only
 * need to add an extra div.  In the context tableau, we also
 * need to express the meaning of the div.
 * Return the index of the div or -1 if anything went wrong.
 *
 * The new integer division is added before any unknown integer
 * divisions in the context to ensure that it does not get
 * equated to some linear combination involving unknown integer
 * divisions.
 */
================================================================================

文件路径: ./isl_tab_pip.c
注释行数: 23
注释内容:
/* Add a parametric cut to cut away the non-integral sample value
 * of the given row.
 * Let a_i be the coefficients of the constant term and the parameters
 * and let b_i be the coefficients of the variables or constraints
 * in basis of the tableau.
 * Let q be the div q = floor(\sum_i {-a_i} y_i).
 *
 * The cut is expressed as
 *
 *	c = \sum_i -{-a_i} y_i + \sum_i {b_i} x_i + q >= 0
 *
 * If q did not already exist in the context tableau, then it is added first.
 * If q is in a column of the main tableau then the "+ q" can be accomplished
 * by setting the corresponding entry to the denominator of the constraint.
 * If q happens to be in a row of the main tableau, then the corresponding
 * row needs to be added instead (taking care of the denominators).
 * Note that this is very unlikely, but perhaps not entirely impossible.
 *
 * The current value of the cut is known to be negative (or at least
 * non-positive), so row_sign is set accordingly.
 *
 * Return the row of the cut or -1.
 */
================================================================================

文件路径: ./isl_tab_pip.c
注释行数: 12
注释内容:
/* Construct a tableau for bmap that can be used for computing
 * the lexicographic minimum (or maximum) of bmap.
 * If not NULL, then dom is the domain where the minimum
 * should be computed.  In this case, we set up a parametric
 * tableau with row signs (initialized to "unknown").
 * If M is set, then the tableau will use a big parameter.
 * If max is set, then a maximum should be computed instead of a minimum.
 * This means that for each variable x, the tableau will contain the variable
 * x' = M - x, rather than x' = M + x.  This in turn means that the coefficient
 * of the variables in all constraints are negated prior to adding them
 * to the tableau.
 */
================================================================================

文件路径: ./isl_tab_pip.c
注释行数: 29
注释内容:
/* Given a main tableau where more than one row requires a split,
 * determine and return the "best" row to split on.
 *
 * If any of the rows requiring a split only involves
 * variables that also appear in the context tableau,
 * then the negative part is guaranteed not to have a solution.
 * It is therefore best to split on any of these rows first.
 *
 * Otherwise,
 * given two rows in the main tableau, if the inequality corresponding
 * to the first row is redundant with respect to that of the second row
 * in the current tableau, then it is better to split on the second row,
 * since in the positive part, both rows will be positive.
 * (In the negative part a pivot will have to be performed and just about
 * anything can happen to the sign of the other row.)
 *
 * As a simple heuristic, we therefore select the row that makes the most
 * of the other rows redundant.
 *
 * Perhaps it would also be useful to look at the number of constraints
 * that conflict with any given constraint.
 *
 * best is the best row so far (-1 when we have not found any row yet).
 * best_r is the number of other rows made redundant by row best.
 * When best is still -1, bset_r is meaningless, but it is initialized
 * to some arbitrary value (0) anyway.  Without this redundant initialization
 * valgrind may warn about uninitialized memory accesses when isl
 * is compiled with some versions of gcc.
 */
================================================================================

文件路径: ./isl_tab_pip.c
注释行数: 17
注释内容:
/* Look through all the recently added equalities in the context
 * to see if we can propagate any of them to the main tableau.
 *
 * The newly added equalities in the context are encoded as pairs
 * of inequalities starting at inequality "first".
 *
 * We tentatively add each of these equalities to the main tableau
 * and if this happens to result in a row with a final coefficient
 * that is one or negative one, we use it to kill a column
 * in the main tableau.  Otherwise, we discard the tentatively
 * added row.
 * This tentative addition of equality constraints turns
 * on the undo facility of the tableau.  Turn it off again
 * at the end, assuming it was turned off to begin with.
 *
 * Return 0 on success and -1 on failure.
 */
================================================================================

文件路径: ./isl_tab_pip.c
注释行数: 56
注释内容:
/* Determine the sign of the given row of the main tableau.
 * The result is one of
 *	isl_tab_row_pos: always non-negative; no pivot needed
 *	isl_tab_row_neg: always non-positive; pivot
 *	isl_tab_row_any: can be both positive and negative; split
 *
 * We first handle some simple cases
 *	- the row sign may be known already
 *	- the row may be obviously non-negative
 *	- the parametric constant may be equal to that of another row
 *	  for which we know the sign.  This sign will be either "pos" or
 *	  "any".  If it had been "neg" then we would have pivoted before.
 *
 * If none of these cases hold, we check the value of the row for each
 * of the currently active samples.  Based on the signs of these values
 * we make an initial determination of the sign of the row.
 *
 *	all zero			->	unk(nown)
 *	all non-negative		->	pos
 *	all non-positive		->	neg
 *	both negative and positive	->	all
 *
 * If we end up with "all", we are done.
 * Otherwise, we perform a check for positive and/or negative
 * values as follows.
 *
 *	samples	       neg	       unk	       pos
 *	<0 ?			    Y        N	    Y        N
 *					    pos    any      pos
 *	>0 ?	     Y      N	 Y     N
 *		    any    neg  any   neg
 *
 * There is no special sign for "zero", because we can usually treat zero
 * as either non-negative or non-positive, whatever works out best.
 * However, if the row is "critical", meaning that pivoting is impossible
 * then we don't want to limp zero with the non-positive case, because
 * then we we would lose the solution for those values of the parameters
 * where the value of the row is zero.  Instead, we treat 0 as non-negative
 * ensuring a split if the row can attain both zero and negative values.
 * The same happens when the original constraint was one that could not
 * be satisfied with equality by any integer values of the parameters.
 * In this case, we normalize the constraint, but then a value of zero
 * for the normalized constraint is actually a positive value for the
 * original constraint, so again we need to treat zero as non-negative.
 * In both these cases, we have the following decision tree instead:
 *
 *	all non-negative		->	pos
 *	all negative			->	neg
 *	both negative and non-negative	->	all
 *
 *	samples	       neg	          	       pos
 *	<0 ?			             	    Y        N
 *					           any      pos
 *	>=0 ?	     Y      N
 *		    any    neg
 */
================================================================================

文件路径: ./isl_tab_pip.c
注释行数: 14
注释内容:
/* Find solutions for values of the parameters that satisfy the given
 * inequality.
 *
 * We currently take a snapshot of the context tableau that is reset
 * when we return from this function, while we make a copy of the main
 * tableau, leaving the original main tableau untouched.
 * These are fairly arbitrary choices.  Making a copy also of the context
 * tableau would obviate the need to undo any changes made to it later,
 * while taking a snapshot of the main tableau could reduce memory usage.
 * If we were to switch to taking a snapshot of the main tableau,
 * we would have to keep in mind that we need to save the row signs
 * and that we need to do this before saving the current basis
 * such that the basis has been restore before we restore the row signs.
 */
================================================================================

文件路径: ./isl_tab_pip.c
注释行数: 94
注释内容:
/* Compute the lexicographic minimum of the set represented by the main
 * tableau "tab" within the context "sol->context_tab".
 * On entry the sample value of the main tableau is lexicographically
 * less than or equal to this lexicographic minimum.
 * Pivots are performed until a feasible point is found, which is then
 * necessarily equal to the minimum, or until the tableau is found to
 * be infeasible.  Some pivots may need to be performed for only some
 * feasible values of the context tableau.  If so, the context tableau
 * is split into a part where the pivot is needed and a part where it is not.
 *
 * Whenever we enter the main loop, the main tableau is such that no
 * "obvious" pivots need to be performed on it, where "obvious" means
 * that the given row can be seen to be negative without looking at
 * the context tableau.  In particular, for non-parametric problems,
 * no pivots need to be performed on the main tableau.
 * The caller of find_solutions is responsible for making this property
 * hold prior to the first iteration of the loop, while restore_lexmin
 * is called before every other iteration.
 *
 * Inside the main loop, we first examine the signs of the rows of
 * the main tableau within the context of the context tableau.
 * If we find a row that is always non-positive for all values of
 * the parameters satisfying the context tableau and negative for at
 * least one value of the parameters, we perform the appropriate pivot
 * and start over.  An exception is the case where no pivot can be
 * performed on the row.  In this case, we require that the sign of
 * the row is negative for all values of the parameters (rather than just
 * non-positive).  This special case is handled inside row_sign, which
 * will say that the row can have any sign if it determines that it can
 * attain both negative and zero values.
 *
 * If we can't find a row that always requires a pivot, but we can find
 * one or more rows that require a pivot for some values of the parameters
 * (i.e., the row can attain both positive and negative signs), then we split
 * the context tableau into two parts, one where we force the sign to be
 * non-negative and one where we force is to be negative.
 * The non-negative part is handled by a recursive call (through find_in_pos).
 * Upon returning from this call, we continue with the negative part and
 * perform the required pivot.
 *
 * If no such rows can be found, all rows are non-negative and we have
 * found a (rational) feasible point.  If we only wanted a rational point
 * then we are done.
 * Otherwise, we check if all values of the sample point of the tableau
 * are integral for the variables.  If so, we have found the minimal
 * integral point and we are done.
 * If the sample point is not integral, then we need to make a distinction
 * based on whether the constant term is non-integral or the coefficients
 * of the parameters.  Furthermore, in order to decide how to handle
 * the non-integrality, we also need to know whether the coefficients
 * of the other columns in the tableau are integral.  This leads
 * to the following table.  The first two rows do not correspond
 * to a non-integral sample point and are only mentioned for completeness.
 *
 *	constant	parameters	other
 *
 *	int		int		int	|
 *	int		int		rat	| -> no problem
 *
 *	rat		int		int	  -> fail
 *
 *	rat		int		rat	  -> cut
 *
 *	int		rat		rat	|
 *	rat		rat		rat	| -> parametric cut
 *
 *	int		rat		int	|
 *	rat		rat		int	| -> split context
 *
 * If the parametric constant is completely integral, then there is nothing
 * to be done.  If the constant term is non-integral, but all the other
 * coefficient are integral, then there is nothing that can be done
 * and the tableau has no integral solution.
 * If, on the other hand, one or more of the other columns have rational
 * coefficients, but the parameter coefficients are all integral, then
 * we can perform a regular (non-parametric) cut.
 * Finally, if there is any parameter coefficient that is non-integral,
 * then we need to involve the context tableau.  There are two cases here.
 * If at least one other column has a rational coefficient, then we
 * can perform a parametric cut in the main tableau by adding a new
 * integer division in the context tableau.
 * If all other columns have integral coefficients, then we need to
 * enforce that the rational combination of parameters (c + \sum a_i y_i)/m
 * is always integral.  We do this by introducing an integer division
 * q = floor((c + \sum a_i y_i)/m) and stipulating that its argument should
 * always be integral in the context tableau, i.e., m q = c + \sum a_i y_i.
 * Since q is expressed in the tableau as
 *	c + \sum a_i y_i - m q >= 0
 *	-c - \sum a_i y_i + m q + m - 1 >= 0
 * it is sufficient to add the inequality
 *	-c - \sum a_i y_i + m q >= 0
 * In the part of the context where this inequality does not hold, the
 * main tableau is marked as being empty.
 */
================================================================================

文件路径: ./isl_tab_pip.c
注释行数: 20
注释内容:
/* Compute the lexicographic minimum of the set represented by the main
 * tableau "tab" within the context "sol->context_tab".
 *
 * As a preprocessing step, we first transfer all the purely parametric
 * equalities from the main tableau to the context tableau, i.e.,
 * parameters that have been pivoted to a row.
 * These equalities are ignored by the main algorithm, because the
 * corresponding rows may not be marked as being non-negative.
 * In parts of the context where the added equality does not hold,
 * the main tableau is marked as being empty.
 *
 * Before we embark on the actual computation, we save a copy
 * of the context.  When we return, we check if there are any
 * partial solutions that can potentially be merged.  If so,
 * we perform a rollback to the initial state of the context.
 * The merging of partial solutions happens inside calls to
 * sol_dec_level that are pushed onto the undo stack of the context.
 * If there are no partial solutions that can potentially be merged
 * then the rollback is skipped as it would just be wasted effort.
 */
================================================================================

文件路径: ./isl_tab_pip.c
注释行数: 14
注释内容:
/* The correspondence between the variables in the main tableau,
 * the context tableau, and the input map and domain is as follows.
 * The first n_param and the last n_div variables of the main tableau
 * form the variables of the context tableau.
 * In the basic map, these n_param variables correspond to the
 * parameters and the input dimensions.  In the domain, they correspond
 * to the parameters and the set dimensions.
 * The n_div variables correspond to the integer divisions in the domain.
 * To ensure that everything lines up, we may need to copy some of the
 * integer divisions of the domain to the map.  These have to be placed
 * in the same order as those in the context and they have to be placed
 * after any other integer divisions that the map may have.
 * This function performs the required reordering.
 */
================================================================================

文件路径: ./isl_tab_pip.c
注释行数: 12
注释内容:
/* Base case of isl_tab_basic_map_partial_lexopt, after removing
 * some obvious symmetries.
 *
 * We make sure the divs in the domain are properly ordered,
 * because they will be added one by one in the given order
 * during the construction of the solution map.
 * Furthermore, make sure that the known integer divisions
 * appear before any unknown integer division because the solution
 * may depend on the known integer divisions, while anything that
 * depends on any variable starting from the first unknown integer
 * division is ignored in sol_pma_add.
 */
================================================================================

文件路径: ./isl_tab_pip.c
注释行数: 10
注释内容:
/* Check whether "bmap" has a pair of constraints that have
 * the same coefficients for the output variables.
 * Note that the coefficients of the existentially quantified
 * variables need to be zero since the existentially quantified
 * of the result are usually not the same as those of the input.
 * Furthermore, check that each of the input variables that occur
 * in those constraints does not occur in any other constraint.
 * If so, return true and return the row indices of the two constraints
 * in *first and *second.
 */
================================================================================

文件路径: ./isl_tab_pip.c
注释行数: 13
注释内容:
/* Given a set of upper bounds on the last "input" variable m,
 * construct a set that assigns the minimal upper bound to m, i.e.,
 * construct a set that divides the space into cells where one
 * of the upper bounds is smaller than all the others and assign
 * this upper bound to m.
 *
 * In particular, if there are n bounds b_i, then the result
 * consists of n basic sets, each one of the form
 *
 *	m = b_i
 *	b_i <= b_j	for j > i
 *	b_i <  b_j	for j < i
 */
================================================================================

文件路径: ./isl_tab_pip.c
注释行数: 13
注释内容:
/* Given a map of which the last input variable is the minimum
 * of the bounds in "cst", split each basic set in the set
 * in pieces where one of the bounds is (strictly) smaller than the others.
 * This subdivision is given in "min_expr".
 * The variable is subsequently projected out.
 *
 * We only do the split when it is needed.
 * For example if the last input variable m = min(a,b) and the only
 * constraints in the given basic set are lower bounds on m,
 * i.e., l <= m = min(a,b), then we can simply project out m
 * to obtain l <= a and l <= b, without having to split on whether
 * m is equal to a or b.
 */
================================================================================

文件路径: ./isl_tab_pip.c
注释行数: 22
注释内容:
/* Extract a domain from "bmap" for the purpose of computing
 * a lexicographic optimum.
 *
 * This function is only called when the caller wants to compute a full
 * lexicographic optimum, i.e., without specifying a domain.  In this case,
 * the caller is not interested in the part of the domain space where
 * there is no solution and the domain can be initialized to those constraints
 * of "bmap" that only involve the parameters and the input dimensions.
 * This relieves the parametric programming engine from detecting those
 * inequalities and transferring them to the context.  More importantly,
 * it ensures that those inequalities are transferred first and not
 * intermixed with inequalities that actually split the domain.
 *
 * If the caller does not require the absence of existentially quantified
 * variables in the result (i.e., if ISL_OPT_QE is not set in "flags"),
 * then the actual domain of "bmap" can be used.  This ensures that
 * the domain does not need to be split at all just to separate out
 * pieces of the domain that do not have a solution from piece that do.
 * This domain cannot be used in general because it may involve
 * (unknown) existentially quantified variables which will then also
 * appear in the solution.
 */
================================================================================

文件路径: ./isl_tab_pip.c
注释行数: 17
注释内容:
/* Global internal data for isl_tab_basic_set_non_trivial_lexmin.
 *
 * "n_op" is the number of initial coordinates to optimize,
 * as passed to isl_tab_basic_set_non_trivial_lexmin.
 * "region" is the "n_region"-sized array of regions passed
 * to isl_tab_basic_set_non_trivial_lexmin.
 *
 * "tab" is the tableau that corresponds to the ILP problem.
 * "local" is an array of local data structure, one for each
 * (potential) level of the backtracking procedure of
 * isl_tab_basic_set_non_trivial_lexmin.
 * "v" is a pre-allocated vector that can be used for adding
 * constraints to the tableau.
 *
 * "sol" contains the best solution found so far.
 * It is initialized to a vector of size zero.
 */
================================================================================

文件路径: ./isl_tab_pip.c
注释行数: 14
注释内容:
/* Add constraints to "tab" that ensure that any solution is significantly
 * better than that represented by "sol".  That is, find the first
 * relevant (within first n_op) non-zero coefficient and force it (along
 * with all previous coefficients) to be zero.
 * If the solution is already optimal (all relevant coefficients are zero),
 * then just mark the table as empty.
 * "n_zero" is the number of coefficients that have been forced zero
 * by previous calls to this function at the same level.
 * Return the updated number of forced zero coefficients or -1 on error.
 *
 * This function assumes that at least 2 * (n_op - n_zero) more rows and
 * at least 2 * (n_op - n_zero) more elements in the constraint array
 * are available in the tableau.
 */
================================================================================

文件路径: ./isl_tab_pip.c
注释行数: 14
注释内容:
/* Local data at each level of the backtracking procedure of
 * isl_tab_basic_set_non_trivial_lexmin.
 *
 * "update" is set if a solution has been found in the current case
 * of this level, such that a better solution needs to be enforced
 * in the next case.
 * "n_zero" is the number of initial coordinates that have already
 * been forced to be zero at this level.
 * "region" is the non-triviality region considered at this level.
 * "side" is the index of the current case at this level.
 * "n" is the number of triviality directions.
 * "snap" is a snapshot of the tableau holding a state that needs
 * to be satisfied by all subsequent cases.
 */
================================================================================

文件路径: ./isl_tab_pip.c
注释行数: 19
注释内容:
/* Enter level "level" of the backtracking search and figure out
 * what to do next.  "init" is set if the level was entered
 * from a higher level and needs to be initialized.
 * Otherwise, the level is entered as a result of backtracking and
 * the tableau needs to be restored to a position that can
 * be used for the next case at this level.
 * The snapshot is assumed to have been saved in the previous case,
 * before the constraints specific to that case were added.
 *
 * In the initialization case, the local region is initialized
 * to point to the first violated region.
 * If the constraints of all regions are satisfied by the current
 * sample of the tableau, then tell the caller to continue looking
 * for a better solution or to stop searching if an optimal solution
 * has been found.
 *
 * If the tableau is empty or if all cases at the current level
 * have been considered, then the caller needs to backtrack as well.
 */
================================================================================

文件路径: ./isl_tab_pip.c
注释行数: 17
注释内容:
/* Add constraints to data->tab that select the current case (local->side)
 * at the current level.
 *
 * If the linear combinations v should not be zero, then the cases are
 *	v_0 >= 1
 *	v_0 <= -1
 *	v_0 = 0 and v_1 >= 1
 *	v_0 = 0 and v_1 <= -1
 *	v_0 = 0 and v_1 = 0 and v_2 >= 1
 *	v_0 = 0 and v_1 = 0 and v_2 <= -1
 *	...
 * in this order.
 *
 * A snapshot is taken after the equality constraint (if any) has been added
 * such that the next case can start off from this position.
 * The rollback to this position is performed in enter_level.
 */
================================================================================

文件路径: ./isl_tab_pip.c
注释行数: 36
注释内容:
/* Return the lexicographically smallest non-trivial solution of the
 * given ILP problem.
 *
 * All variables are assumed to be non-negative.
 *
 * n_op is the number of initial coordinates to optimize.
 * That is, once a solution has been found, we will only continue looking
 * for solutions that result in significantly better values for those
 * initial coordinates.  That is, we only continue looking for solutions
 * that increase the number of initial zeros in this sequence.
 *
 * A solution is non-trivial, if it is non-trivial on each of the
 * specified regions.  Each region represents a sequence of
 * triviality directions on a sequence of variables that starts
 * at a given position.  A solution is non-trivial on such a region if
 * at least one of the triviality directions is non-zero
 * on that sequence of variables.
 *
 * Whenever a conflict is encountered, all constraints involved are
 * reported to the caller through a call to "conflict".
 *
 * We perform a simple branch-and-bound backtracking search.
 * Each level in the search represents an initially trivial region
 * that is forced to be non-trivial.
 * At each level we consider 2 * n cases, where n
 * is the number of triviality directions.
 * In terms of those n directions v_i, we consider the cases
 *	v_0 >= 1
 *	v_0 <= -1
 *	v_0 = 0 and v_1 >= 1
 *	v_0 = 0 and v_1 <= -1
 *	v_0 = 0 and v_1 = 0 and v_2 >= 1
 *	v_0 = 0 and v_1 = 0 and v_2 <= -1
 *	...
 * in this order.
 */
================================================================================

文件路径: ./isl_tab_pip.c
注释行数: 17
注释内容:
/* Given a set of upper bounds on the last "input" variable m,
 * construct a piecewise affine expression that selects
 * the minimal upper bound to m, i.e.,
 * divide the space into cells where one
 * of the upper bounds is smaller than all the others and select
 * this upper bound on that cell.
 *
 * In particular, if there are n bounds b_i, then the result
 * consists of n cell, each one of the form
 *
 *	b_i <= b_j	for j > i
 *	b_i <  b_j	for j < i
 *
 * The affine expression on this cell is
 *
 *	b_i
 */
================================================================================

文件路径: ./isl_tab_pip.c
注释行数: 12
注释内容:
/* Given a piecewise multi-affine expression of which the last input variable
 * is the minimum of the bounds in "cst", plug in the value of the minimum.
 * This minimum expression is given in "min_expr_pa".
 * The set "min_expr" contains the same information, but in the form of a set.
 * The variable is subsequently projected out.
 *
 * The implementation is similar to those of "split" and "split_domain".
 * If the variable appears in a given expression, then minimum expression
 * is plugged in.  Otherwise, if the variable appears in the constraints
 * and a split is required, then the domain is split.  Otherwise, no split
 * is performed.
 */
================================================================================

文件路径: ./isl_convex_hull.c
注释行数: 11
注释内容:
/*
 * Copyright 2008-2009 Katholieke Universiteit Leuven
 * Copyright 2014      INRIA Rocquencourt
 *
 * Use of this software is governed by the MIT license
 *
 * Written by Sven Verdoolaege, K.U.Leuven, Departement
 * Computerwetenschappen, Celestijnenlaan 200A, B-3001 Leuven, Belgium
 * and Inria Paris - Rocquencourt, Domaine de Voluceau - Rocquencourt,
 * B.P. 105 - 78153 Le Chesnay, France
 */
================================================================================

文件路径: ./isl_convex_hull.c
注释行数: 18
注释内容:
/* Remove redundant
 * constraints.  If the minimal value along the normal of a constraint
 * is the same if the constraint is removed, then the constraint is redundant.
 *
 * Since some constraints may be mutually redundant, sort the constraints
 * first such that constraints that involve existentially quantified
 * variables are considered for removal before those that do not.
 * The sorting is also needed for the use in map_simple_hull.
 *
 * Note that isl_tab_detect_implicit_equalities may also end up
 * marking some constraints as redundant.  Make sure the constraints
 * are preserved and undo those marking such that isl_tab_detect_redundant
 * can consider the constraints in the sorted order.
 *
 * Alternatively, we could have intersected the basic map with the
 * corresponding equality and then checked if the dimension was that
 * of a facet.
 */
================================================================================

文件路径: ./isl_convex_hull.c
注释行数: 17
注释内容:
/* Given a union of basic sets, construct the constraints for wrapping
 * a facet around one of its ridges.
 * In particular, if each of n the d-dimensional basic sets i in "set"
 * contains the origin, satisfies the constraints x_1 >= 0 and x_2 >= 0
 * and is defined by the constraints
 *				    [ 1 ]
 *				A_i [ x ]  >= 0
 *
 * then the resulting set is of dimension n*(1+d) and has as constraints
 *
 *				    [ a_i ]
 *				A_i [ x_i ] >= 0
 *
 *				      a_i   >= 0
 *
 *			\sum_i x_{i,1} = 1
 */
================================================================================

文件路径: ./isl_convex_hull.c
注释行数: 57
注释内容:
/* Given a facet "facet" of the convex hull of "set" and a facet "ridge"
 * of that facet, compute the other facet of the convex hull that contains
 * the ridge.
 *
 * We first transform the set such that the facet constraint becomes
 *
 *			x_1 >= 0
 *
 * I.e., the facet lies in
 *
 *			x_1 = 0
 *
 * and on that facet, the constraint that defines the ridge is
 *
 *			x_2 >= 0
 *
 * (This transformation is not strictly needed, all that is needed is
 * that the ridge contains the origin.)
 *
 * Since the ridge contains the origin, the cone of the convex hull
 * will be of the form
 *
 *			x_1 >= 0
 *			x_2 >= a x_1
 *
 * with this second constraint defining the new facet.
 * The constant a is obtained by settting x_1 in the cone of the
 * convex hull to 1 and minimizing x_2.
 * Now, each element in the cone of the convex hull is the sum
 * of elements in the cones of the basic sets.
 * If a_i is the dilation factor of basic set i, then the problem
 * we need to solve is
 *
 *			min \sum_i x_{i,2}
 *			st
 *				\sum_i x_{i,1} = 1
 *				    a_i   >= 0
 *				  [ a_i ]
 *				A [ x_i ] >= 0
 *
 * with
 *				    [  1  ]
 *				A_i [ x_i ] >= 0
 *
 * the constraints of each (transformed) basic set.
 * If a = n/d, then the constraint defining the new facet (in the transformed
 * space) is
 *
 *			-n x_1 + d x_2 >= 0
 *
 * In the original space, we need to take the same combination of the
 * corresponding constraints "facet" and "ridge".
 *
 * If a = -infty = "-1/0", then we just return the original facet constraint.
 * This means that the facet is unbounded, but has a bounded intersection
 * with the union of sets.
 */
================================================================================

文件路径: ./isl_convex_hull.c
注释行数: 13
注释内容:
/* Compute the constraint of a facet of "set".
 *
 * We first compute the intersection with a bounding constraint
 * that is orthogonal to one of the coordinate axes.
 * If the affine hull of this intersection has only one equality,
 * we have found a facet.
 * Otherwise, we wrap the current bounding constraint around
 * one of the equalities of the face (one that is not equal to
 * the current bounding constraint).
 * This process continues until we have found a facet.
 * The dimension of the intersection increases by at least
 * one on each iteration, so termination is guaranteed.
 */
================================================================================

文件路径: ./isl_convex_hull.c
注释行数: 39
注释内容:
/* Given the bounding constraint "c" of a facet of the convex hull of "set",
 * compute a hyperplane description of the facet, i.e., compute the facets
 * of the facet.
 *
 * We compute an affine transformation that transforms the constraint
 *
 *			  [ 1 ]
 *			c [ x ] = 0
 *
 * to the constraint
 *
 *			   z_1  = 0
 *
 * by computing the right inverse U of a matrix that starts with the rows
 *
 *			[ 1 0 ]
 *			[  c  ]
 *
 * Then
 *			[ 1 ]     [ 1 ]
 *			[ x ] = U [ z ]
 * and
 *			[ 1 ]     [ 1 ]
 *			[ z ] = Q [ x ]
 *
 * with Q = U^{-1}
 * Since z_1 is zero, we can drop this variable as well as the corresponding
 * column of U to obtain
 *
 *			[ 1 ]      [ 1  ]
 *			[ x ] = U' [ z' ]
 * and
 *			[ 1  ]      [ 1 ]
 *			[ z' ] = Q' [ x ]
 *
 * with Q' equal to Q, but without the corresponding row.
 * After computing the facets of the facet in the z' space,
 * we convert them back to the x space through Q.
 */
================================================================================

文件路径: ./isl_convex_hull.c
注释行数: 21
注释内容:
/* Given an initial facet constraint, compute the remaining facets.
 * We do this by running through all facets found so far and computing
 * the adjacent facets through wrapping, adding those facets that we
 * hadn't already found before.
 *
 * For each facet we have found so far, we first compute its facets
 * in the resulting convex hull.  That is, we compute the ridges
 * of the resulting convex hull contained in the facet.
 * We also compute the corresponding facet in the current approximation
 * of the convex hull.  There is no need to wrap around the ridges
 * in this facet since that would result in a facet that is already
 * present in the current approximation.
 *
 * This function can still be significantly optimized by checking which of
 * the facets of the basic sets are also facets of the convex hull and
 * using all the facets so far to help in constructing the facets of the
 * facets
 * and/or
 * using the technique in section "3.1 Ridge Generation" of
 * "Extended Convex Hull" by Fukuda et al.
 */
================================================================================

文件路径: ./isl_convex_hull.c
注释行数: 20
注释内容:
/* Given a set and a linear space "lin" of dimension n > 0,
 * project the linear space from the set, compute the convex hull
 * and then map the set back to the original space.
 *
 * Let
 *
 *	M x = 0
 *
 * describe the linear space.  We first compute the Hermite normal
 * form H = M U of M = H Q, to obtain
 *
 *	H Q x = 0
 *
 * The last n rows of H will be zero, so the last n variables of x' = Q x
 * are the one we want to project out.  We do this by transforming each
 * basic set A x >= b to A U x' >= b and then removing the last n dimensions.
 * After computing the convex hull in x'_1, i.e., A' x'_1 >= b',
 * we transform the hull back to the original space as A' Q_1 x >= b',
 * with Q_1 all but the last n rows of Q.
 */
================================================================================

文件路径: ./isl_convex_hull.c
注释行数: 20
注释内容:
/* Compute a vector s in the homogeneous space such that <s, r> > 0
 * for all rays in the homogeneous space of the two cones that correspond
 * to the input polyhedra bset1 and bset2.
 *
 * We compute s as a vector that satisfies
 *
 *	s = \sum_j \alpha_{ij} h_{ij}	for i = 1,2			(*)
 *
 * with h_{ij} the normals of the facets of polyhedron i
 * (including the "positivity constraint" 1 >= 0) and \alpha_{ij}
 * strictly positive numbers.  For simplicity we impose \alpha_{ij} >= 1.
 * We first set up an LP with as variables the \alpha{ij}.
 * In this formulation, for each polyhedron i,
 * the first constraint is the positivity constraint, followed by pairs
 * of variables for the equalities, followed by variables for the inequalities.
 * We then simply pick a feasible solution and compute s using (*).
 *
 * Note that we simply pick any valid direction and make no attempt
 * to pick a "good" or even the "best" valid direction.
 */
================================================================================

文件路径: ./isl_convex_hull.c
注释行数: 59
注释内容:
/* Compute the convex hull of a pair of basic sets without any parameters or
 * integer divisions, where the convex hull is known to be pointed,
 * but the basic sets may be unbounded.
 *
 * We turn this problem into the computation of a convex hull of a pair
 * _bounded_ polyhedra by "changing the direction of the homogeneous
 * dimension".  This idea is due to Matthias Koeppe.
 *
 * Consider the cones in homogeneous space that correspond to the
 * input polyhedra.  The rays of these cones are also rays of the
 * polyhedra if the coordinate that corresponds to the homogeneous
 * dimension is zero.  That is, if the inner product of the rays
 * with the homogeneous direction is zero.
 * The cones in the homogeneous space can also be considered to
 * correspond to other pairs of polyhedra by chosing a different
 * homogeneous direction.  To ensure that both of these polyhedra
 * are bounded, we need to make sure that all rays of the cones
 * correspond to vertices and not to rays.
 * Let s be a direction such that <s, r> > 0 for all rays r of both cones.
 * Then using s as a homogeneous direction, we obtain a pair of polytopes.
 * The vector s is computed in valid_direction.
 *
 * Note that we need to consider _all_ rays of the cones and not just
 * the rays that correspond to rays in the polyhedra.  If we were to
 * only consider those rays and turn them into vertices, then we
 * may inadvertently turn some vertices into rays.
 *
 * The standard homogeneous direction is the unit vector in the 0th coordinate.
 * We therefore transform the two polyhedra such that the selected
 * direction is mapped onto this standard direction and then proceed
 * with the normal computation.
 * Let S be a non-singular square matrix with s as its first row,
 * then we want to map the polyhedra to the space
 *
 *	[ y' ]     [ y ]		[ y ]          [ y' ]
 *	[ x' ] = S [ x ]	i.e.,	[ x ] = S^{-1} [ x' ]
 *
 * We take S to be the unimodular completion of s to limit the growth
 * of the coefficients in the following computations.
 *
 * Let b_i + A_i x >= 0 be the constraints of polyhedron i.
 * We first move to the homogeneous dimension
 *
 *	b_i y + A_i x >= 0		[ b_i A_i ] [ y ]    [ 0 ]
 *	    y         >= 0	or	[  1   0  ] [ x ] >= [ 0 ]
 *
 * Then we change directoin
 *
 *	[ b_i A_i ]        [ y' ]		              [ y' ]
 *	[  1   0  ] S^{-1} [ x' ] >= 0	or	[ b_i' A_i' ] [ x' ] >= 0
 *
 * Then we compute the convex hull of the polytopes b_i' + A_i' x' >= 0
 * resulting in b' + A' x' >= 0, which we then convert back
 *
 *	            [ y ]		        [ y ]
 *	[ b' A' ] S [ x ] >= 0	or	[ b A ] [ x ] >= 0
 *
 * The polyhedron b + A x >= 0 is then the convex hull of the input polyhedra.
 */
================================================================================

文件路径: ./isl_convex_hull.c
注释行数: 13
注释内容:
/* Compute the convex hull of a pair of basic sets without any parameters or
 * integer divisions.
 *
 * This function is called from uset_convex_hull_unbounded, which
 * means that the complete convex hull is unbounded.  Some pairs
 * of basic sets may still be bounded, though.
 * They may even lie inside a lower dimensional space, in which
 * case they need to be handled inside their affine hull since
 * the main algorithm assumes that the result is full-dimensional.
 *
 * If the convex hull of the two basic sets would have a non-trivial
 * lineality space, we first project out this lineality space.
 */
================================================================================

文件路径: ./isl_convex_hull.c
注释行数: 11
注释内容:
/* Check for inequality constraints of a basic set without equalities
 * or redundant constraints
 * such that the same or more stringent copies of the constraint appear
 * in all of the basic sets.  Such constraints are necessarily facet
 * constraints of the convex hull.
 *
 * If the resulting basic set is by chance identical to one of
 * the basic sets in "set", then we know that this basic set contains
 * all other basic sets and is therefore the convex hull of set.
 * In this case we set *is_hull to 1.
 */
================================================================================

文件路径: ./isl_convex_hull.c
注释行数: 10
注释内容:
/* Check if inequality "ineq" is a bound for basic set "j" or if
 * it can be relaxed (by increasing the constant term) to become
 * a bound for that basic set.  In the latter case, the constant
 * term is updated.
 * Relaxation of the constant term is only allowed if "shift" is set.
 *
 * Return 1 if "ineq" is a bound
 *	  0 if "ineq" may attain arbitrarily small values on basic set "j"
 *	 -1 if some error occurred
 */
================================================================================

文件路径: ./isl_convex_hull.c
注释行数: 13
注释内容:
/* Set the constant term of "ineq" to the maximum of those of the constraints
 * in the basic sets of "set" following "i" that are parallel to "ineq".
 * That is, if any of the basic sets of "set" following "i" have a more
 * relaxed copy of "ineq", then replace "ineq" by the most relaxed copy.
 * "c_hash" is the hash value of the linear part of "ineq".
 * "v" has been set up for use by has_ineq.
 *
 * Note that the two inequality constraints corresponding to an equality are
 * represented by the same inequality constraint in data->p[j].table
 * (but with different hash values).  This means the constraint (or at
 * least its constant term) may need to be temporarily negated to get
 * the actually hashed constraint.
 */
================================================================================

文件路径: ./isl_convex_hull.c
注释行数: 21
注释内容:
/* Check if inequality "ineq" from basic set "i" is or can be relaxed to
 * become a bound on the whole set.  If so, add the (relaxed) inequality
 * to "hull".  Relaxation is only allowed if "shift" is set.
 *
 * We first check if "hull" already contains a translate of the inequality.
 * If so, we are done.
 * Then, we check if any of the previous basic sets contains a translate
 * of the inequality.  If so, then we have already considered this
 * inequality and we are done.
 * Otherwise, for each basic set other than "i", we check if the inequality
 * is a bound on the basic set, but first replace the constant term
 * by the maximal value of any translate of the inequality in any
 * of the following basic sets.
 * For previous basic sets, we know that they do not contain a translate
 * of the inequality, so we directly call is_bound.
 * For following basic sets, we first check if a translate of the
 * inequality appears in its description.  If so, the constant term
 * of the inequality has already been updated with respect to this
 * translate and the inequality is therefore known to be a bound
 * of this basic set.
 */
================================================================================

文件路径: ./isl_convex_hull.c
注释行数: 19
注释内容:
/* Compute a superset of the convex hull of map that is described
 * by only (translates of) the constraints in the constituents of map.
 * Translation is only allowed if "shift" is set.
 *
 * The constraints are sorted while removing redundant constraints
 * in order to indicate a preference of which constraints should
 * be preserved.  In particular, pairs of constraints that are
 * sorted together are preferred to either both be preserved
 * or both be removed.  The sorting is performed inside
 * isl_basic_map_remove_redundancies.
 *
 * The result of the computation is stored in map->cached_simple_hull[shift]
 * such that it can be reused in subsequent calls.  The cache is cleared
 * whenever the map is modified (in isl_map_cow).
 * Note that the results need to be stored in the input map for there
 * to be any chance that they may get reused.  In particular, they
 * are stored in a copy of the input map that is saved before
 * the integer division alignment.
 */
================================================================================

文件路径: ./isl_convex_hull.c
注释行数: 16
注释内容:
/* Drop all inequalities from "bmap1" that do not also appear in "bmap2".
 * A constraint that appears with different constant terms
 * in "bmap1" and "bmap2" is also kept, with the least restrictive
 * (i.e., greatest) constant term.
 * "bmap1" and "bmap2" are assumed to have the same (known)
 * integer divisions.
 * The constraints of both "bmap1" and "bmap2" are assumed
 * to have been sorted using isl_basic_map_sort_constraints.
 *
 * Run through the inequality constraints of "bmap1" and "bmap2"
 * in sorted order.
 * Each constraint of "bmap1" without a matching constraint in "bmap2"
 * is removed.
 * If a match is found, the constraint is kept.  If needed, the constant
 * term of the constraint is adjusted.
 */
================================================================================

文件路径: ./isl_convex_hull.c
注释行数: 10
注释内容:
/* Compute a superset of "bmap1" and "bmap2" that is described
 * by only the constraints that appear in both "bmap1" and "bmap2".
 *
 * First drop constraints that involve unknown integer divisions
 * since it is not trivial to check whether two such integer divisions
 * in different basic maps are the same.
 * Then align the remaining (known) divs and sort the constraints.
 * Finally drop all inequalities and equalities from "bmap1" that
 * do not also appear in "bmap2".
 */
================================================================================

文件路径: ./isl_convex_hull.c
注释行数: 12
注释内容:
/* Compute a superset of the convex hull of "map" that is described
 * by only the constraints in the constituents of "map".
 * In particular, the result is composed of constraints that appear
 * in each of the basic maps of "map"
 *
 * Constraints that involve unknown integer divisions are dropped
 * since it is not trivial to check whether two such integer divisions
 * in different basic maps are the same.
 *
 * The hull is initialized from the first basic map and then
 * updated with respect to the other basic maps in turn.
 */
================================================================================

文件路径: ./isl_convex_hull.c
注释行数: 18
注释内容:
/* Compute a superset of the convex hull of "set" that is described
 * by only some of the "n_ineq" constraints in the list "ineq", where "set"
 * has no parameters or integer divisions.
 *
 * The inequalities in "ineq" are assumed to have been sorted such
 * that constraints with the same linear part appear together and
 * that among constraints with the same linear part, those with
 * smaller constant term appear first.
 *
 * We reuse the same data structure that is used by uset_simple_hull,
 * but we do not need the hull table since we will not consider the
 * same constraint more than once.  We therefore allocate it with zero size.
 *
 * We run through the constraints and try to add them one by one,
 * skipping identical constraints.  If we have added a constraint and
 * the next constraint is a more relaxed translate, then we skip this
 * next constraint as well.
 */
================================================================================

文件路径: ./isl_convex_hull.c
注释行数: 11
注释内容:
/* Compute a superset of the convex hull of "map" that is described
 * by only constraints in the elements of "list".
 *
 * If the list is empty, then we can only describe the universe set.
 * If the input map is empty, then all constraints are valid, so
 * we return the intersection of the elements in "list".
 *
 * Otherwise, we align all divs and temporarily treat them
 * as regular variables, computing the unshifted simple hull in
 * uset_unshifted_simple_hull_from_basic_set_list.
 */
================================================================================

文件路径: ./isl_map.c
注释行数: 22
注释内容:
/*
 * Copyright 2008-2009 Katholieke Universiteit Leuven
 * Copyright 2010      INRIA Saclay
 * Copyright 2012-2014 Ecole Normale Superieure
 * Copyright 2014      INRIA Rocquencourt
 * Copyright 2016      INRIA Paris
 * Copyright 2016      Sven Verdoolaege
 * Copyright 2018-2019 Cerebras Systems
 *
 * Use of this software is governed by the MIT license
 *
 * Written by Sven Verdoolaege, K.U.Leuven, Departement
 * Computerwetenschappen, Celestijnenlaan 200A, B-3001 Leuven, Belgium
 * and INRIA Saclay - Ile-de-France, Parc Club Orsay Universite,
 * ZAC des vignes, 4 rue Jacques Monod, 91893 Orsay, France 
 * and Ecole Normale Superieure, 45 rue d’Ulm, 75230 Paris, France
 * and Inria Paris - Rocquencourt, Domaine de Voluceau - Rocquencourt,
 * B.P. 105 - 78153 Le Chesnay, France
 * and Centre de Recherche Inria de Paris, 2 rue Simone Iff - Voie DQ12,
 * CS 42112, 75589 Paris Cedex 12, France
 * and Cerebras Systems, 175 S San Antonio Rd, Los Altos, CA, USA
 */
================================================================================

文件路径: ./isl_map.c
注释行数: 10
注释内容:
/* Return an isl_map that is equal to "map" and that has only
 * a single reference.
 *
 * If the original input already has only one reference, then
 * simply return it, but clear all cached information, since
 * it may be rendered invalid by the operations that will be
 * performed on the result.
 *
 * Otherwise, create a duplicate (without any cached information).
 */
================================================================================

文件路径: ./isl_map.c
注释行数: 48
注释内容:
/* Try and add a lower and/or upper bound on "div" to "bmap"
 * based on inequality "i".
 * "total" is the total number of variables (excluding the divs).
 * "v" is a temporary object that can be used during the calculations.
 * If "lb" is set, then a lower bound should be constructed.
 * If "ub" is set, then an upper bound should be constructed.
 *
 * The calling function has already checked that the inequality does not
 * reference "div", but we still need to check that the inequality is
 * of the right form.  We'll consider the case where we want to construct
 * a lower bound.  The construction of upper bounds is similar.
 *
 * Let "div" be of the form
 *
 *	q = floor((a + f(x))/d)
 *
 * We essentially check if constraint "i" is of the form
 *
 *	b + f(x) >= 0
 *
 * so that we can use it to derive a lower bound on "div".
 * However, we allow a slightly more general form
 *
 *	b + g(x) >= 0
 *
 * with the condition that the coefficients of g(x) - f(x) are all
 * divisible by d.
 * Rewriting this constraint as
 *
 *	0 >= -b - g(x)
 *
 * adding a + f(x) to both sides and dividing by d, we obtain
 *
 *	(a + f(x))/d >= (a-b)/d + (f(x)-g(x))/d
 *
 * Taking the floor on both sides, we obtain
 *
 *	q >= floor((a-b)/d) + (f(x)-g(x))/d
 *
 * or
 *
 *	(g(x)-f(x))/d + ceil((b-a)/d) + q >= 0
 *
 * In the case of an upper bound, we construct the constraint
 *
 *	(g(x)+f(x))/d + floor((b+a)/d) - q >= 0
 *
 */
================================================================================

文件路径: ./isl_map.c
注释行数: 45
注释内容:
/* This function is called right before "div" is eliminated from "bmap"
 * using Fourier-Motzkin.
 * Look through the constraints of "bmap" for constraints on the argument
 * of the integer division and use them to construct constraints on the
 * integer division itself.  These constraints can then be combined
 * during the Fourier-Motzkin elimination.
 * Note that it is only useful to introduce lower bounds on "div"
 * if "bmap" already contains upper bounds on "div" as the newly
 * introduce lower bounds can then be combined with the pre-existing
 * upper bounds.  Similarly for upper bounds.
 * We therefore first check if "bmap" contains any lower and/or upper bounds
 * on "div".
 *
 * It is interesting to note that the introduction of these constraints
 * can indeed lead to more accurate results, even when compared to
 * deriving constraints on the argument of "div" from constraints on "div".
 * Consider, for example, the set
 *
 *	{ [i,j,k] : 3 + i + 2j >= 0 and 2 * [(i+2j)/4] <= k }
 *
 * The second constraint can be rewritten as
 *
 *	2 * [(-i-2j+3)/4] + k >= 0
 *
 * from which we can derive
 *
 *	-i - 2j + 3 >= -2k
 *
 * or
 *
 *	i + 2j <= 3 + 2k
 *
 * Combined with the first constraint, we obtain
 *
 *	-3 <= 3 + 2k	or	k >= -3
 *
 * If, on the other hand we derive a constraint on [(i+2j)/4] from
 * the first constraint, we obtain
 *
 *	[(i + 2j)/4] >= [-3/4] = -1
 *
 * Combining this constraint with the second constraint, we obtain
 *
 *	k >= -2
 */
================================================================================

文件路径: ./isl_map.c
注释行数: 13
注释内容:
/* Add the div constraint of sign "sign" for div "div" of "bmap".
 *
 * In particular, if this div is of the form d = floor(f/m),
 * then add the constraint
 *
 *		f - m d >= 0
 *
 * if sign < 0 or the constraint
 *
 *		-(f-(m-1)) + m d >= 0
 *
 * if sign > 0.
 */
================================================================================

文件路径: ./isl_map.c
注释行数: 10
注释内容:
/* Force the symbolic constant expression "bound"
 * to satisfy the relation "order" with respect to
 * the output variable at position "pos" of "map".
 *
 * Create an affine expression representing the output variable
 * in terms of the range and
 * compare it using "order" to "bound" (defined on the domain).
 * The result is a relation between elements in domain and range that
 * can be intersected with "map".
 */
================================================================================

文件路径: ./isl_map.c
注释行数: 17
注释内容:
/* Given a map "map", compute the lexicographically minimal
 * (or maximal) image element for each domain element in dom,
 * in the form of an isl_pw_multi_aff.
 * If "empty" is not NULL, then set *empty to those elements in dom that
 * do not have an image element.
 * If "flags" includes ISL_OPT_FULL, then "dom" is NULL and the optimum
 * should be computed over the domain of "map".  "empty" is also NULL
 * in this case.
 *
 * We first compute the lexicographically minimal or maximal element
 * in the first basic map.  This results in a partial solution "res"
 * and a subset "todo" of dom that still need to be handled.
 * We then consider each of the remaining maps in "map" and successively
 * update both "res" and "todo".
 * If "empty" is NULL, then the todo sets are not needed and therefore
 * also not computed.
 */
================================================================================

文件路径: ./isl_map.c
注释行数: 23
注释内容:
/* Given a map "map", compute the lexicographically minimal
 * (or maximal) image element for each domain element in "dom",
 * in the form of an isl_map.
 * If "empty" is not NULL, then set *empty to those elements in "dom" that
 * do not have an image element.
 * If "flags" includes ISL_OPT_FULL, then "dom" is NULL and the optimum
 * should be computed over the domain of "map".  "empty" is also NULL
 * in this case.
 *
 * If the input consists of more than one disjunct, then first
 * compute the desired result in the form of an isl_pw_multi_aff and
 * then convert that into an isl_map.
 *
 * This function used to have an explicit implementation in terms
 * of isl_maps, but it would continually intersect the domains of
 * partial results with the complement of the domain of the next
 * partial solution, potentially leading to an explosion in the number
 * of disjuncts if there are several disjuncts in the input.
 * An even earlier implementation of this function would look for
 * better results in the domain of the partial result and for extra
 * results in the complement of this domain, which would lead to
 * even more splintering.
 */
================================================================================

文件路径: ./isl_map.c
注释行数: 14
注释内容:
/* Compute an explicit representation for the existentially quantified
 * variables in "bset" by computing the "minimal value" of the set
 * variables.  Since there are no set variables, the computation of
 * the minimal value essentially computes an explicit representation
 * of the non-empty part(s) of "bset".
 *
 * The input only involves parameters and existentially quantified variables.
 * All equalities among parameters have been removed.
 *
 * Since the existentially quantified variables in the result are in general
 * going to be different from those in the input, we first replace
 * them by the minimal number of variables based on their equalities.
 * This should simplify the parametric integer programming.
 */
================================================================================

文件路径: ./isl_map.c
注释行数: 18
注释内容:
/* Project the given basic set onto its parameter domain, possibly introducing
 * new, explicit, existential variables in the constraints.
 * The input has parameters and (possibly implicit) existential variables.
 * The output has the same parameters, but only
 * explicit existentially quantified variables.
 *
 * The actual projection is performed by pip, but pip doesn't seem
 * to like equalities very much, so we first remove the equalities
 * among the parameters by performing a variable compression on
 * the parameters.  Afterward, an inverse transformation is performed
 * and the equalities among the parameters are inserted back in.
 *
 * The variable compression on the parameters may uncover additional
 * equalities that were only implicit before.  We therefore check
 * if there are any new parameter equalities in the result and
 * if so recurse.  The removal of parameter equalities is required
 * for the parameter compression performed by base_compute_divs.
 */
================================================================================

文件路径: ./isl_map.c
注释行数: 14
注释内容:
/* Compute an explicit representation for the existentially
 * quantified variables for which do not know any explicit representation yet.
 *
 * We first sort the existentially quantified variables so that the
 * existentially quantified variables for which we already have an explicit
 * representation are placed before those for which we do not.
 * The input dimensions, the output dimensions and the existentially
 * quantified variables for which we already have an explicit
 * representation are then turned into parameters.
 * compute_divs returns a map with the same parameters and
 * no input or output dimensions and the dimension specification
 * is reset to that of the input, including the existentially quantified
 * variables for which we already had an explicit representation.
 */
================================================================================

文件路径: ./isl_map.c
注释行数: 10
注释内容:
/* Return the union of "map1" and "map2", where we assume for now that
 * "map1" and "map2" are disjoint.  Note that the basic maps inside
 * "map1" or "map2" may not be disjoint from each other.
 * Also note that this function is also called from isl_map_union,
 * which takes care of handling the situation where "map1" and "map2"
 * may not be disjoint.
 *
 * If one of the inputs is empty, we can simply return the other input.
 * Similarly, if one of the inputs is universal, then it is equal to the union.
 */
================================================================================

文件路径: ./isl_map.c
注释行数: 12
注释内容:
/* Return the union of "map1" and "map2", where "map1" and "map2" may
 * not be disjoint.
 *
 * We currently simply call map_union_disjoint, the internal operation
 * of which does not really depend on the inputs being disjoint.
 * If the result contains more than one basic map, then we clear
 * the disjoint flag since the result may contain basic maps from
 * both inputs and these are not guaranteed to be disjoint.
 *
 * As a special case, if "map1" and "map2" are obviously equal,
 * then we simply return "map1".
 */
================================================================================

文件路径: ./isl_map.c
注释行数: 12
注释内容:
/* Data structure that specifies how isl_map_intersect_factor
 * should operate.
 *
 * "preserve_type" is the tuple where the factor differs from
 * the input map and of which the identifiers needs
 * to be preserved explicitly.
 * "other_factor" is used to extract the space of the other factor
 * from the space of the product ("map").
 * "product" is used to combine the given factor and a universe map
 * in the space returned by "other_factor" to produce a map
 * that lives in the same space as the input map.
 */
================================================================================

文件路径: ./isl_map.c
注释行数: 12
注释内容:
/* Given a map "map" in some product space and a map "factor"
 * living in some factor space, return the intersection.
 *
 * After aligning the parameters,
 * the map "factor" is first extended to a map living in the same space
 * as "map" and then a regular intersection is computed.
 *
 * Note that the extension is computed as a product, which is anonymous
 * by default.  If "map" has an identifier on the corresponding tuple,
 * then this identifier needs to be set on the product
 * before the intersection is computed.
 */
================================================================================

文件路径: ./isl_map.c
注释行数: 10
注释内容:
/* Apply the expansion computed by isl_merge_divs.
 * The expansion itself is given by "exp" while the resulting
 * list of divs is given by "div".
 *
 * Move the integer divisions of "bmap" into the right position
 * according to "exp" and then introduce the additional integer
 * divisions, adding div constraints.
 * The moving should be done first to avoid moving coefficients
 * in the definitions of the extra integer divisions.
 */
================================================================================

文件路径: ./isl_map.c
注释行数: 17
注释内容:
/* Align the divs of "dst" to those of "src", adding divs from "src"
 * if needed.  That is, make sure that the first src->n_div divs
 * of the result are equal to those of src.
 * The integer division of "src" are assumed to be ordered.
 *
 * The integer divisions are swapped into the right position
 * (possibly after adding them first).  This may result
 * in the remaining integer divisions appearing in the wrong order,
 * i.e., with some integer division appearing before
 * some other integer division on which it depends.
 * The integer divisions therefore need to be ordered.
 * This will not affect the integer divisions aligned to those of "src",
 * since "src" is assumed to have ordered integer divisions.
 *
 * The result is not finalized as by design it will have redundant
 * divs if any divs from "src" were copied.
 */
================================================================================

文件路径: ./isl_map.c
注释行数: 11
注释内容:
/* Given two _disjoint_ basic sets bset1 and bset2, check whether
 * for any common value of the parameters and dimensions preceding pos
 * in both basic sets, the values of dimension pos in bset1 are
 * smaller or larger than those in bset2.
 *
 * Returns
 *	 1 if bset1 follows bset2
 *	-1 if bset1 precedes bset2
 *	 0 if bset1 and bset2 are incomparable
 *	-2 if some error occurred.
 */
================================================================================

文件路径: ./isl_map.c
注释行数: 11
注释内容:
/* Given two basic sets bset1 and bset2, check whether
 * for any common value of the parameters and dimensions preceding pos
 * there is a value of dimension pos in bset1 that is larger
 * than a value of the same dimension in bset2.
 *
 * Return
 *	 1 if there exists such a pair
 *	 0 if there is no such pair, but there is a pair of equal values
 *	-1 otherwise
 *	-2 if some error occurred.
 */
================================================================================

文件路径: ./isl_map.c
注释行数: 11
注释内容:
/* Given two sets set1 and set2, check whether
 * for any common value of the parameters and dimensions preceding pos
 * there is a value of dimension pos in set1 that is larger
 * than a value of the same dimension in set2.
 *
 * Return
 *	 1 if there exists such a pair
 *	 0 if there is no such pair, but there is a pair of equal values
 *	-1 otherwise
 *	-2 if some error occurred.
 */
================================================================================

文件路径: ./isl_map.c
注释行数: 18
注释内容:
/* Return -1 if the constraint "c1" should be sorted before "c2"
 * and 1 if it should be sorted after "c2".
 * Return 0 if the two constraints are the same (up to the constant term).
 *
 * In particular, if a constraint involves later variables than another
 * then it is sorted after this other constraint.
 * uset_gist depends on constraints without existentially quantified
 * variables sorting first.
 *
 * For constraints that have the same latest variable, those
 * with the same coefficient for this latest variable (first in absolute value
 * and then in actual value) are grouped together.
 * This is useful for detecting pairs of constraints that can
 * be chained in their printed representation.
 *
 * Finally, within a group, constraints are sorted according to
 * their coefficients (excluding the constant term).
 */
================================================================================

文件路径: ./isl_map.c
注释行数: 10
注释内容:
/* Remove obvious duplicates among the basic maps of "map".
 *
 * Unlike isl_map_normalize, this function does not remove redundant
 * constraints and only removes duplicates that have exactly the same
 * constraints in the input.  It does sort the constraints and
 * the basic maps to ease the detection of duplicates.
 *
 * If "map" has already been normalized or if the basic maps are
 * disjoint, then there can be no duplicates.
 */
================================================================================

文件路径: ./isl_map.c
注释行数: 15
注释内容:
/* Look for a pair of inequality constraints in "bmap" of the form
 *
 *	-l + i >= 0		or		i >= l
 * and
 *	n + l - i >= 0		or		i <= l + n
 *
 * with n < "m" and i the output dimension at position "pos".
 * (Note that n >= 0 as otherwise the two constraints would conflict.)
 * Furthermore, "l" is only allowed to involve parameters, input dimensions
 * and earlier output dimensions, as well as integer divisions that do
 * not involve any of the output dimensions.
 *
 * Return the index of the first inequality constraint or bmap->n_ineq
 * if no such pair can be found.
 */
================================================================================

文件路径: ./isl_map.c
注释行数: 23
注释内容:
/* Return the index of the equality of "bmap" that defines
 * the output dimension "pos" in terms of earlier dimensions.
 * The equality may also involve integer divisions, as long
 * as those integer divisions are defined in terms of
 * parameters or input dimensions.
 * In this case, *div is set to the number of integer divisions and
 * *ineq is set to the number of inequality constraints (provided
 * div and ineq are not NULL).
 *
 * The equality may also involve a single integer division involving
 * the output dimensions (typically only output dimension "pos") as
 * long as the coefficient of output dimension "pos" is 1 or -1 and
 * there is a pair of constraints i >= l and i <= l + n, with i referring
 * to output dimension "pos", l an expression involving only earlier
 * dimensions and n smaller than the coefficient of the integer division
 * in the equality.  In this case, the output dimension can be defined
 * in terms of a modulo expression that does not involve the integer division.
 * *div is then set to this single integer division and
 * *ineq is set to the index of constraint i >= l.
 *
 * Return bmap->n_eq if there is no such equality.
 * Return -1 on error.
 */
================================================================================

文件路径: ./isl_map.c
注释行数: 26
注释内容:
/* Plug in "subs" for dimension "type", "pos" of "bset".
 *
 * Let i be the dimension to replace and let "subs" be of the form
 *
 *	f/d
 *
 * Any integer division with a non-zero coefficient for i,
 *
 *	floor((a i + g)/m)
 *
 * is replaced by
 *
 *	floor((a f + d g)/(m d))
 *
 * Constraints of the form
 *
 *	a i + g
 *
 * are replaced by
 *
 *	a f + d g
 *
 * We currently require that "subs" is an integral expression.
 * Handling rational expressions may require us to add stride constraints
 * as we do in isl_basic_set_preimage_multi_aff.
 */
================================================================================

文件路径: ./isl_map.c
注释行数: 18
注释内容:
/* For each affine expression in ma of the form
 *
 *	x_i = (f_i y + h_i)/m_i
 *
 * with m_i different from one, add a constraint to "bmap"
 * of the form
 *
 *	f_i y + h_i = m_i alpha_i
 *
 * with alpha_i an additional existentially quantified variable.
 *
 * The input variables of "ma" correspond to a subset of the variables
 * of "bmap".  There are "n_before" variables in "bmap" before this
 * subset and "n_after" variables after this subset.
 * The integer divisions of the affine expressions in "ma" are assumed
 * to have been aligned.  There are "n_div_ma" of them and
 * they appear first in "bmap", straight after the "n_after" variables.
 */
================================================================================

文件路径: ./isl_map.c
注释行数: 46
注释内容:
/* Compute the preimage of the domain or range (depending on "type")
 * of "bmap" under the function represented by "ma".
 * In other words, plug in "ma" in the domain or range of "bmap".
 * The result is a basic map that lives in the same space as "bmap"
 * except that the domain or range has been replaced by
 * the domain space of "ma".
 *
 * If bmap is represented by
 *
 *	A(p) + S u + B x + T v + C(divs) >= 0,
 *
 * where u and x are input and output dimensions if type == isl_dim_out
 * while x and v are input and output dimensions if type == isl_dim_in,
 * and ma is represented by
 *
 *	x = D(p) + F(y) + G(divs')
 *
 * then the result is
 *
 *	A(p) + B D(p) + S u + B F(y) + T v + B G(divs') + C(divs) >= 0
 *
 * The divs in the input set are similarly adjusted.
 * In particular
 *
 *	floor((a_i(p) + s u + b_i x + t v + c_i(divs))/n_i)
 *
 * becomes
 *
 *	floor((a_i(p) + b_i D(p) + s u + b_i F(y) + t v +
 *		B_i G(divs') + c_i(divs))/n_i)
 *
 * If bmap is not a rational map and if F(y) involves any denominators
 *
 *	x_i = (f_i y + h_i)/m_i
 *
 * then additional constraints are added to ensure that we only
 * map back integer points.  That is we enforce
 *
 *	f_i y + h_i = m_i alpha_i
 *
 * with alpha_i an additional existentially quantified variable.
 *
 * We first copy over the divs from "ma".
 * Then we add the modified constraints and divs from "bmap".
 * Finally, we add the stride constraints, if needed.
 */
================================================================================

文件路径: ./isl_map.c
注释行数: 15
注释内容:
/* Compute the preimage of "map" under the function represented by "mpa".
 * In other words, plug in "mpa" in the domain or range of "map".
 * The result is a map that lives in the same space as "map",
 * except that the space of type "type" has been replaced by
 * the domain space of "mpa".
 *
 * If the map does not involve any constraints that refer to the
 * dimensions of the substituted space, then the only possible
 * effect of "mpa" on the map is to map the space to a different space.
 * We create a separate isl_multi_aff to effectuate this change
 * in order to avoid spurious splitting of the map along the pieces
 * of "mpa".
 * If "mpa" has a non-trivial explicit domain, however,
 * then the full substitution should be performed.
 */
================================================================================

文件路径: ./isl_map.c
注释行数: 17
注释内容:
/* Tighten the inequality constraints of "bset" that are outward with respect
 * to the point "vec".
 * That is, tighten the constraints that are not satisfied by "vec".
 *
 * "vec" is a point internal to some superset S of "bset" that is used
 * to make the subsets of S disjoint, by tightening one half of the constraints
 * that separate two subsets.  In particular, the constraints of S
 * are all satisfied by "vec" and should not be tightened.
 * Of the internal constraints, those that have "vec" on the outside
 * are tightened.  The shared facet is included in the adjacent subset
 * with the opposite constraint.
 * For constraints that saturate "vec", this criterion cannot be used
 * to determine which of the two sides should be tightened.
 * Instead, the sign of the first non-zero coefficient is used
 * to make this choice.  Note that this second criterion is never used
 * on the constraints of S since "vec" is interior to "S".
 */
================================================================================

文件路径: ./isl_affine_hull.c
注释行数: 13
注释内容:
/*
 * Copyright 2008-2009 Katholieke Universiteit Leuven
 * Copyright 2010      INRIA Saclay
 * Copyright 2012      Ecole Normale Superieure
 *
 * Use of this software is governed by the MIT license
 *
 * Written by Sven Verdoolaege, K.U.Leuven, Departement
 * Computerwetenschappen, Celestijnenlaan 200A, B-3001 Leuven, Belgium
 * and INRIA Saclay - Ile-de-France, Parc Club Orsay Universite,
 * ZAC des vignes, 4 rue Jacques Monod, 91893 Orsay, France
 * and Ecole Normale Superieure, 45 rue d'Ulm, 75230 Paris, France
 */
================================================================================

文件路径: ./isl_affine_hull.c
注释行数: 15
注释内容:
/* Find an integer point in the set represented by "tab"
 * that lies outside of the equality "eq" e(x) = 0.
 * If "up" is true, look for a point satisfying e(x) - 1 >= 0.
 * Otherwise, look for a point satisfying -e(x) - 1 >= 0 (i.e., e(x) <= -1).
 * The point, if found, is returned.
 * If no point can be found, a zero-length vector is returned.
 *
 * Before solving an ILP problem, we first check if simply
 * adding the normal of the constraint to one of the known
 * integer points in the basic set represented by "tab"
 * yields another point inside the basic set.
 *
 * The caller of this function ensures that the tableau is bounded or
 * that tab->basis and tab->n_unbounded have been set appropriately.
 */
================================================================================

文件路径: ./isl_affine_hull.c
注释行数: 13
注释内容:
/* Extend an initial (under-)approximation of the affine hull of basic
 * set represented by the tableau "tab"
 * by looking for points that do not satisfy one of the equalities
 * in the current approximation and adding them to that approximation
 * until no such points can be found any more.
 *
 * The caller of this function ensures that "tab" is bounded or
 * that tab->basis and tab->n_unbounded have been set appropriately.
 *
 * "bset" may be either NULL or the basic set represented by "tab".
 * If "bset" is not NULL, we check for any point we find if any
 * of its adjacent points also belong to "bset".
 */
================================================================================

文件路径: ./isl_affine_hull.c
注释行数: 10
注释内容:
/* Given a tableau of a set and a tableau of the corresponding
 * recession cone, detect and add all equalities to the tableau.
 * If the tableau is bounded, then we can simply keep the
 * tableau in its state after the return from extend_affine_hull.
 * However, if the tableau is unbounded, then
 * isl_tab_set_initial_basis_with_cone will add some additional
 * constraints to the tableau that have to be removed again.
 * In this case, we therefore rollback to the state before
 * any constraints were added and then add the equalities back in.
 */
================================================================================

文件路径: ./isl_affine_hull.c
注释行数: 31
注释内容:
/* Compute the affine hull of "bset", where "cone" is the recession cone
 * of "bset".
 *
 * We first compute a unimodular transformation that puts the unbounded
 * directions in the last dimensions.  In particular, we take a transformation
 * that maps all equalities to equalities (in HNF) on the first dimensions.
 * Let x be the original dimensions and y the transformed, with y_1 bounded
 * and y_2 unbounded.
 *
 *	       [ y_1 ]			[ y_1 ]   [ Q_1 ]
 *	x = U  [ y_2 ]			[ y_2 ] = [ Q_2 ] x
 *
 * Let's call the input basic set S.  We compute S' = preimage(S, U)
 * and drop the final dimensions including any constraints involving them.
 * This results in set S''.
 * Then we compute the affine hull A'' of S''.
 * Let F y_1 >= g be the constraint system of A''.  In the transformed
 * space the y_2 are unbounded, so we can add them back without any constraints,
 * resulting in
 *
 *		        [ y_1 ]
 *		[ F 0 ] [ y_2 ] >= g
 * or
 *		        [ Q_1 ]
 *		[ F 0 ] [ Q_2 ] x >= g
 * or
 *		F Q_1 x >= g
 *
 * The affine hull in the original space is then obtained as
 * A = preimage(A'', Q_1).
 */
================================================================================

文件路径: ./isl_affine_hull.c
注释行数: 16
注释内容:
/* Look for all equalities satisfied by the integer points in bset,
 * which is assumed not to have any explicit equalities.
 *
 * The equalities are obtained by successively looking for
 * a point that is affinely independent of the points found so far.
 * In particular, for each equality satisfied by the points so far,
 * we check if there is any point on a hyperplane parallel to the
 * corresponding hyperplane shifted by at least one (in either direction).
 *
 * Before looking for any outside points, we first compute the recession
 * cone.  The directions of this recession cone will always be part
 * of the affine hull, so there is no need for looking for any points
 * in these directions.
 * In particular, if the recession cone is full-dimensional, then
 * the affine hull is simply the whole universe.
 */
================================================================================

文件路径: ./isl_affine_hull.c
注释行数: 13
注释内容:
/* Look for all equalities satisfied by the integer points in bmap
 * that are independent of the equalities already explicitly available
 * in bmap.
 *
 * We first remove all equalities already explicitly available,
 * then look for additional equalities in the reduced space
 * and then transform the result to the original space.
 * The original equalities are _not_ added to this set.  This is
 * the responsibility of the calling function.
 * The resulting basic set has all meaning about the dimensions removed.
 * In particular, dimensions that correspond to existential variables
 * in bmap and that are found to be fixed are not removed.
 */
================================================================================

文件路径: ./isl_affine_hull.c
注释行数: 18
注释内容:
/* Given a rational affine matrix "M", add stride constraints to "bmap"
 * that ensure that
 *
 *		M(x)
 *
 * is an integer vector.  The variables x include all the variables
 * of "bmap" except the unknown divs.
 *
 * If d is the common denominator of M, then we need to impose that
 *
 *		d M(x) = 0 	mod d
 *
 * or
 *
 *		exists alpha : d M(x) = d alpha
 *
 * This function is similar to add_strides in isl_morph.c
 */
================================================================================

文件路径: ./isl_affine_hull.c
注释行数: 27
注释内容:
/* If there are any equalities that involve (multiple) unknown divs,
 * then extract the stride information encoded by those equalities
 * and make it explicitly available in "bmap".
 *
 * We first sort the divs so that the unknown divs appear last and
 * then we count how many equalities involve these divs.
 *
 * Let these equalities be of the form
 *
 *		A(x) + B y = 0
 *
 * where y represents the unknown divs and x the remaining variables.
 * Let [H 0] be the Hermite Normal Form of B, i.e.,
 *
 *		B = [H 0] Q
 *
 * Then x is a solution of the equalities iff
 *
 *		H^-1 A(x) (= - [I 0] Q y)
 *
 * is an integer vector.  Let d be the common denominator of H^-1.
 * We impose
 *
 *		d H^-1 A(x) = d alpha
 *
 * in add_strides, with alpha fresh existentially quantified variables.
 */
================================================================================

文件路径: ./isl_affine_hull.c
注释行数: 12
注释内容:
/* Compute the affine hull of each basic map in "map" separately
 * and make all stride information explicit so that we can remove
 * all unknown divs without losing this information.
 * The result is also guaranteed to be gaussed.
 *
 * In simple cases where a div is determined by an equality,
 * calling isl_basic_map_gauss is enough to make the stride information
 * explicit, as it will derive an explicit representation for the div
 * from the equality.  If, however, the stride information
 * is encoded through multiple unknown divs then we need to make
 * some extra effort in isl_basic_map_make_strides_explicit.
 */
================================================================================

文件路径: ./isl_affine_hull.c
注释行数: 19
注释内容:
/* Compute the affine hull of "map".
 *
 * We first compute the affine hull of each basic map separately.
 * Then we align the divs and recompute the affine hulls of the basic
 * maps since some of them may now have extra divs.
 * In order to avoid performing parametric integer programming to
 * compute explicit expressions for the divs, possible leading to
 * an explosion in the number of basic maps, we first drop all unknown
 * divs before aligning the divs.  Note that isl_map_local_affine_hull tries
 * to make sure that all stride information is explicitly available
 * in terms of known divs.  This involves calling isl_basic_set_gauss,
 * which is also needed because affine_hull assumes its input has been gaussed,
 * while isl_map_affine_hull may be called on input that has not been gaussed,
 * in particular from initial_facet_constraint.
 * Similarly, align_divs may reorder some divs so that we need to
 * gauss the result again.
 * Finally, we combine the individual affine hulls into a single
 * affine hull.
 */
================================================================================

文件路径: ./isl_union_templ.c
注释行数: 11
注释内容:
/*
 * Copyright 2010      INRIA Saclay
 * Copyright 2013      Ecole Normale Superieure
 *
 * Use of this software is governed by the MIT license
 *
 * Written by Sven Verdoolaege, INRIA Saclay - Ile-de-France,
 * Parc Club Orsay Universite, ZAC des vignes, 4 rue Jacques Monod,
 * 91893 Orsay, France 
 * and Ecole Normale Superieure, 45 rue d'Ulm, 75230 Paris, France
 */
================================================================================

文件路径: ./isl_union_templ.c
注释行数: 14
注释内容:
/* Data structure that specifies how isl_union_*_transform
 * should modify the base expressions in the union expression.
 *
 * If "inplace" is set, then the base expression in the input union
 * are modified in place.  This means that "fn" should not
 * change the meaning of the union or that the union only
 * has a single reference.
 * If "space" is not NULL, then a new union is created in this space.
 * If "filter" is not NULL, then only the base expressions that satisfy "filter"
 * are taken into account.
 * "filter_user" is passed as the second argument to "filter".
 * If "fn" it not NULL, then it is applied to each entry in the input.
 * "fn_user" is passed as the second argument to "fn".
 */
================================================================================

文件路径: ./isl_union_templ.c
注释行数: 10
注释内容:
/* Compute the sum of "u1" and "u2" on the union of their domains,
 * with the actual sum on the shared domain and
 * the defined expression on the symmetric difference of the domains.
 *
 * This is an internal function that is exposed under different
 * names depending on whether the base expressions have a zero default
 * value.
 * If they do, then this function is called "add".
 * Otherwise, it is called "union_add".
 */
================================================================================

文件路径: ./isl_union_templ.c
注释行数: 13
注释内容:
/* Data structure that specifies how isl_union_*_match_domain_op
 * should combine its arguments.
 *
 * If "filter" is not NULL, then only parts that pass the given
 * filter are considered for matching.
 * "fn" is applied to each part in the union and each corresponding
 * set in the union set, i.e., such that the set lives in the same space
 * as the domain of the part.
 * If "match_space" is not NULL, then the set extracted from the union set
 * does not live in the same space as the domain of the part,
 * but rather in the space that results from calling "match_space"
 * on this domain space.
 */
================================================================================

文件路径: ./isl_sort.c
注释行数: 23
注释内容:
/*
 * The code of this file was taken from http://jeffreystedfast.blogspot.be,
 * where it was posted in 2011 by Jeffrey Stedfast under the MIT license.
 * The MIT license text is as follows:
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to
 * deal in the Software without restriction, including without limitation the
 * rights to use, copy, modify, merge, publish, distribute, sublicense, and/or
 * sell copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in
 * all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
 * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS
 * IN THE SOFTWARE.
 */
================================================================================

文件路径: ./isl_sort.c
注释行数: 19
注释内容:
/* The code here is an optimized merge sort. Starting from a generic merge sort
 * the following optimizations were applied:
 *
 * o Batching of memcpy() calls: Instead of calling memcpy() to copy each and
 *   every element into a temporary buffer, blocks of elements are copied
 *   at a time.
 *
 * o To reduce the number of memcpy() calls further, copying leading
 *   and trailing elements into our temporary buffer is avoided, in case it is
 *   not necessary to merge them.
 *
 * A further optimization could be to specialize memcpy calls based on the
 * size of the types we compare. For now, this code does not include the
 * relevant optimization, as clang e.g. inlines a very efficient memcpy()
 * implementation. It is not clear, that the specialized version as provided in
 * the blog post, is really superior to the one that will be inlined by
 * default. So we decided to keep the code simple until this optimization was
 * proven to be beneficial.
 */
================================================================================

文件路径: ./isl_vec.c
注释行数: 10
注释内容:
/*
 * Copyright 2008-2009 Katholieke Universiteit Leuven
 * Copyright 2013      Ecole Normale Superieure
 *
 * Use of this software is governed by the MIT license
 *
 * Written by Sven Verdoolaege, K.U.Leuven, Departement
 * Computerwetenschappen, Celestijnenlaan 200A, B-3001 Leuven, Belgium
 * and Ecole Normale Superieure, 45 rue d’Ulm, 75230 Paris, France
 */
================================================================================

文件路径: ./isl_morph.c
注释行数: 11
注释内容:
/*
 * Copyright 2010-2011 INRIA Saclay
 * Copyright 2014      Ecole Normale Superieure
 *
 * Use of this software is governed by the MIT license
 *
 * Written by Sven Verdoolaege, INRIA Saclay - Ile-de-France,
 * Parc Club Orsay Universite, ZAC des vignes, 4 rue Jacques Monod,
 * 91893 Orsay, France 
 * and Ecole Normale Superieure, 45 rue d'Ulm, 75230 Paris, France
 */
================================================================================

文件路径: ./isl_morph.c
注释行数: 25
注释内容:
/* Given a basic set, exploit the equalities in the basic set to construct
 * a morphism that maps the basic set to a lower-dimensional space.
 * Specifically, the morphism reduces the number of dimensions of type "type".
 *
 * We first select the equalities of interest, that is those that involve
 * variables of type "type" and no later variables.
 * Denote those equalities as
 *
 *		-C(p) + M x = 0
 *
 * where C(p) depends on the parameters if type == isl_dim_set and
 * is a constant if type == isl_dim_param.
 *
 * Use isl_mat_final_variable_compression to construct a compression
 *
 *	x = T x'
 *
 *	x' = Q x
 *
 * If T is a zero-column matrix, then the set of equality constraints
 * do not admit a solution.  In this case, an empty morphism is returned.
 *
 * Both matrices are extended to map the full original space to the full
 * compressed space.
 */
================================================================================

文件路径: ./isl_morph.c
注释行数: 16
注释内容:
/* Construct a parameter compression for "bset".
 * We basically just call isl_mat_parameter_compression with the right input
 * and then extend the resulting matrix to include the variables.
 *
 * The implementation assumes that "bset" does not have any equalities
 * that only involve the parameters and that isl_basic_set_gauss has
 * been applied to "bset".
 *
 * Let the equalities be given as
 *
 *	B(p) + A x = 0.
 *
 * We use isl_mat_parameter_compression_ext to compute the compression
 *
 *	p = T p'.
 */
================================================================================

文件路径: ./isl_farkas.c
注释行数: 47
注释内容:
/*
 * Let C be a cone and define
 *
 *	C' := { y | forall x in C : y x >= 0 }
 *
 * C' contains the coefficients of all linear constraints
 * that are valid for C.
 * Furthermore, C'' = C.
 *
 * If C is defined as { x | A x >= 0 }
 * then any element in C' must be a non-negative combination
 * of the rows of A, i.e., y = t A with t >= 0.  That is,
 *
 *	C' = { y | exists t >= 0 : y = t A }
 *
 * If any of the rows in A actually represents an equality, then
 * also negative combinations of this row are allowed and so the
 * non-negativity constraint on the corresponding element of t
 * can be dropped.
 *
 * A polyhedron P = { x | b + A x >= 0 } can be represented
 * in homogeneous coordinates by the cone
 * C = { [z,x] | b z + A x >= and z >= 0 }
 * The valid linear constraints on C correspond to the valid affine
 * constraints on P.
 * This is essentially Farkas' lemma.
 *
 * Since
 *				  [ 1 0 ]
 *		[ w y ] = [t_0 t] [ b A ]
 *
 * we have
 *
 *	C' = { w, y | exists t_0, t >= 0 : y = t A and w = t_0 + t b }
 * or
 *
 *	C' = { w, y | exists t >= 0 : y = t A and w - t b >= 0 }
 *
 * In practice, we introduce an extra variable (w), shifting all
 * other variables to the right, and an extra inequality
 * (w - t b >= 0) corresponding to the positivity constraint on
 * the homogeneous coordinate.
 *
 * When going back from coefficients to solutions, we immediately
 * plug in 1 for z, which corresponds to shifting all variables
 * to the left, with the leftmost ending up in the constant position.
 */
================================================================================

文件路径: ./isl_farkas.c
注释行数: 13
注释内容:
/* Given a dimension specification of the solutions space, construct
 * a dimension specification for the space of coefficients.
 *
 * In particular transform
 *
 *	[params] -> { S }
 *
 * to
 *
 *	{ coefficients[[cst, params] -> S] }
 *
 * and prefix each dimension name with "c_".
 */
================================================================================

文件路径: ./isl_farkas.c
注释行数: 13
注释内容:
/* Given a dimension specification of the space of coefficients, construct
 * a dimension specification for the space of solutions.
 *
 * In particular transform
 *
 *	{ coefficients[[cst, params] -> S] }
 *
 * to
 *
 *	[params] -> { S }
 *
 * and drop the "c_" prefix from the dimension names.
 */
================================================================================

文件路径: ./isl_farkas.c
注释行数: 13
注释内容:
/* Compute the dual of "bset" by applying Farkas' lemma.
 * As explained above, we add an extra dimension to represent
 * the coefficient of the constant term when going from solutions
 * to coefficients (shift == 1) and we drop the extra dimension when going
 * in the opposite direction (shift == -1).
 * The dual can be created in an arbitrary space.
 * The caller is responsible for putting the result in the appropriate space.
 *
 * If "bset" is (obviously) empty, then the way this emptiness
 * is represented by the constraints does not allow for the application
 * of the standard farkas algorithm.  We therefore handle this case
 * specifically and return the universe basic set.
 */
================================================================================

文件路径: ./isl_farkas.c
注释行数: 14
注释内容:
/* Information about a single factor within isl_basic_set_coefficients_product.
 *
 * "start" is the position of the first coefficient (beyond
 * the one corresponding to the constant term) in this factor.
 * "dim" is the number of coefficients (other than
 * the one corresponding to the constant term) in this factor.
 * "n_line" is the number of lines in "coeff".
 * "n_ray" is the number of rays (other than lines) in "coeff".
 * "n_vertex" is the number of vertices in "coeff".
 *
 * While iterating over the vertices,
 * "pos" represents the inequality constraint corresponding
 * to the current vertex.
 */
================================================================================

文件路径: ./isl_farkas.c
注释行数: 10
注释内容:
/* Add a vertex to the product "bset" combining the currently selected
 * vertices of the factors.
 *
 * In the dual representation, the constant term is always zero.
 * The vertex itself is the sum of the contributions of the factors
 * with a shared denominator in position 1.
 *
 * First compute the shared denominator (lcm) and
 * then scale the numerators to this shared denominator.
 */
================================================================================

文件路径: ./isl_farkas.c
注释行数: 35
注释内容:
/* Combine the duals of the factors in the factorization of a basic set
 * to form the dual of the entire basic set.
 * The dual share the coefficient of the constant term.
 * All other coefficients are specific to a factor.
 * Any constraint not involving the coefficient of the constant term
 * can therefor simply be copied into the appropriate position.
 * This includes all equality constraints since the coefficient
 * of the constant term can always be increased and therefore
 * never appears in an equality constraint.
 * The inequality constraints involving the coefficient of
 * the constant term need to be combined across factors.
 * In particular, if this coefficient needs to be greater than or equal
 * to some linear combination of the other coefficients in each factor,
 * then it needs to be greater than or equal to the sum of
 * these linear combinations across the factors.
 *
 * Alternatively, the constraints of the dual can be seen
 * as the vertices, rays and lines of the original basic set.
 * Clearly, rays and lines can simply be copied,
 * while vertices needs to be combined across factors.
 * This means that the number of rays and lines in the product
 * is equal to the sum of the numbers in the factors,
 * while the number of vertices is the product
 * of the number of vertices in the factors.  Note that each
 * factor has at least one vertex.
 * The only exception is when the factor is the dual of an obviously empty set,
 * in which case a universe dual is created.
 * In this case, return a universe dual for the product as well.
 *
 * While constructing the vertices, look for the first combination
 * of inequality constraints that represent a vertex,
 * construct the corresponding vertex and then move on
 * to the next combination of inequality constraints until
 * all combinations have been considered.
 */
================================================================================

文件路径: ./isl_farkas.c
注释行数: 11
注释内容:
/* Given a factorization "f" of a basic set,
 * construct a basic set containing the tuples of coefficients of all
 * valid affine constraints on the product of the factors, ignoring
 * the space of input and output.
 * Note that this product may not be equal to the original basic set,
 * if a non-trivial transformation is involved.
 * This is handled by the caller.
 *
 * Compute the tuples of coefficients for each factor separately and
 * then combine the results.
 */
================================================================================

文件路径: ./isl_farkas.c
注释行数: 15
注释内容:
/* Given a factorization "f" of a basic set,
 * construct a basic set containing the tuples of coefficients of all
 * valid affine constraints on the basic set, ignoring
 * the space of input and output.
 *
 * The factorization may involve a linear transformation of the basic set.
 * In particular, the transformed basic set is formulated
 * in terms of x' = U x, i.e., x = V x', with V = U^{-1}.
 * The dual is then computed in terms of y' with y'^t [z; x'] >= 0.
 * Plugging in y' = [1 0; 0 V^t] y yields
 * y^t [1 0; 0 V] [z; x'] >= 0, i.e., y^t [z; x] >= 0, which is
 * the desired set of coefficients y.
 * Note that this transformation to y' only needs to be applied
 * if U is not the identity matrix.
 */
================================================================================

文件路径: ./isl_farkas.c
注释行数: 16
注释内容:
/* Construct a basic set containing the tuples of coefficients of all
 * valid affine constraints on the given basic set, ignoring
 * the space of input and output.
 *
 * The caller has already checked that "bset" does not involve
 * any local variables.  It may have parameters, though.
 * Treat them as regular variables internally.
 * This is especially important for the factorization,
 * since the (original) parameters should be taken into account
 * explicitly in this factorization.
 *
 * Check if the basic set can be factorized.
 * If so, compute constraints on the coefficients of the factors
 * separately and combine the results.
 * Otherwise, compute the results for the input basic set as a whole.
 */
================================================================================

文件路径: ./isl_range.c
注释行数: 15
注释内容:
/* Given a lower and upper bound on the final variable and constraints
 * on the remaining variables where these bounds are active,
 * eliminate the variable from data->poly based on these bounds.
 * If the polynomial has been determined to be monotonic
 * in the variable, then simply plug in the appropriate bound.
 * If the current polynomial is tight and if this bound is integer,
 * then the result is still tight.  In all other cases, the results
 * may not be tight.
 * Otherwise, plug in the largest bound (in absolute value) in
 * the positive terms (if an upper bound is wanted) or the negative terms
 * (if a lower bounded is wanted) and the other bound in the other terms.
 *
 * If all variables have been eliminated, then record the result.
 * Ohterwise, recurse on the next variable.
 */
================================================================================

文件路径: ./isl_map_subtract.c
注释行数: 11
注释内容:
/* Expand the constraint "c" into "v".  The initial "dim" dimensions
 * are the same, but "v" may have more divs than "c" and the divs of "c"
 * may appear in different positions in "v".
 * The number of divs in "c" is given by "n_div" and the mapping
 * of divs in "c" to divs in "v" is given by "div_map".
 *
 * Although it shouldn't happen in practice, it is theoretically
 * possible that two or more divs in "c" are mapped to the same div in "v".
 * These divs are then necessarily the same, so we simply add their
 * coefficients.
 */
================================================================================

文件路径: ./isl_map_subtract.c
注释行数: 29
注释内容:
/* Compute the set difference between bmap and map and call
 * dc->add on each of the piece until this function returns
 * a negative value.
 * Return 0 on success and -1 on error.  dc->add returning
 * a negative value is treated as an error, but the calling
 * function can interpret the results based on the state of dc.
 *
 * Assumes that map has known divs.
 *
 * The difference is computed by a backtracking algorithm.
 * Each level corresponds to a basic map in "map".
 * When a node in entered for the first time, we check
 * if the corresonding basic map intersects the current piece
 * of "bmap".  If not, we move to the next level.
 * Otherwise, we split the current piece into as many
 * pieces as there are non-redundant constraints of the current
 * basic map in the intersection.  Each of these pieces is
 * handled by a child of the current node.
 * In particular, if there are n non-redundant constraints,
 * then for each 0 <= i < n, a piece is cut off by adding
 * constraints 0 <= j < i and adding the opposite of constraint i.
 * If there are no non-redundant constraints, meaning that the current
 * piece is a subset of the current basic map, then we simply backtrack.
 *
 * In the leaves, we check if the remaining piece has any integer points
 * and if so, pass it along to dc->add.  As a special case, if nothing
 * has been removed when we end up in a leaf, we simply pass along
 * the original basic map.
 */
================================================================================

文件路径: ./isl_seq.c
注释行数: 20
注释内容:
/* Given two affine expressions "p" of length p_len (including the
 * denominator and the constant term) and "subs" of length subs_len,
 * plug in "subs" for the variable at position "pos".
 * The variables of "subs" and "p" are assumed to match up to subs_len,
 * but "p" may have additional variables.
 * "v" is an initialized isl_int that can be used internally.
 *
 * In particular, if "p" represents the expression
 *
 *	(a i + g)/m
 *
 * with i the variable at position "pos" and "subs" represents the expression
 *
 *	f/d
 *
 * then the result represents the expression
 *
 *	(a f + d g)/(m d)
 *
 */
================================================================================

文件路径: ./isl_input.c
注释行数: 15
注释内容:
/*
 * Copyright 2008-2009 Katholieke Universiteit Leuven
 * Copyright 2010      INRIA Saclay
 * Copyright 2012-2013 Ecole Normale Superieure
 * Copyright 2019      Cerebras Systems
 *
 * Use of this software is governed by the MIT license
 *
 * Written by Sven Verdoolaege, K.U.Leuven, Departement
 * Computerwetenschappen, Celestijnenlaan 200A, B-3001 Leuven, Belgium
 * and INRIA Saclay - Ile-de-France, Parc Club Orsay Universite,
 * ZAC des vignes, 4 rue Jacques Monod, 91893 Orsay, France 
 * and Ecole Normale Superieure, 45 rue d’Ulm, 75230 Paris, France
 * and Cerebras Systems, 175 S San Antonio Rd, Los Altos, CA, USA
 */
================================================================================

文件路径: ./isl_input.c
注释行数: 12
注释内容:
/* Read an isl_val from "s".
 *
 * The following token sequences are recognized
 *
 *	"infty"		->	infty
 *	"-" "infty"	->	-infty
 *	"NaN"		->	NaN
 *	n "/" d		->	n/d
 *	v		->	v
 *
 * where n, d and v are integer constants.
 */
================================================================================

文件路径: ./isl_input.c
注释行数: 10
注释内容:
/* Read an integer division from "s" and return it as an isl_pw_aff.
 *
 * The integer division can be of the form
 *
 *	[<affine expression>]
 *	floor(<affine expression>)
 *	ceil(<affine expression>)
 *	floord(<affine expression>,<denominator>)
 *	ceild(<affine expression>,<denominator>)
 */
================================================================================

文件路径: ./isl_input.c
注释行数: 12
注释内容:
/* Impose the lower bound "lower" on the variable represented by "range_pa".
 *
 * In particular, "range_pa" is of the form
 *
 *	D[..., i] -> i : C
 *
 * with D also the domains space of "lower' and "C" some constraints.
 *
 * Return the expression
 *
 *	D[..., i] -> i : C and i >= lower
 */
================================================================================

文件路径: ./isl_input.c
注释行数: 12
注释内容:
/* Impose the upper bound "upper" on the variable represented by "range_pa".
 *
 * In particular, "range_pa" is of the form
 *
 *	D[..., i] -> i : C
 *
 * with D also the domains space of "upper' and "C" some constraints.
 *
 * Return the expression
 *
 *	D[..., i] -> i : C and i <= upper
 */
================================================================================

文件路径: ./isl_input.c
注释行数: 12
注释内容:
/* Construct a piecewise affine expression corresponding
 * to the last variable in "v" that is greater than or equal to "pa".
 *
 * In particular, if D is the domain space of "pa",
 * then construct the expression
 *
 *	D[..., i] -> i,
 *
 * impose lower bound "pa" and return
 *
 *	D[..., i] -> i : i >= pa
 */
================================================================================

文件路径: ./isl_input.c
注释行数: 12
注释内容:
/* Construct a piecewise affine expression corresponding
 * to the last variable in "v" that is smaller than or equal to "pa".
 *
 * In particular, if D is the domain space of "pa",
 * then construct the expression
 *
 *	D[..., i] -> i,
 *
 * impose lower bound "pa" and return
 *
 *	D[..., i] -> i : i <= pa
 */
================================================================================

文件路径: ./isl_input.c
注释行数: 12
注释内容:
/* Construct a piecewise affine expression corresponding
 * to the last variable in "v" that ranges between "pa" and "pa2".
 *
 * In particular, if D is the domain space of "pa" (and "pa2"),
 * then construct the expression
 *
 *	D[..., i] -> i,
 *
 * impose lower bound "pa" and upper bound "pa2" and return
 *
 *	D[..., i] -> i : pa <= i <= pa2
 */
================================================================================

文件路径: ./isl_input.c
注释行数: 15
注释内容:
/* Given that the (piecewise) affine expression "pa"
 * has just been parsed, followed by a colon,
 * continue parsing as part of a piecewise affine expression.
 *
 * In particular, check if the colon is followed by a condition.
 * If so, parse the conditions(a) on "pa" and include them in the domain.
 * Otherwise, if the colon is followed by another (piecewise) affine expression
 * then consider the two expressions as endpoints of a range of values and
 * return a piecewise affine expression that takes values in that range.
 * Note that an affine expression followed by a comparison operator
 * is considered to be part of a condition.
 * If the colon is not followed by anything (inside the tuple element),
 * then consider "pa" as a lower bound on a range of values without upper bound
 * and return a piecewise affine expression that takes values in that range.
 */
================================================================================

文件路径: ./isl_input.c
注释行数: 35
注释内容:
/* Accept a piecewise affine expression.
 *
 * At the outer level, the piecewise affine expression may be of the form
 *
 *	aff1 : condition1; aff2 : conditions2; ...
 *
 * or one of
 *
 *	aff :
 *	aff1 : aff2
 *	: aff
 *	:
 *
 * or simply
 *
 *	aff
 *
 * each of the affine expressions may in turn include ternary operators.
 *
 * If the first token is a colon, then the expression must be
 * ":" or ": aff2", depending on whether anything follows the colon
 * inside the tuple element.
 * The first is considered to represent an arbitrary value.
 * The second is considered to represent a range of values
 * with the given upper bound and no lower bound.
 *
 * There may be parentheses around some subexpression of "aff1"
 * around "aff1" itself, around "aff1 : condition1" and/or
 * around the entire piecewise affine expression.
 * We therefore remove the opening parenthesis (if any) from the stream
 * in case the closing parenthesis follows the colon, but if the closing
 * parenthesis is the first thing in the stream after the parsed affine
 * expression, we push the parsed expression onto the stream and parse
 * again in case the parentheses enclose some subexpression of "aff1".
 */
================================================================================

文件路径: ./isl_input.c
注释行数: 10
注释内容:
/* This function is called for each element in a tuple inside read_tuple.
 * Add a new variable to "v" and construct a corresponding isl_pw_aff defined
 * over a space containing all variables in "v" defined so far.
 * The isl_pw_aff expresses the new variable in terms of earlier variables
 * if a definition is provided.  Otherwise, it is represented as being
 * equal to itself.
 * Add the isl_pw_aff to *list.
 * If the new variable was named, then adjust "space" accordingly and
 * return the updated space.
 */
================================================================================

文件路径: ./isl_input.c
注释行数: 15
注释内容:
/* Read a tuple and represent it as an isl_multi_pw_aff.
 * The range space of the isl_multi_pw_aff is the space of the tuple.
 * The domain space is an anonymous space
 * with a dimension for each variable in the set of variables in "v",
 * including the variables in the range.
 * If a given dimension is not defined in terms of earlier dimensions in
 * the input, then the corresponding isl_pw_aff is set equal to one time
 * the variable corresponding to the dimension being defined.
 *
 * The elements in the tuple are collected in a list by read_tuple_pw_aff_el.
 * Each element in this list is defined over a space representing
 * the variables defined so far.  We need to adjust the earlier
 * elements to have as many variables in the domain as the final
 * element in the list.
 */
================================================================================

文件路径: ./isl_input.c
注释行数: 15
注释内容:
/* Given two equal-length lists of piecewise affine expression with the space
 * of "set" as domain, construct a set in the same space that expresses
 * that "left" and "right" satisfy the comparison "type".
 *
 * A space is constructed of the same dimension as the number of elements
 * in the two lists.  The comparison is then expressed in a map from
 * this space to itself and wrapped into a set.  Finally the two lists
 * of piecewise affine expressions are plugged into this set.
 *
 * Let S be the space of "set" and T the constructed space.
 * The lists are first changed into two isl_multi_pw_affs in S -> T and
 * then combined into an isl_multi_pw_aff in S -> [T -> T],
 * while the comparison is first expressed in T -> T, then [T -> T]
 * and finally in S.
 */
================================================================================

文件路径: ./isl_input.c
注释行数: 14
注释内容:
/* Construct constraints of the form
 *
 *	a op b
 *
 * where a is an element in "left", op is an operator of type "type" and
 * b is an element in "right", add the constraints to "set" and return
 * the result.
 * "rational" is set if the constraints should be treated as
 * a rational constraints.
 *
 * If "type" is the type of a comparison operator between lists
 * of affine expressions, then a single (compound) constraint
 * is constructed by list_cmp instead.
 */
================================================================================

文件路径: ./isl_input.c
注释行数: 19
注释内容:
/* Read a constraint from "s", add it to "map" and return the result.
 * "v" contains a description of the identifiers parsed so far.
 * "rational" is set if the constraint should be treated as
 * a rational constraint.
 * The constraint read from "s" may be applied to multiple pairs
 * of affine expressions and may be chained.
 * In particular, a list of affine expressions is read, followed
 * by a comparison operator and another list of affine expressions.
 * The comparison operator is then applied to each pair of elements
 * in the two lists and the results are added to "map".
 * However, if the operator expects two lists of affine expressions,
 * then it is applied directly to those lists and the two lists
 * are required to have the same length.
 * If the next token is another comparison operator, then another
 * list of affine expressions is read and the process repeats.
 *
 * The processing is performed on a wrapped copy of "map" because
 * an affine expression cannot have a binary relation as domain.
 */
================================================================================

文件路径: ./isl_input.c
注释行数: 15
注释内容:
/* Parse an expression between parentheses and push the result
 * back on the stream.
 *
 * The parsed expression may be either an affine expression
 * or a condition.  The first type is pushed onto the stream
 * as an isl_pw_aff, while the second is pushed as an isl_map.
 *
 * If the initial token indicates the start of a condition,
 * we parse it as such.
 * Otherwise, we first parse an affine expression and push
 * that onto the stream.  If the affine expression covers the
 * entire expression between parentheses, we return.
 * Otherwise, we assume that the affine expression is the
 * start of a condition and continue parsing.
 */
================================================================================

文件路径: ./isl_input.c
注释行数: 21
注释内容:
/* Read a first order formula from "s", add the corresponding
 * constraints to "map" and return the result.
 *
 * In particular, read a formula of the form
 *
 *	a
 *
 * or
 *
 *	a implies b
 *
 * where a and b are disjunctions.
 *
 * In the first case, map is replaced by
 *
 *	map \cap { [..] : a }
 *
 * In the second case, it is replaced by
 *
 *	(map \setminus { [..] : a}) \cup (map \cap { [..] : b })
 */
================================================================================

文件路径: ./isl_input.c
注释行数: 12
注释内容:
/* First read the domain of the affine expression, which may be
 * a parameter space or a set.
 * The tricky part is that we don't know if the domain is a set or not,
 * so when we are trying to read the domain, we may actually be reading
 * the affine expression itself (defined on a parameter domains)
 * If the tuple we are reading is named, we assume it's the domain.
 * Also, if inside the tuple, the first thing we find is a nested tuple
 * or a new identifier, we again assume it's the domain.
 * Finally, if the tuple is empty, then it must be the domain
 * since it does not contain an affine expression.
 * Otherwise, we assume we are reading an affine expression.
 */
================================================================================

文件路径: ./isl_input.c
注释行数: 15
注释内容:
/* Extract an isl_multi_pw_aff with domain space "dom_space"
 * from a tuple "tuple" read by read_tuple.
 *
 * Note that the function read_tuple accepts tuples where some output or
 * set dimensions are defined in terms of other output or set dimensions
 * since this function is also used to read maps.  As a special case,
 * read_tuple also accept dimensions that are defined in terms of themselves
 * (i.e., that are not defined).
 * These cases are not allowed when extracting an isl_multi_pw_aff so check
 * that the definitions of the output/set dimensions do not involve any
 * output/set dimensions.
 * Finally, drop the output dimensions from the domain of the result
 * of read_tuple (which is of the form [input, output] -> [output],
 * with anonymous domain) and reset the space.
 */
================================================================================

文件路径: ./isl_input.c
注释行数: 13
注释内容:
/* Read a tuple of affine expressions, together with optional constraints
 * on the domain from "s".  "dom" represents the initial constraints
 * on the domain.
 *
 * The isl_multi_aff may live in either a set or a map space.
 * First read the first tuple and check if it is followed by a "->".
 * If so, convert the tuple into the domain of the isl_multi_pw_aff and
 * read in the next tuple.  This tuple (or the first tuple if it was
 * not followed by a "->") is then converted into an isl_multi_pw_aff
 * through a call to extract_mpa_from_tuple.
 * The result is converted to an isl_pw_multi_aff and
 * its domain is intersected with the domain.
 */
================================================================================

文件路径: ./isl_input.c
注释行数: 18
注释内容:
/* Read an isl_multi_pw_aff from "s".
 *
 * The input format is similar to that of map, except that any conditions
 * on the domains should be specified inside the tuple since each
 * piecewise affine expression may have a different domain.
 * However, additional, shared conditions can also be specified.
 * This is especially useful for setting the explicit domain
 * of a zero-dimensional isl_multi_pw_aff.
 *
 * Since we do not know in advance if the isl_multi_pw_aff lives
 * in a set or a map space, we first read the first tuple and check
 * if it is followed by a "->".  If so, we convert the tuple into
 * the domain of the isl_multi_pw_aff and read in the next tuple.
 * This tuple (or the first tuple if it was not followed by a "->")
 * is then converted into the isl_multi_pw_aff through a call
 * to extract_mpa_from_tuple and the domain of the result
 * is intersected with the domain.
 */
================================================================================

文件路径: ./isl_input.c
注释行数: 14
注释内容:
/* Read the core of a body of an isl_multi_union_pw_aff from "s",
 * i.e., everything except the parameter specification and
 * without shared domain constraints.
 * "v" contains a description of the identifiers parsed so far.
 * The parameters, if any, are specified by "space".
 *
 * The body is of the form
 *
 *	[{ [..] : ... ; [..] : ... }, { [..] : ... ; [..] : ... }]
 *
 * Read the tuple, collecting the individual isl_union_pw_aff
 * elements in a list and construct the result from the tuple space and
 * the list.
 */
================================================================================

文件路径: ./isl_input.c
注释行数: 15
注释内容:
/* Read the body of an isl_multi_union_pw_aff from "s",
 * i.e., everything except the parameter specification.
 * "v" contains a description of the identifiers parsed so far.
 * The parameters, if any, are specified by "space".
 *
 * In particular, handle the special case with shared domain constraints.
 * These are specified as
 *
 *	([...] : ...)
 *
 * and are especially useful for setting the explicit domain
 * of a zero-dimensional isl_multi_union_pw_aff.
 * The core isl_multi_union_pw_aff body ([...]) is read by
 * read_multi_union_pw_aff_body_core.
 */
================================================================================

文件路径: ./isl_input.c
注释行数: 25
注释内容:
/* Read an isl_multi_union_pw_aff from "s".
 *
 * The input has the form
 *
 *	[{ [..] : ... ; [..] : ... }, { [..] : ... ; [..] : ... }]
 *
 * or
 *
 *	[..] -> [{ [..] : ... ; [..] : ... }, { [..] : ... ; [..] : ... }]
 *
 * Additionally, a shared domain may be specified as
 *
 *	([..] : ...)
 *
 * or
 *
 *	[..] -> ([..] : ...)
 *
 * The first case is handled by the caller, the second case
 * is handled by read_multi_union_pw_aff_body.
 *
 * We first check for the special case of an empty tuple "[]".
 * Then we check if there are any parameters.
 * Finally, read the tuple and construct the result.
 */
================================================================================

文件路径: ./isl_input.c
注释行数: 12
注释内容:
/* Read an isl_multi_union_pw_aff from "s".
 *
 * In particular, handle the special case with shared domain constraints.
 * These are specified as
 *
 *	([...] : ...)
 *
 * and are especially useful for setting the explicit domain
 * of a zero-dimensional isl_multi_union_pw_aff.
 * The core isl_multi_union_pw_aff ([...]) is read by
 * read_multi_union_pw_aff_core.
 */
================================================================================

文件路径: ./isl_multi_intersect.c
注释行数: 10
注释内容:
/* Intersect the explicit domain of "multi" with "domain".
 *
 * The parameters of "multi" and "domain" are assumed to have been aligned.
 *
 * In the case of an isl_multi_union_pw_aff object, the explicit domain
 * is allowed to have only constraints on the parameters, while
 * "domain" contains actual domain elements.  In this case,
 * "domain" is intersected with those parameter constraints and
 * then used as the explicit domain of "multi".
 */
================================================================================

文件路径: ./isl_ast_graft_private.h
注释行数: 15
注释内容:
/* Representation of part of an AST ("node") with some additional polyhedral
 * information about the tree.
 *
 * "guard" contains conditions that should still be enforced by
 * some ancestor of the current tree.  In particular, the already
 * generated tree assumes that these conditions hold, but may not
 * have enforced them itself.
 * The guard should not contain any unknown divs as it will be used
 * to generate an if condition.
 *
 * "enforced" expresses constraints that are already enforced by the for
 * nodes in the current tree and that therefore do not need to be enforced
 * by any ancestor.
 * The constraints only involve outer loop iterators.
 */
================================================================================

文件路径: ./isl_mat.c
注释行数: 14
注释内容:
/*
 * Copyright 2008-2009 Katholieke Universiteit Leuven
 * Copyright 2010      INRIA Saclay
 * Copyright 2014      Ecole Normale Superieure
 * Copyright 2017      Sven Verdoolaege
 *
 * Use of this software is governed by the MIT license
 *
 * Written by Sven Verdoolaege, K.U.Leuven, Departement
 * Computerwetenschappen, Celestijnenlaan 200A, B-3001 Leuven, Belgium
 * and INRIA Saclay - Ile-de-France, Parc Club Orsay Universite,
 * ZAC des vignes, 4 rue Jacques Monod, 91893 Orsay, France
 * and Ecole Normale Superieure, 45 rue d'Ulm, 75230 Paris, France
 */
================================================================================

文件路径: ./isl_mat.c
注释行数: 12
注释内容:
/* Given matrix M, compute
 *
 *		M U = H
 *		M   = H Q
 *
 * with U and Q unimodular matrices and H a matrix in column echelon form
 * such that on each echelon row the entries in the non-echelon column
 * are non-negative (if neg == 0) or non-positive (if neg == 1)
 * and strictly smaller (in absolute value) than the entries in the echelon
 * column.
 * If U or Q are NULL, then these matrices are not computed.
 */
================================================================================

文件路径: ./isl_mat.c
注释行数: 11
注释内容:
/* Replace the variables x in the rows q by x' given by x = M x',
 * with M the matrix mat.
 *
 * If the number of new variables is greater than the original
 * number of variables, then the rows q have already been
 * preextended.  If the new number is smaller, then the coefficients
 * of the divs, which are not changed, need to be shifted down.
 * The row q may be the equalities, the inequalities or the
 * div expressions.  In the latter case, has_div is true and
 * we need to take into account the extra denominator column.
 */
================================================================================

文件路径: ./isl_mat.c
注释行数: 10
注释内容:
/* Replace the variables x in bset by x' given by x = M x', with
 * M the matrix mat.
 *
 * If there are fewer variables x' then there are x, then we perform
 * the transformation in place, which means that, in principle,
 * this frees up some extra variables as the number
 * of columns remains constant, but we would have to extend
 * the div array too as the number of rows in this array is assumed
 * to be equal to extra.
 */
================================================================================

文件路径: ./isl_mat.c
注释行数: 12
注释内容:
/* Return rows that extend a basis of "mat1" to one
 * that covers both "mat1" and "mat2".
 * The Hermite normal form of the concatenation of the two matrices is
 *
 *	                     [ Q1 ]
 *	[ M1 ] = [ H1 0  0 ] [ Q2 ]
 *	[ M2 ] = [ H2 H3 0 ] [ Q3 ]
 *
 * The number of columns in H1 and H3 determine the number of rows
 * in Q1 and Q2.  Q1 is a basis for M1, while Q2 extends this basis
 * to also cover M2.
 */
================================================================================

文件路径: ./isl_tarjan.h
注释行数: 10
注释内容:
/* Structure for representing the graph being traversed
 * using Tarjan's algorithm.
 * len is the number of nodes
 * node is an array of nodes
 * stack contains the nodes on the path from the root to the current node
 * sp is the stack pointer
 * index is the index of the last node visited
 * order contains the elements of the components separated by -1
 * op represents the current position in order
 */
================================================================================

文件路径: ./isl_space.c
注释行数: 15
注释内容:
/*
 * Copyright 2008-2009 Katholieke Universiteit Leuven
 * Copyright 2010      INRIA Saclay
 * Copyright 2013-2014 Ecole Normale Superieure
 * Copyright 2018-2019 Cerebras Systems
 *
 * Use of this software is governed by the MIT license
 *
 * Written by Sven Verdoolaege, K.U.Leuven, Departement
 * Computerwetenschappen, Celestijnenlaan 200A, B-3001 Leuven, Belgium
 * and INRIA Saclay - Ile-de-France, Parc Club Orsay Universite,
 * ZAC des vignes, 4 rue Jacques Monod, 91893 Orsay, France 
 * and Ecole Normale Superieure, 45 rue d’Ulm, 75230 Paris, France
 * and Cerebras Systems, 175 S San Antonio Rd, Los Altos, CA, USA
 */
================================================================================

文件路径: ./isl_space.c
注释行数: 12
注释内容:
/* Check if the tuple of type "type1" of "space1" is the same as
 * the tuple of type "type2" of "space2".
 *
 * That is, check if the tuples have the same identifier, the same dimension
 * and the same internal structure.
 * The identifiers of the dimensions inside the tuples do not affect the result.
 *
 * Note that this function only checks the tuples themselves.
 * If nested tuples are involved, then we need to be careful not
 * to have result affected by possibly differing parameters
 * in those nested tuples.
 */
================================================================================

文件路径: ./isl_space.c
注释行数: 14
注释内容:
/* Internal function that introduces a domain in "space"
 * corresponding to the range space of "tuple".
 * In particular, if "space" is a parameter space, then the result
 * is a set space.  If "space" is a set space, then the result
 * is a map space with the original space as range.
 * Parameters that correspond to the identifiers in "tuple" are removed.
 *
 * The parameters are removed in reverse order (under the assumption
 * that they appear in the same order in "multi") because
 * it is slightly more efficient to remove parameters at the end.
 *
 * For pretty-printing purposes, the identifiers of the set dimensions
 * of the introduced domain are set to the identifiers in "tuple".
 */
================================================================================

文件路径: ./isl_test_cpp-generic.cc
注释行数: 14
注释内容:
/* Test the pointer interface for interaction between isl C and C++ types.
 *
 * This tests:
 * - construction from an isl C object
 * - check that constructed objects are non-null
 * - get a non-owned C pointer from an isl C++ object usable in __isl_keep
 *   methods
 * - use copy to get an owned C pointer from an isl C++ object which is usable
 *   in __isl_take methods. Verify that the original C++ object retains a valid
 *   pointer.
 * - use release to get an owned C pointer from an isl C++ object which is
 *   usable in __isl_take methods. Verify that the original C++ object gave up
 *   its pointer and now is null.
 */
================================================================================

文件路径: ./isl_test_cpp-generic.cc
注释行数: 18
注释内容:
/* Test that isl objects can be constructed.
 *
 * This tests:
 *  - construction of a null object
 *  - construction from a string
 *  - construction from an integer
 *  - static constructor without a parameter
 *  - conversion construction (implicit)
 *  - conversion construction (explicit)
 *  - construction of empty union set
 *
 *  The tests to construct from integers and strings cover functionality that
 *  is also tested in the parameter type tests, but here we verify that
 *  multiple overloaded constructors are available and that overload resolution
 *  works as expected.
 *
 *  Construction from an isl C pointer is tested in test_pointer.
 */
================================================================================

文件路径: ./isl_output.c
注释行数: 15
注释内容:
/*
 * Copyright 2008-2009 Katholieke Universiteit Leuven
 * Copyright 2010      INRIA Saclay
 * Copyright 2012-2013 Ecole Normale Superieure
 * Copyright 2019      Cerebras Systems
 *
 * Use of this software is governed by the MIT license
 *
 * Written by Sven Verdoolaege, K.U.Leuven, Departement
 * Computerwetenschappen, Celestijnenlaan 200A, B-3001 Leuven, Belgium
 * and INRIA Saclay - Ile-de-France, Parc Club Orsay Universite,
 * ZAC des vignes, 4 rue Jacques Monod, 91893 Orsay, France 
 * and Ecole Normale Superieure, 45 rue d'Ulm, 75230 Paris, France
 * and Cerebras Systems, 175 S San Antonio Rd, Los Altos, CA, USA
 */
================================================================================

文件路径: ./isl_output.c
注释行数: 11
注释内容:
/* Print one side of a constraint "c" to "p", with
 * the variable names taken from "space" and the integer division definitions
 * taken from "div".
 * "last" is the position of the last non-zero coefficient.
 * Let c' be the result of zeroing out this coefficient, then
 * the partial constraint
 *
 *	c' op
 *
 * is printed.
 */
================================================================================

文件路径: ./isl_output.c
注释行数: 11
注释内容:
/* Given an integer division
 *
 *	floor(f/m)
 *
 * at position "pos" in "div", print the corresponding modulo expression
 *
 *	(f) mod m
 *
 * to "p".  The variable names are taken from "space", while any
 * nested integer division definitions are taken from "div".
 */
================================================================================

文件路径: ./isl_output.c
注释行数: 15
注释内容:
/* Given an equality constraint with a non-zero coefficient "c"
 * in position "pos", is this term of the form
 *
 *	a m floor(g/m),
 *
 * with c = a m?
 * Return the position of the corresponding integer division if so.
 * Return the number of integer divisions if not.
 * Return isl_size_error on error.
 *
 * Modulo constraints are currently not printed in C format.
 * Other than that, "pos" needs to correspond to an integer division
 * with explicit representation and "c" needs to be a multiple
 * of the denominator of the integer division.
 */
================================================================================

文件路径: ./isl_output.c
注释行数: 16
注释内容:
/* Print equality constraint "c" to "p" as a modulo constraint,
 * with the variable names taken from "space" and
 * the integer division definitions taken from "div".
 * "last" is the position of the last non-zero coefficient, which is
 * moreover assumed to be negative and a multiple of the denominator
 * of the corresponding integer division.  "div_pos" is the corresponding
 * position in the sequence of integer divisions.
 *
 * The equality is of the form
 *
 *	f - a m floor(g/m) = 0.
 *
 * Print it as
 *
 *	a (g mod m) = -f + a g
 */
================================================================================

文件路径: ./isl_output.c
注释行数: 40
注释内容:
/* Print the constraints of "bmap" to "p".
 * The names of the variables are taken from "space" and
 * the integer division definitions are taken from "div".
 * Div constraints are only printed in "dump" mode.
 * The constraints are sorted prior to printing (except in "dump" mode).
 *
 * If x is the last variable with a non-zero coefficient,
 * then a lower bound
 *
 *	f - a x >= 0
 *
 * is printed as
 *
 *	a x <= f
 *
 * while an upper bound
 *
 *	f + a x >= 0
 *
 * is printed as
 *
 *	a x >= -f
 *
 * If the next constraint has an opposite sign for the same last coefficient,
 * then it is printed as
 *
 *	f >= a x
 *
 * or
 *
 *	-f <= a x
 *
 * instead.  In fact, the "a x" part is not printed explicitly, but
 * reused from the next constraint, which is therefore treated as
 * a first constraint in the conjunction.
 *
 * If the constant term of "f" is -1, then "f" is replaced by "f + 1" and
 * the comparison operator is replaced by the strict variant.
 * Essentially, ">= 1" is replaced by "> 0".
 */
================================================================================

文件路径: ./isl_output.c
注释行数: 20
注释内容:
/* Look for the last of the "n" integer divisions that is used in "aff" and
 * that can be printed as a modulo and
 * return the position of this integer division.
 * Return "n" if no such integer division can be found.
 * Return isl_size_error on error.
 *
 * In particular, look for an integer division that appears in "aff"
 * with a coefficient that is a multiple of the denominator
 * of the integer division.
 * That is, check if the numerator of "aff" is of the form
 *
 *	f(...) + a m floor(g/m)
 *
 * and return the position of "floor(g/m)".
 *
 * Note that, unlike print_as_modulo_pos, no check needs to be made
 * for whether the integer division can be printed, since it will
 * need to be printed as an integer division anyway if it is not printed
 * as a modulo.
 */
================================================================================

文件路径: ./isl_output.c
注释行数: 16
注释内容:
/* Print the numerator of the affine expression "aff" to "p",
 * with the variable names taken from "space",
 * given that the numerator of "aff" is of the form
 *
 *	f(...) + a m floor(g/m)
 *
 * with "floor(g/m)" the integer division at position "last".
 *
 * First replace "aff" by its numerator and rewrite it as
 *
 *	f(...) + a g - a (g mod m)
 *
 * Recursively write out (the numerator of) "f(...) + a g"
 * (which may involve other modulo expressions) and
 * then write out "- a (g mod m)".
 */
================================================================================

文件路径: ./isl_output.c
注释行数: 11
注释内容:
/* Print dimension "pos" of data->space to "p".
 *
 * data->user is assumed to be an isl_multi_pw_aff.
 *
 * If the current dimension is an output dimension, then print
 * the corresponding piecewise affine expression.
 * Otherwise, print the name of the dimension.
 * Make sure to use the same space in both cases.
 * In particular, use the domain space for printing names as
 * that is the space that is used for printing constraints.
 */
================================================================================

文件路径: ./isl_scan.c
注释行数: 18
注释内容:
/* Look for all integer points in "bset", which is assumed to be bounded,
 * and call callback->add on each of them.
 *
 * We first compute a reduced basis for the set and then scan
 * the set in the directions of this basis.
 * We basically perform a depth first search, where in each level i
 * we compute the range in the i-th basis vector direction, given
 * fixed values in the directions of the previous basis vector.
 * We then add an equality to the tableau fixing the value in the
 * direction of the current basis vector to each value in the range
 * in turn and then continue to the next level.
 *
 * The search is implemented iteratively.  "level" identifies the current
 * basis vector.  "init" is true if we want the first value at the current
 * level and false if we want the next value.
 * Solutions are added in the leaves of the search tree, i.e., after
 * we have fixed a value in each direction of the basis.
 */
================================================================================

文件路径: ./isl_factorization.c
注释行数: 14
注释内容:
/*
 * Copyright 2005-2007 Universiteit Leiden
 * Copyright 2008-2009 Katholieke Universiteit Leuven
 * Copyright 2010      INRIA Saclay
 *
 * Use of this software is governed by the MIT license
 *
 * Written by Sven Verdoolaege, Leiden Institute of Advanced Computer Science,
 * Universiteit Leiden, Niels Bohrweg 1, 2333 CA Leiden, The Netherlands
 * and K.U.Leuven, Departement Computerwetenschappen, Celestijnenlaan 200A,
 * B-3001 Leuven, Belgium
 * and INRIA Saclay - Ile-de-France, Parc Club Orsay Universite,
 * ZAC des vignes, 4 rue Jacques Monod, 91893 Orsay, France 
 */
================================================================================

文件路径: ./isl_int_sioimath.h
注释行数: 41
注释内容:
/* The type to represent integers optimized for small values. It is either a
 * pointer to an mp_int ( = mpz_t*; big representation) or an int32_t (small
 * represenation) with a discriminator at the least significant bit. In big
 * representation it will be always zero because of heap alignment. It is set
 * to 1 for small representation and use the 32 most significant bits for the
 * int32_t.
 *
 * Structure on 64 bit machines, with 8-byte aligment (3 bits):
 *
 * Big representation:
 * MSB                                                          LSB
 * |------------------------------------------------------------000
 * |                            mpz_t*                            |
 * |                           != NULL                            |
 *
 * Small representation:
 * MSB                           32                             LSB
 * |------------------------------|00000000000000000000000000000001
 * |          int32_t             |
 * |  2147483647 ... -2147483647  |
 *                                                                ^
 *                                                                |
 *                                                        discriminator bit
 *
 * On 32 bit machines isl_sioimath type is blown up to 8 bytes, i.e.
 * isl_sioimath is guaranteed to be at least 8 bytes. This is to ensure the
 * int32_t can be hidden in that type without data loss. In the future we might
 * optimize this to use 31 hidden bits in a 32 bit pointer. We may also use 63
 * bits on 64 bit machines, but this comes with the cost of additional overflow
 * checks because there is no standardized 128 bit integer we could expand to.
 *
 * We use native integer types and avoid union structures to avoid assumptions
 * on the machine's endianness.
 *
 * This implementation makes the following assumptions:
 * - long can represent any int32_t
 * - mp_small is signed long
 * - mp_usmall is unsigned long
 * - adresses returned by malloc are aligned to 2-byte boundaries (leastmost
 *   bit is zero)
 */
================================================================================

文件路径: ./isl_int_sioimath.h
注释行数: 11
注释内容:
/* The negation of the smallest possible number in int32_t, INT32_MIN
 * (0x80000000u, -2147483648), cannot be represented in an int32_t, therefore
 * every operation that may produce this value needs to special-case it.
 * The operations are:
 * abs(INT32_MIN)
 * -INT32_MIN   (negation)
 * -1 * INT32_MIN (multiplication)
 * INT32_MIN/-1 (any division: divexact, fdiv, cdiv, tdiv)
 * To avoid checking these cases, we exclude INT32_MIN from small
 * representation.
 */
================================================================================

文件路径: ./isl_int_sioimath.h
注释行数: 22
注释内容:
/* A common situation is to call an IMath function with at least one argument
 * that is currently in small representation or an integer parameter, i.e. a big
 * representation of the same number is required. Promoting the original
 * argument comes with multiple problems, such as modifying a read-only
 * argument, the responsibility of deallocation and the execution cost. Instead,
 * we make a copy by 'faking' the IMath internal structure.
 *
 * We reserve the maximum number of required digits on the stack to avoid heap
 * allocations.
 *
 * mp_digit can be uint32_t or uint16_t. This code must work for little and big
 * endian digits. The structure for an uint64_t argument and 32-bit mp_digits is
 * sketched below.
 *
 * |----------------------------|
 *            uint64_t
 *
 * |-------------||-------------|
 *    mp_digit        mp_digit
 *    digits[1]       digits[0]
 * Most sig digit  Least sig digit
 */
================================================================================

文件路径: ./isl_int_sioimath.h
注释行数: 12
注释内容:
/* Convert a native integer to IMath's digit representation. A native integer
 * might be big- or little endian, but IMath always stores the least significant
 * digit in the lowest array indices.  memcpy therefore is not possible.
 *
 * We also have to consider that long and mp_digit can be of different sizes,
 * depending on the compiler (LP64, LLP64) and IMath's USE_64BIT_WORDS. This
 * macro should work for all of them.
 *
 * "used" is set to the number of written digits. It must be minimal (IMath
 * checks zeroness using the used field), but always at least one.  Also note
 * that the result of num>>(sizeof(num)*CHAR_BIT) is undefined.
 */
================================================================================

文件路径: ./isl_schedule_node.c
注释行数: 12
注释内容:
/*
 * Copyright 2013-2014 Ecole Normale Superieure
 * Copyright 2014      INRIA Rocquencourt
 * Copyright 2016      Sven Verdoolaege
 *
 * Use of this software is governed by the MIT license
 *
 * Written by Sven Verdoolaege,
 * Ecole Normale Superieure, 45 rue d'Ulm, 75230 Paris, France
 * and Inria Paris - Rocquencourt, Domaine de Voluceau - Rocquencourt,
 * B.P. 105 - 78153 Le Chesnay, France
 */
================================================================================

文件路径: ./isl_schedule_node.c
注释行数: 13
注释内容:
/* Internal data structure for
 * isl_schedule_node_get_prefix_schedule_union_pw_multi_aff
 *
 * "initialized" is set if the filter field has been initialized.
 * If "universe_domain" is not set, then the collected filter is intersected
 * with the domain of the root domain node.
 * "universe_filter" is set if we are only collecting the universes of filters
 * "collect_prefix" is set if we are collecting prefixes.
 * "filter" collects all outer filters and is NULL until "initialized" is set.
 * "prefix" collects all outer band partial schedules (if "collect_prefix"
 * is set).  If it is used, then it is initialized by the caller
 * of collect_filter_prefix to a zero-dimensional function.
 */
================================================================================

文件路径: ./isl_schedule_node.c
注释行数: 15
注释内容:
/* Update "data" based on the tree node "tree" in case "data" has
 * not been initialized yet.
 *
 * Return 0 on success and -1 on error.
 *
 * If "tree" is a filter, then we set data->filter to this filter
 * (or its universe).
 * If "tree" is a domain, then this means we have reached the root
 * of the schedule tree without being able to extract any information.
 * We therefore initialize data->filter to the universe of the domain,
 * or the domain itself if data->universe_domain is not set.
 * If "tree" is a band with at least one member, then we set data->filter
 * to the universe of the schedule domain and replace the zero-dimensional
 * data->prefix by the band schedule (if data->collect_prefix is set).
 */
================================================================================

文件路径: ./isl_schedule_node.c
注释行数: 14
注释内容:
/* Update "data" based on the tree node "tree" in case "data" has
 * already been initialized.
 *
 * Return 0 on success and -1 on error.
 *
 * If "tree" is a domain and data->universe_domain is not set, then
 * intersect data->filter with the domain.
 * If "tree" is a filter, then we intersect data->filter with this filter
 * (or its universe).
 * If "tree" is a band with at least one member and data->collect_prefix
 * is set, then we extend data->prefix with the band schedule.
 * If "tree" is an extension, then we make sure that we are not collecting
 * information on any extended domain elements.
 */
================================================================================

文件路径: ./isl_schedule_node.c
注释行数: 26
注释内容:
/* Collect filter and/or prefix information from the first "n"
 * elements in "list" (which represent the ancestors of a node).
 * Store the results in "data".
 *
 * Extension nodes are only supported if they do not affect the outcome,
 * i.e., if we are collecting information on non-extended domain elements,
 * or if we are collecting the universe domain (without prefix).
 *
 * Return 0 on success and -1 on error.
 *
 * We traverse the list from innermost ancestor (last element)
 * to outermost ancestor (first element), calling collect_filter_prefix_init
 * on each node as long as we have not been able to extract any information
 * yet and collect_filter_prefix_update afterwards.
 * If we come across an expansion node, then we interrupt the traversal
 * and call collect_filter_prefix_expansion to restart the traversal
 * over the remaining ancestors and to combine the results with those
 * that have already been collected.
 * If we come across an extension node and we are only computing
 * the universe domain, then we interrupt the traversal and call
 * collect_universe_domain_extension to restart the traversal
 * over the remaining ancestors and to combine the results with those
 * that have already been collected.
 * On successful return, data->initialized will be set since the outermost
 * ancestor is a domain node, which always results in an initialization.
 */
================================================================================

文件路径: ./isl_schedule_node.c
注释行数: 14
注释内容:
/* Return the concatenation of the partial schedules of all outer band
 * nodes of "node" interesected with all outer filters
 * as an isl_multi_union_pw_aff.
 * None of the ancestors of "node" may be an extension node, unless
 * there is also a filter ancestor that filters out all the extended
 * domain elements.
 *
 * If "node" is pointing at the root of the schedule tree, then
 * there are no domain elements reaching the current node, so
 * we return an empty result.
 *
 * We collect all the filters and partial schedules in collect_filter_prefix
 * and intersect the domain of the combined schedule with the combined filter.
 */
================================================================================

文件路径: ./isl_schedule_node.c
注释行数: 19
注释内容:
/* Return the concatenation of the partial schedules of all outer band
 * nodes of "node" interesected with all outer filters
 * as an isl_union_pw_multi_aff.
 * None of the ancestors of "node" may be an extension node, unless
 * there is also a filter ancestor that filters out all the extended
 * domain elements.
 *
 * If "node" is pointing at the root of the schedule tree, then
 * there are no domain elements reaching the current node, so
 * we return an empty result.
 *
 * We collect all the filters and partial schedules in collect_filter_prefix.
 * The partial schedules are collected as an isl_multi_union_pw_aff.
 * If this isl_multi_union_pw_aff is zero-dimensional, then it does not
 * contain any domain information, so we construct the isl_union_pw_multi_aff
 * result as a zero-dimensional function on the collected filter.
 * Otherwise, we convert the isl_multi_union_pw_aff to
 * an isl_multi_union_pw_aff and intersect the domain with the filter.
 */
================================================================================

文件路径: ./isl_schedule_node.c
注释行数: 11
注释内容:
/* Return the concatenation of the partial schedules of all outer band
 * nodes of "node" intersected with all outer domain constraints.
 * None of the ancestors of "node" may be an extension node, unless
 * there is also a filter ancestor that filters out all the extended
 * domain elements.
 *
 * Essentially, this function intersects the domain of the output
 * of isl_schedule_node_get_prefix_schedule_union_map with the output
 * of isl_schedule_node_get_domain, except that it only traverses
 * the ancestors of "node" once.
 */
================================================================================

文件路径: ./isl_schedule_node.c
注释行数: 12
注释内容:
/* Return the domain elements that reach "node".
 *
 * If "node" is pointing at the root of the schedule tree, then
 * there are no domain elements reaching the current node, so
 * we return an empty result.
 * None of the ancestors of "node" may be an extension node, unless
 * there is also a filter ancestor that filters out all the extended
 * domain elements.
 *
 * Otherwise, we collect all filters reaching the node,
 * intersected with the root domain in collect_filter_prefix.
 */
================================================================================

文件路径: ./isl_schedule_node.c
注释行数: 11
注释内容:
/* Return the subtree schedule of "node".
 *
 * Since isl_schedule_tree_get_subtree_schedule_union_map does not handle
 * trees that do not contain any schedule information, we first
 * move down to the first relevant descendant and handle leaves ourselves.
 *
 * If the subtree rooted at "node" contains any expansion nodes, then
 * the returned subtree schedule is formulated in terms of the expanded
 * domains.
 * The subtree is not allowed to contain any extension nodes.
 */
================================================================================

文件路径: ./isl_schedule_node.c
注释行数: 10
注释内容:
/* Return the number of children of "node"?
 *
 * Any node other than the leaf nodes is considered to have at least
 * one child, even if the corresponding isl_schedule_tree does not
 * have any children.  That is, the number of children of "node" is
 * only zero if its tree is the explicit empty tree.  Otherwise,
 * if the isl_schedule_tree has any children, then it is equal
 * to the number of children of "node".  If it has zero children,
 * then "node" still has a leaf node as child.
 */
================================================================================

文件路径: ./isl_schedule_node.c
注释行数: 10
注释内容:
/* Callback for "traverse" to enter a node and to move
 * to the deepest initial subtree that should be traversed
 * for use in a preorder visit.
 *
 * If the user callback returns a negative value, then we abort
 * the traversal.  If this callback returns zero, then we skip
 * the subtree rooted at the current node.  Otherwise, we move
 * down to the first child and repeat the process until a leaf
 * is reached.
 */
================================================================================

文件路径: ./isl_schedule_node.c
注释行数: 10
注释内容:
/* Traverse the descendants of "node" (including the node itself)
 * in depth first preorder.
 *
 * If "fn" returns isl_bool_error on any of the nodes,
 * then the traversal is aborted.
 * If "fn" returns isl_bool_false on any of the nodes, then the subtree rooted
 * at that node is skipped.
 *
 * Return isl_stat_ok on success and isl_stat_error on failure.
 */
================================================================================

文件路径: ./isl_schedule_node.c
注释行数: 23
注释内容:
/* Tile "node" with tile sizes "sizes".
 *
 * The current node is replaced by two nested nodes corresponding
 * to the tile dimensions and the point dimensions.
 *
 * Return a pointer to the outer (tile) node.
 *
 * If any of the descendants of "node" depend on the set of outer band nodes,
 * then we refuse to tile the node.
 *
 * If the scale tile loops option is set, then the tile loops
 * are scaled by the tile sizes.  If the shift point loops option is set,
 * then the point loops are shifted to start at zero.
 * In particular, these options affect the tile and point loop schedules
 * as follows
 *
 *	scale	shift	original	tile		point
 *
 *	0	0	i		floor(i/s)	i
 *	1	0	i		s * floor(i/s)	i
 *	0	1	i		floor(i/s)	i - s * floor(i/s)
 *	1	1	i		s * floor(i/s)	i - s * floor(i/s)
 */
================================================================================

文件路径: ./isl_schedule_node.c
注释行数: 16
注释内容:
/* Move the band node "node" down to all the leaves in the subtree
 * rooted at "node".
 * Return a pointer to the node in the resulting tree that is in the same
 * position as the node pointed to by "node" in the original tree.
 *
 * If the node only has a leaf child, then nothing needs to be done.
 * Otherwise, the child of the node is removed and the result is
 * appended to all the leaves in the subtree rooted at the original child.
 * Since the node is moved to the leaves, it needs to be expanded
 * according to the expansion, if any, defined by that subtree.
 * In the end, the original node is replaced by the result of
 * attaching copies of the expanded node to the leaves.
 *
 * If any of the nodes in the subtree rooted at "node" depend on
 * the set of outer band nodes then we refuse to sink the band node.
 */
================================================================================

文件路径: ./isl_schedule_node.c
注释行数: 15
注释内容:
/* Update the ancestors of "node" to point to the tree that "node"
 * now points to.
 * That is, replace the child in the original parent that corresponds
 * to the current tree position by node->tree and continue updating
 * the ancestors in the same way until the root is reached.
 *
 * If "fn" is not NULL, then it is called on each ancestor as we move up
 * the tree so that it can modify the ancestor before it is added
 * to the list of ancestors of the modified node.
 * The additional "pos" argument records the position
 * of the "tree" argument in the original schedule tree.
 *
 * If "node" originally points to a leaf of the schedule tree, then make sure
 * that in the end it points to a leaf in the updated schedule tree.
 */
================================================================================

文件路径: ./isl_schedule_node.c
注释行数: 20
注释内容:
/* Internal data structure for the group_ancestor callback.
 *
 * If "finished" is set, then we no longer need to modify
 * any further ancestors.
 *
 * "contraction" and "expansion" represent the expansion
 * that reflects the grouping.
 *
 * "domain" contains the domain elements that reach the position
 * where the grouping is performed.  That is, it is the range
 * of the resulting expansion.
 * "domain_universe" is the universe of "domain".
 * "group" is the set of group elements, i.e., the domain
 * of the resulting expansion.
 * "group_universe" is the universe of "group".
 *
 * "sched" is the schedule for the group elements, in pratice
 * an identity mapping on "group_universe".
 * "dim" is the dimension of "sched".
 */
================================================================================

文件路径: ./isl_schedule_node.c
注释行数: 12
注释内容:
/* Update the band tree root "tree" to refer to the group instances
 * in data->group rather than the original domain elements in data->domain.
 * "pos" is the position in the original schedule tree where the modified
 * "tree" will be attached.
 *
 * Add the part of the identity schedule on the group instances data->sched
 * that corresponds to this band node to the band schedule.
 * If the domain elements that reach the node and that are part
 * of data->domain_universe are all elements of data->domain (and therefore
 * replaced by the group instances) then this data->domain_universe
 * is removed from the domain of the band schedule.
 */
================================================================================

文件路径: ./isl_schedule_node.c
注释行数: 14
注释内容:
/* Update the expansion tree root "tree" to refer to the group instances
 * in data->group rather than the original domain elements in data->domain.
 * "pos" is the position in the original schedule tree where the modified
 * "tree" will be attached.
 *
 * Let G_1 -> D_1 be the expansion of "tree" and G_2 -> D_2 the newly
 * introduced expansion in a descendant of "tree".
 * We first double-check that D_2 is a subset of D_1.
 * Then we remove D_2 from the range of G_1 -> D_1 and add the mapping
 * G_1 -> D_1 . D_2 -> G_2.
 * Simmilarly, we restrict the domain of the contraction to the universe
 * of the range of the updated expansion and add G_2 -> D_2 . D_1 -> G_1,
 * attempting to remove the domain constraints of this additional part.
 */
================================================================================

文件路径: ./isl_schedule_node.c
注释行数: 15
注释内容:
/* Update the tree root "tree" to refer to the group instances
 * in data->group rather than the original domain elements in data->domain.
 * "pos" is the position in the original schedule tree where the modified
 * "tree" will be attached.
 *
 * If we have come across a domain or expansion node before (data->finished
 * is set), then we no longer need perform any modifications.
 *
 * If "tree" is a filter, then we add data->group_universe to the filter.
 * We also remove data->domain_universe from the filter if all the domain
 * elements in this universe that reach the filter node are part of
 * the elements that are being grouped by data->expansion.
 * If "tree" is a band, domain or expansion, then it is handled
 * in a separate function.
 */
================================================================================

文件路径: ./isl_schedule_node.c
注释行数: 19
注释内容:
/* Group the domain elements that reach "node" into instances
 * of a single statement with identifier "group_id".
 * In particular, group the domain elements according to their
 * prefix schedule.
 *
 * That is, introduce an expansion node with as contraction
 * the prefix schedule (with the target space replaced by "group_id")
 * and as expansion the inverse of this contraction (with its range
 * intersected with the domain elements that reach "node").
 * The outer nodes are then modified to refer to the group instances
 * instead of the original domain elements.
 *
 * No instance of "group_id" is allowed to reach "node" prior
 * to the grouping.
 * No ancestor of "node" is allowed to be an extension node.
 *
 * Return a pointer to original node in tree, i.e., the child
 * of the newly introduced expansion node.
 */
================================================================================

文件路径: ./isl_schedule_node.c
注释行数: 29
注释内容:
/* Callback for "traverse" to enter a node and to move
 * to the deepest initial subtree that should be traversed
 * by isl_schedule_node_gist.
 *
 * The "filters" list is extended by one element each time
 * we come across a filter node by the result of intersecting
 * the last element in the list with the filter on the filter node.
 *
 * If the filter on the current filter node is a subset of
 * the original context passed to isl_schedule_node_gist,
 * then there is no need to go into its subtree since it cannot
 * be further simplified by the context.  The "filters" list is
 * still extended for consistency, but the actual value of the
 * added element is immaterial since it will not be used.
 *
 * Otherwise, the filter on the current filter node is replaced by
 * the gist of the original filter with respect to the intersection
 * of the original context with the intermediate filters.
 *
 * If the new element in the "filters" list is empty, then no elements
 * can reach the descendants of the current filter node.  The subtree
 * underneath the filter node is therefore removed.
 *
 * Each expansion node we come across is handled by
 * gist_enter_expansion.
 *
 * Each extension node we come across is handled by
 * gist_enter_extension.
 */
================================================================================

文件路径: ./isl_schedule_node.c
注释行数: 26
注释内容:
/* Callback for "traverse" to leave a node for isl_schedule_node_gist.
 *
 * In particular, if the current node is a filter node, then we remove
 * the element on the "filters" list that was added when we entered
 * the node.  There is no need to compute any gist here, since we
 * already did that when we entered the node.
 *
 * Expansion nodes are handled by gist_leave_expansion.
 *
 * If the current node is an extension, then remove the element
 * in data->filters that was added by gist_enter_extension.
 *
 * If the current node is a band node, then we compute the gist of
 * the band node with respect to the intersection of the original context
 * and the intermediate filters.
 *
 * If the current node is a sequence or set node, then some of
 * the filter children may have become empty and so they are removed.
 * If only one child is left, then the set or sequence node along with
 * the single remaining child filter is removed.  The filter can be
 * removed because the filters on a sequence or set node are supposed
 * to partition the incoming domain instances.
 * In principle, it should then be impossible for there to be zero
 * remaining children, but should this happen, we replace the entire
 * subtree with an empty filter.
 */
================================================================================

文件路径: ./isl_schedule_node.c
注释行数: 11
注释内容:
/* Compute the gist of the subtree at "node" with respect to
 * the reaching domain elements in "context".
 * In particular, compute the gist of all band and filter nodes
 * in the subtree with respect to "context".  Children of set or sequence
 * nodes that end up with an empty filter are removed completely.
 *
 * We keep track of the intersection of "context" with all outer filters
 * of the current node within the subtree in the final element of "filters".
 * Initially, this list contains the single element "context" and it is
 * extended or shortened each time we enter or leave a filter node.
 */
================================================================================

文件路径: ./isl_schedule_node.c
注释行数: 14
注释内容:
/* Callback for "traverse" to enter a node and to move
 * to the deepest initial subtree that should be traversed
 * by isl_schedule_node_get_subtree_expansion.
 *
 * Whenever we come across an expansion node, the last element
 * of data->expansions is combined with the expansion
 * on the expansion node.
 *
 * Whenever we come across a filter node that is the child
 * of a set or sequence node, data->expansions is extended
 * with a new element that restricts the previous element
 * to the elements selected by the filter.
 * The previous element can then be reused while backtracking.
 */
================================================================================

文件路径: ./isl_schedule_node.c
注释行数: 10
注释内容:
/* Callback for "traverse" to leave a node for
 * isl_schedule_node_get_subtree_expansion.
 *
 * If we come across a filter node that is the child
 * of a set or sequence node, then we remove the element
 * of data->expansions that was added in subtree_expansion_enter.
 *
 * If we reach a leaf node, then the accumulated expansion is
 * added to data->res.
 */
================================================================================

文件路径: ./isl_schedule_node.c
注释行数: 11
注释内容:
/* Return a mapping from the domain elements that reach "node"
 * to the corresponding domain elements in the leaves of the subtree
 * rooted at "node" obtained by composing the intermediate expansions.
 *
 * We start out with an identity mapping between the domain elements
 * that reach "node" and compose it with all the expansions
 * on a path from "node" to a leaf while traversing the subtree.
 * Within the children of an a sequence or set node, the
 * accumulated expansion is restricted to the elements selected
 * by the filter child.
 */
================================================================================

文件路径: ./isl_schedule_node.c
注释行数: 14
注释内容:
/* Callback for "traverse" to enter a node and to move
 * to the deepest initial subtree that should be traversed
 * by isl_schedule_node_get_subtree_contraction.
 *
 * Whenever we come across an expansion node, the last element
 * of data->contractions is combined with the contraction
 * on the expansion node.
 *
 * Whenever we come across a filter node that is the child
 * of a set or sequence node, data->contractions is extended
 * with a new element that restricts the previous element
 * to the elements selected by the filter.
 * The previous element can then be reused while backtracking.
 */
================================================================================

文件路径: ./isl_schedule_node.c
注释行数: 10
注释内容:
/* Callback for "traverse" to leave a node for
 * isl_schedule_node_get_subtree_contraction.
 *
 * If we come across a filter node that is the child
 * of a set or sequence node, then we remove the element
 * of data->contractions that was added in subtree_contraction_enter.
 *
 * If we reach a leaf node, then the accumulated contraction is
 * added to data->res.
 */
================================================================================

文件路径: ./isl_schedule_node.c
注释行数: 11
注释内容:
/* Return a mapping from the domain elements in the leaves of the subtree
 * rooted at "node" to the corresponding domain elements that reach "node"
 * obtained by composing the intermediate contractions.
 *
 * We start out with an identity mapping between the domain elements
 * that reach "node" and compose it with all the contractions
 * on a path from "node" to a leaf while traversing the subtree.
 * Within the children of an a sequence or set node, the
 * accumulated contraction is restricted to the elements selected
 * by the filter child.
 */
================================================================================

文件路径: ./isl_schedule_node.c
注释行数: 16
注释内容:
/* Insert an extension node on top of "node" with extension "extension".
 * In addition, insert a filter that separates node from the extension
 * between the extension node and "node".
 * Return a pointer to the inserted filter node.
 *
 * If "node" already appears in an extension (i.e., if it is the child
 * of a filter in a sequence inside an extension node), then extend that
 * extension with "extension" instead.
 * In this case, a pointer to the original filter node is returned.
 * Note that if some of the elements in the new extension live in the
 * same space as those of the original extension or the domain elements
 * reaching the original extension, then we insert a new extension anyway.
 * Otherwise, we would have to adjust the filters in the sequence child
 * of the extension to ensure that the elements in the new extension
 * are filtered out.
 */
================================================================================

文件路径: ./isl_schedule_node.c
注释行数: 16
注释内容:
/* Insert a node "graft" into the schedule tree of "node" such that it
 * is executed before (if "before" is set) or after (if "before" is not set)
 * the node that "node" points to.
 * The root of "graft" is an extension node.
 * Return a pointer to the node that "node" pointed to.
 *
 * We first insert an extension node on top of "node" (or extend
 * the extension node if there already is one), with a filter on "node"
 * separating it from the extension.
 * We then insert a filter in the graft to separate it from the original
 * domain elements and combine the original and new tree in a sequence.
 * If we have extended an extension node, then the children of this
 * sequence are spliced in the sequence of the extended extension
 * at the position where "node" appears in the original extension.
 * Otherwise, the sequence pair is attached to the new extension node.
 */
================================================================================

文件路径: ./isl_schedule_node.c
注释行数: 26
注释内容:
/* Insert a node "graft" into the schedule tree of "node" such that it
 * is executed before (if "before" is set) or after (if "before" is not set)
 * the node that "node" points to.
 * The root of "graft" may be either a domain or an extension node.
 * In the latter case, the domain of the extension needs to correspond
 * to the outer band nodes of "node".
 * The elements of the domain or the range of the extension may not
 * intersect with the domain elements that reach "node".
 * The schedule tree of "graft" may not be anchored.
 *
 * The schedule tree of "node" is modified to include an extension node
 * corresponding to the root node of "graft" as a child of the original
 * parent of "node".  The original node that "node" points to and the
 * child of the root node of "graft" are attached to this extension node
 * through a sequence, with appropriate filters and with the child
 * of "graft" appearing before or after the original "node".
 *
 * If "node" already appears inside a sequence that is the child of
 * an extension node and if the spaces of the new domain elements
 * do not overlap with those of the original domain elements,
 * then that extension node is extended with the new extension
 * rather than introducing a new segment of extension and sequence nodes.
 *
 * Return a pointer to the same node in the modified tree that
 * "node" pointed to in the original tree.
 */
================================================================================

文件路径: ./isl_schedule_node.c
注释行数: 12
注释内容:
/* Insert a node "graft" into the schedule tree of "node" such that it
 * is executed before the node that "node" points to.
 * The root of "graft" may be either a domain or an extension node.
 * In the latter case, the domain of the extension needs to correspond
 * to the outer band nodes of "node".
 * The elements of the domain or the range of the extension may not
 * intersect with the domain elements that reach "node".
 * The schedule tree of "graft" may not be anchored.
 *
 * Return a pointer to the same node in the modified tree that
 * "node" pointed to in the original tree.
 */
================================================================================

文件路径: ./isl_schedule_node.c
注释行数: 12
注释内容:
/* Insert a node "graft" into the schedule tree of "node" such that it
 * is executed after the node that "node" points to.
 * The root of "graft" may be either a domain or an extension node.
 * In the latter case, the domain of the extension needs to correspond
 * to the outer band nodes of "node".
 * The elements of the domain or the range of the extension may not
 * intersect with the domain elements that reach "node".
 * The schedule tree of "graft" may not be anchored.
 *
 * Return a pointer to the same node in the modified tree that
 * "node" pointed to in the original tree.
 */
================================================================================

文件路径: ./isl_schedule_node.c
注释行数: 14
注释内容:
/* Split the domain elements that reach "node" into those that satisfy
 * "filter" and those that do not.  Arrange for the first subset to be
 * executed before or after the second subset, depending on the value
 * of "before".
 * Return a pointer to the tree corresponding to the second subset,
 * except when this subset is empty in which case the original pointer
 * is returned.
 * If both subsets are non-empty, then a sequence node is introduced
 * to impose the order.  If the grandparent of the original node was
 * itself a sequence, then the original child is replaced by two children
 * in this sequence instead.
 * The children in the sequence are copies of the original subtree,
 * simplified with respect to their filters.
 */
================================================================================

文件路径: ./isl_schedule_node.c
注释行数: 11
注释内容:
/* Compute the pullback of schedule node "node"
 * by the function represented by "upma".
 * In other words, plug in "upma" in the iteration domains
 * of schedule node "node".
 * We currently do not handle expansion nodes.
 *
 * Note that this is only a helper function for
 * isl_schedule_pullback_union_pw_multi_aff.  In order to maintain consistency,
 * this function should not be called on a single node without also
 * calling it on all the other nodes.
 */
================================================================================

文件路径: ./isl_schedule_node.c
注释行数: 10
注释内容:
/* Expand the tree rooted at "node" by extending all leaves
 * with an expansion node with as child "tree".
 * The expansion is determined by "contraction" and "domain".
 * That is, the elements of "domain" are contracted according
 * to "contraction".  The expansion relation is then the inverse
 * of "contraction" with its range intersected with "domain".
 *
 * Insert the appropriate expansion node on top of "tree" and
 * then plug in the result in all leaves of "node".
 */
================================================================================

文件路径: ./isl_schedule_node.c
注释行数: 11
注释内容:
/* Given two nodes that point to the same schedule tree, return their
 * closest shared ancestor.
 *
 * Since the two nodes point to the same schedule, they share at least
 * one ancestor, the root of the schedule.  We move down from the root
 * to the first ancestor where the respective children have a different
 * child position.  This is the requested ancestor.
 * If there is no ancestor where the children have a different position,
 * then one node is an ancestor of the other and then this node is
 * the requested ancestor.
 */
================================================================================

文件路径: ./isl_val_sioimath.c
注释行数: 11
注释内容:
/* Store a representation of the absolute value of the numerator of "v"
 * in terms of chunks of size "size" at "chunks".
 * The least significant chunk is stored first.
 * The number of chunks in the result can be obtained by calling
 * isl_val_n_abs_num_chunks.  The user is responsible for allocating
 * enough memory to store the results.
 *
 * In the special case of a zero value, isl_val_n_abs_num_chunks will
 * return one, while impz_export will not fill in any chunks.  We therefore
 * do it ourselves.
 */
================================================================================

文件路径: ./isl_stream.c
注释行数: 39
注释内容:
/* Move to the next state at the innermost level.
 * Return 1 if successful.
 * Return 0 if we are at the end of the innermost level.
 * Return -1 on error.
 *
 * If we are in state isl_yaml_mapping_key_start, then we have just
 * started a mapping and we are expecting a key.  If the mapping started
 * with a '{', then we check if the next token is a '}'.  If so,
 * then the mapping is empty and there is no next state at this level.
 * Otherwise, we assume that there is at least one key (the one from
 * which we derived the indentation in isl_stream_yaml_read_start_mapping.
 *
 * If we are in state isl_yaml_mapping_key, then the we expect a colon
 * followed by a value, so there is always a next state unless
 * some error occurs.
 *
 * If we are in state isl_yaml_mapping_val, then there may or may
 * not be a subsequent key in the same mapping.
 * In flow format, the next key is preceded by a comma.
 * In block format, the next key has the same indentation as the first key.
 * If the first token has a smaller indentation, then we have reached
 * the end of the current mapping.
 *
 * If we are in state isl_yaml_sequence_start, then we have just
 * started a sequence.  If the sequence started with a '[',
 * then we check if the next token is a ']'.  If so, then the sequence
 * is empty and there is no next state at this level.
 * Otherwise, we assume that there is at least one element in the sequence
 * (the one from which we derived the indentation in
 * isl_stream_yaml_read_start_sequence.
 *
 * If we are in state isl_yaml_sequence, then there may or may
 * not be a subsequent element in the same sequence.
 * In flow format, the next element is preceded by a comma.
 * In block format, the next element is introduced by a dash with
 * the same indentation as that of the first element.
 * If the first token is not a dash or if it has a smaller indentation,
 * then we have reached the end of the current sequence.
 */
================================================================================

文件路径: ./isl_stream.c
注释行数: 10
注释内容:
/* Start reading a YAML mapping.
 * Return 0 on success and -1 on error.
 *
 * If the first token on the stream is a '{' then we remove this token
 * from the stream and keep track of the fact that the mapping
 * is given in flow format.
 * Otherwise, we assume the first token is the first key of the mapping and
 * keep track of its indentation, but keep the token on the stream.
 * In both cases, the next token we expect is the first key of the mapping.
 */
================================================================================

文件路径: ./isl_stream.c
注释行数: 12
注释内容:
/* Start reading a YAML sequence.
 * Return 0 on success and -1 on error.
 *
 * If the first token on the stream is a '[' then we remove this token
 * from the stream and keep track of the fact that the sequence
 * is given in flow format.
 * Otherwise, we assume the first token is the dash that introduces
 * the first element of the sequence and keep track of its indentation,
 * but keep the token on the stream.
 * In both cases, the next token we expect is the first element
 * of the sequence.
 */
================================================================================

文件路径: ./isl_union_map.c
注释行数: 14
注释内容:
/*
 * Copyright 2010-2011 INRIA Saclay
 * Copyright 2013-2014 Ecole Normale Superieure
 * Copyright 2014      INRIA Rocquencourt
 * Copyright 2016-2017 Sven Verdoolaege
 *
 * Use of this software is governed by the MIT license
 *
 * Written by Sven Verdoolaege, INRIA Saclay - Ile-de-France,
 * Parc Club Orsay Universite, ZAC des vignes, 4 rue Jacques Monod,
 * 91893 Orsay, France 
 * and Inria Paris - Rocquencourt, Domaine de Voluceau - Rocquencourt,
 * B.P. 105 - 78153 Le Chesnay, France
 */
================================================================================

文件路径: ./isl_union_map.c
注释行数: 17
注释内容:
/* Data structure that specifies how gen_bin_op should
 * construct results from the inputs.
 *
 * If "subtract" is set, then a map in the first input is copied to the result
 * if there is no corresponding map in the second input.
 * Otherwise, a map in the first input with no corresponding map
 * in the second input is ignored.
 * If "filter" is not NULL, then it specifies which maps in the first
 * input may have a matching map in the second input.
 * In particular, it makes sure that "match_space" can be called
 * on the space of the map.
 * "match_space" specifies how to transform the space of a map
 * in the first input to the space of the corresponding map
 * in the second input.
 * "fn_map" specifies how the matching maps, one from each input,
 * should be combined to form a map in the result.
 */
================================================================================

文件路径: ./isl_union_map.c
注释行数: 10
注释内容:
/* Look for the map in data->umap2 that corresponds to "map", if any.
 * Return (isl_bool_true, matching map) if there is one,
 * (isl_bool_false, NULL) if there is no matching map and
 * (isl_bool_error, NULL) on error.
 *
 * If not NULL, then data->control->filter specifies whether "map"
 * can have any matching map.  If so,
 * data->control->match_space specifies which map in data->umap2
 * corresponds to "map".
 */
================================================================================

文件路径: ./isl_union_map.c
注释行数: 18
注释内容:
/* Data structure that specifies how un_op should modify
 * the maps in the union map.
 *
 * If "inplace" is set, then the maps in the input union map
 * are modified in place.  This means that "fn_map" should not
 * change the meaning of the map or that the union map only
 * has a single reference.
 * If "total" is set, then all maps need to be modified and
 * the results need to live in the same space.
 * Otherwise, a new union map is constructed to store the results.
 * If "filter" is not NULL, then only the input maps that satisfy "filter"
 * are taken into account.  "filter_user" is passed as the second argument
 * to "filter".  No filter can be set if "inplace" or
 * "total" is set.
 * At most one of "fn_map" or "fn_map2" can be set, specifying
 * how the maps (selected by "filter") should be transformed.
 * If "fn_map2" is set, then "fn_map2_user" is passed as the second argument.
 */
================================================================================

文件路径: ./isl_union_map.c
注释行数: 15
注释内容:
/* Check if the data->umap is single-valued on "set".
 *
 * If data->umap consists of a single map on "set", then test it
 * as an isl_map.
 *
 * Otherwise, compute
 *
 *	M \circ M^-1
 *
 * check if the result is a subset of the identity mapping and
 * store the result in data->sv.
 *
 * Terminate as soon as data->umap has been determined not to
 * be single-valued.
 */
================================================================================

文件路径: ./isl_union_map.c
注释行数: 12
注释内容:
/* Is "map" obviously not an identity relation because
 * it maps elements from one space to another space?
 * Update *non_identity accordingly.
 *
 * In particular, if the domain and range spaces are the same,
 * then the map is not considered to obviously not be an identity relation.
 * Otherwise, the map is considered to obviously not be an identity relation
 * if it is is non-empty.
 *
 * If "map" is determined to obviously not be an identity relation,
 * then the search is aborted.
 */
================================================================================

文件路径: ./isl_union_map.c
注释行数: 10
注释内容:
/* Given a list of the maps, with their fixed values at output dimension "pos",
 * check whether the ranges of the maps form an obvious partition.
 *
 * We first sort the maps according to their fixed values.
 * If all maps have a different value, then we know the ranges form
 * a partition.
 * Otherwise, we collect the maps with the same fixed value and
 * check whether each such collection is obviously injective
 * based on later dimensions.
 */
================================================================================

文件路径: ./isl_map_lexopt_templ.c
注释行数: 11
注释内容:
/*
 * Copyright 2010      INRIA Saclay
 * Copyright 2012      Ecole Normale Superieure
 *
 * Use of this software is governed by the MIT license
 *
 * Written by Sven Verdoolaege,
 * INRIA Saclay - Ile-de-France, Parc Club Orsay Universite,
 * ZAC des vignes, 4 rue Jacques Monod, 91893 Orsay, France
 * and Ecole Normale Superieure, 45 rue d’Ulm, 75230 Paris, France
 */
================================================================================

文件路径: ./isl_map_lexopt_templ.c
注释行数: 11
注释内容:
/* Compute the lexicographic minimum (or maximum if "flags" includes
 * ISL_OPT_MAX) of "bmap" over the domain "dom" and return the result.
 * If "empty" is not NULL, then *empty is assigned a set that
 * contains those parts of the domain where there is no solution.
 * If "flags" includes ISL_OPT_FULL, then "dom" is NULL and the optimum
 * should be computed over the domain of "bmap".  "empty" is also NULL
 * in this case.
 * If "bmap" is marked as rational (ISL_BASIC_MAP_RATIONAL),
 * then the rational optimum is computed.  Otherwise, the integral optimum
 * is computed.
 */
================================================================================

文件路径: ./isl_map_lexopt_templ.c
注释行数: 17
注释内容:
/* Given a basic map "bmap", compute the lexicographically minimal
 * (or maximal) image element for each domain element in dom.
 * If empty is not NULL, then set *empty to those elements in dom
 * that do not have an image element.
 * If "flags" includes ISL_OPT_FULL, then "dom" is NULL and the optimum
 * should be computed over the domain of "bmap".  "empty" is also NULL
 * in this case.
 *
 * We first make sure the basic sets in dom are disjoint and then
 * simply collect the results over each of the basic sets separately.
 * We could probably improve the efficiency a bit by moving the union
 * domain down into the parametric integer programming.
 *
 * If a full optimum is being computed (i.e., "flags" includes ISL_OPT_FULL),
 * then no domain is given and there is then also no need to consider
 * the disjuncts of the domain.
 */
================================================================================

文件路径: ./isl_aff.c
注释行数: 18
注释内容:
/*
 * Copyright 2011      INRIA Saclay
 * Copyright 2011      Sven Verdoolaege
 * Copyright 2012-2014 Ecole Normale Superieure
 * Copyright 2014      INRIA Rocquencourt
 * Copyright 2016      Sven Verdoolaege
 * Copyright 2018,2020 Cerebras Systems
 *
 * Use of this software is governed by the MIT license
 *
 * Written by Sven Verdoolaege, INRIA Saclay - Ile-de-France,
 * Parc Club Orsay Universite, ZAC des vignes, 4 rue Jacques Monod,
 * 91893 Orsay, France
 * and Ecole Normale Superieure, 45 rue d’Ulm, 75230 Paris, France
 * and Inria Paris - Rocquencourt, Domaine de Voluceau - Rocquencourt,
 * B.P. 105 - 78153 Le Chesnay, France
 * and Cerebras Systems, 175 S San Antonio Rd, Los Altos, CA, USA
 */
================================================================================

文件路径: ./isl_aff.c
注释行数: 19
注释内容:
/* Look for any divs j that appear with a unit coefficient inside
 * the definitions of other divs i and plug them into the definitions
 * of the divs i.
 *
 * In particular, an expression of the form
 *
 *	floor((f(..) + floor(g(..)/n))/m)
 *
 * is simplified to
 *
 *	floor((n * f(..) + g(..))/(n * m))
 *
 * This simplification is correct because we can move the expression
 * f(..) into the inner floor in the original expression to obtain
 *
 *	floor(floor((n * f(..) + g(..))/n)/m)
 *
 * from which we can derive the simplified expression.
 */
================================================================================

文件路径: ./isl_aff.c
注释行数: 11
注释内容:
/* Given f, return floor(f).
 * If f is an integer expression, then just return f.
 * If f is a constant, then return the constant floor(f).
 * Otherwise, if f = g/m, write g = q m + r,
 * create a new div d = [r/m] and return the expression q + d.
 * The coefficients in r are taken to lie between -m/2 and m/2.
 *
 * reduce_div_coefficients performs the same normalization.
 *
 * As a special case, floor(NaN) = NaN.
 */
================================================================================

文件路径: ./isl_aff.c
注释行数: 12
注释内容:
/* Given f, return ceil(f).
 * If f is an integer expression, then just return f.
 * Otherwise, let f be the expression
 *
 *	e/m
 *
 * then return
 *
 *	floor((e + m - 1)/m)
 *
 * As a special case, ceil(NaN) = NaN.
 */
================================================================================

文件路径: ./isl_aff.c
注释行数: 10
注释内容:
/* Return a map containing pairs of elements in the domains of "pa1" and "pa2"
 * where the function values are ordered in the same way as "order",
 * which returns a set in the shared domain of its two arguments.
 *
 * Let "pa1" and "pa2" be defined on domains A and B respectively.
 * We first pull back the two functions such that they are defined on
 * the domain [A -> B].  Then we apply "order", resulting in a set
 * in the space [A -> B].  Finally, we unwrap this set to obtain
 * a map in the space A -> B.
 */
================================================================================

文件路径: ./isl_aff.c
注释行数: 12
注释内容:
/* Return an affine expression that is equal to pwaff_true for elements
 * where "cond" is non-zero and to pwaff_false for elements where "cond"
 * is zero.
 * That is, return cond ? pwaff_true : pwaff_false;
 *
 * If "cond" involves and NaN, then we conservatively return a NaN
 * on its entire domain.  In principle, we could consider the pieces
 * where it is NaN separately from those where it is not.
 *
 * If "pwaff_true" and "pwaff_false" are obviously equal to each other,
 * then only use the domain of "cond" to restrict the domain.
 */
================================================================================

文件路径: ./isl_aff.c
注释行数: 12
注释内容:
/* Return the set of domain elements where "ma1" is lexicographically
 * greater than to "ma2".  If "equal" is set, then include the domain
 * elements where they are equal.
 *
 * In particular, for all but the final entry,
 * include the set of elements where this entry is strictly greater in "ma1"
 * and all previous entries are equal.
 * The final entry is also allowed to be equal in the two functions
 * if "equal" is set.
 *
 * The case where there are no entries is handled separately.
 */
================================================================================

文件路径: ./isl_aff.c
注释行数: 67
注释内容:
/* Extract an affine expression that expresses the output dimension "pos"
 * of "bmap" in terms of the parameters and input dimensions from
 * equality "eq".
 * Note that this expression may involve integer divisions defined
 * in terms of parameters and input dimensions.
 * The equality may also involve references to earlier (but not later)
 * output dimensions.  These are replaced by the corresponding elements
 * in "ma".
 *
 * If the equality is of the form
 *
 *	f(i) + h(j) + a x + g(i) = 0,
 *
 * with f(i) a linear combinations of the parameters and input dimensions,
 * g(i) a linear combination of integer divisions defined in terms of the same
 * and h(j) a linear combinations of earlier output dimensions,
 * then the affine expression is
 *
 *	(-f(i) - g(i))/a - h(j)/a
 *
 * If the equality is of the form
 *
 *	f(i) + h(j) - a x + g(i) = 0,
 *
 * then the affine expression is
 *
 *	(f(i) + g(i))/a - h(j)/(-a)
 *
 *
 * If "div" refers to an integer division (i.e., it is smaller than
 * the number of integer divisions), then the equality constraint
 * does involve an integer division (the one at position "div") that
 * is defined in terms of output dimensions.  However, this integer
 * division can be eliminated by exploiting a pair of constraints
 * x >= l and x <= l + n, with n smaller than the coefficient of "div"
 * in the equality constraint.  "ineq" refers to inequality x >= l, i.e.,
 * -l + x >= 0.
 * In particular, let
 *
 *	x = e(i) + m floor(...)
 *
 * with e(i) the expression derived above and floor(...) the integer
 * division involving output dimensions.
 * From
 *
 *	l <= x <= l + n,
 *
 * we have
 *
 *	0 <= x - l <= n
 *
 * This means
 *
 *	e(i) + m floor(...) - l = (e(i) + m floor(...) - l) mod m
 *	                        = (e(i) - l) mod m
 *
 * Therefore,
 *
 *	x - l = (e(i) - l) mod m
 *
 * or
 *
 *	x = ((e(i) - l) mod m) + l
 *
 * The variable "shift" below contains the expression -l, which may
 * also involve a linear combination of earlier output dimensions.
 */
================================================================================

文件路径: ./isl_aff.c
注释行数: 12
注释内容:
/* Given a basic map with output dimensions defined
 * in terms of the parameters input dimensions and earlier
 * output dimensions using an equality (and possibly a pair on inequalities),
 * extract an isl_aff that expresses output dimension "pos" in terms
 * of the parameters and input dimensions.
 * Note that this expression may involve integer divisions defined
 * in terms of parameters and input dimensions.
 * "ma" contains the expressions corresponding to earlier output dimensions.
 *
 * This function shares some similarities with
 * isl_basic_map_has_defining_equality and isl_constraint_get_bound.
 */
================================================================================

文件路径: ./isl_aff.c
注释行数: 18
注释内容:
/* Create an isl_pw_multi_aff that is equivalent to
 * isl_map_intersect_domain(isl_map_from_basic_map(bmap), domain).
 * The given basic map is such that each output dimension is defined
 * in terms of the parameters and input dimensions using an equality.
 *
 * Since some applications expect the result of isl_pw_multi_aff_from_map
 * to only contain integer affine expressions, we compute the floor
 * of the expression before returning.
 *
 * Remove all constraints involving local variables without
 * an explicit representation (resulting in the removal of those
 * local variables) prior to the actual extraction to ensure
 * that the local spaces in which the resulting affine expressions
 * are created do not contain any unknown local variables.
 * Removing such constraints is safe because constraints involving
 * unknown local variables are not used to determine whether
 * a basic map is obviously single-valued.
 */
================================================================================

文件路径: ./isl_aff.c
注释行数: 27
注释内容:
/* Try and create an isl_pw_multi_aff that is equivalent to the given isl_map,
 * taking into account that the output dimension at position "d"
 * can be represented as
 *
 *	x = floor((e(...) + c1) / m)
 *
 * given that constraint "i" is of the form
 *
 *	e(...) + c1 - m x >= 0
 *
 *
 * Let "map" be of the form
 *
 *	A -> B
 *
 * We construct a mapping
 *
 *	A -> [A -> x = floor(...)]
 *
 * apply that to the map, obtaining
 *
 *	[A -> x = floor(...)] -> B
 *
 * and equate dimension "d" to x.
 * We then compute a isl_pw_multi_aff representation of the resulting map
 * and plug in the mapping above.
 */
================================================================================

文件路径: ./isl_aff.c
注释行数: 13
注释内容:
/* Is constraint "c" of the form
 *
 *	e(...) + c1 - m x >= 0
 *
 * or
 *
 *	-e(...) + c2 + m x >= 0
 *
 * where m > 1 and e only depends on parameters and input dimemnsions?
 *
 * "offset" is the offset of the output dimensions
 * "pos" is the position of output dimension x.
 */
================================================================================

文件路径: ./isl_aff.c
注释行数: 33
注释内容:
/* Try and create an isl_pw_multi_aff that is equivalent to the given isl_map.
 *
 * As a special case, we first check if there is any pair of constraints,
 * shared by all the basic maps in "map" that force a given dimension
 * to be equal to the floor of some affine combination of the input dimensions.
 *
 * In particular, if we can find two constraints
 *
 *	e(...) + c1 - m x >= 0		i.e.,		m x <= e(...) + c1
 *
 * and
 *
 *	-e(...) + c2 + m x >= 0		i.e.,		m x >= e(...) - c2
 *
 * where m > 1 and e only depends on parameters and input dimemnsions,
 * and such that
 *
 *	c1 + c2 < m			i.e.,		-c2 >= c1 - (m - 1)
 *
 * then we know that we can take
 *
 *	x = floor((e(...) + c1) / m)
 *
 * without having to perform any computation.
 *
 * Note that we know that
 *
 *	c1 + c2 >= 1
 *
 * If c1 + c2 were 0, then we would have detected an equality during
 * simplification.  If c1 + c2 were negative, then we would have detected
 * a contradiction.
 */
================================================================================

文件路径: ./isl_aff.c
注释行数: 21
注释内容:
/* Given an affine expression
 *
 *	[A -> B] -> f(A,B)
 *
 * construct an isl_multi_aff
 *
 *	[A -> B] -> B'
 *
 * such that dimension "d" in B' is set to "aff" and the remaining
 * dimensions are set equal to the corresponding dimensions in B.
 * "n_in" is the dimension of the space A.
 * "n_out" is the dimension of the space B.
 *
 * If "is_set" is set, then the affine expression is of the form
 *
 *	[B] -> f(B)
 *
 * and we construct an isl_multi_aff
 *
 *	B -> B'
 */
================================================================================

文件路径: ./isl_aff.c
注释行数: 56
注释内容:
/* Try and create an isl_pw_multi_aff that is equivalent to the given isl_map,
 * taking into account that the dimension at position "d" can be written as
 *
 *	x = m a + f(..)						(1)
 *
 * where m is equal to "gcd".
 * "i" is the index of the equality in "hull" that defines f(..).
 * In particular, the equality is of the form
 *
 *	f(..) - x + m g(existentials) = 0
 *
 * or
 *
 *	-f(..) + x + m g(existentials) = 0
 *
 * We basically plug (1) into "map", resulting in a map with "a"
 * in the range instead of "x".  The corresponding isl_pw_multi_aff
 * defining "a" is then plugged back into (1) to obtain a definition for "x".
 *
 * Specifically, given the input map
 *
 *	A -> B
 *
 * We first wrap it into a set
 *
 *	[A -> B]
 *
 * and define (1) on top of the corresponding space, resulting in "aff".
 * We use this to create an isl_multi_aff that maps the output position "d"
 * from "a" to "x", leaving all other (intput and output) dimensions unchanged.
 * We plug this into the wrapped map, unwrap the result and compute the
 * corresponding isl_pw_multi_aff.
 * The result is an expression
 *
 *	A -> T(A)
 *
 * We adjust that to
 *
 *	A -> [A -> T(A)]
 *
 * so that we can plug that into "aff", after extending the latter to
 * a mapping
 *
 *	[A -> B] -> B'
 *
 *
 * If "map" is actually a set, then there is no "A" space, meaning
 * that we do not need to perform any wrapping, and that the result
 * of the recursive call is of the form
 *
 *	[T]
 *
 * which is plugged into a mapping of the form
 *
 *	B -> B'
 */
================================================================================

文件路径: ./isl_aff.c
注释行数: 15
注释内容:
/* Try and create an isl_pw_multi_aff that is equivalent to the given isl_map.
 * "hull" contains the equalities valid for "map".
 *
 * Check if any of the output dimensions is "strided".
 * That is, we check if it can be written as
 *
 *	x = m a + f(..)
 *
 * with m greater than 1, a some combination of existentially quantified
 * variables and f an expression in the parameters and input dimensions.
 * If so, we remove the stride in pw_multi_aff_from_map_stride.
 *
 * Otherwise, we continue with pw_multi_aff_from_map_check_div for a further
 * special case.
 */
================================================================================

文件路径: ./isl_aff.c
注释行数: 10
注释内容:
/* Try and create an isl_pw_multi_aff that is equivalent to the given isl_map.
 *
 * As a special case, we first check if all output dimensions are uniquely
 * defined in terms of the parameters and input dimensions over the entire
 * domain.  If so, we extract the desired isl_pw_multi_aff directly
 * from the affine hull of "map" and its domain.
 *
 * Otherwise, continue with pw_multi_aff_from_map_check_strides for more
 * special cases.
 */
================================================================================

文件路径: ./isl_aff.c
注释行数: 17
注释内容:
/* Plug in "subs" for dimension "type", "pos" of "aff".
 *
 * Let i be the dimension to replace and let "subs" be of the form
 *
 *	f/d
 *
 * and "aff" of the form
 *
 *	(a i + g)/m
 *
 * The result is
 *
 *	(a f + d g')/(m d)
 *
 * where g' is the result of plugging in "subs" in each of the integer
 * divisions in g.
 */
================================================================================

文件路径: ./isl_aff.c
注释行数: 18
注释内容:
/* Plug in "subs" for dimension "type", "pos" of "pma".
 *
 * pma is of the form
 *
 *	A_i(v) -> M_i(v)
 *
 * while subs is of the form
 *
 *	v' = B_j(v) -> S_j
 *
 * Each pair i,j such that C_ij = A_i \cap B_i is non-empty
 * has a contribution in the result, in particular
 *
 *	C_ij(S_j) -> M_i(S_j)
 *
 * Note that plugging in S_j in C_ij may also result in an empty set
 * and this contribution should simply be discarded.
 */
================================================================================

文件路径: ./isl_aff.c
注释行数: 36
注释内容:
/* Compute the preimage of a range of dimensions in the affine expression "src"
 * under "ma" and put the result in "dst".  The number of dimensions in "src"
 * that precede the range is given by "n_before".  The number of dimensions
 * in the range is given by the number of output dimensions of "ma".
 * The number of dimensions that follow the range is given by "n_after".
 * If "has_denom" is set (to one),
 * then "src" and "dst" have an extra initial denominator.
 * "n_div_ma" is the number of existentials in "ma"
 * "n_div_bset" is the number of existentials in "src"
 * The resulting "dst" (which is assumed to have been allocated by
 * the caller) contains coefficients for both sets of existentials,
 * first those in "ma" and then those in "src".
 * f, c1, c2 and g are temporary objects that have been initialized
 * by the caller.
 *
 * Let src represent the expression
 *
 *	(a(p) + f_u u + b v + f_w w + c(divs))/d
 *
 * and let ma represent the expressions
 *
 *	v_i = (r_i(p) + s_i(y) + t_i(divs'))/m_i
 *
 * We start out with the following expression for dst:
 *
 *	(a(p) + f_u u + 0 y + f_w w + 0 divs' + c(divs) + f \sum_i b_i v_i)/d
 *
 * with the multiplication factor f initially equal to 1
 * and f \sum_i b_i v_i kept separately.
 * For each x_i that we substitute, we multiply the numerator
 * (and denominator) of dst by c_1 = m_i and add the numerator
 * of the x_i expression multiplied by c_2 = f b_i,
 * after removing the common factors of c_1 and c_2.
 * The multiplication factor f also needs to be multiplied by c_1
 * for the next x_j, j > i.
 */
================================================================================

文件路径: ./isl_aff.c
注释行数: 19
注释内容:
/* Compute the pullback of "aff" by the function represented by "ma".
 * In other words, plug in "ma" in "aff".  The result is an affine expression
 * defined over the domain space of "ma".
 *
 * If "aff" is represented by
 *
 *	(a(p) + b x + c(divs))/d
 *
 * and ma is represented by
 *
 *	x = D(p) + F(y) + G(divs')
 *
 * then the result is
 *
 *	(a(p) + b D(p) + b F(y) + b G(divs') + c(divs))/d
 *
 * The divs in the local space of the input are similarly adjusted
 * through a call to isl_local_space_preimage_multi_aff.
 */
================================================================================

文件路径: ./isl_aff.c
注释行数: 10
注释内容:
/* Apply "aff" to "mpa".  The range of "mpa" needs to be compatible
 * with the domain of "aff".  The domain of the result is the same
 * as that of "mpa".
 * "mpa" and "aff" are assumed to have been aligned.
 *
 * We first extract the parametric constant from "aff", defined
 * over the correct domain.
 * Then we add the appropriate combinations of the members of "mpa".
 * Finally, we add the integer divisions through recursive calls.
 */
================================================================================

文件路径: ./isl_aff.c
注释行数: 15
注释内容:
/* Return a map containing pairs of elements in the domains of "mpa1" and "mpa2"
 * where the function values of "mpa1" lexicographically satisfies
 * "strict_base"/"base" compared to that of "mpa2".
 * "space" is the space of the result.
 * The parameters of "mpa1" and "mpa2" are assumed to have been aligned.
 *
 * "mpa1" lexicographically satisfies "strict_base"/"base" compared to "mpa2"
 * if, for some i, the i-th element of "mpa1" satisfies "strict_base"/"base"
 * when compared to the i-th element of "mpa2" while all previous elements are
 * pairwise equal.
 * In particular, if i corresponds to the final elements
 * then they need to satisfy "base", while "strict_base" needs to be satisfied
 * for other values of i.
 * If "base" is a strict order, then "base" and "strict_base" are the same.
 */
================================================================================

文件路径: ./isl_aff.c
注释行数: 10
注释内容:
/* Given a function "pma1" of the form A[B -> C] -> D and
 * a function "pma2" of the form E -> B,
 * replace the domain of the wrapped relation inside the domain of "pma1"
 * by the preimage with respect to "pma2".
 * In other words, plug in "pma2" in this nested domain.
 * The result is of the form A[E -> C] -> D.
 *
 * In particular, extend E -> B to A[E -> C] -> A[B -> C] and
 * plug that into "pma1".
 */
================================================================================

文件路径: ./isl_aff.c
注释行数: 10
注释内容:
/* Check that the domain space of "upa" matches "space".
 *
 * This function is called from isl_multi_union_pw_aff_set_union_pw_aff and
 * can in principle never fail since the space "space" is that
 * of the isl_multi_union_pw_aff and is a set space such that
 * there is no domain space to match.
 *
 * We check the parameters and double-check that "space" is
 * indeed that of a set.
 */
================================================================================

文件路径: ./isl_aff.c
注释行数: 10
注释内容:
/* Compute the pullback of "upa" by the function represented by "upma".
 * In other words, plug in "upma" in "upa".  The result contains
 * expressions defined over the domain space of "upma".
 *
 * Run over all pairs of elements in "upa" and "upma", perform
 * the pullback when appropriate and collect the results.
 * If the hash value were based on the domain space rather than
 * the function space, then we could run through all elements
 * of "upma" and directly pick out the corresponding element of "upa".
 */
================================================================================

文件路径: ./isl_aff.c
注释行数: 10
注释内容:
/* Construct and return a multi union piecewise affine expression
 * that is equal to the given union piecewise multi affine expression.
 *
 * In order to be able to perform the conversion, the input
 * needs to be non-empty and may only involve a single range space.
 *
 * If the resulting multi union piecewise affine expression has
 * an explicit domain, then assign it the domain of the input.
 * In other cases, the domain is stored in the individual elements.
 */
================================================================================

文件路径: ./isl_aff.c
注释行数: 11
注释内容:
/* Replace the range space of all the piecewise affine expressions in "upma" by
 * the range space of "space".
 *
 * This assumes that all these expressions have the same output dimension.
 *
 * Since the spaces of the expressions change, so do their hash values.
 * We therefore need to create a new isl_union_pw_multi_aff.
 * Note that the hash value is currently computed based on the entire
 * space even though there can only be a single expression with a given
 * domain space.
 */
================================================================================

文件路径: ./isl_aff.c
注释行数: 12
注释内容:
/* Apply "aff" to "mupa".  The space of "mupa" is equal to the domain of "aff".
 * In particular, the spaces have been aligned.
 * The result is defined over the shared domain of the elements of "mupa"
 *
 * We first extract the parametric constant part of "aff" and
 * define that over the shared domain.
 * Then we iterate over all input dimensions of "aff" and add the corresponding
 * multiples of the elements of "mupa".
 * Finally, we consider the integer divisions, calling the function
 * recursively to obtain an isl_union_pw_aff corresponding to the
 * integer division argument.
 */
================================================================================

文件路径: ./isl_printer_private.h
注释行数: 16
注释内容:
/* A printer to a file or a string.
 *
 * "dump" is set if the printing is performed from an isl_*_dump function.
 *
 * yaml_style is the YAML style in which the next elements should
 * be printed and may be either ISL_YAML_STYLE_BLOCK or ISL_YAML_STYLE_FLOW,
 * with ISL_YAML_STYLE_FLOW being the default.
 * yaml_state keeps track of the currently active YAML elements.
 * yaml_size is the size of this arrays, while yaml_depth
 * is the number of elements currently in use.
 * yaml_state may be NULL if no YAML printing is being performed.
 *
 * notes keeps track of arbitrary notes as a mapping between
 * name identifiers and note identifiers.  It may be NULL
 * if there are no notes yet.
 */
================================================================================

文件路径: ./isl_point.c
注释行数: 14
注释内容:
/*
 * Copyright 2010      INRIA Saclay
 * Copyright 2013      Ecole Normale Superieure
 * Copyright 2015      Sven Verdoolaege
 * Copyright 2019      Cerebras Systems
 *
 * Use of this software is governed by the MIT license
 *
 * Written by Sven Verdoolaege, INRIA Saclay - Ile-de-France,
 * Parc Club Orsay Universite, ZAC des vignes, 4 rue Jacques Monod,
 * 91893 Orsay, France
 * and Ecole Normale Superieure, 45 rue d'Ulm, 75230 Paris, France
 * and Cerebras Systems, 175 S San Antonio Rd, Los Altos, CA, USA
 */
================================================================================

文件路径: ./isl_box.c
注释行数: 11
注释内容:
/*
 * Copyright 2010-2011 INRIA Saclay
 * Copyright 2012-2013 Ecole Normale Superieure
 *
 * Use of this software is governed by the MIT license
 *
 * Written by Sven Verdoolaege, INRIA Saclay - Ile-de-France,
 * Parc Club Orsay Universite, ZAC des vignes, 4 rue Jacques Monod,
 * 91893 Orsay, France
 * and Ecole Normale Superieure, 45 rue d'Ulm, 75230 Paris, France
 */
================================================================================

文件路径: ./isl_box.c
注释行数: 12
注释内容:
/* Data used in set_dim_extent and compute_size_in_direction.
 *
 * "bset" is a wrapped copy of the basic map that has the selected
 * output dimension as range.
 * "pos" is the position of the variable representing the output dimension,
 * i.e., the variable for which the size should be computed.  This variable
 * is also the last variable in "bset".
 * "size" is the best size found so far
 * (infinity if no offset was found so far).
 * "offset" is the offset corresponding to the best size
 * (NULL if no offset was found so far).
 */
================================================================================

文件路径: ./isl_box.c
注释行数: 18
注释内容:
/* Look for a fixed-size range of values for the output dimension "pos"
 * of "map", by looking for a lower-bound expression in the parameters
 * and input dimensions such that the range of the output dimension
 * is a constant shifted by this expression.
 *
 * In particular, look through the explicit lower bounds on the output dimension
 * for candidate expressions and pick the one that results in the smallest size.
 * Initialize the size with infinity and if no better size is found
 * then invalidate the box.  Otherwise, set the offset and size
 * in the given direction by those that correspond to the smallest size.
 *
 * Note that while evaluating the size corresponding to a lower bound,
 * an affine expression is constructed from the lower bound.
 * This lower bound may therefore not have any unknown local variables.
 * Eliminate any unknown local variables up front.
 * No such restriction needs to be imposed on the set over which
 * the size is computed.
 */
================================================================================

文件路径: ./isl_schedule_tree.c
注释行数: 14
注释内容:
/*
 * Copyright 2013-2014 Ecole Normale Superieure
 * Copyright 2014      INRIA Rocquencourt
 * Copyright 2016      INRIA Paris
 *
 * Use of this software is governed by the MIT license
 *
 * Written by Sven Verdoolaege,
 * Ecole Normale Superieure, 45 rue d'Ulm, 75230 Paris, France
 * and Inria Paris - Rocquencourt, Domaine de Voluceau - Rocquencourt,
 * B.P. 105 - 78153 Le Chesnay, France
 * and Centre de Recherche Inria de Paris, 2 rue Simone Iff - Voie DQ12,
 * CS 42112, 75589 Paris Cedex 12, France
 */
================================================================================

文件路径: ./isl_schedule_tree.c
注释行数: 11
注释内容:
/* Should we skip the root of "tree" while looking for the first
 * descendant with schedule information?
 * That is, is it impossible to derive any information about
 * the iteration domain from this node?
 *
 * We do not want to skip leaf or error nodes because there is
 * no point in looking any deeper from these nodes.
 * We can only extract partial iteration domain information
 * from an extension node, but extension nodes are not supported
 * by the caller and it will error out on them.
 */
================================================================================

文件路径: ./isl_schedule_tree.c
注释行数: 20
注释内容:
/* Extend the schedule map "outer" with the subtree schedule
 * of a set or sequence node.
 *
 * The schedule for the set or sequence node itself is composed of
 * pieces of the form
 *
 *	filter -> []
 *
 * or
 *
 *	filter -> [index]
 *
 * The first form is used if there is only a single child or
 * if the current node is a set node and the schedule_separate_components
 * option is not set.
 *
 * Each of the pieces above is extended with the subtree schedule of
 * the child of the corresponding filter, if any, padded with zeros
 * to ensure that all pieces have the same range dimension.
 */
================================================================================

文件路径: ./isl_schedule_tree.c
注释行数: 10
注释内容:
/* Extend the schedule map "outer" with the subtree schedule of "tree".
 *
 * If the root of the tree is a set or a sequence, then we extend
 * the schedule map in subtree_schedule_extend_from_children.
 * Otherwise, we extend the schedule map with the partial schedule
 * corresponding to the root of the tree and then continue with
 * the single child of this root.
 * In the special case of an expansion, the schedule map is "extended"
 * by applying the expansion to the domain of the schedule map.
 */
================================================================================

文件路径: ./isl_schedule_tree.c
注释行数: 12
注释内容:
/* Return the subtree schedule of a node that contains some schedule
 * information, i.e., a node that would not be skipped by
 * isl_schedule_tree_first_schedule_descendant and that is not a leaf.
 *
 * If the tree contains any expansions, then the returned subtree
 * schedule is formulated in terms of the expanded domains.
 * The tree is not allowed to contain any extension nodes.
 *
 * We start with an initial zero-dimensional subtree schedule based
 * on the domain information in the root node and then extend it
 * based on the schedule information in the root node and its descendants.
 */
================================================================================

文件路径: ./isl_schedule_tree.c
注释行数: 12
注释内容:
/* Given an isolate AST generation option "isolate" for a band of size pos + n,
 * return the corresponding option for a band covering the first "pos"
 * members.
 *
 * The input isolate option is of the form
 *
 *	isolate[[flattened outer bands] -> [pos; n]]
 *
 * The output isolate option is of the form
 *
 *	isolate[[flattened outer bands] -> [pos]]
 */
================================================================================

文件路径: ./isl_schedule_tree.c
注释行数: 23
注释内容:
/* Given an isolate AST generation option "isolate" for a band of size pos + n,
 * return the corresponding option for a band covering the final "n"
 * members within a band covering the first "pos" members.
 *
 * The input isolate option is of the form
 *
 *	isolate[[flattened outer bands] -> [pos; n]]
 *
 * The output isolate option is of the form
 *
 *	isolate[[flattened outer bands; pos] -> [n]]
 *
 *
 * The range is first split into
 *
 *	isolate[[flattened outer bands] -> [[pos] -> [n]]]
 *
 * and then the first pos members are moved to the domain
 *
 *	isolate[[[flattened outer bands] -> [pos]] -> [n]]
 *
 * after which the domain is flattened to obtain the desired output.
 */
================================================================================

文件路径: ./isl_schedule_tree.c
注释行数: 11
注释内容:
/* Print "tree" to "p".
 *
 * If "n_ancestor" is non-negative, then "child_pos" contains the child
 * positions of a descendant of the current node that should be marked
 * (by the comment "YOU ARE HERE").  In particular, if "n_ancestor"
 * is zero, then the current node should be marked.
 * The marking is only printed in YAML block format.
 *
 * Implicit leaf nodes are not printed, except if they correspond
 * to the node that should be marked.
 */
================================================================================

文件路径: ./isl_printer.c
注释行数: 19
注释内容:
/* If we are printing a YAML document and we are at the start of an element,
 * print whatever is needed before we can print the actual element and
 * keep track of the fact that we are now printing the element.
 * If "eol" is set, then whatever we print is going to be the last
 * thing that gets printed on this line.
 *
 * If we are about the print the first key of a mapping, then nothing
 * extra needs to be printed.  For any other key, however, we need
 * to either move to the next line (in block format) or print a comma
 * (in flow format).
 * Before printing a value in a mapping, we need to print a colon.
 *
 * For sequences, in flow format, we only need to print a comma
 * for each element except the first.
 * In block format, before the first element in the sequence,
 * we move to a new line, print a dash and increase the indentation.
 * Before any other element, we print a dash on a new line,
 * temporarily moving the indentation back.
 */
================================================================================

文件路径: ./isl_printer.c
注释行数: 11
注释内容:
/* Finish a YAML mapping and pop it from the state stack.
 *
 * In flow style, print the closing brace.
 *
 * In block style, first check if we are still in the
 * isl_yaml_mapping_first_key_start state.  If so, we have not printed
 * anything yet, so print "{}" to indicate an empty mapping.
 * If we increased the indentation in isl_printer_yaml_start_mapping,
 * then decrease it again.
 * If this is the outer mapping then print a newline.
 */
================================================================================

文件路径: ./isl_printer.c
注释行数: 14
注释内容:
/* Finish a YAML sequence and pop it from the state stack.
 *
 * In flow style, print the closing bracket.
 *
 * In block style, check if we are still in the
 * isl_yaml_sequence_first_start state.  If so, we have not printed
 * anything yet, so print "[]" or " []" to indicate an empty sequence.
 * We print the extra space when we instructed enter_state not
 * to print a space at the end of the line.
 * Otherwise, undo the increase in indentation performed by
 * enter_state when moving away from the isl_yaml_sequence_first_start
 * state.
 * If this is the outer sequence then print a newline.
 */
================================================================================

文件路径: ./isl_val_imath.c
注释行数: 11
注释内容:
/* Store a representation of the absolute value of the numerator of "v"
 * in terms of chunks of size "size" at "chunks".
 * The least significant chunk is stored first.
 * The number of chunks in the result can be obtained by calling
 * isl_val_n_abs_num_chunks.  The user is responsible for allocating
 * enough memory to store the results.
 *
 * In the special case of a zero value, isl_val_n_abs_num_chunks will
 * return one, while impz_export will not fill in any chunks.  We therefore
 * do it ourselves.
 */
================================================================================

文件路径: ./isl_aff_map.c
注释行数: 12
注释内容:
/*
 * Copyright 2011      INRIA Saclay
 * Copyright 2012-2013 Ecole Normale Superieure
 * Copyright 2016      Sven Verdoolaege
 *
 * Use of this software is governed by the MIT license
 *
 * Written by Sven Verdoolaege, INRIA Saclay - Ile-de-France,
 * Parc Club Orsay Universite, ZAC des vignes, 4 rue Jacques Monod,
 * 91893 Orsay, France
 * and Ecole Normale Superieure, 45 rue d'Ulm, 75230 Paris, France
 */
================================================================================

文件路径: ./isl_reordering.c
注释行数: 11
注释内容:
/* Return a reordering that moves the parameters identified by
 * the elements of "tuple" to a domain tuple inserted into "space".
 * The parameters that remain, are moved from their original positions
 * in the list of parameters to their new positions in this list.
 * The parameters that get removed, are moved to the corresponding
 * positions in the new domain.  Note that these set dimensions
 * do not necessarily need to appear as parameters in "space".
 * Any other dimensions are shifted by the number of extra dimensions
 * introduced, i.e., the number of dimensions in the new domain
 * that did not appear as parameters in "space".
 */
================================================================================

文件路径: ./isl_schedule_band.c
注释行数: 11
注释内容:
/*
 * Copyright 2013-2014 Ecole Normale Superieure
 * Copyright 2014      INRIA Rocquencourt
 *
 * Use of this software is governed by the MIT license
 *
 * Written by Sven Verdoolaege,
 * Ecole Normale Superieure, 45 rue d'Ulm, 75230 Paris, France
 * and Inria Paris - Rocquencourt, Domaine de Voluceau - Rocquencourt,
 * B.P. 105 - 78153 Le Chesnay, France
 */
================================================================================

文件路径: ./isl_schedule_band.c
注释行数: 11
注释内容:
/* Given a parameter space "space", extend it to a set space
 *
 *	{ type[x] }
 *
 * or
 *
 *	{ [isolate[] -> type[x]] }
 *
 * depending on whether "isolate" is set.
 * These can be used to encode loop AST generation options of the given type.
 */
================================================================================

文件路径: ./isl_schedule_band.c
注释行数: 12
注释内容:
/* Add encodings of the "n" loop AST generation options "type" to "options".
 * If "isolate" is set, then these options refer to the isolated part.
 *
 * In particular, for each sequence of consecutive identical types "t",
 * different from the default, add an option
 *
 *	{ t[x] : first <= x <= last }
 *
 * or
 *
 *	{ [isolate[] -> t[x]] : first <= x <= last }
 */
================================================================================

文件路径: ./isl_schedule_band.c
注释行数: 10
注释内容:
/* Construct universe sets of the spaces that encode loop AST generation
 * types (for the isolated part if "isolate" is set).  That is, construct
 *
 *	{ atomic[x]; separate[x]; unroll[x] }
 *
 * or
 *
 *	{ [isolate[] -> atomic[x]]; [isolate[] -> separate[x]];
 *	  [isolate[] -> unroll[x]] }
 */
================================================================================

文件路径: ./isl_schedule_band.c
注释行数: 11
注释内容:
/* Replace the AST build options associated to "band" by "options".
 * If there are any loop AST generation type options, then they
 * are extracted and stored in band->loop_type.  Otherwise,
 * band->loop_type is removed to indicate that the default applies
 * to all members.  Similarly for the loop AST generation type options
 * for the isolated part, which are stored in band->isolate_loop_type.
 * The remaining options are stored in band->ast_build_options.
 *
 * Set anchored if the options include an isolate option since the
 * domain of the wrapped map references the outer band node schedules.
 */
================================================================================

文件路径: ./isl_schedule_band.c
注释行数: 10
注释内容:
/* Given the schedule of a band, construct the corresponding
 * schedule for the tile loops based on the given tile sizes
 * and return the result.
 *
 * If the scale tile loops options is set, then the tile loops
 * are scaled by the tile sizes.
 *
 * That is replace each schedule dimension "i" by either
 * "floor(i/s)" or "s * floor(i/s)".
 */
================================================================================

文件路径: ./isl_schedule_band.c
注释行数: 12
注释内容:
/* Replace "band" by a band corresponding to the point loops of a tiling
 * with the given tile sizes.
 * "tile" is the corresponding tile loop band.
 *
 * If the shift point loops option is set, then the point loops
 * are shifted to start at zero.  That is, each schedule dimension "i"
 * is replaced by "i - s * floor(i/s)".
 * The expression "floor(i/s)" (or "s * floor(i/s)") is extracted from
 * the tile band.
 *
 * Otherwise, the band is left untouched.
 */
================================================================================

文件路径: ./isl_multi_union_add_templ.c
注释行数: 16
注释内容:
/* Compute the sum of "multi1" and "multi2" on the union of their domains,
 * with the actual sum on the shared domain and
 * the defined expression on the symmetric difference of the domains.
 *
 * We simply iterate over the elements in both arguments and
 * call isl_union_pw_aff_union_add on each of them, if there is
 * at least one element.
 *
 * Otherwise, the two expressions have an explicit domain and
 * the union of these explicit domains is computed.
 * This assumes that the explicit domains are either both in terms
 * of specific domains elements or both in terms of parameters.
 * However, if one of the expressions does not have any constraints
 * on its explicit domain, then this is allowed as well and the result
 * is the expression with no constraints on its explicit domain.
 */
================================================================================

文件路径: ./isl_multi_templ.c
注释行数: 10
注释内容:
/* Reset the space of "multi".  This function is called from isl_pw_templ.c
 * and doesn't know if the space of an element object is represented
 * directly or through its domain.  It therefore passes along both,
 * which we pass along to the element function since we don't know how
 * that is represented either.
 *
 * If "multi" has an explicit domain, then the caller is expected
 * to make sure that any modification that would change the dimensions
 * of the explicit domain has bee applied before this function is called.
 */
================================================================================

文件路径: ./isl_multi_templ.c
注释行数: 12
注释内容:
/* Given two multi expressions, "multi1"
 *
 *	[A] -> [B1 B2]
 *
 * where B2 starts at position "pos", and "multi2"
 *
 *	[A] -> [D]
 *
 * return the multi expression
 *
 *	[A] -> [B1 D B2]
 */
================================================================================

文件路径: ./isl_vertices.c
注释行数: 15
注释内容:
/* Check whether we can select constraint "level", given the current selection
 * reflected by facets in "tab", the rows of "facets" and the earlier
 * "selected" elements of "selection".
 *
 * If the constraint is (strictly) redundant in the tableau, selecting it would
 * result in an empty tableau, so it can't be selected.
 * If the set variable part of the constraint is not linearly independent
 * of the set variable parts of the already selected constraints,
 * the constraint cannot be selected.
 * If selecting the constraint results in an empty tableau, the constraint
 * cannot be selected.
 * Finally, if selecting the constraint results in some explicitly
 * deselected constraints turning into equalities, then the corresponding
 * vertices have already been generated, so the constraint cannot be selected.
 */
================================================================================

文件路径: ./isl_vertices.c
注释行数: 42
注释内容:
/* Compute the parametric vertices and the chamber decomposition
 * of the parametric polytope defined using the same constraints
 * as "bset".  "bset" is assumed to have no existentially quantified
 * variables.
 *
 * The vertices themselves are computed in a fairly simplistic way.
 * We simply run through all combinations of d constraints,
 * with d the number of set variables, and check if those d constraints
 * define a vertex.  To avoid the generation of duplicate vertices,
 * which we may happen if a vertex is defined by more that d constraints,
 * we make sure we only generate the vertex for the d constraints with
 * smallest index.
 *
 * Only potential vertices with a full-dimensional activity domain
 * are considered.  However, if the input has (implicit) equality
 * constraints among the parameters, then activity domain
 * should be considered full-dimensional if it does not satisfy
 * any extra equality constraints beyond those of the input.
 * The implicit equality constraints of the input are therefore first detected.
 * If there are any, then the input is mapped to a lower dimensional space
 * such that the check for full-dimensional activity domains
 * can be performed with respect to a full-dimensional space.
 * Note that it is important to leave "bset" unmodified while detecting
 * equality constraints since the inequality constraints of "bset"
 * are assumed to correspond to those of the tableau.
 *
 * We set up a tableau and keep track of which facets have been
 * selected.  The tableau is marked strict_redundant so that we can be
 * sure that any constraint that is marked redundant (and that is not
 * also marked zero) is not an equality.
 * If a constraint is marked DESELECTED, it means the constraint was
 * SELECTED before (in combination with the same selection of earlier
 * constraints).  If such a deselected constraint turns out to be an
 * equality, then any vertex that may still be found with the current
 * selection has already been generated when the constraint was selected.
 * A constraint is marked UNSELECTED when there is no way selecting
 * the constraint could lead to a vertex (in combination with the current
 * selection of earlier constraints).
 *
 * The set variable coefficients of the selected constraints are stored
 * in the facets matrix.
 */
================================================================================

文件路径: ./isl_vertices.c
注释行数: 22
注释内容:
/* Compute the chamber decomposition of the parametric polytope respresented
 * by "bset" given the parametric vertices and their activity domains.
 *
 * We are only interested in full-dimensional chambers.
 * Each of these chambers is the intersection of the activity domains of
 * one or more vertices and the union of all chambers is equal to the
 * projection of the entire parametric polytope onto the parameter space.
 *
 * We first create an initial chamber by intersecting as many activity
 * domains as possible without ending up with an empty or lower-dimensional
 * set.  As a minor optimization, we only consider those activity domains
 * that contain some arbitrary point.
 *
 * For each of the interior facets of the chamber, we construct a todo item,
 * containing the facet and a constraint containing the other side of the facet,
 * for constructing the chamber on the other side.
 * While their are any todo items left, we pick a todo item and
 * create the required chamber by intersecting all activity domains
 * that contain the facet and have a full-dimensional intersection with
 * the other side of the facet.  For each of the interior facets, we
 * again create todo items, taking care to cancel opposite todo items.
 */
================================================================================

文件路径: ./isl_vertices.c
注释行数: 12
注释内容:
/* Check whether the parametric vertex described by "vertex"
 * lies on the facet corresponding to constraint "facet" of "bset".
 * The isl_vec "v" is a temporary vector than can be used by this function.
 *
 * We eliminate the variables from the facet constraint using the
 * equalities defining the vertex and check if the result is identical
 * to zero.
 *
 * It would probably be better to keep track of the constraints defining
 * a vertex during the vertex construction so that we could simply look
 * it up here.
 */
================================================================================

文件路径: ./isl_vertices.c
注释行数: 10
注释内容:
/* Triangulate the polytope spanned by the vertices with ids
 * in "simplex_ids" and "other_ids" and call "fn" on each of
 * the resulting simplices.
 * If the input polytope is already a simplex, we simply call "fn".
 * Otherwise, we pick a point from "other_ids" and add it to "simplex_ids".
 * Then we consider each facet of "bset" that does not contain the point
 * we just picked, but does contain some of the other points in "other_ids"
 * and call ourselves recursively on the polytope spanned by the new
 * "simplex_ids" and those points in "other_ids" that lie on the facet.
 */
================================================================================

文件路径: ./isl_tab_lexopt_templ.c
注释行数: 12
注释内容:
/*
 * Copyright 2008-2009 Katholieke Universiteit Leuven
 * Copyright 2010      INRIA Saclay
 * Copyright 2011      Sven Verdoolaege
 *
 * Use of this software is governed by the MIT license
 *
 * Written by Sven Verdoolaege, K.U.Leuven, Departement
 * Computerwetenschappen, Celestijnenlaan 200A, B-3001 Leuven, Belgium
 * and INRIA Saclay - Ile-de-France, Parc Club Orsay Universite,
 * ZAC des vignes, 4 rue Jacques Monod, 91893 Orsay, France
 */
================================================================================

文件路径: ./isl_tab_lexopt_templ.c
注释行数: 32
注释内容:
/* Given a basic map with at least two parallel constraints (as found
 * by the function parallel_constraints), first look for more constraints
 * parallel to the two constraint and replace the found list of parallel
 * constraints by a single constraint with as "input" part the minimum
 * of the input parts of the list of constraints.  Then, recursively call
 * basic_map_partial_lexopt (possibly finding more parallel constraints)
 * and plug in the definition of the minimum in the result.
 *
 * As in parallel_constraints, only inequality constraints that only
 * involve input variables that do not occur in any other inequality
 * constraints are considered.
 *
 * More specifically, given a set of constraints
 *
 *	a x + b_i(p) >= 0
 *
 * Replace this set by a single constraint
 *
 *	a x + u >= 0
 *
 * with u a new parameter with constraints
 *
 *	u <= b_i(p)
 *
 * Any solution to the new system is also a solution for the original system
 * since
 *
 *	a x >= -u >= -b_i(p)
 *
 * Moreover, m = min_i(b_i(p)) satisfies the constraints on u and can
 * therefore be plugged into the solution.
 */
================================================================================

文件路径: ./isl_tab_lexopt_templ.c
注释行数: 24
注释内容:
/* Compute the lexicographic minimum (or maximum if "flags" includes
 * ISL_OPT_MAX) of "bmap" over the domain "dom" and return the result as
 * either a map or a piecewise multi-affine expression depending on TYPE.
 * If "empty" is not NULL, then *empty is assigned a set that
 * contains those parts of the domain where there is no solution.
 * If "flags" includes ISL_OPT_FULL, then "dom" is NULL and the optimum
 * should be computed over the domain of "bmap".  "empty" is also NULL
 * in this case.
 * If "bmap" is marked as rational (ISL_BASIC_MAP_RATIONAL),
 * then we compute the rational optimum.  Otherwise, we compute
 * the integral optimum.
 *
 * We perform some preprocessing.  As the PILP solver does not
 * handle implicit equalities very well, we first make sure all
 * the equalities are explicitly available.
 *
 * We also add context constraints to the basic map and remove
 * redundant constraints.  This is only needed because of the
 * way we handle simple symmetries.  In particular, we currently look
 * for symmetries on the constraints, before we set up the main tableau.
 * It is then no good to look for symmetries on possibly redundant constraints.
 * If the domain was extracted from the basic map, then there is
 * no need to add back those constraints again.
 */
================================================================================

文件路径: ./isl_map_simplify.c
注释行数: 14
注释内容:
/*
 * Copyright 2008-2009 Katholieke Universiteit Leuven
 * Copyright 2012-2013 Ecole Normale Superieure
 * Copyright 2014-2015 INRIA Rocquencourt
 * Copyright 2016      Sven Verdoolaege
 *
 * Use of this software is governed by the MIT license
 *
 * Written by Sven Verdoolaege, K.U.Leuven, Departement
 * Computerwetenschappen, Celestijnenlaan 200A, B-3001 Leuven, Belgium
 * and Ecole Normale Superieure, 45 rue d’Ulm, 75230 Paris, France
 * and Inria Paris - Rocquencourt, Domaine de Voluceau - Rocquencourt,
 * B.P. 105 - 78153 Le Chesnay, France
 */
================================================================================

文件路径: ./isl_map_simplify.c
注释行数: 20
注释内容:
/* Reduce the coefficient of the variable at position "pos"
 * in integer division "div", such that it lies in the half-open
 * interval (1/2,1/2], extracting any excess value from this integer division.
 * "pos" is as determined by isl_basic_map_offset, i.e., pos == 0
 * corresponds to the constant term.
 *
 * That is, the integer division is of the form
 *
 *	floor((... + (c * d + r) * x_pos + ...)/d)
 *
 * with -d < 2 * r <= d.
 * Replace it by
 *
 *	floor((... + r * x_pos + ...)/d) + c * x_pos
 *
 * If 2 * ((c * d + r) % d) <= d, then c = floor((c * d + r)/d).
 * Otherwise, c = floor((c * d + r)/d) + 1.
 *
 * This is the same normalization that is performed by isl_aff_floor.
 */
================================================================================

文件路径: ./isl_map_simplify.c
注释行数: 13
注释内容:
/* Remove any common factor in numerator and denominator of the div expression,
 * not taking into account the constant term.
 * That is, if the div is of the form
 *
 *	floor((a + m f(x))/(m d))
 *
 * then replace it by
 *
 *	floor((floor(a/m) + f(x))/d)
 *
 * The difference {a/m}/d in the argument satisfies 0 <= {a/m}/d < 1/d
 * and can therefore not influence the result of the floor.
 */
================================================================================

文件路径: ./isl_map_simplify.c
注释行数: 13
注释内容:
/* Remove any common factor in numerator and denominator of a div expression,
 * not taking into account the constant term.
 * That is, look for any div of the form
 *
 *	floor((a + m f(x))/(m d))
 *
 * and replace it by
 *
 *	floor((floor(a/m) + f(x))/d)
 *
 * The difference {a/m}/d in the argument satisfies 0 <= {a/m}/d < 1/d
 * and can therefore not influence the result of the floor.
 */
================================================================================

文件路径: ./isl_map_simplify.c
注释行数: 23
注释内容:
/* The last local variable involved in the equality constraint
 * at position "eq" in "bmap" is the local variable at position "div".
 * It can therefore be used to extract an explicit representation
 * for that variable.
 * Do so unless the local variable already has an explicit representation or
 * the explicit representation would involve any other local variables
 * that in turn do not have an explicit representation.
 * An equality constraint involving local variables without an explicit
 * representation can be used in isl_basic_map_drop_redundant_divs
 * to separate out an independent local variable.  Introducing
 * an explicit representation here would block this transformation,
 * while the partial explicit representation in itself is not very useful.
 * Set *progress if anything is changed.
 *
 * The equality constraint is of the form
 *
 *	f(x) + n e >= 0
 *
 * with n a positive number.  The explicit representation derived from
 * this constraint is
 *
 *	floor((-f(x))/n)
 */
================================================================================

文件路径: ./isl_map_simplify.c
注释行数: 19
注释内容:
/* Perform fangcheng (Gaussian elimination) on the equality
 * constraints of "bmap".
 * That is, put them into row-echelon form, starting from the last column
 * backward and use them to eliminate the corresponding coefficients
 * from all constraints.
 *
 * If "progress" is not NULL, then it gets set if the elimination
 * results in any changes.
 * The elimination process may result in some equality constraints
 * getting interchanged or removed.
 * If "swap" or "drop" are not NULL, then they get called when
 * two equality constraints get interchanged or
 * when a number of final equality constraints get removed.
 * As a special case, if the input turns out to be empty,
 * then drop gets called with the number of removed equality
 * constraints set to the total number of equality constraints.
 * If "swap" or "drop" are not NULL, then the local variables (if any)
 * are assumed to be in a valid order.
 */
================================================================================

文件路径: ./isl_map_simplify.c
注释行数: 13
注释内容:
/* Is the inequality ineq (obviously) redundant with respect
 * to the constraints in "ci"?
 *
 * Look for an inequality in "ci" with the same coefficients and then
 * check if the contant term of "ineq" is greater than or equal
 * to the constant term of that inequality.  If so, "ineq" is clearly
 * redundant.
 *
 * Note that hash_index_ineq ignores a stored constraint if it has
 * the same address as the passed inequality.  It is ok to pass
 * the address of a local variable here since it will never be
 * the same as the address of a constraint in "ci".
 */
================================================================================

文件路径: ./isl_map_simplify.c
注释行数: 48
注释内容:
/* Normalize divs that appear in equalities.
 *
 * In particular, we assume that bmap contains some equalities
 * of the form
 *
 *	a x = m * e_i
 *
 * and we want to replace the set of e_i by a minimal set and
 * such that the new e_i have a canonical representation in terms
 * of the vector x.
 * If any of the equalities involves more than one divs, then
 * we currently simply bail out.
 *
 * Let us first additionally assume that all equalities involve
 * a div.  The equalities then express modulo constraints on the
 * remaining variables and we can use "parameter compression"
 * to find a minimal set of constraints.  The result is a transformation
 *
 *	x = T(x') = x_0 + G x'
 *
 * with G a lower-triangular matrix with all elements below the diagonal
 * non-negative and smaller than the diagonal element on the same row.
 * We first normalize x_0 by making the same property hold in the affine
 * T matrix.
 * The rows i of G with a 1 on the diagonal do not impose any modulo
 * constraint and simply express x_i = x'_i.
 * For each of the remaining rows i, we introduce a div and a corresponding
 * equality.  In particular
 *
 *	g_ii e_j = x_i - g_i(x')
 *
 * where each x'_k is replaced either by x_k (if g_kk = 1) or the
 * corresponding div (if g_kk != 1).
 *
 * If there are any equalities not involving any div, then we
 * first apply a variable compression on the variables x:
 *
 *	x = C x''	x'' = C_2 x
 *
 * and perform the above parameter compression on A C instead of on A.
 * The resulting compression is then of the form
 *
 *	x'' = T(x') = x_0 + G x'
 *
 * and in constructing the new divs and the corresponding equalities,
 * we have to replace each x'', i.e., the x'_k with (g_kk = 1),
 * by the corresponding row from C_2.
 */
================================================================================

文件路径: ./isl_map_simplify.c
注释行数: 12
注释内容:
/* Given two constraints "k" and "l" that are opposite to each other,
 * except for the constant term, check if we can use them
 * to obtain an expression for one of the hitherto unknown divs or
 * a "better" expression for a div for which we already have an expression.
 * "sum" is the sum of the constant terms of the constraints.
 * If this sum is strictly smaller than the coefficient of one
 * of the divs, then this pair can be used define the div.
 * To avoid the introduction of circular definitions of divs, we
 * do not use the pair if the resulting expression would refer to
 * any other undefined divs or if any known div is defined in
 * terms of the unknown div.
 */
================================================================================

文件路径: ./isl_map_simplify.c
注释行数: 35
注释内容:
/* Given a known integer division "div" that is not integral
 * (with denominator 1), eliminate it from the constraints in "bmap"
 * where it appears with a (positive or negative) unit coefficient.
 * If "progress" is not NULL, then it gets set if the elimination
 * results in any changes.
 *
 * That is, replace
 *
 *	floor(e/m) + f >= 0
 *
 * by
 *
 *	e + m f >= 0
 *
 * and
 *
 *	-floor(e/m) + f >= 0
 *
 * by
 *
 *	-e + m f + m - 1 >= 0
 *
 * The first conversion is valid because floor(e/m) >= -f is equivalent
 * to e/m >= -f because -f is an integral expression.
 * The second conversion follows from the fact that
 *
 *	-floor(e/m) = ceil(-e/m) = floor((-e + m - 1)/m)
 *
 *
 * Note that one of the div constraints may have been eliminated
 * due to being redundant with respect to the constraint that is
 * being modified by this function.  The modified constraint may
 * no longer imply this div constraint, so we add it back to make
 * sure we do not lose any information.
 */
================================================================================

文件路径: ./isl_map_simplify.c
注释行数: 12
注释内容:
/* Eliminate selected known divs from constraints where they appear with
 * a (positive or negative) unit coefficient.
 * In particular, only handle those for which "select" returns isl_bool_true.
 * If "progress" is not NULL, then it gets set if the elimination
 * results in any changes.
 *
 * We skip integral divs, i.e., those with denominator 1, as we would
 * risk eliminating the div from the div constraints.  We do not need
 * to handle those divs here anyway since the div constraints will turn
 * out to form an equality and this equality can then be used to eliminate
 * the div from all constraints.
 */
================================================================================

文件路径: ./isl_map_simplify.c
注释行数: 11
注释内容:
/* Remove all constraints from "bmap" that reference any unknown local
 * variables (directly or indirectly).
 *
 * Dropping all constraints on a local variable will make it redundant,
 * so it will get removed implicitly by
 * isl_basic_map_drop_constraints_involving_dims.  Some other local
 * variables may also end up becoming redundant if they only appear
 * in constraints together with the unknown local variable.
 * Therefore, start over after calling
 * isl_basic_map_drop_constraints_involving_dims.
 */
================================================================================

文件路径: ./isl_map_simplify.c
注释行数: 12
注释内容:
/* Update the groups in "group" based on the (linear part of a) constraint "c".
 *
 * In particular, for any variable involved in the constraint,
 * find the actual group id from before and replace the group
 * of the corresponding variable by the minimal group of all
 * the variables involved in the constraint considered so far
 * (if this minimum is smaller) or replace the minimum by this group
 * (if the minimum is larger).
 *
 * At the end, all the variables in "c" will (indirectly) point
 * to the minimal of the groups that they referred to originally.
 */
================================================================================

文件路径: ./isl_map_simplify.c
注释行数: 20
注释内容:
/* Drop constraints from "bmap" that only involve variables that are
 * not related to any of the variables marked with a "-1" in "group".
 *
 * We construct groups of variables that collect variables that
 * (indirectly) appear in some common constraint of "bmap".
 * Each group is identified by the first variable in the group,
 * except for the special group of variables that was already identified
 * in the input as -1 (or are related to those variables).
 * If group[i] is equal to i (or -1), then the group of i is i (or -1),
 * otherwise the group of i is the group of group[i].
 *
 * We first initialize groups for the remaining variables.
 * Then we iterate over the constraints of "bmap" and update the
 * group of the variables in the constraint by the smallest group.
 * Finally, we resolve indirect references to groups by running over
 * the variables.
 *
 * After computing the groups, we drop constraints that do not involve
 * any variables in the -1 group.
 */
================================================================================

文件路径: ./isl_map_simplify.c
注释行数: 10
注释内容:
/* Drop constraints from "context" that are irrelevant for computing
 * the gist of "bset".
 *
 * In particular, drop constraints in variables that are not related
 * to any of the variables involved in the constraints of "bset"
 * in the sense that there is no sequence of constraints that connects them.
 *
 * We first mark all variables that appear in "bset" as belonging
 * to a "-1" group and then continue with group_and_drop_irrelevant_constraints.
 */
================================================================================

文件路径: ./isl_map_simplify.c
注释行数: 12
注释内容:
/* Drop constraints from "context" that are irrelevant for computing
 * the gist of the inequalities "ineq".
 * Inequalities in "ineq" for which the corresponding element of row
 * is set to -1 have already been marked for removal and should be ignored.
 *
 * In particular, drop constraints in variables that are not related
 * to any of the variables involved in "ineq"
 * in the sense that there is no sequence of constraints that connects them.
 *
 * We first mark all variables that appear in "bset" as belonging
 * to a "-1" group and then continue with group_and_drop_irrelevant_constraints.
 */
================================================================================

文件路径: ./isl_map_simplify.c
注释行数: 13
注释内容:
/* Update the inequalities in "bset" based on the information in "row"
 * and "tab".
 *
 * In particular, the array "row" contains either -1, meaning that
 * the corresponding inequality of "bset" is redundant, or the index
 * of an inequality in "tab".
 *
 * If the row entry is -1, then drop the inequality.
 * Otherwise, if the constraint is marked redundant in the tableau,
 * then drop the inequality.  Similarly, if it is marked as an equality
 * in the tableau, then turn the inequality into an equality and
 * perform Gaussian elimination.
 */
================================================================================

文件路径: ./isl_map_simplify.c
注释行数: 32
注释内容:
/* Remove all information from bset that is redundant in the context
 * of context.
 * "ineq" contains the (possibly transformed) inequalities of "bset",
 * in the same order.
 * The (explicit) equalities of "bset" are assumed to have been taken
 * into account by the transformation such that only the inequalities
 * are relevant.
 * "context" is assumed not to be empty.
 *
 * "row" keeps track of the constraint index of a "bset" inequality in "tab".
 * A value of -1 means that the inequality is obviously redundant and may
 * not even appear in  "tab".
 *
 * We first mark the inequalities of "bset"
 * that are obviously redundant with respect to some inequality in "context".
 * Then we remove those constraints from "context" that have become
 * irrelevant for computing the gist of "bset".
 * Note that this removal of constraints cannot be replaced by
 * a factorization because factors in "bset" may still be connected
 * to each other through constraints in "context".
 *
 * If there are any inequalities left, we construct a tableau for
 * the context and then add the inequalities of "bset".
 * Before adding these inequalities, we freeze all constraints such that
 * they won't be considered redundant in terms of the constraints of "bset".
 * Then we detect all redundant constraints (among the
 * constraints that weren't frozen), first by checking for redundancy in the
 * the tableau and then by checking if replacing a constraint by its negation
 * would lead to an empty set.  This last step is fairly expensive
 * and could be optimized by more reuse of the tableau.
 * Finally, we update bset according to the results.
 */
================================================================================

文件路径: ./isl_map_simplify.c
注释行数: 30
注释内容:
/* Remove all information from "bset" that is redundant in the context
 * of "context", for the case where the combined equalities of
 * "bset" and "context" allow for a compression that can be obtained
 * by preapplication of "T".
 * If the compression of "context" is empty, meaning that "bset" and
 * "context" do not intersect, then return the empty set.
 *
 * "bset" itself is not transformed by "T".  Instead, the inequalities
 * are extracted from "bset" and those are transformed by "T".
 * uset_gist_full then determines which of the transformed inequalities
 * are redundant with respect to the transformed "context" and removes
 * the corresponding inequalities from "bset".
 *
 * After preapplying "T" to the inequalities, any common factor is
 * removed from the coefficients.  If this results in a tightening
 * of the constant term, then the same tightening is applied to
 * the corresponding untransformed inequality in "bset".
 * That is, if after plugging in T, a constraint f(x) >= 0 is of the form
 *
 *	g f'(x) + r >= 0
 *
 * with 0 <= r < g, then it is equivalent to
 *
 *	f'(x) >= 0
 *
 * This means that f(x) >= 0 is equivalent to f(x) - r >= 0 in the affine
 * subspace compressed by T since the latter would be transformed to
 *
 *	g f'(x) >= 0
 */
================================================================================

文件路径: ./isl_map_simplify.c
注释行数: 25
注释内容:
/* Remove all information from bset that is redundant in the context
 * of context.  In particular, equalities that are linear combinations
 * of those in context are removed.  Then the inequalities that are
 * redundant in the context of the equalities and inequalities of
 * context are removed.
 *
 * First of all, we drop those constraints from "context"
 * that are irrelevant for computing the gist of "bset".
 * Alternatively, we could factorize the intersection of "context" and "bset".
 *
 * We first compute the intersection of the integer affine hulls
 * of "bset" and "context",
 * compute the gist inside this intersection and then reduce
 * the constraints with respect to the equalities of the context
 * that only involve variables already involved in the input.
 * If the intersection of the affine hulls turns out to be empty,
 * then return the empty set.
 *
 * If two constraints are mutually redundant, then uset_gist_full
 * will remove the second of those constraints.  We therefore first
 * sort the constraints so that constraints not involving existentially
 * quantified variables are given precedence over those that do.
 * We have to perform this sorting before the variable compression,
 * because that may effect the order of the variables.
 */
================================================================================

文件路径: ./isl_map_simplify.c
注释行数: 20
注释内容:
/* Construct and return a variable compression based on the equality
 * constraints in "bmap1" and "bmap2" that do not involve the local variables.
 * "n1" is the number of (initial) equality constraints in "bmap1"
 * that do involve local variables.
 * "n2" is the number of (initial) equality constraints in "bmap2"
 * that do involve local variables.
 * "total" is the total number of other variables.
 * This function assumes that Gaussian elimination
 * has been applied to the equality constraints in both "bmap1" and "bmap2"
 * such that the equality constraints not involving local variables
 * are those that start at "n1" or "n2".
 *
 * If either of "bmap1" and "bmap2" does not have such equality constraints,
 * then simply compute the compression based on the equality constraints
 * in the other basic map.
 * Otherwise, combine the equality constraints from both into a new
 * basic map such that Gaussian elimination can be applied to this combination
 * and then construct a variable compression from the resulting
 * equality constraints.
 */
================================================================================

文件路径: ./isl_map_simplify.c
注释行数: 32
注释内容:
/* Extract the stride constraints from "bmap", compressed
 * with respect to both the stride constraints in "context" and
 * the remaining equality constraints in both "bmap" and "context".
 * "bmap_n_eq" is the number of (initial) stride constraints in "bmap".
 * "context_n_eq" is the number of (initial) stride constraints in "context".
 *
 * Let x be all variables in "bmap" (and "context") other than the local
 * variables.  First compute a variable compression
 *
 *	x = V x'
 *
 * based on the non-stride equality constraints in "bmap" and "context".
 * Consider the stride constraints of "context",
 *
 *	A(x) + B(y) = 0
 *
 * with y the local variables and plug in the variable compression,
 * resulting in
 *
 *	A(V x') + B(y) = 0
 *
 * Use these constraints to compute a parameter compression on x'
 *
 *	x' = T x''
 *
 * Now consider the stride constraints of "bmap"
 *
 *	C(x) + D(y) = 0
 *
 * and plug in x = V*T x''.
 * That is, return A = [C*V*T D].
 */
================================================================================

文件路径: ./isl_map_simplify.c
注释行数: 28
注释内容:
/* Remove the prime factors from *g that have an exponent that
 * is strictly smaller than the exponent in "c".
 * All exponents in *g are known to be smaller than or equal
 * to those in "c".
 *
 * That is, if *g is equal to
 *
 *	p_1^{e_1} p_2^{e_2} ... p_n^{e_n}
 *
 * and "c" is equal to
 *
 *	p_1^{f_1} p_2^{f_2} ... p_n^{f_n}
 *
 * then update *g to
 *
 *	p_1^{e_1 * (e_1 = f_1)} p_2^{e_2 * (e_2 = f_2)} ...
 *		p_n^{e_n * (e_n = f_n)}
 *
 * If e_i = f_i, then c / *g does not have any p_i factors and therefore
 * neither does the gcd of *g and c / *g.
 * If e_i < f_i, then the gcd of *g and c / *g has a positive
 * power min(e_i, s_i) of p_i with s_i = f_i - e_i among its factors.
 * Dividing *g by this gcd therefore strictly reduces the exponent
 * of the prime factors that need to be removed, while leaving the
 * other prime factors untouched.
 * Repeating this process until gcd(*g, c / *g) = 1 therefore
 * removes all undesired factors, without removing any others.
 */
================================================================================

文件路径: ./isl_map_simplify.c
注释行数: 49
注释内容:
/* Reduce the "n" stride constraints in "bmap" based on a copy "A"
 * of the same stride constraints in a compressed space that exploits
 * all equalities in the context and the other equalities in "bmap".
 *
 * If the stride constraints of "bmap" are of the form
 *
 *	C(x) + D(y) = 0
 *
 * then A is of the form
 *
 *	B(x') + D(y) = 0
 *
 * If any of these constraints involves only a single local variable y,
 * then the constraint appears as
 *
 *	f(x) + m y_i = 0
 *
 * in "bmap" and as
 *
 *	h(x') + m y_i = 0
 *
 * in "A".
 *
 * Let g be the gcd of m and the coefficients of h.
 * Then, in particular, g is a divisor of the coefficients of h and
 *
 *	f(x) = h(x')
 *
 * is known to be a multiple of g.
 * If some prime factor in m appears with the same exponent in g,
 * then it can be removed from m because f(x) is already known
 * to be a multiple of g and therefore in particular of this power
 * of the prime factors.
 * Prime factors that appear with a smaller exponent in g cannot
 * be removed from m.
 * Let g' be the divisor of g containing all prime factors that
 * appear with the same exponent in m and g, then
 *
 *	f(x) + m y_i = 0
 *
 * can be replaced by
 *
 *	f(x) + m/g' y_i' = 0
 *
 * Note that (if g' != 1) this changes the explicit representation
 * of y_i to that of y_i', so the integer division at position i
 * is marked unknown and later recomputed by a call to
 * isl_basic_map_gauss.
 */
================================================================================

文件路径: ./isl_map_simplify.c
注释行数: 20
注释内容:
/* Return a basic map that has the same intersection with "context" as "bmap"
 * and that is as "simple" as possible.
 *
 * The core computation is performed on the pure constraints.
 * When we add back the meaning of the integer divisions, we need
 * to (re)introduce the div constraints.  If we happen to have
 * discovered that some of these integer divisions are equal to
 * some affine combination of other variables, then these div
 * constraints may end up getting simplified in terms of the equalities,
 * resulting in extra inequalities on the other variables that
 * may have been removed already or that may not even have been
 * part of the input.  We try and remove those constraints of
 * this form that are most obviously redundant with respect to
 * the context.  We also remove those div constraints that are
 * redundant with respect to the other constraints in the result.
 *
 * The stride constraints among the equality constraints in "bmap" are
 * also simplified with respecting to the other equality constraints
 * in "bmap" and with respect to all equality constraints in "context".
 */
================================================================================

文件路径: ./isl_map_simplify.c
注释行数: 13
注释内容:
/* Drop all inequalities from "bmap" that also appear in "context".
 * "context" is assumed to have only known local variables and
 * the initial local variables of "bmap" are assumed to be the same
 * as those of "context".
 * The constraints of both "bmap" and "context" are assumed
 * to have been sorted using isl_basic_map_sort_constraints.
 *
 * Run through the inequality constraints of "bmap" and "context"
 * in sorted order.
 * If a constraint of "bmap" involves variables not in "context",
 * then it cannot appear in "context".
 * If a matching constraint is found, it is removed from "bmap".
 */
================================================================================

文件路径: ./isl_map_simplify.c
注释行数: 11
注释内容:
/* Drop all equalities from "bmap" that also appear in "context".
 * "context" is assumed to have only known local variables and
 * the initial local variables of "bmap" are assumed to be the same
 * as those of "context".
 *
 * Run through the equality constraints of "bmap" and "context"
 * in sorted order.
 * If a constraint of "bmap" involves variables not in "context",
 * then it cannot appear in "context".
 * If a matching constraint is found, it is removed from "bmap".
 */
================================================================================

文件路径: ./isl_map_simplify.c
注释行数: 25
注释内容:
/* Return a map that has the same intersection with "context" as "map"
 * and that is as "simple" as possible.
 *
 * If "map" is already the universe, then we cannot make it any simpler.
 * Similarly, if "context" is the universe, then we cannot exploit it
 * to simplify "map"
 * If "map" and "context" are identical to each other, then we can
 * return the corresponding universe.
 *
 * If either "map" or "context" consists of multiple disjuncts,
 * then check if "context" happens to be a subset of "map",
 * in which case all constraints can be removed.
 * In case of multiple disjuncts, the standard procedure
 * may not be able to detect that all constraints can be removed.
 *
 * If none of these cases apply, we have to work a bit harder.
 * During this computation, we make use of a single disjunct context,
 * so if the original context consists of more than one disjunct
 * then we need to approximate the context by a single disjunct set.
 * Simply taking the simple hull may drop constraints that are
 * only implicitly available in each disjunct.  We therefore also
 * look for constraints among those defining "map" that are valid
 * for the context.  These can then be used to simplify away
 * the corresponding constraints in "map".
 */
================================================================================

文件路径: ./isl_map_simplify.c
注释行数: 14
注释内容:
/* Are "map1" and "map2" obviously disjoint?
 *
 * If one of them is empty or if they live in different spaces (ignoring
 * parameters), then they are clearly disjoint.
 * This is checked by isl_map_plain_is_disjoint_global.
 *
 * If they have different parameters, then we skip any further tests.
 *
 * If they are obviously equal, but not obviously empty, then we will
 * not be able to detect if they are disjoint.
 *
 * Otherwise we check if each basic map in "map1" is obviously disjoint
 * from each basic map in "map2".
 */
================================================================================

文件路径: ./isl_map_simplify.c
注释行数: 31
注释内容:
/* Check if we can combine a given div with lower bound l and upper
 * bound u with some other div and if so return that other div.
 * Otherwise, return a position beyond the integer divisions.
 * Return -1 on error.
 *
 * We first check that
 *	- the bounds are opposites of each other (except for the constant
 *	  term)
 *	- the bounds do not reference any other div
 *	- no div is defined in terms of this div
 *
 * Let m be the size of the range allowed on the div by the bounds.
 * That is, the bounds are of the form
 *
 *	e <= a <= e + m - 1
 *
 * with e some expression in the other variables.
 * We look for another div b such that no third div is defined in terms
 * of this second div b and such that in any constraint that contains
 * a (except for the given lower and upper bound), also contains b
 * with a coefficient that is m times that of b.
 * That is, all constraints (except for the lower and upper bound)
 * are of the form
 *
 *	e + f (a + m b) >= 0
 *
 * Furthermore, in the constraints that only contain b, the coefficient
 * of b should be equal to 1 or -1.
 * If so, we return b so that "a + m b" can be replaced by
 * a single div "c = a + m b".
 */
================================================================================

文件路径: ./isl_map_simplify.c
注释行数: 10
注释内容:
/* Internal data structure used during the construction and/or evaluation of
 * an inequality that ensures that a pair of bounds always allows
 * for an integer value.
 *
 * "tab" is the tableau in which the inequality is evaluated.  It may
 * be NULL until it is actually needed.
 * "v" contains the inequality coefficients.
 * "g", "fl" and "fu" are temporary scalars used during the construction and
 * evaluation.
 */
================================================================================

文件路径: ./isl_map_simplify.c
注释行数: 52
注释内容:
/* Given a lower and an upper bound on div i, do they always allow
 * for an integer value of the given div?
 * Determine this property by constructing an inequality
 * such that the property is guaranteed when the inequality is nonnegative.
 * The lower bound is inequality l, while the upper bound is inequality u.
 * The constructed inequality is stored in data->v.
 *
 * Let the upper bound be
 *
 *	-n_u a + e_u >= 0
 *
 * and the lower bound
 *
 *	n_l a + e_l >= 0
 *
 * Let n_u = f_u g and n_l = f_l g, with g = gcd(n_u, n_l).
 * We have
 *
 *	- f_u e_l <= f_u f_l g a <= f_l e_u
 *
 * Since all variables are integer valued, this is equivalent to
 *
 *	- f_u e_l - (f_u - 1) <= f_u f_l g a <= f_l e_u + (f_l - 1)
 *
 * If this interval is at least f_u f_l g, then it contains at least
 * one integer value for a.
 * That is, the test constraint is
 *
 *	f_l e_u + f_u e_l + f_l - 1 + f_u - 1 + 1 >= f_u f_l g
 *
 * or
 *
 *	f_l e_u + f_u e_l + f_l - 1 + f_u - 1 + 1 - f_u f_l g >= 0
 *
 * If the coefficients of f_l e_u + f_u e_l have a common divisor g',
 * then the constraint can be scaled down by a factor g',
 * with the constant term replaced by
 * floor((f_l e_{u,0} + f_u e_{l,0} + f_l - 1 + f_u - 1 + 1 - f_u f_l g)/g').
 * Note that the result of applying Fourier-Motzkin to this pair
 * of constraints is
 *
 *	f_l e_u + f_u e_l >= 0
 *
 * If the constant term of the scaled down version of this constraint,
 * i.e., floor((f_l e_{u,0} + f_u e_{l,0})/g') is equal to the constant
 * term of the scaled down test constraint, then the test constraint
 * is known to hold and no explicit evaluation is required.
 * This is essentially the Omega test.
 *
 * If the test constraint consists of only a constant term, then
 * it is sufficient to look at the sign of this constant term.
 */
================================================================================

文件路径: ./isl_map_simplify.c
注释行数: 11
注释内容:
/* Remove more kinds of divs that are not strictly needed.
 * In particular, if all pairs of lower and upper bounds on a div
 * are such that they allow at least one integer value of the div,
 * then we can eliminate the div using Fourier-Motzkin without
 * introducing any spurious solutions.
 *
 * If at least one of the two constraints has a unit coefficient for the div,
 * then the presence of such a value is guaranteed so there is no need to check.
 * In particular, the value attained by the bound with unit coefficient
 * can serve as this intermediate value.
 */
================================================================================

文件路径: ./isl_map_simplify.c
注释行数: 49
注释内容:
/* Given a pair of divs div1 and div2 such that, except for the lower bound l
 * and the upper bound u, div1 always occurs together with div2 in the form
 * (div1 + m div2), where m is the constant range on the variable div1
 * allowed by l and u, replace the pair div1 and div2 by a single
 * div that is equal to div1 + m div2.
 *
 * The new div will appear in the location that contains div2.
 * We need to modify all constraints that contain
 * div2 = (div - div1) / m
 * The coefficient of div2 is known to be equal to 1 or -1.
 * (If a constraint does not contain div2, it will also not contain div1.)
 * If the constraint also contains div1, then we know they appear
 * as f (div1 + m div2) and we can simply replace (div1 + m div2) by div,
 * i.e., the coefficient of div is f.
 *
 * Otherwise, we first need to introduce div1 into the constraint.
 * Let l be
 *
 *	div1 + f >=0
 *
 * and u
 *
 *	-div1 + f' >= 0
 *
 * A lower bound on div2
 *
 *	div2 + t >= 0
 *
 * can be replaced by
 *
 *	m div2 + div1 + m t + f >= 0
 *
 * An upper bound
 *
 *	-div2 + t >= 0
 *
 * can be replaced by
 *
 *	-(m div2 + div1) + m t + f' >= 0
 *
 * These constraint are those that we would obtain from eliminating
 * div1 using Fourier-Motzkin.
 *
 * After all constraints have been modified, we drop the lower and upper
 * bound and then drop div1.
 * Since the new div is only placed in the same location that used
 * to store div2, but otherwise has a different meaning, any possible
 * explicit representation of the original div2 is removed.
 */
================================================================================

文件路径: ./isl_map_simplify.c
注释行数: 16
注释内容:
/* Given two inequality constraints
 *
 *	f(x) + n d + c >= 0,		(ineq)
 *
 * with d the variable at position "pos", and
 *
 *	f(x) + c0 >= 0,			(lower)
 *
 * compute the maximal value of the lower bound ceil((-f(x) - c)/n)
 * determined by the first constraint.
 * That is, store
 *
 *	ceil((c0 - c)/n)
 *
 * in *l.
 */
================================================================================

文件路径: ./isl_map_simplify.c
注释行数: 16
注释内容:
/* Given two inequality constraints
 *
 *	f(x) + n d + c >= 0,		(ineq)
 *
 * with d the variable at position "pos", and
 *
 *	-f(x) - c0 >= 0,		(upper)
 *
 * compute the minimal value of the lower bound ceil((-f(x) - c)/n)
 * determined by the first constraint.
 * That is, store
 *
 *	ceil((-c1 - c)/n)
 *
 * in *u.
 */
================================================================================

文件路径: ./isl_map_simplify.c
注释行数: 27
注释内容:
/* Given a lower bound constraint "ineq" on "div" in "bmap",
 * does the corresponding lower bound have a fixed value in "bmap"?
 *
 * In particular, "ineq" is of the form
 *
 *	f(x) + n d + c >= 0
 *
 * with n > 0, c the constant term and
 * d the existentially quantified variable "div".
 * That is, the lower bound is
 *
 *	ceil((-f(x) - c)/n)
 *
 * Look for a pair of constraints
 *
 *	f(x) + c0 >= 0
 *	-f(x) + c1 >= 0
 *
 * i.e., -c1 <= -f(x) <= c0, that fix ceil((-f(x) - c)/n) to a constant value.
 * That is, check that
 *
 *	ceil((-c1 - c)/n) = ceil((c0 - c)/n)
 *
 * If so, return the index of inequality f(x) + c0 >= 0.
 * Otherwise, return bmap->n_ineq.
 * Return -1 on error.
 */
================================================================================

文件路径: ./isl_map_simplify.c
注释行数: 19
注释内容:
/* Given a lower bound constraint "ineq" on the existentially quantified
 * variable "div", such that the corresponding lower bound has
 * a fixed value in "bmap", assign this fixed value to the variable and
 * then try and drop redundant divs again,
 * freeing the temporary data structure "pairs" that was associated
 * to the old version of "bmap".
 * "lower" determines the constant value for the lower bound.
 *
 * In particular, "ineq" is of the form
 *
 *	f(x) + n d + c >= 0,
 *
 * while "lower" is of the form
 *
 *	f(x) + c0 >= 0
 *
 * The lower bound is ceil((-f(x) - c)/n) and its constant value
 * is ceil((c0 - c)/n).
 */
================================================================================

文件路径: ./isl_map_simplify.c
注释行数: 42
注释内容:
/* Remove divs that are not strictly needed based on the inequality
 * constraints.
 * In particular, if a div only occurs positively (or negatively)
 * in constraints, then it can simply be dropped.
 * Also, if a div occurs in only two constraints and if moreover
 * those two constraints are opposite to each other, except for the constant
 * term and if the sum of the constant terms is such that for any value
 * of the other values, there is always at least one integer value of the
 * div, i.e., if one plus this sum is greater than or equal to
 * the (absolute value) of the coefficient of the div in the constraints,
 * then we can also simply drop the div.
 *
 * If an existentially quantified variable does not have an explicit
 * representation, appears in only a single lower bound that does not
 * involve any other such existentially quantified variables and appears
 * in this lower bound with coefficient 1,
 * then fix the variable to the value of the lower bound.  That is,
 * turn the inequality into an equality.
 * If for any value of the other variables, there is any value
 * for the existentially quantified variable satisfying the constraints,
 * then this lower bound also satisfies the constraints.
 * It is therefore safe to pick this lower bound.
 *
 * The same reasoning holds even if the coefficient is not one.
 * However, fixing the variable to the value of the lower bound may
 * in general introduce an extra integer division, in which case
 * it may be better to pick another value.
 * If this integer division has a known constant value, then plugging
 * in this constant value removes the existentially quantified variable
 * completely.  In particular, if the lower bound is of the form
 * ceil((-f(x) - c)/n) and there are two constraints, f(x) + c0 >= 0 and
 * -f(x) + c1 >= 0 such that ceil((-c1 - c)/n) = ceil((c0 - c)/n),
 * then the existentially quantified variable can be assigned this
 * shared value.
 *
 * We skip divs that appear in equalities or in the definition of other divs.
 * Divs that appear in the definition of other divs usually occur in at least
 * 4 constraints, but the constraints may have been simplified.
 *
 * If any divs are left after these simple checks then we move on
 * to more complicated cases in drop_more_redundant_divs.
 */
================================================================================

文件路径: ./isl_map_simplify.c
注释行数: 41
注释内容:
/* Remove divs that are not strictly needed.
 *
 * First look for an equality constraint involving two or more
 * existentially quantified variables without an explicit
 * representation.  Replace the combination that appears
 * in the equality constraint by a single existentially quantified
 * variable such that the equality can be used to derive
 * an explicit representation for the variable.
 * If there are no more such equality constraints, then continue
 * with isl_basic_map_drop_redundant_divs_ineq.
 *
 * In particular, if the equality constraint is of the form
 *
 *	f(x) + \sum_i c_i a_i = 0
 *
 * with a_i existentially quantified variable without explicit
 * representation, then apply a transformation on the existentially
 * quantified variables to turn the constraint into
 *
 *	f(x) + g a_1' = 0
 *
 * with g the gcd of the c_i.
 * In order to easily identify which existentially quantified variables
 * have a complete explicit representation, i.e., without being defined
 * in terms of other existentially quantified variables without
 * an explicit representation, the existentially quantified variables
 * are first sorted.
 *
 * The variable transformation is computed by extending the row
 * [c_1/g ... c_n/g] to a unimodular matrix, obtaining the transformation
 *
 *	[a_1']   [c_1/g ... c_n/g]   [ a_1 ]
 *	[a_2']                       [ a_2 ]
 *	 ...   =         U             ....
 *	[a_n']            	     [ a_n ]
 *
 * with [c_1/g ... c_n/g] representing the first row of U.
 * The inverse of U is then plugged into the original constraints.
 * The call to isl_basic_map_simplify makes sure the explicit
 * representation for a_1' is extracted from the equality constraint.
 */
================================================================================

文件路径: ./isl_map_simplify.c
注释行数: 30
注释内容:
/* If "bmap" is an integer set that satisfies any equality involving
 * more than 2 variables and/or has coefficients different from -1 and 1,
 * then use variable compression to reduce the coefficients by removing
 * any (hidden) common factor.
 * In particular, apply the variable compression to each constraint,
 * factor out any common factor in the non-constant coefficients and
 * then apply the inverse of the compression.
 * At the end, we mark the basic map as having reduced constants.
 * If this flag is still set on the next invocation of this function,
 * then we skip the computation.
 *
 * Removing a common factor may result in a tightening of some of
 * the constraints.  If this happens, then we may end up with two
 * opposite inequalities that can be replaced by an equality.
 * We therefore call isl_basic_map_detect_inequality_pairs,
 * which checks for such pairs of inequalities as well as eliminate_divs_eq
 * and isl_basic_map_gauss if such a pair was found.
 *
 * Tightening may also result in some other constraints becoming
 * (rationally) redundant with respect to the tightened constraint
 * (in combination with other constraints).  The basic map may
 * therefore no longer be assumed to have no redundant constraints.
 *
 * Note that this function may leave the result in an inconsistent state.
 * In particular, the constraints may not be gaussed.
 * Unfortunately, isl_map_coalesce actually depends on this inconsistent state
 * for some of the test cases to pass successfully.
 * Any potential modification of the representation is therefore only
 * performed on a single copy of the basic map.
 */
================================================================================

文件路径: ./isl_map_simplify.c
注释行数: 13
注释内容:
/* Shift the integer division at position "div" of "bmap"
 * by "shift" times the variable at position "pos".
 * "pos" is as determined by isl_basic_map_offset, i.e., pos == 0
 * corresponds to the constant term.
 *
 * That is, if the integer division has the form
 *
 *	floor(f(x)/d)
 *
 * then replace it by
 *
 *	floor((f(x) + shift * d * x_pos)/d) - shift * x_pos
 */
================================================================================

文件路径: ./isl_tab.h
注释行数: 61
注释内容:
/* The tableau maintains equality relations.
 * Each column and each row is associated to a variable or a constraint.
 * The "value" of an inequality constraint is the value of the corresponding
 * slack variable.
 * The "row_var" and "col_var" arrays map column and row indices
 * to indices in the "var" and "con" arrays.  The elements of these
 * arrays maintain extra information about the variables and the constraints.
 * Each row expresses the corresponding row variable as an affine expression
 * of the column variables.
 * The first two columns in the matrix contain the common denominator of
 * the row and the numerator of the constant term.
 * If "M" is set, then the third column represents the "big parameter".
 * The third (M = 0) or fourth (M = 1) column
 * in the matrix is called column 0 with respect to the col_var array.
 * The sample value of the tableau is the value that assigns zero
 * to all the column variables and the constant term of each affine
 * expression to the corresponding row variable.
 * The operations on the tableau maintain the property that the sample
 * value satisfies the non-negativity constraints (usually on the slack
 * variables).
 *
 * The big parameter represents an arbitrarily big (and divisible)
 * positive number.  If present, then the sign of a row is determined
 * lexicographically, with the sign of the big parameter coefficient
 * considered first.  The big parameter is only used while
 * solving PILP problems.
 *
 * The first n_dead column variables have their values fixed to zero.
 * The corresponding tab_vars are flagged "is_zero".
 * Some of the rows that have have zero coefficients in all but
 * the dead columns are also flagged "is_zero".
 *
 * The first n_redundant rows correspond to inequality constraints
 * that are always satisfied for any value satisfying the non-redundant
 * rows.  The corresponding tab_vars are flagged "is_redundant".
 * A row variable that is flagged "is_zero" is also flagged "is_redundant"
 * since the constraint has been reduced to 0 = 0 and is therefore always
 * satisfied.
 *
 * There are "n_var" variables in total.  The first "n_param" of these
 * are called parameters and the last "n_div" of these are called divs.
 * The basic tableau operations makes no distinction between different
 * kinds of variables.  These special variables are only used while
 * solving PILP problems.
 *
 * Dead columns and redundant rows are detected on the fly.
 * However, the basic operations do not ensure that all dead columns
 * or all redundant rows are detected.
 * isl_tab_detect_implicit_equalities and isl_tab_detect_redundant can be used
 * to perform an exhaustive search for dead columns and redundant rows.
 *
 * The samples matrix contains "n_sample" integer points that have at some
 * point been elements satisfying the tableau.  The first "n_outside"
 * of them no longer satisfy the tableau.  They are kept because they
 * can be reinstated during rollback when the constraint that cut them
 * out is removed.  These samples are only maintained for the context
 * tableau while solving PILP problems.
 *
 * If "preserve" is set, then we want to keep all constraints in the
 * tableau, even if they turn out to be redundant.
 */
================================================================================

文件路径: ./isl_opt_mpa_templ.c
注释行数: 10
注释内容:
/* Compute the optima of the set or output dimensions as a function of the
 * parameters (and input dimensions), but independently of
 * the other set or output dimensions,
 * given a function "opt" that computes this optimum
 * for a single dimension.
 *
 * If the resulting multi piecewise affine expression has
 * an explicit domain, then assign it the (parameter) domain of the input.
 * In other cases, the (parameter) domain is stored in the individual elements.
 */
================================================================================

文件路径: ./isl_obj.c
注释行数: 14
注释内容:
/*
 * Copyright 2010      INRIA Saclay
 * Copyright 2014      Ecole Normale Superieure
 * Copyright 2014      INRIA Rocquencourt
 *
 * Use of this software is governed by the MIT license
 *
 * Written by Sven Verdoolaege, INRIA Saclay - Ile-de-France,
 * Parc Club Orsay Universite, ZAC des vignes, 4 rue Jacques Monod,
 * 91893 Orsay, France 
 * and Ecole Normale Superieure, 45 rue d'Ulm, 75230 Paris, France
 * and Inria Paris - Rocquencourt, Domaine de Voluceau - Rocquencourt,
 * B.P. 105 - 78153 Le Chesnay, France
 */
================================================================================

文件路径: ./isl_pw_union_opt.c
注释行数: 13
注释内容:
/*
 * Copyright 2011      INRIA Saclay
 * Copyright 2012      Ecole Normale Superieure
 * Copyright 2020      Cerebras Systems
 *
 * Use of this software is governed by the MIT license
 *
 * Written by Sven Verdoolaege, INRIA Saclay - Ile-de-France,
 * Parc Club Orsay Universite, ZAC des vignes, 4 rue Jacques Monod,
 * 91893 Orsay, France
 * and Ecole Normale Superieure, 45 rue d'Ulm, 75230 Paris, France
 * and Cerebras Systems, 175 S San Antonio Rd, Los Altos, CA, USA
 */
================================================================================

文件路径: ./isl_pw_union_opt.c
注释行数: 29
注释内容:
/* Given (potentially) updated cells "i" of data_i->pw and "j" of data_j->pw and
 * a set "better" where the piece from data_j->pw is better
 * than the piece from data_i->pw,
 * (further) update the specified cells such that only the better elements
 * remain on the (non-empty) intersection.
 *
 * Let C be the set "better".
 * Let A be the cell data_i->cell[i] and B the cell data_j->cell[j].
 *
 * The elements in C need to be removed from A, except for those parts
 * that lie outside of B.  That is,
 *
 *	A <- (A \setminus C) \cup ((A \cap C) \setminus B')
 *
 * Conversely, the elements in B need to be restricted to C, except
 * for those parts that lie outside of A.  That is
 *
 *	B <- (B \cap C) \cup ((B \setminus C) \setminus A')
 *
 * Since all pairs of pieces are considered, the domains are updated
 * several times.  A and B refer to these updated domains
 * (kept track of in data_i->cell[i] and data_j->cell[j]), while A' and B' refer
 * to the original domains of the pieces.  It is safe to use these
 * original domains because the difference between, say, A' and A is
 * the domains of pw2-pieces that have been removed before and
 * those domains are disjoint from B.  A' is used instead of A
 * because the continued updating of A may result in this domain
 * getting broken up into more disjuncts.
 */
================================================================================

文件路径: ./isl_pw_union_opt.c
注释行数: 23
注释内容:
/* Given (potentially) updated cells "i" of data_i->pw and "j" of data_j->pw and
 * a function "cmp" that returns the set of elements where
 * "el1" is "better" than "el2",
 * (further) update the specified cells such that only the "better" elements
 * remain on the (non-empty) intersection.
 *
 * The base computation is performed by isl_pw_*_union_opt_cmp_pair,
 * which splits the cells according to the set of elements
 * where the piece from data_j->pw is better than the piece from data_i->pw.
 *
 * In some cases, there may be a subset of the intersection
 * where both pieces have the same value and can therefore
 * both be considered to be "better" than the other.
 * This can result in unnecessary splitting on this subset.
 * Avoid some of these cases by checking whether
 * data_i->pw is always better than data_j->pw on the intersection.
 * In particular, do this for the special case where this intersection
 * is equal to the cell "j" and data_i->pw is better on its entire cell.
 *
 * Similarly, if data_i->pw is never better than data_j->pw,
 * then no splitting will occur and there is no need to check
 * where data_j->pw is better than data_i->pw.
 */
================================================================================

文件路径: ./isl_pw_union_opt.c
注释行数: 16
注释内容:
/* Given two piecewise expressions data1->pw and data2->pw, replace
 * their domains
 * by the sets in data1->cell and data2->cell and combine the results into
 * a single piecewise expression.
 * The pieces of data1->pw and data2->pw are assumed to have been sorted
 * according to the function value expressions.
 * The pieces of the result are also sorted in this way.
 *
 * Run through the pieces of data1->pw and data2->pw in order until they
 * have both been exhausted, picking the piece from data1->pw or data2->pw
 * depending on which should come first, together with the corresponding
 * domain from data1->cell or data2->cell.  In cases where the next pieces
 * in both data1->pw and data2->pw have the same function value expression,
 * construct only a single piece in the result with as domain
 * the union of the domains in data1->cell and data2->cell.
 */
================================================================================

文件路径: ./isl_pw_union_opt.c
注释行数: 18
注释内容:
/* Given a function "cmp" that returns the set of elements where
 * "el1" is "better" than "el2", return a piecewise
 * expression defined on the union of the definition domains
 * of "pw1" and "pw2" that maps to the "best" of "pw1" and
 * "pw2" on each cell.  If only one of the two input functions
 * is defined on a given cell, then it is considered the best.
 *
 * Run through all pairs of pieces in "pw1" and "pw2".
 * If the domains of these pieces intersect, then the intersection
 * needs to be distributed over the two pieces based on "cmp".
 *
 * After the updated domains have been computed, the result is constructed
 * from "pw1", "pw2", data[0].cell and data[1].cell.  If there are any pieces
 * in "pw1" and "pw2" with the same function value expression, then
 * they are combined into a single piece in the result.
 * In order to be able to do this efficiently, the pieces of "pw1" and
 * "pw2" are first sorted according to their function value expressions.
 */
================================================================================

文件路径: ./isl_fold.c
注释行数: 10
注释内容:
/* Determine the sign of the constant quasipolynomial "qp".
 *
 * Return
 *	-1 if qp <= 0
 *	 1 if qp >= 0
 *	 0 if unknown
 *
 * For qp == 0, we can return either -1 or 1.  In practice, we return 1.
 * For qp == NaN, the sign is undefined, so we return 0.
 */
================================================================================

文件路径: ./isl_fold.c
注释行数: 20
注释内容:
/* Determine, if possible, the sign of the quasipolynomial "qp" on
 * the domain "set".
 *
 * If qp is a constant, then the problem is trivial.
 * If qp is linear, then we check if the minimum of the corresponding
 * affine constraint is non-negative or if the maximum is non-positive.
 *
 * Otherwise, we check if the outermost variable "v" has a lower bound "l"
 * in "set".  If so, we write qp(v,v') as
 *
 *	q(v,v') * (v - l) + r(v')
 *
 * if q(v,v') and r(v') have the same known sign, then the original
 * quasipolynomial has the same sign as well.
 *
 * Return
 *	-1 if qp <= 0
 *	 1 if qp >= 0
 *	 0 if unknown
 */
================================================================================

文件路径: ./isl_val_gmp.c
注释行数: 11
注释内容:
/* Store a representation of the absolute value of the numerator of "v"
 * in terms of chunks of size "size" at "chunks".
 * The least significant chunk is stored first.
 * The number of chunks in the result can be obtained by calling
 * isl_val_n_abs_num_chunks.  The user is responsible for allocating
 * enough memory to store the results.
 *
 * In the special case of a zero value, isl_val_n_abs_num_chunks will
 * return one, while mpz_export will not fill in any chunks.  We therefore
 * do it ourselves.
 */
================================================================================

文件路径: ./isl_schedule_node_private.h
注释行数: 16
注释内容:
/* An isl_schedule_node points to a particular location in a schedule tree.
 *
 * "schedule" is the schedule that the node is pointing to.
 * "ancestors" is a list of the n ancestors of the node
 * that is being pointed to.
 * The first ancestor is the root of "schedule", while the last ancestor
 * is the parent of the specified location.
 * "child_pos" is an array of child positions of the same length as "ancestors",
 * where ancestor i (i > 0) appears in child_pos[i - 1] of ancestor i - 1 and
 * "tree" appears in child_pos[n - 1] of ancestor n - 1.
 * "tree" is the subtree at the specified location.
 *
 * Note that the same isl_schedule_tree object may appear several times
 * in a schedule tree and therefore does not uniquely identify a position
 * in the schedule tree.
 */
================================================================================

文件路径: ./isl_union_single.c
注释行数: 11
注释内容:
/*
 * Copyright 2010      INRIA Saclay
 * Copyright 2013      Ecole Normale Superieure
 *
 * Use of this software is governed by the MIT license
 *
 * Written by Sven Verdoolaege, INRIA Saclay - Ile-de-France,
 * Parc Club Orsay Universite, ZAC des vignes, 4 rue Jacques Monod,
 * 91893 Orsay, France
 * and Ecole Normale Superieure, 45 rue d'Ulm, 75230 Paris, France
 */
================================================================================

文件路径: ./pip.c
注释行数: 15
注释内容:
/* The input of this program is the same as that of the "example" program
 * from the PipLib distribution, except that the "big parameter column"
 * should always be -1.
 *
 * Context constraints in PolyLib format
 * -1
 * Problem constraints in PolyLib format
 * Optional list of options
 *
 * The options are
 *	Maximize	compute maximum instead of minimum
 *	Rational	compute rational optimum instead of integer optimum
 *	Urs_parms	don't assume parameters are non-negative
 *	Urs_unknowns	don't assume unknowns are non-negative
 */
================================================================================

文件路径: ./isl_stride.c
注释行数: 27
注释内容:
/* Set the stride and offset of data->pos to the given
 * value and expression.
 *
 * If we had already found a stride before, then the two strides
 * are combined into a single stride.
 *
 * In particular, if the new stride information is of the form
 *
 *	i = f + s (...)
 *
 * and the old stride information is of the form
 *
 *	i = f2 + s2 (...)
 *
 * then we compute the extended gcd of s and s2
 *
 *	a s + b s2 = g,
 *
 * with g = gcd(s,s2), multiply the first equation with t1 = b s2/g
 * and the second with t2 = a s1/g.
 * This results in
 *
 *	i = (b s2 + a s1)/g i = t1 f + t2 f2 + (s s2)/g (...)
 *
 * so that t1 f + t2 f2 is the combined offset and (s s2)/g = lcm(s,s2)
 * is the combined stride.
 */
================================================================================

文件路径: ./isl_stride.c
注释行数: 34
注释内容:
/* Check if constraint "c" imposes any stride on dimension data->pos
 * and, if so, update the stride information in "data".
 *
 * In order to impose a stride on the dimension, "c" needs to be an equality
 * and it needs to involve the dimension.  Note that "c" may also be
 * a div constraint and thus an inequality that we cannot use.
 *
 * Let c be of the form
 *
 *	h(p) + g * v * i + g * stride * f(alpha) = 0
 *
 * with h(p) an expression in terms of the parameters and other dimensions
 * and f(alpha) an expression in terms of the existentially quantified
 * variables.
 *
 * If "stride" is not zero and not one, then it represents a non-trivial stride
 * on "i".  We compute a and b such that
 *
 *	a v + b stride = 1
 *
 * We have
 *
 *	g v i = -h(p) + g stride f(alpha)
 *
 *	a g v i = -a h(p) + g stride f(alpha)
 *
 *	a g v i + b g stride i = -a h(p) + g stride * (...)
 *
 *	g i = -a h(p) + g stride * (...)
 *
 *	i = -a h(p)/g + stride * (...)
 *
 * The expression "-a h(p)/g" can therefore be used as offset.
 */
================================================================================

文件路径: ./isl_coalesce.c
注释行数: 21
注释内容:
/*
 * Copyright 2008-2009 Katholieke Universiteit Leuven
 * Copyright 2010      INRIA Saclay
 * Copyright 2012-2013 Ecole Normale Superieure
 * Copyright 2014      INRIA Rocquencourt
 * Copyright 2016      INRIA Paris
 * Copyright 2020      Cerebras Systems
 *
 * Use of this software is governed by the MIT license
 *
 * Written by Sven Verdoolaege, K.U.Leuven, Departement
 * Computerwetenschappen, Celestijnenlaan 200A, B-3001 Leuven, Belgium
 * and INRIA Saclay - Ile-de-France, Parc Club Orsay Universite,
 * ZAC des vignes, 4 rue Jacques Monod, 91893 Orsay, France 
 * and Ecole Normale Superieure, 45 rue d’Ulm, 75230 Paris, France
 * and Inria Paris - Rocquencourt, Domaine de Voluceau - Rocquencourt,
 * B.P. 105 - 78153 Le Chesnay, France
 * and Centre de Recherche Inria de Paris, 2 rue Simone Iff - Voie DQ12,
 * CS 42112, 75589 Paris Cedex 12, France
 * and Cerebras Systems, 175 S San Antonio Rd, Los Altos, CA, USA
 */
================================================================================

文件路径: ./isl_coalesce.c
注释行数: 21
注释内容:
/* Internal information associated to a basic map in a map
 * that is to be coalesced by isl_map_coalesce.
 *
 * "bmap" is the basic map itself (or NULL if "removed" is set)
 * "tab" is the corresponding tableau (or NULL if "removed" is set)
 * "hull_hash" identifies the affine space in which "bmap" lives.
 * "modified" is set if this basic map may not be identical
 * to any of the basic maps in the input.
 * "removed" is set if this basic map has been removed from the map
 * "simplify" is set if this basic map may have some unknown integer
 * divisions that were not present in the input basic maps.  The basic
 * map should then be simplified such that we may be able to find
 * a definition among the constraints.
 *
 * "eq" and "ineq" are only set if we are currently trying to coalesce
 * this basic map with another basic map, in which case they represent
 * the position of the inequalities of this basic map with respect to
 * the other basic map.  The number of elements in the "eq" array
 * is twice the number of equalities in the "bmap", corresponding
 * to the two inequalities that make up each equality.
 */
================================================================================

文件路径: ./isl_coalesce.c
注释行数: 21
注释内容:
/* Replace the pair of basic maps i and j by the basic map bounded
 * by the valid constraints in both basic maps and the constraints
 * in extra (if not NULL).
 * Place the fused basic map in the position that is the smallest of i and j.
 *
 * If "detect_equalities" is set, then look for equalities encoded
 * as pairs of inequalities.
 * If "check_number" is set, then the original basic maps are only
 * replaced if the total number of constraints does not increase.
 * While the number of integer divisions in the two basic maps
 * is assumed to be the same, the actual definitions may be different.
 * We only copy the definition from one of the basic map if it is
 * the same as that of the other basic map.  Otherwise, we mark
 * the integer division as unknown and simplify the basic map
 * in an attempt to recover the integer division definition.
 * If any extra constraints get introduced, then these may
 * involve integer divisions with a unit coefficient.
 * Eliminate those that do not appear with any other coefficient
 * in other constraints, to ensure they get eliminated completely,
 * improving the chances of further coalescing.
 */
================================================================================

文件路径: ./isl_coalesce.c
注释行数: 29
注释内容:
/* Given a pair of basic maps i and j such that all constraints are either
 * "valid" or "cut", check if the facets corresponding to the "cut"
 * constraints of i lie entirely within basic map j.
 * If so, replace the pair by the basic map consisting of the valid
 * constraints in both basic maps.
 * Checking whether the facet lies entirely within basic map j
 * is performed by checking whether the constraints of basic map j
 * are valid for the facet.  These tests are performed on a rational
 * tableau to avoid the theoretical possibility that a constraint
 * that was considered to be a cut constraint for the entire basic map i
 * happens to be considered to be a valid constraint for the facet,
 * even though it cuts off the same rational points.
 *
 * To see that we are not introducing any extra points, call the
 * two basic maps A and B and the resulting map U and let x
 * be an element of U \setminus ( A \cup B ).
 * A line connecting x with an element of A \cup B meets a facet F
 * of either A or B.  Assume it is a facet of B and let c_1 be
 * the corresponding facet constraint.  We have c_1(x) < 0 and
 * so c_1 is a cut constraint.  This implies that there is some
 * (possibly rational) point x' satisfying the constraints of A
 * and the opposite of c_1 as otherwise c_1 would have been marked
 * valid for A.  The line connecting x and x' meets a facet of A
 * in a (possibly rational) point that also violates c_1, but this
 * is impossible since all cut constraints of B are valid for all
 * cut facets of A.
 * In case F is a facet of A rather than B, then we can apply the
 * above reasoning to find a facet of B separating x from A \cup B first.
 */
================================================================================

文件路径: ./isl_coalesce.c
注释行数: 51
注释内容:
/* Basic map "i" has an inequality "k" that is adjacent
 * to some inequality of basic map "j".  All the other inequalities
 * are valid for "j".
 * If not NULL, then "extra" contains extra wrapping constraints that are valid
 * for both "i" and "j".
 * Check if basic map "j" forms an extension of basic map "i",
 * taking into account the extra constraints, if any.
 *
 * Note that this function is only called if some of the equalities or
 * inequalities of basic map "j" do cut basic map "i".  The function is
 * correct even if there are no such cut constraints, but in that case
 * the additional checks performed by this function are overkill.
 *
 * In particular, we replace constraint k, say f >= 0, by constraint
 * f <= -1, add the inequalities of "j" that are valid for "i",
 * as well as the "extra" constraints, if any,
 * and check if the result is a subset of basic map "j".
 * To improve the chances of the subset relation being detected,
 * any variable that only attains a single integer value
 * in the tableau of "i" is first fixed to that value.
 * If the result is a subset, then we know that this result is exactly equal
 * to basic map "j" since all its constraints are valid for basic map "j".
 * By combining the valid constraints of "i" (all equalities and all
 * inequalities except "k"), the valid constraints of "j" and
 * the "extra" constraints, if any, we therefore
 * obtain a basic map that is equal to their union.
 * In this case, there is no need to perform a rollback of the tableau
 * since it is going to be destroyed in fuse().
 *
 *
 *	|\__			|\__
 *	|   \__			|   \__
 *	|      \_	=>	|      \__
 *	|_______| _		|_________\
 *
 *
 *	|\			|\
 *	| \			| \
 *	|  \			|  \
 *	|  |			|   \
 *	|  ||\		=>      |    \
 *	|  || \			|     \
 *	|  ||  |		|      |
 *	|__||_/			|_____/
 *
 *
 *	_______			 _______
 *     |       | __		|       \__
 *     |       ||__|	=>	|        __|
 *     |_______|		|_______/
 */
================================================================================

文件路径: ./isl_coalesce.c
注释行数: 20
注释内容:
/* Given the compressed version of inequality constraint "ineq"
 * of info->bmap in "v", check if the constraint can be tightened,
 * where the compression is based on an equality constraint valid
 * for info->tab.
 * If so, add the tightened version of the inequality constraint
 * to info->tab.  "v" may be modified by this function.
 *
 * That is, if the compressed constraint is of the form
 *
 *	m f() + c >= 0
 *
 * with 0 < c < m, then it is equivalent to
 *
 *	f() >= 0
 *
 * This means that c can also be subtracted from the original,
 * uncompressed constraint without affecting the integer points
 * in info->tab.  Add this tightened constraint as an extra row
 * to info->tab to make this information explicitly available.
 */
================================================================================

文件路径: ./isl_coalesce.c
注释行数: 37
注释内容:
/* Tighten the (non-redundant) constraints on the facet represented
 * by info->tab.
 * In particular, on input, info->tab represents the result
 * of relaxing the "n" inequality constraints of info->bmap in "relaxed"
 * by one, i.e., replacing f_i >= 0 by f_i + 1 >= 0, and then
 * replacing the one at index "l" by the corresponding equality,
 * i.e., f_k + 1 = 0, with k = relaxed[l].
 *
 * Compute a variable compression from the equality constraint f_k + 1 = 0
 * and use it to tighten the other constraints of info->bmap
 * (that is, all constraints that have not been relaxed),
 * updating info->tab (and leaving info->bmap untouched).
 * The compression handles essentially two cases, one where a variable
 * is assigned a fixed value and can therefore be eliminated, and one
 * where one variable is a shifted multiple of some other variable and
 * can therefore be replaced by that multiple.
 * Gaussian elimination would also work for the first case, but for
 * the second case, the effectiveness would depend on the order
 * of the variables.
 * After compression, some of the constraints may have coefficients
 * with a common divisor.  If this divisor does not divide the constant
 * term, then the constraint can be tightened.
 * The tightening is performed on the tableau info->tab by introducing
 * extra (temporary) constraints.
 *
 * Only constraints that are possibly affected by the compression are
 * considered.  In particular, if the constraint only involves variables
 * that are directly mapped to a distinct set of other variables, then
 * no common divisor can be introduced and no tightening can occur.
 *
 * It is important to only consider the non-redundant constraints
 * since the facet constraint has been relaxed prior to the call
 * to this function, meaning that the constraints that were redundant
 * prior to the relaxation may no longer be redundant.
 * These constraints will be ignored in the fused result, so
 * the fusion detection should not exploit them.
 */
================================================================================

文件路径: ./isl_coalesce.c
注释行数: 11
注释内容:
/* Replace the basic maps "i" and "j" by an extension of "i"
 * along the "n" inequality constraints in "relax" by one.
 * The tableau info[i].tab has already been extended.
 * Extend info[i].bmap accordingly by relaxing all constraints in "relax"
 * by one.
 * Each integer division that does not have exactly the same
 * definition in "i" and "j" is marked unknown and the basic map
 * is scheduled to be simplified in an attempt to recover
 * the integer division definition.
 * Place the extension in the position that is the smallest of i and j.
 */
================================================================================

文件路径: ./isl_coalesce.c
注释行数: 44
注释内容:
/* Basic map "i" has "n" inequality constraints (collected in "relax")
 * that are such that they include basic map "j" if they are relaxed
 * by one.  All the other inequalities are valid for "j".
 * Check if basic map "j" forms an extension of basic map "i".
 *
 * In particular, relax the constraints in "relax", compute the corresponding
 * facets one by one and check whether each of these is included
 * in the other basic map.
 * Before testing for inclusion, the constraints on each facet
 * are tightened to increase the chance of an inclusion being detected.
 * (Adding the valid constraints of "j" to the tableau of "i", as is done
 * in is_adj_ineq_extension, may further increase those chances, but this
 * is not currently done.)
 * If each facet is included, we know that relaxing the constraints extends
 * the basic map with exactly the other basic map (we already know that this
 * other basic map is included in the extension, because all other
 * inequality constraints are valid of "j") and we can replace the
 * two basic maps by this extension.
 *
 * If any of the relaxed constraints turn out to be redundant, then bail out.
 * isl_tab_select_facet refuses to handle such constraints.  It may be
 * possible to handle them anyway by making a distinction between
 * redundant constraints with a corresponding facet that still intersects
 * the set (allowing isl_tab_select_facet to handle them) and
 * those where the facet does not intersect the set (which can be ignored
 * because the empty facet is trivially included in the other disjunct).
 * However, relaxed constraints that turn out to be redundant should
 * be fairly rare and no such instance has been reported where
 * coalescing would be successful.
 *        ____			  _____
 *       /    || 		 /     |
 *      /     ||  		/      |
 *      \     ||   	=>	\      |
 *       \    ||		 \     |
 *        \___||		  \____|
 *
 *
 *	 \			|\
 *	|\\			| \
 *	| \\			|  \
 *	|  |		=>	|  /
 *	| /			| /
 *	|/			|/
 */
================================================================================

文件路径: ./isl_coalesce.c
注释行数: 33
注释内容:
/* This function has two modes of operations.
 *
 * If "add_valid" is set, then all the constraints of info->bmap
 * (except the opposite of "bound") are valid for the other basic map.
 * In this case, attempts are made to wrap some of these valid constraints
 * to more tightly fit around "set".  Only successful wrappings are recorded
 * and failed wrappings are ignored.
 *
 * If "add_valid" is not set, then some of the constraints of info->bmap
 * are not valid for the other basic map, and only those are considered
 * for wrapping.  In this case all attempted wrappings need to succeed.
 * Otherwise "wraps" is marked as failed.
 * Note that the constraints that are valid for the other basic map
 * will be added to the combined basic map by default, so there is
 * no need to wrap them.
 * The caller wrap_in_facets even relies on this function not wrapping
 * any constraints that are already valid.
 *
 * Only consider constraints that are not redundant (as determined
 * by info->tab) and that are valid or invalid depending on "add_valid".
 * Wrap each constraint around "bound" such that it includes the whole
 * set "set" and append the resulting constraint to "wraps".
 * "wraps" is assumed to have been pre-allocated to the appropriate size.
 * wraps->n_row is the number of actual wrapped constraints that have
 * been added.
 * If any of the wrapping problems results in a constraint that is
 * identical to "bound", then this means that "set" is unbounded in such
 * a way that no wrapping is possible.
 * Similarly, if we want to bound the coefficients of the wrapping
 * constraints and a newly added wrapping constraint does not
 * satisfy the bound, then the wrapping is considered to have failed.
 * Note though that "wraps" is only marked failed if "add_valid" is not set.
 */
================================================================================

文件路径: ./isl_coalesce.c
注释行数: 20
注释内容:
/* For each constraint in info->bmap that is not redundant (as determined
 * by info->tab) and that is not a valid constraint for the other basic map,
 * wrap the constraint around "bound" such that it includes the whole
 * set "set" and append the resulting constraint to "wraps".
 * Note that the constraints that are valid for the other basic map
 * will be added to the combined basic map by default, so there is
 * no need to wrap them.
 * The caller wrap_in_facets even relies on this function not wrapping
 * any constraints that are already valid.
 * "wraps" is assumed to have been pre-allocated to the appropriate size.
 * wraps->n_row is the number of actual wrapped constraints that have
 * been added.
 * If any of the wrapping problems results in a constraint that is
 * identical to "bound", then this means that "set" is unbounded in such
 * a way that no wrapping is possible.  If this happens then "wraps"
 * is marked as failed.
 * Similarly, if we want to bound the coefficients of the wrapping
 * constraints and a newly added wrapping constraint does not
 * satisfy the bound, then "wraps" is also marked as failed.
 */
================================================================================

文件路径: ./isl_coalesce.c
注释行数: 16
注释内容:
/* Return a set that corresponds to the non-redundant constraints
 * (as recorded in tab) of bmap.
 *
 * It's important to remove the redundant constraints as some
 * of the other constraints may have been modified after the
 * constraints were marked redundant.
 * In particular, a constraint may have been relaxed.
 * Redundant constraints are ignored when a constraint is relaxed
 * and should therefore continue to be ignored ever after.
 * Otherwise, the relaxation might be thwarted by some of
 * these constraints.
 *
 * Update the underlying set to ensure that the dimension doesn't change.
 * Otherwise the integer divisions could get dropped if the tab
 * turns out to be empty.
 */
================================================================================

文件路径: ./isl_coalesce.c
注释行数: 25
注释内容:
/* Wrap some constraints of info->bmap that bound the facet defined
 * by inequality "k" around (the opposite of) this inequality to
 * include "set".  "bound" may be used to store the negated inequality.
 *
 * If "add_valid" is set, then all ridges are already valid and
 * the purpose is to wrap "set" more tightly.  In this case,
 * wrapping doesn't fail, although it is possible that no constraint
 * gets wrapped.
 *
 * If "add_valid" is not set, then some of the ridges are cut constraints
 * and only those are wrapped around "set".
 *
 * Since the wrapped constraints are not guaranteed to contain the whole
 * of info->bmap, we check them in check_wraps.
 * If any of the wrapped constraints turn out to be invalid, then
 * check_wraps will mark "wraps" as failed if "add_valid" is not set.
 * If "add_valid" is set, then the offending constraints are
 * simply removed.
 *
 * If any of the cut constraints of info->bmap turn out
 * to be redundant with respect to other constraints
 * then these will neither be wrapped nor added directly to the result.
 * The result may therefore not be correct.
 * Skip wrapping and mark "wraps" as failed in this case.
 */
================================================================================

文件路径: ./isl_coalesce.c
注释行数: 15
注释内容:
/* Basic map "i" has an inequality (say "k") that is adjacent
 * to some inequality of basic map "j".  All the other inequalities
 * are valid for "j".
 * Check if basic map "j" forms an extension of basic map "i".
 *
 * Note that this function is only called if some of the equalities or
 * inequalities of basic map "j" do cut basic map "i".  The function is
 * correct even if there are no such cut constraints, but in that case
 * the additional checks performed by this function are overkill.
 *
 * First try and wrap the ridges of "k" around "j".
 * Note that those ridges are already valid for "j",
 * but the wrapped versions may wrap "j" more tightly,
 * increasing the chances of "j" being detected as an extension of "i"
 */
================================================================================

文件路径: ./isl_coalesce.c
注释行数: 31
注释内容:
/* Both basic maps have at least one inequality with and adjacent
 * (but opposite) inequality in the other basic map.
 * Check that there are no cut constraints and that there is only
 * a single pair of adjacent inequalities.
 * If so, we can replace the pair by a single basic map described
 * by all but the pair of adjacent inequalities.
 * Any additional points introduced lie strictly between the two
 * adjacent hyperplanes and can therefore be integral.
 *
 *        ____			  _____
 *       /    ||\		 /     \
 *      /     || \		/       \
 *      \     ||  \	=>	\        \
 *       \    ||  /		 \       /
 *        \___||_/		  \_____/
 *
 * The test for a single pair of adjacent inequalities is important
 * for avoiding the combination of two basic maps like the following
 *
 *       /|
 *      / |
 *     /__|
 *         _____
 *         |   |
 *         |   |
 *         |___|
 *
 * If there are some cut constraints on one side, then we may
 * still be able to fuse the two basic maps, but we need to perform
 * some additional checks in is_adj_ineq_extension.
 */
================================================================================

文件路径: ./isl_coalesce.c
注释行数: 21
注释内容:
/* Given a basic set i with a constraint k that is adjacent to
 * basic set j, check if we can wrap
 * both the facet corresponding to k (if "wrap_facet" is set) and basic map j
 * (always) around their ridges to include the other set.
 * If so, replace the pair of basic sets by their union.
 *
 * All constraints of i (except k) are assumed to be valid or
 * cut constraints for j.
 * Wrapping the cut constraints to include basic map j may result
 * in constraints that are no longer valid of basic map i
 * we have to check that the resulting wrapping constraints are valid for i.
 * If "wrap_facet" is not set, then all constraints of i (except k)
 * are assumed to be valid for j.
 *        ____			  _____
 *       /    | 		 /     \
 *      /     ||  		/      |
 *      \     ||   	=>	\      |
 *       \    ||		 \     |
 *        \___||		  \____|
 *
 */
================================================================================

文件路径: ./isl_coalesce.c
注释行数: 21
注释内容:
/* Given a cut constraint t(x) >= 0 of basic map i, stored in row "w"
 * of wrap.mat, replace it by its relaxed version t(x) + 1 >= 0, and
 * add wrapping constraints to wrap.mat for all constraints
 * of basic map j that bound the part of basic map j that sticks out
 * of the cut constraint.
 * "set_i" is the underlying set of basic map i.
 * If any wrapping fails, then wraps->mat.n_row is reset to zero.
 *
 * In particular, we first intersect basic map j with t(x) + 1 = 0.
 * If the result is empty, then t(x) >= 0 was actually a valid constraint
 * (with respect to the integer points), so we add t(x) >= 0 instead.
 * Otherwise, we wrap the constraints of basic map j that are not
 * redundant in this intersection and that are not already valid
 * for basic map i over basic map i.
 * Note that it is sufficient to wrap the constraints to include
 * basic map i, because we will only wrap the constraints that do
 * not include basic map i already.  The wrapped constraint will
 * therefore be more relaxed compared to the original constraint.
 * Since the original constraint is valid for basic map j, so is
 * the wrapped constraint.
 */
================================================================================

文件路径: ./isl_coalesce.c
注释行数: 17
注释内容:
/* Given a pair of basic maps i and j such that j sticks out
 * of i at n cut constraints, each time by at most one,
 * try to compute wrapping constraints and replace the two
 * basic maps by a single basic map.
 * The other constraints of i are assumed to be valid for j.
 * "set_i" is the underlying set of basic map i.
 * "wraps" has been initialized to be of the right size.
 *
 * For each cut constraint t(x) >= 0 of i, we add the relaxed version
 * t(x) + 1 >= 0, along with wrapping constraints for all constraints
 * of basic map j that bound the part of basic map j that sticks out
 * of the cut constraint.
 *
 * If any wrapping fails, i.e., if we cannot wrap to touch
 * the union, then we give up.
 * Otherwise, the pair of basic maps is replaced by their union.
 */
================================================================================

文件路径: ./isl_coalesce.c
注释行数: 11
注释内容:
/* Given a pair of basic maps i and j such that j sticks out
 * of i at n cut constraints, each time by at most one,
 * try to compute wrapping constraints and replace the two
 * basic maps by a single basic map.
 * The other constraints of i are assumed to be valid for j.
 *
 * The core computation is performed by try_wrap_in_facets.
 * This function simply extracts an underlying set representation
 * of basic map i and initializes the data structure for keeping
 * track of wrapping constraints.
 */
================================================================================

文件路径: ./isl_coalesce.c
注释行数: 59
注释内容:
/* Given two basic sets i and j,
 * check if relaxing all the cut constraints of i by one turns
 * them into valid constraint for j and check if we can wrap in
 * the bits that are sticking out.
 * If so, replace the pair by their union.
 *
 * We first check if all relaxed cut inequalities of i are valid for j
 * and then try to wrap in the intersections of the relaxed cut inequalities
 * with j.
 *
 * During this wrapping, we consider the points of j that lie at a distance
 * of exactly 1 from i.  In particular, we ignore the points that lie in
 * between this lower-dimensional space and the basic map i.
 * We can therefore only apply this to integer maps.
 *        ____			  _____
 *       / ___|_		 /     \
 *      / |    |  		/      |
 *      \ |    |   	=>	\      |
 *       \|____|		 \     |
 *        \___| 		  \____/
 *
 *	 _____			 ______
 *	| ____|_		|      \
 *	| |     |		|       |
 *	| |	|	=>	|       |
 *	|_|     |		|       |
 *	  |_____|		 \______|
 *
 *	 _______
 *	|       |
 *	|  |\   |
 *	|  | \  |
 *	|  |  \ |
 *	|  |   \|
 *	|  |    \
 *	|  |_____\
 *	|       |
 *	|_______|
 *
 * Wrapping can fail if the result of wrapping one of the facets
 * around its edges does not produce any new facet constraint.
 * In particular, this happens when we try to wrap in unbounded sets.
 *
 *	 _______________________________________________________________________
 *	|
 *	|  ___
 *	| |   |
 *	|_|   |_________________________________________________________________
 *	  |___|
 *
 * The following is not an acceptable result of coalescing the above two
 * sets as it includes extra integer points.
 *	 _______________________________________________________________________
 *	|
 *	|     
 *	|      
 *	|
 *	 \______________________________________________________________________
 */
================================================================================

文件路径: ./isl_coalesce.c
注释行数: 16
注释内容:
/* Given two basic maps such that "j" has at least one equality constraint
 * that is adjacent to an inequality constraint of "i" and such that "i" has
 * exactly one inequality constraint that is adjacent to an equality
 * constraint of "j", check whether "i" can be extended to include "j" or
 * whether "j" can be wrapped into "i".
 * All remaining constraints of "i" and "j" are assumed to be valid
 * or cut constraints of the other basic map.
 * However, none of the equality constraints of "i" are cut constraints.
 *
 * If "i" has any "cut" inequality constraints, then check if relaxing
 * each of them by one is sufficient for them to become valid.
 * If so, check if the inequality constraint adjacent to an equality
 * constraint of "j" along with all these cut constraints
 * can be relaxed by one to contain exactly "j".
 * Otherwise, or if this fails, check if "j" can be wrapped into "i".
 */
================================================================================

文件路径: ./isl_coalesce.c
注释行数: 10
注释内容:
/* At least one of the basic maps has an equality that is adjacent
 * to an inequality.  Make sure that only one of the basic maps has
 * such an equality and that the other basic map has exactly one
 * inequality adjacent to an equality.
 * If the other basic map does not have such an inequality, then
 * check if all its constraints are either valid or cut constraints
 * and, if so, try wrapping in the first map into the second.
 * Otherwise, try to extend one basic map with the other or
 * wrap one basic map in the other.
 */
================================================================================

文件路径: ./isl_coalesce.c
注释行数: 12
注释内容:
/* Disjunct "j" lies on a hyperplane that is adjacent to disjunct "i".
 * In particular, disjunct "i" has an inequality constraint that is adjacent
 * to a (combination of) equality constraint(s) of disjunct "j",
 * but disjunct "j" has no explicit equality constraint adjacent
 * to an inequality constraint of disjunct "i".
 *
 * Disjunct "i" is already known not to have any equality constraints
 * that are adjacent to an equality or inequality constraint.
 * Check that, other than the inequality constraint mentioned above,
 * all other constraints of disjunct "i" are valid for disjunct "j".
 * If so, try and wrap in disjunct "j".
 */
================================================================================

文件路径: ./isl_coalesce.c
注释行数: 18
注释内容:
/* The two basic maps lie on adjacent hyperplanes.  In particular,
 * basic map "i" has an equality that lies parallel to basic map "j".
 * Check if we can wrap the facets around the parallel hyperplanes
 * to include the other set.
 *
 * We perform basically the same operations as can_wrap_in_facet,
 * except that we don't need to select a facet of one of the sets.
 *				_
 *	\\			\\
 *	 \\		=>	 \\
 *	  \			  \|
 *
 * If there is more than one equality of "i" adjacent to an equality of "j",
 * then the result will satisfy one or more equalities that are a linear
 * combination of these equalities.  These will be encoded as pairs
 * of inequalities in the wrapping constraints and need to be made
 * explicit.
 */
================================================================================

文件路径: ./isl_coalesce.c
注释行数: 12
注释内容:
/* Basic map "i" has one or more equality constraints that separate it
 * from basic map "j".  Check if it happens to be an extension
 * of basic map "j".
 * In particular, check that all constraints of "j" are valid for "i",
 * except for one inequality constraint that is adjacent
 * to an inequality constraints of "i".
 * If so, check for "i" being an extension of "j" by calling
 * is_adj_ineq_extension.
 *
 * Clean up the memory allocated for keeping track of the status
 * of the constraints before returning.
 */
================================================================================

文件路径: ./isl_coalesce.c
注释行数: 86
注释内容:
/* Check if the union of the given pair of basic maps
 * can be represented by a single basic map.
 * If so, replace the pair by the single basic map and return
 * isl_change_drop_first, isl_change_drop_second or isl_change_fuse.
 * Otherwise, return isl_change_none.
 * The two basic maps are assumed to live in the same local space.
 * The "eq" and "ineq" fields of info[i] and info[j] are assumed
 * to have been initialized by the caller, either to NULL or
 * to valid information.
 *
 * We first check the effect of each constraint of one basic map
 * on the other basic map.
 * The constraint may be
 *	redundant	the constraint is redundant in its own
 *			basic map and should be ignore and removed
 *			in the end
 *	valid		all (integer) points of the other basic map
 *			satisfy the constraint
 *	separate	no (integer) point of the other basic map
 *			satisfies the constraint
 *	cut		some but not all points of the other basic map
 *			satisfy the constraint
 *	adj_eq		the given constraint is adjacent (on the outside)
 *			to an equality of the other basic map
 *	adj_ineq	the given constraint is adjacent (on the outside)
 *			to an inequality of the other basic map
 *
 * We consider seven cases in which we can replace the pair by a single
 * basic map.  We ignore all "redundant" constraints.
 *
 *	1. all constraints of one basic map are valid
 *		=> the other basic map is a subset and can be removed
 *
 *	2. all constraints of both basic maps are either "valid" or "cut"
 *	   and the facets corresponding to the "cut" constraints
 *	   of one of the basic maps lies entirely inside the other basic map
 *		=> the pair can be replaced by a basic map consisting
 *		   of the valid constraints in both basic maps
 *
 *	3. there is a single pair of adjacent inequalities
 *	   (all other constraints are "valid")
 *		=> the pair can be replaced by a basic map consisting
 *		   of the valid constraints in both basic maps
 *
 *	4. one basic map has a single adjacent inequality, while the other
 *	   constraints are "valid".  The other basic map has some
 *	   "cut" constraints, but replacing the adjacent inequality by
 *	   its opposite and adding the valid constraints of the other
 *	   basic map results in a subset of the other basic map
 *		=> the pair can be replaced by a basic map consisting
 *		   of the valid constraints in both basic maps
 *
 *	5. there is a single adjacent pair of an inequality and an equality,
 *	   the other constraints of the basic map containing the inequality are
 *	   "valid".  Moreover, if the inequality the basic map is relaxed
 *	   and then turned into an equality, then resulting facet lies
 *	   entirely inside the other basic map
 *		=> the pair can be replaced by the basic map containing
 *		   the inequality, with the inequality relaxed.
 *
 *	6. there is a single inequality adjacent to an equality,
 *	   the other constraints of the basic map containing the inequality are
 *	   "valid".  Moreover, the facets corresponding to both
 *	   the inequality and the equality can be wrapped around their
 *	   ridges to include the other basic map
 *		=> the pair can be replaced by a basic map consisting
 *		   of the valid constraints in both basic maps together
 *		   with all wrapping constraints
 *
 *	7. one of the basic maps extends beyond the other by at most one.
 *	   Moreover, the facets corresponding to the cut constraints and
 *	   the pieces of the other basic map at offset one from these cut
 *	   constraints can be wrapped around their ridges to include
 *	   the union of the two basic maps
 *		=> the pair can be replaced by a basic map consisting
 *		   of the valid constraints in both basic maps together
 *		   with all wrapping constraints
 *
 *	8. the two basic maps live in adjacent hyperplanes.  In principle
 *	   such sets can always be combined through wrapping, but we impose
 *	   that there is only one such pair, to avoid overeager coalescing.
 *
 * Throughout the computation, we maintain a collection of tableaus
 * corresponding to the basic maps.  When the basic maps are dropped
 * or combined, the tableaus are modified accordingly.
 */
================================================================================

文件路径: ./isl_coalesce.c
注释行数: 11
注释内容:
/* Shift the integer division at position "div" of the basic map
 * represented by "info" by "shift".
 *
 * That is, if the integer division has the form
 *
 *	floor(f(x)/d)
 *
 * then replace it by
 *
 *	floor((f(x) + shift * d)/d) - shift
 */
================================================================================

文件路径: ./isl_coalesce.c
注释行数: 29
注释内容:
/* If the integer division at position "div" is defined by an equality,
 * i.e., a stride constraint, then change the integer division expression
 * to have a constant term equal to zero.
 *
 * Let the equality constraint be
 *
 *	c + f + m a = 0
 *
 * The integer division expression is then typically of the form
 *
 *	a = floor((-f - c')/m)
 *
 * The integer division is first shifted by t = floor(c/m),
 * turning the equality constraint into
 *
 *	c - m floor(c/m) + f + m a' = 0
 *
 * i.e.,
 *
 *	(c mod m) + f + m a' = 0
 *
 * That is,
 *
 *	a' = (-f - (c mod m))/m = floor((-f)/m)
 *
 * because a' is an integer and 0 <= (c mod m) < m.
 * The constant term of a' can therefore be zeroed out,
 * but only if the integer division expression is of the expected form.
 */
================================================================================

文件路径: ./isl_coalesce.c
注释行数: 12
注释内容:
/* The basic maps represented by "info1" and "info2" are known
 * to have the same number of integer divisions.
 * Check if pairs of integer divisions are equal to each other
 * despite the fact that they differ by a rational constant.
 *
 * In particular, look for any pair of integer divisions that
 * only differ in their constant terms.
 * If either of these integer divisions is defined
 * by stride constraints, then modify it to have a zero constant term.
 * If both are defined by stride constraints then in the end they will have
 * the same (zero) constant term.
 */
================================================================================

文件路径: ./isl_coalesce.c
注释行数: 13
注释内容:
/* If "shift" is an integer constant, then shift the integer division
 * at position "div" of the basic map represented by "info" by "shift".
 * If "shift" is not an integer constant, then do nothing.
 * If "shift" is equal to zero, then no shift needs to be performed either.
 *
 * That is, if the integer division has the form
 *
 *	floor(f(x)/d)
 *
 * then replace it by
 *
 *	floor((f(x) + shift * d)/d) - shift
 */
================================================================================

文件路径: ./isl_coalesce.c
注释行数: 33
注释内容:
/* Check if some of the divs in the basic map represented by "info1"
 * are shifts of the corresponding divs in the basic map represented
 * by "info2", taking into account the equality constraints "eq1" of "info1"
 * and "eq2" of "info2".  If so, align them with those of "info2".
 * "info1" and "info2" are assumed to have the same number
 * of integer divisions.
 *
 * An integer division is considered to be a shift of another integer
 * division if, after simplification with respect to the equality
 * constraints of the other basic map, one is equal to the other
 * plus a constant.
 *
 * In particular, for each pair of integer divisions, if both are known,
 * have the same denominator and are not already equal to each other,
 * simplify each with respect to the equality constraints
 * of the other basic map.  If the difference is an integer constant,
 * then move this difference outside.
 * That is, if, after simplification, one integer division is of the form
 *
 *	floor((f(x) + c_1)/d)
 *
 * while the other is of the form
 *
 *	floor((f(x) + c_2)/d)
 *
 * and n = (c_2 - c_1)/d is an integer, then replace the first
 * integer division by
 *
 *	floor((f_1(x) + c_1 + n * d)/d) - n,
 *
 * where floor((f_1(x) + c_1 + n * d)/d) = floor((f2(x) + c_2)/d)
 * after simplification with respect to the equality constraints.
 */
================================================================================

文件路径: ./isl_coalesce.c
注释行数: 23
注释内容:
/* Check if some of the divs in the basic map represented by "info1"
 * are shifts of the corresponding divs in the basic map represented
 * by "info2".  If so, align them with those of "info2".
 * Only do this if "info1" and "info2" have the same number
 * of integer divisions.
 *
 * An integer division is considered to be a shift of another integer
 * division if, after simplification with respect to the equality
 * constraints of the other basic map, one is equal to the other
 * plus a constant.
 *
 * First check if pairs of integer divisions are equal to each other
 * despite the fact that they differ by a rational constant.
 * If so, try and arrange for them to have the same constant term.
 *
 * Then, extract the equality constraints and continue with
 * harmonize_divs_with_hulls.
 *
 * If the equality constraints of both basic maps are the same,
 * then there is no need to perform any shifting since
 * the coefficients of the integer divisions should have been
 * reduced in the same way.
 */
================================================================================

文件路径: ./isl_coalesce.c
注释行数: 27
注释内容:
/* For each of the "n" integer division variables "expanded",
 * if the variable has a fixed value, then add two inequality
 * constraints expressing the fixed value.
 * Otherwise, add the corresponding div constraints.
 * The caller is responsible for removing the div constraints
 * that it added for all these "n" integer divisions.
 *
 * The div constraints and the pair of inequality constraints
 * forcing the fixed value cannot both be added for a given variable
 * as the combination may render some of the original constraints redundant.
 * These would then be ignored during the coalescing detection,
 * while they could remain in the fused result.
 *
 * The two added inequality constraints are
 *
 *	-a + v >= 0
 *	a - v >= 0
 *
 * with "a" the variable and "v" its fixed value.
 * The facet corresponding to one of these two constraints is selected
 * in the tableau to ensure that the pair of inequality constraints
 * is treated as an equality constraint.
 *
 * The information in info->ineq is thrown away because it was
 * computed in terms of div constraints, while some of those
 * have now been replaced by these pairs of inequality constraints.
 */
================================================================================

文件路径: ./isl_coalesce.c
注释行数: 30
注释内容:
/* Insert the "n" integer division variables "expanded"
 * into info->tab and info->bmap and
 * update info->ineq with respect to the redundant constraints
 * in the resulting tableau.
 * "bmap" contains the result of this insertion in info->bmap,
 * while info->bmap is the original version
 * of "bmap", i.e., the one that corresponds to the current
 * state of info->tab.  The number of constraints in info->bmap
 * is assumed to be the same as the number of constraints
 * in info->tab.  This is required to be able to detect
 * the extra constraints in "bmap".
 *
 * In particular, introduce extra variables corresponding
 * to the extra integer divisions and add the div constraints
 * that were added to "bmap" after info->tab was created
 * from info->bmap.
 * Furthermore, check if these extra integer divisions happen
 * to attain a fixed integer value in info->tab.
 * If so, replace the corresponding div constraints by pairs
 * of inequality constraints that fix these
 * integer divisions to their single integer values.
 * Replace info->bmap by "bmap" to match the changes to info->tab.
 * info->ineq was computed without a tableau and therefore
 * does not take into account the redundant constraints
 * in the tableau.  Mark them here.
 * There is no need to check the newly added div constraints
 * since they cannot be redundant.
 * The redundancy check is not performed when constants have been discovered
 * since info->ineq is completely thrown away in this case.
 */
================================================================================

文件路径: ./isl_coalesce.c
注释行数: 13
注释内容:
/* Expand info->tab and info->bmap in the same way "bmap" was expanded
 * in isl_basic_map_expand_divs using the expansion "exp" and
 * update info->ineq with respect to the redundant constraints
 * in the resulting tableau. info->bmap is the original version
 * of "bmap", i.e., the one that corresponds to the current
 * state of info->tab.  The number of constraints in info->bmap
 * is assumed to be the same as the number of constraints
 * in info->tab.  This is required to be able to detect
 * the extra constraints in "bmap".
 *
 * Extract the positions where extra local variables are introduced
 * from "exp" and call tab_insert_divs.
 */
================================================================================

文件路径: ./isl_coalesce.c
注释行数: 30
注释内容:
/* Check if the union of the basic maps represented by info[i] and info[j]
 * can be represented by a single basic map,
 * after expanding the divs of info[i] to match those of info[j].
 * If so, replace the pair by the single basic map and return
 * isl_change_drop_first, isl_change_drop_second or isl_change_fuse.
 * Otherwise, return isl_change_none.
 *
 * The caller has already checked for info[j] being a subset of info[i].
 * If some of the divs of info[j] are unknown, then the expanded info[i]
 * will not have the corresponding div constraints.  The other patterns
 * therefore cannot apply.  Skip the computation in this case.
 *
 * The expansion is performed using the divs "div" and expansion "exp"
 * computed by the caller.
 * info[i].bmap has already been expanded and the result is passed in
 * as "bmap".
 * The "eq" and "ineq" fields of info[i] reflect the status of
 * the constraints of the expanded "bmap" with respect to info[j].tab.
 * However, inequality constraints that are redundant in info[i].tab
 * have not yet been marked as such because no tableau was available.
 *
 * Replace info[i].bmap by "bmap" and expand info[i].tab as well,
 * updating info[i].ineq with respect to the redundant constraints.
 * Then try and coalesce the expanded info[i] with info[j],
 * reusing the information in info[i].eq and info[i].ineq.
 * If this does not result in any coalescing or if it results in info[j]
 * getting dropped (which should not happen in practice, since the case
 * of info[j] being a subset of info[i] has already been checked by
 * the caller), then revert info[i] to its original state.
 */
================================================================================

文件路径: ./isl_coalesce.c
注释行数: 24
注释内容:
/* Check if the union of "bmap" and the basic map represented by info[j]
 * can be represented by a single basic map,
 * after expanding the divs of "bmap" to match those of info[j].
 * If so, replace the pair by the single basic map and return
 * isl_change_drop_first, isl_change_drop_second or isl_change_fuse.
 * Otherwise, return isl_change_none.
 *
 * In particular, check if the expanded "bmap" contains the basic map
 * represented by the tableau info[j].tab.
 * The expansion is performed using the divs "div" and expansion "exp"
 * computed by the caller.
 * Then we check if all constraints of the expanded "bmap" are valid for
 * info[j].tab.
 *
 * If "i" is not equal to -1, then "bmap" is equal to info[i].bmap.
 * In this case, the positions of the constraints of info[i].bmap
 * with respect to the basic map represented by info[j] are stored
 * in info[i].
 *
 * If the expanded "bmap" does not contain the basic map
 * represented by the tableau info[j].tab and if "i" is not -1,
 * i.e., if the original "bmap" is info[i].bmap, then expand info[i].tab
 * as well and check if that results in coalescing.
 */
================================================================================

文件路径: ./isl_coalesce.c
注释行数: 18
注释内容:
/* Check if the union of "bmap_i" and the basic map represented by info[j]
 * can be represented by a single basic map,
 * after aligning the divs of "bmap_i" to match those of info[j].
 * If so, replace the pair by the single basic map and return
 * isl_change_drop_first, isl_change_drop_second or isl_change_fuse.
 * Otherwise, return isl_change_none.
 *
 * In particular, check if "bmap_i" contains the basic map represented by
 * info[j] after aligning the divs of "bmap_i" to those of info[j].
 * Note that this can only succeed if the number of divs of "bmap_i"
 * is smaller than (or equal to) the number of divs of info[j].
 *
 * We first check if the divs of "bmap_i" are all known and form a subset
 * of those of info[j].bmap.  If so, we pass control over to
 * coalesce_with_expanded_divs.
 *
 * If "i" is not equal to -1, then "bmap" is equal to info[i].bmap.
 */
================================================================================

文件路径: ./isl_coalesce.c
注释行数: 17
注释内容:
/* Check if basic map "j" is a subset of basic map "i" after
 * exploiting the extra equalities of "j" to simplify the divs of "i".
 * If so, remove basic map "j" and return isl_change_drop_second.
 *
 * If "j" does not have any equalities or if they are the same
 * as those of "i", then we cannot exploit them to simplify the divs.
 * Similarly, if there are no divs in "i", then they cannot be simplified.
 * If, on the other hand, the affine hulls of "i" and "j" do not intersect,
 * then "j" cannot be a subset of "i".
 *
 * Otherwise, we intersect "i" with the affine hull of "j" and then
 * check if "j" is a subset of the result after aligning the divs.
 * If so, then "j" is definitely a subset of "i" and can be removed.
 * Note that if after intersection with the affine hull of "j".
 * "i" still has more divs than "j", then there is no way we can
 * align the divs of "i" to those of "j".
 */
================================================================================

文件路径: ./isl_coalesce.c
注释行数: 15
注释内容:
/* Check if the union of and the basic maps represented by info[i] and info[j]
 * can be represented by a single basic map, by aligning or equating
 * their integer divisions.
 * If so, replace the pair by the single basic map and return
 * isl_change_drop_first, isl_change_drop_second or isl_change_fuse.
 * Otherwise, return isl_change_none.
 *
 * Note that we only perform any test if the number of divs is different
 * in the two basic maps.  In case the number of divs is the same,
 * we have already established that the divs are different
 * in the two basic maps.
 * In particular, if the number of divs of basic map i is smaller than
 * the number of divs of basic map j, then we check if j is a subset of i
 * and vice versa.
 */
================================================================================

文件路径: ./isl_coalesce.c
注释行数: 11
注释内容:
/* Return a list of affine expressions, one for each integer division
 * in "bmap_i".  For each integer division that also appears in "bmap_j",
 * the affine expression is set to NaN.  The number of NaNs in the list
 * is equal to the number of integer divisions in "bmap_j".
 * For the other integer divisions of "bmap_i", the corresponding
 * element in the list is a purely affine expression equal to the integer
 * division in "hull".
 * If no such list can be constructed, then the number of elements
 * in the returned list is smaller than the number of integer divisions
 * in "bmap_i".
 */
================================================================================

文件路径: ./isl_coalesce.c
注释行数: 16
注释内容:
/* Add variables to info->bmap and info->tab corresponding to the elements
 * in "list" that are not set to NaN.
 * "extra_var" is the number of these elements.
 * "dim" is the offset in the variables of "tab" where we should
 * start considering the elements in "list".
 * When this function returns, the total number of variables in "tab"
 * is equal to "dim" plus the number of elements in "list".
 *
 * The newly added existentially quantified variables are not given
 * an explicit representation because the corresponding div constraints
 * do not appear in info->bmap.  These constraints are not added
 * to info->bmap because for internal consistency, they would need to
 * be added to info->tab as well, where they could combine with the equality
 * that is added later to result in constraints that do not hold
 * in the original input.
 */
================================================================================

文件路径: ./isl_coalesce.c
注释行数: 13
注释内容:
/* Coalesce basic map "j" into basic map "i" after adding the extra integer
 * divisions in "i" but not in "j" to basic map "j", with values
 * specified by "list".  The total number of elements in "list"
 * is equal to the number of integer divisions in "i", while the number
 * of NaN elements in the list is equal to the number of integer divisions
 * in "j".
 *
 * If no coalescing can be performed, then we need to revert basic map "j"
 * to its original state.  We do the same if basic map "i" gets dropped
 * during the coalescing, even though this should not happen in practice
 * since we have already checked for "j" being a subset of "i"
 * before we reach this stage.
 */
================================================================================

文件路径: ./isl_coalesce.c
注释行数: 14
注释内容:
/* Check if we can coalesce basic map "j" into basic map "i" after copying
 * those extra integer divisions in "i" that can be simplified away
 * using the extra equalities in "j".
 * All divs are assumed to be known and not contain any nested divs.
 *
 * We first check if there are any extra equalities in "j" that we
 * can exploit.  Then we check if every integer division in "i"
 * either already appears in "j" or can be simplified using the
 * extra equalities to a purely affine expression.
 * If these tests succeed, then we try to coalesce the two basic maps
 * by introducing extra dimensions in "j" corresponding to
 * the extra integer divisions "i" fixed to the corresponding
 * purely affine expression.
 */
================================================================================

文件路径: ./isl_coalesce.c
注释行数: 20
注释内容:
/* Check if the union of the given pair of basic maps
 * can be represented by a single basic map.
 * If so, replace the pair by the single basic map and return
 * isl_change_drop_first, isl_change_drop_second or isl_change_fuse.
 * Otherwise, return isl_change_none.
 *
 * We first check if the two basic maps live in the same local space,
 * after aligning the divs that differ by only an integer constant.
 * If so, we do the complete check.  Otherwise, we check if they have
 * the same number of integer divisions and can be coalesced, if one is
 * an obvious subset of the other or if the extra integer divisions
 * of one basic map can be simplified away using the extra equalities
 * of the other basic map.
 *
 * Note that trying to coalesce pairs of disjuncts with the same
 * number, but different local variables may drop the explicit
 * representation of some of these local variables.
 * This operation is therefore not performed when
 * the "coalesce_preserve_locals" option is set.
 */
================================================================================

文件路径: ./isl_coalesce.c
注释行数: 14
注释内容:
/* Pairwise coalesce the basic maps in the range [start1, end1[ of "info"
 * with those in the range [start2, end2[, skipping basic maps
 * that have been removed (either before or within this function).
 *
 * For each basic map i in the first range, we check if it can be coalesced
 * with respect to any previously considered basic map j in the second range.
 * If i gets dropped (because it was a subset of some j), then
 * we can move on to the next basic map.
 * If j gets dropped, we need to continue checking against the other
 * previously considered basic maps.
 * If the two basic maps got fused, then we recheck the fused basic map
 * against the previously considered basic maps, starting at i + 1
 * (even if start2 is greater than i + 1).
 */
================================================================================

文件路径: ./isl_coalesce.c
注释行数: 12
注释内容:
/* Update the basic maps in "map" based on the information in "info".
 * In particular, remove the basic maps that have been marked removed and
 * update the others based on the information in the corresponding tableau.
 * Since we detected implicit equalities without calling
 * isl_basic_map_gauss, we need to do it now.
 * Also call isl_basic_map_simplify if we may have lost the definition
 * of one or more integer divisions.
 * If a basic map is still equal to the one from which the corresponding "info"
 * entry was created, then redundant constraint and
 * implicit equality constraint detection have been performed
 * on the corresponding tableau and the basic map can be marked as such.
 */
================================================================================

文件路径: ./isl_coalesce.c
注释行数: 25
注释内容:
/* For each pair of basic maps in the map, check if the union of the two
 * can be represented by a single basic map.
 * If so, replace the pair by the single basic map and start over.
 *
 * We factor out any (hidden) common factor from the constraint
 * coefficients to improve the detection of adjacent constraints.
 * Note that this function does not call isl_basic_map_gauss,
 * but it does make sure that only a single copy of the basic map
 * is affected.  This means that isl_basic_map_gauss may have
 * to be called at the end of the computation (in update_basic_maps)
 * on this single copy to ensure that
 * the basic maps are not left in an unexpected state.
 *
 * Since we are constructing the tableaus of the basic maps anyway,
 * we exploit them to detect implicit equalities and redundant constraints.
 * This also helps the coalescing as it can ignore the redundant constraints.
 * In order to avoid confusion, we make all implicit equalities explicit
 * in the basic maps.  If the basic map only has a single reference
 * (this happens in particular if it was modified by
 * isl_basic_map_reduce_coefficients), then isl_basic_map_gauss
 * does not get called on the result.  The call to
 * isl_basic_map_gauss in update_basic_maps resolves this as well.
 * For each basic map, we also compute the hash of the apparent affine hull
 * for use in coalesce.
 */
================================================================================

文件路径: ./isl_pw_templ.c
注释行数: 12
注释内容:
/*
 * Copyright 2010-2011 INRIA Saclay
 * Copyright 2011      Sven Verdoolaege
 * Copyright 2012-2014 Ecole Normale Superieure
 *
 * Use of this software is governed by the MIT license
 *
 * Written by Sven Verdoolaege, INRIA Saclay - Ile-de-France,
 * Parc Club Orsay Universite, ZAC des vignes, 4 rue Jacques Monod,
 * 91893 Orsay, France
 * and Ecole Normale Superieure, 45 rue d’Ulm, 75230 Paris, France
 */
================================================================================

文件路径: ./isl_pw_templ.c
注释行数: 11
注释内容:
/* Return the base expression associated to
 * the cell at position "pos" in "pw".
 * This may be either a copy or the base expression itself
 * if there is only one reference to "pw".
 * This allows the base expression to be modified inplace
 * if both the piecewise expression and this base expression
 * have only a single reference.
 * The caller is not allowed to modify "pw" between this call and
 * a subsequent call to isl_pw_*_restore_*.
 * The only exception is that isl_pw_*_free can be called instead.
 */
================================================================================

文件路径: ./isl_union_multi.c
注释行数: 14
注释内容:
/*
 * Copyright 2010      INRIA Saclay
 * Copyright 2013      Ecole Normale Superieure
 * Copyright 2015      INRIA Paris-Rocquencourt
 *
 * Use of this software is governed by the MIT license
 *
 * Written by Sven Verdoolaege, INRIA Saclay - Ile-de-France,
 * Parc Club Orsay Universite, ZAC des vignes, 4 rue Jacques Monod,
 * 91893 Orsay, France
 * and Ecole Normale Superieure, 45 rue d'Ulm, 75230 Paris, France
 * and INRIA Paris-Rocquencourt, Domaine de Voluceau, Rocquenqourt, B.P. 105,
 * 78153 Le Chesnay Cedex France
 */
================================================================================

文件路径: ./isl_union_multi.c
注释行数: 10
注释内容:
/* Return the entry, if any, in "u" that lives in "space".
 * If "reserve" is set, then an entry is created if it does not exist yet.
 * Return NULL on error and isl_hash_table_entry_none if no entry was found.
 * Note that when "reserve" is set, the function will never return
 * isl_hash_table_entry_none.
 *
 * First look for the group of expressions with the same domain space,
 * creating one if needed.
 * Then look for the expression living in the specified space in that group.
 */
================================================================================

文件路径: ./isl_schedule.c
注释行数: 12
注释内容:
/*
 * Copyright 2011      INRIA Saclay
 * Copyright 2012-2014 Ecole Normale Superieure
 * Copyright 2016      Sven Verdoolaege
 *
 * Use of this software is governed by the MIT license
 *
 * Written by Sven Verdoolaege, INRIA Saclay - Ile-de-France,
 * Parc Club Orsay Universite, ZAC des vignes, 4 rue Jacques Monod,
 * 91893 Orsay, France
 * and Ecole Normale Superieure, 45 rue d'Ulm, 75230 Paris, France
 */
================================================================================

文件路径: ./isl_schedule.c
注释行数: 11
注释内容:
/* Return a schedule encapsulating the given schedule tree.
 *
 * We currently only allow schedule trees with a domain or extension as root.
 *
 * The leaf field is initialized as a leaf node so that it can be
 * used to represent leaves in the constructed schedule.
 * The reference count is set to -1 since the isl_schedule_tree
 * should never be freed.  It is up to the (internal) users of
 * these leaves to ensure that they are only used while the schedule
 * is still alive.
 */
================================================================================

文件路径: ./isl_schedule.c
注释行数: 12
注释内容:
/* Construct a schedule that combines the schedules "schedule1" and "schedule2"
 * with a top-level node (underneath the domain node) of type "type",
 * either isl_schedule_node_sequence or isl_schedule_node_set.
 * The domains of the two schedules are assumed to be disjoint.
 *
 * The new schedule has as domain the union of the domains of the two
 * schedules.  The child of the domain node is a node of type "type"
 * with two filters corresponding to the domains of the input schedules.
 * If one (or both) of the top-level nodes of the two schedules is itself
 * of type "type", then the filter is pushed into the children of that
 * node and the sequence or set is flattened.
 */
================================================================================

文件路径: ./isl_constraint.c
注释行数: 11
注释内容:
/*
 * Copyright 2008-2009 Katholieke Universiteit Leuven
 * Copyright 2010      INRIA Saclay
 *
 * Use of this software is governed by the MIT license
 *
 * Written by Sven Verdoolaege, K.U.Leuven, Departement
 * Computerwetenschappen, Celestijnenlaan 200A, B-3001 Leuven, Belgium
 * and INRIA Saclay - Ile-de-France, Parc Club Orsay Universite,
 * ZAC des vignes, 4 rue Jacques Monod, 91893 Orsay, France 
 */
================================================================================

文件路径: ./isl_constraint.c
注释行数: 14
注释内容:
/* Is "constraint" an equality that corresponds to integer division "div"?
 *
 * That is, given an integer division of the form
 *
 *	a = floor((f + c)/m)
 *
 * is the equality of the form
 *
 *		-f + m d + c' = 0
 * ?
 * Note that the constant term is not checked explicitly, but given
 * that this is a valid equality constraint, the constant c' necessarily
 * has a value close to -c.
 */
================================================================================

文件路径: ./isl_constraint.c
注释行数: 16
注释内容:
/* For each pair of lower and upper bounds on the variable "pos"
 * of type "type", call "fn" with these lower and upper bounds and the
 * set of constraints on the remaining variables where these bounds
 * are active, i.e., (stricly) larger/smaller than the other lower/upper bounds.
 *
 * If the designated variable is equal to an affine combination of the
 * other variables then fn is called with both lower and upper
 * set to the corresponding equality.
 *
 * If there is no lower (or upper) bound, then NULL is passed
 * as the corresponding bound.
 *
 * We first check if the variable is involved in any equality.
 * If not, we count the number of lower and upper bounds and
 * act accordingly.
 */
================================================================================

文件路径: ./isl_constraint.c
注释行数: 10
注释内容:
/* For an inequality constraint
 *
 *	f >= 0
 *
 * or an equality constraint
 *
 *	f = 0
 *
 * return the affine expression f.
 */
================================================================================

文件路径: ./isl_constraint.c
注释行数: 11
注释内容:
/* Compare two constraints based on their final (non-zero) coefficients.
 * In particular, the constraint that involves later variables or
 * that has a larger coefficient for a shared latest variable
 * is considered "greater" than the other constraint.
 *
 * Return -1 if "c1" is "smaller" than "c2", 1 if "c1" is "greater"
 * than "c2" and 0 if they are equal.
 *
 * If the constraints live in different local spaces, then we cannot
 * really compare the constraints so we compare the local spaces instead.
 */
================================================================================

文件路径: ./isl_flow.c
注释行数: 17
注释内容:
/*
 * Copyright 2005-2007 Universiteit Leiden
 * Copyright 2008-2009 Katholieke Universiteit Leuven
 * Copyright 2010      INRIA Saclay
 * Copyright 2012      Universiteit Leiden
 * Copyright 2014      Ecole Normale Superieure
 *
 * Use of this software is governed by the MIT license
 *
 * Written by Sven Verdoolaege, Leiden Institute of Advanced Computer Science,
 * Universiteit Leiden, Niels Bohrweg 1, 2333 CA Leiden, The Netherlands
 * and K.U.Leuven, Departement Computerwetenschappen, Celestijnenlaan 200A,
 * B-3001 Leuven, Belgium
 * and INRIA Saclay - Ile-de-France, Parc Club Orsay Universite,
 * ZAC des vignes, 4 rue Jacques Monod, 91893 Orsay, France 
 * and Ecole Normale Superieure, 45 rue d'Ulm, 75230 Paris, France
 */
================================================================================

文件路径: ./isl_flow.c
注释行数: 17
注释内容:
/* A structure containing the input for dependence analysis:
 * - a sink
 * - n_must + n_may (<= max_source) sources
 * - a function for determining the relative order of sources and sink
 * - an optional function "coscheduled" for determining whether sources
 *   may be coscheduled.  If "coscheduled" is NULL, then the sources
 *   are assumed not to be coscheduled.
 * The must sources are placed before the may sources.
 *
 * domain_map is an auxiliary map that maps the sink access relation
 * to the domain of this access relation.
 * This field is only needed when restrict_fn is set and
 * the field itself is set by isl_access_info_compute_flow.
 *
 * restrict_fn is a callback that (if not NULL) will be called
 * right before any lexicographical maximization.
 */
================================================================================

文件路径: ./isl_flow.c
注释行数: 16
注释内容:
/* Return -n, 0 or n (with n a positive value), depending on whether
 * the source access identified by p1 should be sorted before, together
 * or after that identified by p2.
 *
 * If p1 appears before p2, then it should be sorted first.
 * For more generic initial schedules, it is possible that neither
 * p1 nor p2 appears before the other, or at least not in any obvious way.
 * We therefore also check if p2 appears before p1, in which case p2
 * should be sorted first.
 * If not, we try to order the two statements based on the description
 * of the iteration domains.  This results in an arbitrary, but fairly
 * stable ordering.
 *
 * In case of an error, sort_info.error is set to true and all elements are
 * reported to be equal.
 */
================================================================================

文件路径: ./isl_flow.c
注释行数: 10
注释内容:
/* Initialize an empty isl_flow structure corresponding to a given
 * isl_access_info structure.
 * For each must access, two dependences are created (initialized
 * to the empty relation), one for the resulting must dependences
 * and one for the resulting may dependences.  May accesses can
 * only lead to may dependences, so only one dependence is created
 * for each of them.
 * This function is private as isl_flow structures are only supposed
 * to be created by isl_access_info_compute_flow.
 */
================================================================================

文件路径: ./isl_flow.c
注释行数: 10
注释内容:
/* Return a map that enforces that the domain iteration occurs after
 * the range iteration at the given level.
 * If level is odd, then the domain iteration should occur after
 * the target iteration in their shared level/2 outermost loops.
 * In this case we simply need to enforce that these outermost
 * loop iterations are the same.
 * If level is even, then the loop iterator of the domain should
 * be greater than the loop iterator of the range at the last
 * of the level/2 shared loops, i.e., loop level/2 - 1.
 */
================================================================================

文件路径: ./isl_flow.c
注释行数: 12
注释内容:
/* Compute the partial lexicographic maximum of "dep" on domain "sink",
 * but first check if the user has set acc->restrict_fn and if so
 * update either the input or the output of the maximization problem
 * with respect to the resulting restriction.
 *
 * Since the user expects a mapping from sink iterations to source iterations,
 * whereas the domain of "dep" is a wrapped map, mapping sink iterations
 * to accessed array elements, we first need to project out the accessed
 * sink array elements by applying acc->domain_map.
 * Similarly, the sink restriction specified by the user needs to be
 * converted back to the wrapped map.
 */
================================================================================

文件路径: ./isl_flow.c
注释行数: 15
注释内容:
/* Given a possible flow dependence temp_rel[j] between source j and the sink
 * at level sink_level, remove those elements for which
 * there is an iteration of another source k < j that is closer to the sink.
 * The flow dependences temp_rel[k] are updated with the improved sources.
 * Any improved source needs to precede the sink at the same level
 * and needs to follow source j at the same or a deeper level.
 * The lower this level, the later the execution date of source k.
 * We therefore consider lower levels first.
 *
 * If temp_rel[j] is empty, then there can be no improvement and
 * we return immediately.
 *
 * This function returns isl_stat_ok in case it was executed successfully and
 * isl_stat_error in case of errors during the execution of this function.
 */
================================================================================

文件路径: ./isl_flow.c
注释行数: 20
注释内容:
/* Given a dependence relation "old_map" between a must-source and the sink,
 * return a subset of the dependences, augmented with instances
 * of the source at position "pos" in "acc" that are coscheduled
 * with the must-source and that access the same element.
 * That is, if the input lives in a space T -> K, then the output
 * lives in the space [T -> S] -> K, with S the space of source "pos", and
 * the domain factor of the domain product is a subset of the input.
 * The sources are considered to be coscheduled if they have the same values
 * for the initial "depth" coordinates.
 *
 * First construct a dependence relation S -> K and a mapping
 * between coscheduled sources T -> S.
 * The second is combined with the original dependence relation T -> K
 * to form a relation in T -> [S -> K], which is subsequently
 * uncurried to [T -> S] -> K.
 * This result is then intersected with the dependence relation S -> K
 * to form the output.
 *
 * In case a negative depth is given, NULL is returned to indicate an error.
 */
================================================================================

文件路径: ./isl_flow.c
注释行数: 35
注释内容:
/* After the dependences derived from a must-source have been computed
 * at a certain level, check if any of the sources of the must-dependences
 * may be coscheduled with other sources.
 * If they are any such sources, then there is no way of determining
 * which of the sources actually comes last and the must-dependences
 * need to be turned into may-dependences, while dependences from
 * the other sources need to be added to the may-dependences as well.
 * "acc" describes the sources and a callback for checking whether
 * two sources may be coscheduled.  If acc->coscheduled is NULL then
 * the sources are assumed not to be coscheduled.
 * "must_rel" and "may_rel" describe the must and may-dependence relations
 * computed at the current level for the must-sources.  Some of the dependences
 * may be moved from "must_rel" to "may_rel".
 * "flow" contains all dependences computed so far (apart from those
 * in "must_rel" and "may_rel") and may be updated with additional
 * dependences derived from may-sources.
 *
 * In particular, consider all the must-sources with a non-empty
 * dependence relation in "must_rel".  They are considered in reverse
 * order because that is the order in which they are considered in the caller.
 * If any of the must-sources are coscheduled, then the last one
 * is the one that will have a corresponding dependence relation.
 * For each must-source i, consider both all the previous must-sources
 * and all the may-sources.  If any of those may be coscheduled with
 * must-source i, then compute the coscheduled instances that access
 * the same memory elements.  The result is a relation [T -> S] -> K.
 * The projection onto T -> K is a subset of the must-dependence relation
 * that needs to be turned into may-dependences.
 * The projection onto S -> K needs to be added to the may-dependences
 * of source S.
 * Since a given must-source instance may be coscheduled with several
 * other source instances, the dependences that need to be turned
 * into may-dependences are first collected and only actually removed
 * from the must-dependences after all other sources have been considered.
 */
================================================================================

文件路径: ./isl_flow.c
注释行数: 40
注释内容:
/* Compute dependences for the case where there is at least one
 * "must" access.
 *
 * The core algorithm considers all levels in which a source may precede
 * the sink, where a level may either be a statement level or a loop level.
 * The outermost statement level is 1, the first loop level is 2, etc...
 * The algorithm basically does the following:
 * for all levels l of the read access from innermost to outermost
 *	for all sources w that may precede the sink access at that level
 *	    compute the last iteration of the source that precedes the sink access
 *					    at that level
 *	    add result to possible last accesses at level l of source w
 *	    for all sources w2 that we haven't considered yet at this level that may
 *					    also precede the sink access
 *		for all levels l2 of w from l to innermost
 *		    for all possible last accesses dep of w at l
 *			compute last iteration of w2 between the source and sink
 *								of dep
 *			add result to possible last accesses at level l of write w2
 *			and replace possible last accesses dep by the remainder
 *
 *
 * The above algorithm is applied to the must access.  During the course
 * of the algorithm, we keep track of sink iterations that still
 * need to be considered.  These iterations are split into those that
 * haven't been matched to any source access (mustdo) and those that have only
 * been matched to may accesses (maydo).
 * At the end of each level, must-sources and may-sources that are coscheduled
 * with the sources of the must-dependences at that level are considered.
 * If any coscheduled instances are found, then corresponding may-dependences
 * are added and the original must-dependences are turned into may-dependences.
 * Afterwards, the may accesses that occur after must-dependence sources
 * are considered.
 * In particular, we consider may accesses that precede the remaining
 * sink iterations, moving elements from mustdo to maydo when appropriate,
 * and may accesses that occur between a must source and a sink of any 
 * dependences found at the current level, turning must dependences into
 * may dependences when appropriate.
 * 
 */
================================================================================

文件路径: ./isl_flow.c
注释行数: 17
注释内容:
/* Given a "sink" access, a list of n "source" accesses,
 * compute for each iteration of the sink access
 * and for each element accessed by that iteration,
 * the source access in the list that last accessed the
 * element accessed by the sink access before this sink access.
 * Each access is given as a map from the loop iterators
 * to the array indices.
 * The result is a list of n relations between source and sink
 * iterations and a subset of the domain of the sink access,
 * corresponding to those iterations that access an element
 * not previously accessed.
 *
 * To deal with multi-valued sink access relations, the sink iteration
 * domain is first extended with dimensions that correspond to the data
 * space.  However, these extra dimensions are not projected out again.
 * It is up to the caller to decide whether these dimensions should be kept.
 */
================================================================================

文件路径: ./isl_flow.c
注释行数: 17
注释内容:
/* Given a "sink" access, a list of n "source" accesses,
 * compute for each iteration of the sink access
 * and for each element accessed by that iteration,
 * the source access in the list that last accessed the
 * element accessed by the sink access before this sink access.
 * Each access is given as a map from the loop iterators
 * to the array indices.
 * The result is a list of n relations between source and sink
 * iterations and a subset of the domain of the sink access,
 * corresponding to those iterations that access an element
 * not previously accessed.
 *
 * To deal with multi-valued sink access relations,
 * access_info_compute_flow_core extends the sink iteration domain
 * with dimensions that correspond to the data space.  These extra dimensions
 * are projected out from the result of access_info_compute_flow_core.
 */
================================================================================

文件路径: ./isl_flow.c
注释行数: 10
注释内容:
/* The different types of access relations that isl_union_access_info
 * keeps track of.

 * "isl_access_sink" represents the sink accesses.
 * "isl_access_must_source" represents the definite source accesses.
 * "isl_access_may_source" represents the possible source accesses.
 * "isl_access_kill" represents the kills.
 *
 * isl_access_sink is sometimes treated differently and
 * should therefore appear first.
 */
================================================================================

文件路径: ./isl_flow.c
注释行数: 14
注释内容:
/* This structure represents the input for a dependence analysis computation.
 *
 * "access" contains the access relations.
 *
 * "schedule" or "schedule_map" represents the execution order.
 * Exactly one of these fields should be NULL.  The other field
 * determines the execution order.
 *
 * The domains of these four maps refer to the same iteration spaces(s).
 * The ranges of the first three maps also refer to the same data space(s).
 *
 * After a call to isl_union_access_info_introduce_schedule,
 * the "schedule_map" field no longer contains useful information.
 */
================================================================================

文件路径: ./isl_flow.c
注释行数: 22
注释内容:
/* Prepend the schedule dimensions to the iteration domains.
 *
 * That is, if the schedule is of the form
 *
 *	D -> S
 *
 * while the access relations are of the form
 *
 *	D -> A
 *
 * then the updated access relations are of the form
 *
 *	[S -> D] -> A
 *
 * The schedule map is also replaced by the map
 *
 *	[S -> D] -> D
 *
 * that is used during the internal computation.
 * Neither the original schedule map nor this updated schedule map
 * are used after the call to this function.
 */
================================================================================

文件路径: ./isl_flow.c
注释行数: 14
注释内容:
/* This structure represents the result of a dependence analysis computation.
 *
 * "must_dep" represents the full definite dependences
 * "may_dep" represents the full non-definite dependences.
 * Both are of the form
 *
 *	[Source] -> [[Sink -> Data]]
 *
 * (after the schedule dimensions have been projected out).
 * "must_no_source" represents the subset of the sink accesses for which
 * definitely no source was found.
 * "may_no_source" represents the subset of the sink accesses for which
 * possibly, but not definitely, no source was found.
 */
================================================================================

文件路径: ./isl_flow.c
注释行数: 20
注释内容:
/* Drop the schedule dimensions from the iteration domains in "flow".
 * In particular, the schedule dimensions have been prepended
 * to the iteration domains prior to the dependence analysis by
 * replacing the iteration domain D, by the wrapped map [S -> D].
 * Replace these wrapped maps by the original D.
 *
 * In particular, the dependences computed by access_info_compute_flow_core
 * are of the form
 *
 *	[S -> D] -> [[S' -> D'] -> A]
 *
 * The schedule dimensions are projected out by first currying the range,
 * resulting in
 *
 *	[S -> D] -> [S' -> [D' -> A]]
 *
 * and then computing the factor range
 *
 *	D -> [D' -> A]
 */
================================================================================

文件路径: ./isl_flow.c
注释行数: 12
注释内容:
/* Determine the shared nesting level and the "textual order" of
 * the given accesses.
 *
 * We first determine the minimal schedule dimension for both accesses.
 *
 * If among those dimensions, we can find one where both have a fixed
 * value and if moreover those values are different, then the previous
 * dimension is the last shared nesting level and the textual order
 * is determined based on the order of the fixed values.
 * If no such fixed values can be found, then we set the shared
 * nesting level to the minimal schedule dimension, with no textual ordering.
 */
================================================================================

文件路径: ./isl_flow.c
注释行数: 22
注释内容:
/* Drop dependences from "flow" that purely originate from kills.
 * That is, only keep those dependences that originate from
 * the original must-sources "must" and/or the original may-sources "may".
 * In particular, "must" contains the must-sources from before
 * the kills were added and "may" contains the may-source from before
 * the kills were removed.
 *
 * The dependences are of the form
 *
 *	Source -> [Sink -> Data]
 *
 * Only those dependences are kept where the Source -> Data part
 * is a subset of the original may-sources or must-sources.
 * Of those, only the must-dependences that intersect with the must-sources
 * remain must-dependences.
 * If there is some overlap between the may-sources and the must-sources,
 * then the may-dependences and must-dependences may also overlap.
 * This should be fine since the may-dependences are only kept
 * disjoint from the must-dependences for the isl_union_map_compute_flow
 * interface.  This interface does not support kills, so it will
 * not end up calling this function.
 */
================================================================================

文件路径: ./isl_flow.c
注释行数: 19
注释内容:
/* Given a description of the "sink" accesses, the "source" accesses and
 * a schedule, compute for each instance of a sink access
 * and for each element accessed by that instance,
 * the possible or definite source accesses that last accessed the
 * element accessed by the sink access before this sink access
 * in the sense that there is no intermediate definite source access.
 *
 * The must_no_source and may_no_source elements of the result
 * are subsets of access->sink.  The elements must_dep and may_dep
 * map domain elements of access->{may,must)_source to
 * domain elements of access->sink.
 *
 * This function is used when only the schedule map representation
 * is available.
 *
 * We first prepend the schedule dimensions to the domain
 * of the accesses so that we can easily compare their relative order.
 * Then we consider each sink access individually in compute_flow.
 */
================================================================================

文件路径: ./isl_flow.c
注释行数: 10
注释内容:
/* Data structure for keeping track of individual scheduled sink and source
 * accesses when computing dependence analysis based on a schedule tree.
 *
 * "n_sink" is the number of used entries in "sink"
 * "n_source" is the number of used entries in "source"
 *
 * "set_sink", "must" and "node" are only used inside collect_sink_source,
 * to keep track of the current node and
 * of what extract_sink_source needs to do.
 */
================================================================================

文件路径: ./isl_flow.c
注释行数: 24
注释内容:
/* isl_schedule_foreach_schedule_node_top_down callback for collecting
 * individual scheduled source and sink accesses (taking into account
 * the domain of the schedule).
 *
 * We only collect accesses at the leaves of the schedule tree.
 * We prepend the schedule dimensions at the leaf to the iteration
 * domains of the source and sink accesses and then extract
 * the individual accesses (per space).
 *
 * In particular, if the prefix schedule at the node is of the form
 *
 *	D -> S
 *
 * while the access relations are of the form
 *
 *	D -> A
 *
 * then the updated access relations are of the form
 *
 *	[S -> D] -> A
 *
 * Note that S consists of a single space such that introducing S
 * in the access relations does not increase the number of spaces.
 */
================================================================================

文件路径: ./isl_flow.c
注释行数: 16
注释内容:
/* isl_access_info_compute_flow callback for determining whether
 * the shared nesting level and the ordering within that level
 * for two scheduled accesses for use in compute_single_flow.
 *
 * The tokens passed to this function refer to the leaves
 * in the schedule tree where the accesses take place.
 *
 * If n is the shared number of loops, then we need to return
 * "2 * n + 1" if "first" precedes "second" inside the innermost
 * shared loop and "2 * n" otherwise.
 *
 * The innermost shared ancestor may be the leaves themselves
 * if the accesses take place in the same leaf.  Otherwise,
 * it is either a set node or a sequence node.  Only in the case
 * of a sequence node do we consider one access to precede the other.
 */
================================================================================

文件路径: ./isl_flow.c
注释行数: 17
注释内容:
/* Given a scheduled sink access relation "sink", compute the corresponding
 * dependences on the sources in "data" and add the computed dependences
 * to "uf".
 *
 * The dependences computed by access_info_compute_flow_core are of the form
 *
 *	[S -> I] -> [[S' -> I'] -> A]
 *
 * The schedule dimensions are projected out by first currying the range,
 * resulting in
 *
 *	[S -> I] -> [S' -> [I' -> A]]
 *
 * and then computing the factor range
 *
 *	I -> [I' -> A]
 */
================================================================================

文件路径: ./isl_flow.c
注释行数: 21
注释内容:
/* Given a description of the "sink" accesses, the "source" accesses and
 * a schedule, compute for each instance of a sink access
 * and for each element accessed by that instance,
 * the possible or definite source accesses that last accessed the
 * element accessed by the sink access before this sink access
 * in the sense that there is no intermediate definite source access.
 * Only consider dependences between statement instances that belong
 * to the domain of the schedule.
 *
 * The must_no_source and may_no_source elements of the result
 * are subsets of access->sink.  The elements must_dep and may_dep
 * map domain elements of access->{may,must)_source to
 * domain elements of access->sink.
 *
 * This function is used when a schedule tree representation
 * is available.
 *
 * We extract the individual scheduled source and sink access relations
 * (taking into account the domain of the schedule) and
 * then compute dependences for each scheduled sink individually.
 */
================================================================================

文件路径: ./isl_flow.c
注释行数: 20
注释内容:
/* Given a description of the "sink" accesses, the "source" accesses and
 * a schedule, compute for each instance of a sink access
 * and for each element accessed by that instance,
 * the possible or definite source accesses that last accessed the
 * element accessed by the sink access before this sink access
 * in the sense that there is no intermediate definite source access.
 *
 * The must_no_source and may_no_source elements of the result
 * are subsets of access->sink.  The elements must_dep and may_dep
 * map domain elements of access->{may,must)_source to
 * domain elements of access->sink.
 *
 * If any kills have been specified, then they are treated as
 * must-sources internally.  Any dependence that purely derives
 * from an original kill is removed from the output.
 *
 * We check whether the schedule is available as a schedule tree
 * or a schedule map and call the corresponding function to perform
 * the analysis.
 */
================================================================================

文件路径: ./isl_flow.c
注释行数: 16
注释内容:
/* Given a collection of "sink" and "source" accesses,
 * compute for each iteration of a sink access
 * and for each element accessed by that iteration,
 * the source access in the list that last accessed the
 * element accessed by the sink access before this sink access.
 * Each access is given as a map from the loop iterators
 * to the array indices.
 * The result is a relations between source and sink
 * iterations and a subset of the domain of the sink accesses,
 * corresponding to those iterations that access an element
 * not previously accessed.
 *
 * We collect the inputs in an isl_union_access_info object,
 * call isl_union_access_info_compute_flow and extract
 * the outputs from the result.
 */
================================================================================

文件路径: ./interface/template_cpp.h
注释行数: 11
注释内容:
/* A representation of a template class.
 *
 * "class_name" is the name of the template class.
 * "super_name" is the (fully qualified) name of the corresponding
 * plain C++ interface class, from which this template class derives.
 * "clazz" describes the plain class.
 *
 * "class_tuples" contains the specializations.
 * It is initialized with a predefined set of specializations,
 * but may be extended during the generations of the specializations.
 */
================================================================================

文件路径: ./interface/generator.cc
注释行数: 32
注释内容:
/*
 * Copyright 2011,2015 Sven Verdoolaege. All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 *
 *    1. Redistributions of source code must retain the above copyright
 *       notice, this list of conditions and the following disclaimer.
 *
 *    2. Redistributions in binary form must reproduce the above
 *       copyright notice, this list of conditions and the following
 *       disclaimer in the documentation and/or other materials provided
 *       with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY SVEN VERDOOLAEGE ''AS IS'' AND ANY
 * EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
 * PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL SVEN VERDOOLAEGE OR
 * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
 * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
 * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA,
 * OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
 * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
 * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 *
 * The views and conclusions contained in the software and documentation
 * are those of the authors and should not be interpreted as
 * representing official policies, either expressed or implied, of
 * Sven Verdoolaege.
 */
================================================================================

文件路径: ./interface/generator.cc
注释行数: 18
注释内容:
/* Collect all functions that belong to a certain type, separating
 * constructors from methods that set an enum value,
 * methods that set a persistent callback and
 * from regular methods, while keeping track of the _to_str,
 * _copy and _free functions, if any, separately.
 * Methods that accept any enum arguments that are not specifically handled
 * are not supported.
 * If there are any overloaded
 * functions, then they are grouped based on their name after removing the
 * argument type suffix.
 * Check for functions that describe subclasses before considering
 * any other functions in order to be able to detect those other
 * functions as belonging to the subclasses.
 * Sort the names of the functions based on their lengths
 * to ensure that nested subclasses are handled later.
 *
 * Also extract information about automatic conversion functions.
 */
================================================================================

文件路径: ./interface/generator.cc
注释行数: 16
注释内容:
/* Return a sequence of the types of which the given type declaration is
 * marked as being a subtype.
 * The order of the types is the opposite of the order in which they
 * appear in the source.  In particular, the first annotation
 * is the one that is closest to the annotated type and the corresponding
 * type is then also the first that will appear in the sequence of types.
 * This is also the order in which the annotations appear
 * in the AttrVec returned by Decl::getAttrs() in older versions of clang.
 * In newer versions of clang, the order is that in which
 * the attribute appears in the source.
 * Use the position of the "isl_export" attribute to determine
 * whether this is an old (with reversed order) or a new version.
 * The "isl_export" attribute is automatically added
 * after each "isl_subclass" attribute.  If it appears in the list before
 * any "isl_subclass" is encountered, then this must be a reversed list.
 */
================================================================================

文件路径: ./interface/generator.cc
注释行数: 16
注释内容:
/* Does the callback argument "param" take its argument at position "pos"?
 *
 * The memory management annotations of arguments to function pointers
 * are not recorded by clang, so the information cannot be extracted
 * from the type of "param".
 * Instead, go to the location in the source where the callback argument
 * is declared, look for the right argument of the callback itself and
 * then check if it has an "__isl_take" memory management annotation.
 *
 * If the return value of the function has a memory management annotation,
 * then the spelling of "param" will point to the spelling
 * of this memory management annotation.  Since the macro is defined
 * on the command line (in main), this location does not have a file entry.
 * In this case, move up one level in the macro expansion to the location
 * where the memory management annotation is used.
 */
================================================================================

文件路径: ./interface/extract_interface.cc
注释行数: 32
注释内容:
/*
 * Copyright 2011 Sven Verdoolaege. All rights reserved.
 * 
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 
 *    1. Redistributions of source code must retain the above copyright
 *       notice, this list of conditions and the following disclaimer.
 * 
 *    2. Redistributions in binary form must reproduce the above
 *       copyright notice, this list of conditions and the following
 *       disclaimer in the documentation and/or other materials provided
 *       with the distribution.
 * 
 * THIS SOFTWARE IS PROVIDED BY SVEN VERDOOLAEGE ''AS IS'' AND ANY
 * EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
 * PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL SVEN VERDOOLAEGE OR
 * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
 * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
 * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA,
 * OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
 * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
 * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 * 
 * The views and conclusions contained in the software and documentation
 * are those of the authors and should not be interpreted as
 * representing official policies, either expressed or implied, of
 * Sven Verdoolaege.
 */
================================================================================

文件路径: ./interface/template_cpp.cc
注释行数: 32
注释内容:
/*
 * Copyright 2020 Cerebras Systems. All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 *
 *    1. Redistributions of source code must retain the above copyright
 *       notice, this list of conditions and the following disclaimer.
 *
 *    2. Redistributions in binary form must reproduce the above
 *       copyright notice, this list of conditions and the following
 *       disclaimer in the documentation and/or other materials provided
 *       with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY CEREBRAS SYSTEMS ''AS IS'' AND ANY
 * EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
 * PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL CEREBRAS SYSTEMS OR
 * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
 * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
 * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA,
 * OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
 * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
 * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 *
 * The views and conclusions contained in the software and documentation
 * are those of the authors and should not be interpreted as
 * representing official policies, either expressed or implied, of
 * Cerebras Systems.
 */
================================================================================

文件路径: ./interface/template_cpp.cc
注释行数: 23
注释内容:
/* Signatures for methods of types containing a given substring
 * that override the default signatures, where larger substrings
 * appear first.
 *
 * In particular, "gist" is usually a regular binary operation,
 * but for any type derived from "aff", the argument refers
 * to the domain of the function.
 *
 * The "size" method can usually simply be inherited from
 * the corresponding plain C++ type, but for a "fixed_box",
 * the size lives in the space of the box or its range.
 *
 * The "space" method is usually a regular unary operation
 * that returns the single space of the elements in the object,
 * with the same number of tuples.
 * However, a "union" object may contain elements from many spaces and
 * therefore its space only refers to the symbolic constants and
 * has zero tuples, except if it is also a "multi_union" object,
 * in which case it has a fixed range space and the space of the object
 * has a single tuple.
 * Note that since "space' is also the name of a template class,
 * the default space method is handled by print_type_named_member_method.
 */
================================================================================

文件路径: ./interface/template_cpp.cc
注释行数: 15
注释内容:
/* The initial sequence of specialization kinds for base types.
 * The specialization kinds for other types are derived
 * from the corresponding base types.
 *
 * In particular, this sequence specifies how many tuples
 * a given type can have and whether it is anonymous.
 *
 * "space" can have any number of tuples.
 * "set" and "point" can have zero or one tuple.
 * "map" can only have two tuples.
 * "aff" can have one or two tuples, the last of which is anonymous.
 * "fixed_box" can represent a (proper) set) or a map.
 * "val" and "id" are treated as anonymous sets so that
 * they can form the basis of "multi_val" and "multi_id".
 */
================================================================================

文件路径: ./interface/template_cpp.cc
注释行数: 11
注释内容:
/* Construct a templated C++ bindings generator from
 * the exported types and functions and the set of all declared functions.
 *
 * On top of the initialization of the shared parts
 * of C++ bindings generators, add a template class
 * for each plain C++ class for which template kinds
 * have been defined.
 * In particular, determine the base type from which the plain C++ class
 * was derived using type constructors and check if any template kinds
 * have been registered for this base type.
 */
================================================================================

文件路径: ./interface/template_cpp.cc
注释行数: 12
注释内容:
/* Print all specializations of all template classes.
 *
 * Each class has a predefined set of initial specializations,
 * but while such a specialization is being printed,
 * the need for other specializations may arise and
 * these are added at the end of the list of specializations.
 * That is, class_tuples.size() may change during the execution
 * of the loop.
 *
 * For each specialization of a template class, call
 * the print_class virtual method.
 */
================================================================================

文件路径: ./interface/template_cpp.cc
注释行数: 10
注释内容:
/* If a method with signature "sig" requires additional template parameters
 * compared to those of the class, then print a declaration for them.
 * If this->declarations is set, then this will be part of a method declaration,
 * requiring extra indentation.
 *
 * Construct the sequence of all required template parameters
 * with those of the template class appearing first.
 * If this sequence has any parameters not induced by the template class itself,
 * then print a declaration for these extra parameters.
 */
================================================================================

文件路径: ./interface/template_cpp.cc
注释行数: 12
注释内容:
/* Print a lambda for passing to the plain method corresponding to "method"
 * with signature "sig".
 *
 * The method is assumed to have only the callback as argument,
 * which means the arguments of the callback are shifted by 2
 * with respect to the arguments of the signature
 * (one for the position of the callback argument plus
 * one for the return kind of the callback).
 *
 * The lambda takes arguments with plain isl types and
 * calls the callback of "method" with templated arguments.
 */
================================================================================

文件路径: ./interface/template_cpp.cc
注释行数: 11
注释内容:
/* Print a definition of the member method "method", which is known
 * to have a callback argument, with signature "sig".
 *
 * First print a lambda for passing to the corresponding plain method and
 * calling the callback of "method" with templated arguments.
 * Then call the plain method, replacing the original callback
 * by the lambda.
 *
 * The return value is assumed to be isl_bool or isl_stat
 * so that no conversion to a template type is required.
 */
================================================================================

文件路径: ./interface/template_cpp.cc
注释行数: 11
注释内容:
/* Print a definition of the method "method" with signature "sig",
 * if "deleted" is not set.
 *
 * If "deleted" is set, then the corresponding declaration
 * is marked "delete" and no definition needs to be printed.
 *
 * Otherwise print the method header, preceded by the template parameters,
 * if needed.
 * The body depends on whether the method is a constructor or
 * takes a callback.
 */
================================================================================

文件路径: ./interface/template_cpp.cc
注释行数: 14
注释内容:
/* Signatures for constructors and methods named after some other class.
 *
 * Two forms of constructors are handled
 * - conversion from another object
 * - construction of a multi-expression from a space and a list
 *
 * Methods named after some other class also come in two forms
 * - extraction of information such as the space or a list
 * - construction of a multi-expression from a space and a list
 *
 * In both cases, the first form is a unary operation and
 * the second has an extra argument with a kind that is equal
 * to that of the first argument, except that the final tuple is anonymous.
 */
================================================================================

文件路径: ./interface/template_cpp.cc
注释行数: 10
注释内容:
/* Update the substitution "sub" to map "general" to "specific"
 * if "specific" is a special case of "general" consistent with "sub",
 * given that "general" is not a pair and can be assigned "specific".
 * Return true if successful.
 * Otherwise, return false.
 *
 * Check whether "general" is already assigned something in "sub".
 * If so, it must be assigned "specific".
 * Otherwise, there is a conflict.
 */
================================================================================

文件路径: ./interface/template_cpp.cc
注释行数: 14
注释内容:
/* Update the substitution "sub" to map "general" to "specific"
 * if "specific" is a special case of "general" consistent with "sub".
 * Return true if successful.
 * Otherwise, return false.
 *
 * If "general" is a pair and "specific" is not,
 * then "specific" cannot be a special case.
 * If both are pairs, then update the substitution based
 * on both sides.
 * If "general" is Anonymous, then "specific" must be Anonymous as well.
 * If "general" is Leaf, then "specific" cannot be a pair.
 *
 * Otherwise, assign "specific" to "general", if possible.
 */
================================================================================

文件路径: ./interface/template_cpp.cc
注释行数: 10
注释内容:
/* Try and compute a unifier of "kind1" and "kind2",
 * i.e., a substitution that produces the same result when
 * applied to both "kind1" and "kind2",
 * for the case where both "kind1" and "kind2" are pairs.
 * Return this unifier if it was found.
 * Return an empty substitution if no unifier can be found.
 *
 * First compute a unifier for the left parts of the pairs and,
 * if successful, combine it with a unifier for the right parts.
 */
================================================================================

文件路径: ./interface/template_cpp.cc
注释行数: 15
注释内容:
/* Try and compute a unifier of "kind1" and "kind2",
 * i.e., a substitution that produces the same result when
 * applied to both "kind1" and "kind2".
 * Return this unifier if it was found.
 * Return an empty substitution if no unifier can be found.
 *
 * If one of the tuple kinds is a pair then assign it
 * to the other tuple kind, if possible.
 * If neither is a pair, then try and assign one to the other.
 * Otherwise, let compute_pair_unifier compute a unifier.
 *
 * Note that an assignment is added to the unifier even
 * if "kind1" and "kind2" are identical.
 * This ensures that a successful substitution is never empty.
 */
================================================================================

文件路径: ./interface/template_cpp.cc
注释行数: 14
注释内容:
/* Try and compute a unifier of "kind1" and "kind2",
 * i.e., a substitution that produces the same result when
 * applied to both "kind1" and "kind2".
 * Return this unifier if it was found.
 * Return an empty substitution if no unifier can be found.
 *
 * Start with an empty substitution and compute a unifier for
 * each pair of tuple kinds, combining the results.
 * If no combined unifier can be found or
 * if the numbers of tuple kinds are different, then return
 * an empty substitution.
 * This assumes that the number of tuples is greater than zero,
 * as otherwise an empty substitution would be returned as well.
 */
================================================================================

文件路径: ./interface/template_cpp.cc
注释行数: 10
注释内容:
/* Try and construct a Kind that is a specialization of both "general" and
 * "specific", where "specific" is known _not_ to be a specialization
 * of "general" and not to contain any Leaf.
 *
 * First check whether "general" is a specialization of "specific".
 * If so, simply return "general".
 * Otherwise, rename the placeholders in the two kinds apart and
 * try and compute a unifier.
 * If this succeeds, then return the result of applying the unifier.
 */
================================================================================

文件路径: ./interface/template_cpp.cc
注释行数: 10
注释内容:
/* Try and add a template class specialization corresponding to "kind".
 * The new specialization needs to be a specialization of both
 * the current specialization and "kind".
 *
 * The current template class specialization is known not to be a special case
 * of "kind".
 *
 * Try and unify the two kinds and, if this succeeds, add the result
 * to this list of template class specializations.
 */
================================================================================

文件路径: ./interface/template_cpp.cc
注释行数: 19
注释内容:
/* Print a declaration or definition of the method "method"
 * if the template class specialization matches "match_arg".
 * Return true if so.
 * "sig" is the complete signature, of which "match_arg" refers
 * to the first argument or the return type.
 *
 * Since "sig" may have parameters with the same names as
 * those in instance.kind, rename them apart first.
 *
 * If the template class specialization is a special case of
 * (the renamed) "match_arg"
 * then apply the specializer to the complete (renamed) signature,
 * check that the return kind is allowed and, if so,
 * print the declaration or definition using the specialized signature.
 *
 * If the template class specialization is not a special case of "match_arg"
 * then add a further specialization to the list of specializations
 * of the template class.
 */
================================================================================

文件路径: ./interface/template_cpp.cc
注释行数: 14
注释内容:
/* Print a declaration or definition of the member method "method"
 * if it matches the signature "sig".
 * Return true if so.
 *
 * First determine the part of the signature that needs to match
 * the template class specialization and
 * check that it has the same number of template arguments.
 * Also check that the number of arguments of the signature
 * matches that of the method.
 * If there is at least one argument, then check that the first method argument
 * is an isl_ctx if and only if the first signature argument is Ctx.
 *
 * If these tests succeed, proceed with the actual matching.
 */
================================================================================

文件路径: ./interface/template_cpp.cc
注释行数: 11
注释内容:
/* Print a declaration or definition of the "at" member method "method".
 *
 * There are two types of methods called "at".
 * One type extracts an element from a multi-expression and
 * the other extracts an element from a list.
 *
 * In the first case, the return type is an anonymous function
 * while the object type is not.  In this case, the return kind
 * should have a final Anonymous tuple.
 * Otherwise, the return kind should be the same as the object kind.
 */
================================================================================

文件路径: ./interface/template_cpp.cc
注释行数: 10
注释内容:
/* Print a declaration or definition of the member method "method".
 *
 * If the method is called "at", then it requires special treatment.
 * Otherwise, check if the signature is overridden for this class or
 * if the method is named after some other type.
 * Otherwise look for an appropriate signature using different variations
 * of the method name.  First try the method name itself,
 * then the method name with the return type removed and
 * finally the method name with the callback argument type removed.
 */
================================================================================

文件路径: ./interface/template_cpp.cc
注释行数: 20
注释内容:
/* Print the declaration and definition of a constructor
 * for the template class specialization "instance" taking
 * an instance with more specialized template arguments,
 * where "params" holds the template parameters of "instance".
 * It is assumed that there is at least one template parameter as otherwise
 * there are no template arguments to be specialized and
 * no constructor needs to be printed.
 *
 * In particular, the constructor takes an object of the same instance where
 * for each template parameter, the corresponding template argument
 * of the input object is a subclass of the template argument
 * of the constructed object.
 *
 * Pick fresh names for all template parameters and
 * add a constructor with these fresh names as extra template parameters and
 * a constraint requiring that each of them is a subclass
 * of the corresponding class template parameter.
 * The plain C++ interface object of the constructed object is initialized with
 * the plain C++ interface object of the constructor argument.
 */
================================================================================

文件路径: ./interface/template_cpp.cc
注释行数: 21
注释内容:
/* Print the declaration and definition of a constructor
 * for the template class specialization "instance" taking
 * an instance of the base class.
 *
 * If the instance kind is that of an anonymous set
 * (i.e., it has a single tuple that is set to Anonymous),
 * then allow the constructor to be called externally.
 * This is mostly useful for being able to use isl::val and
 * isl::typed::val<Anonymous> interchangeably and similarly for isl::id.
 *
 * If the instance is of any other kind, then make this constructor private
 * to avoid objects of the plain interface being converted automatically.
 * Also make sure that it does not apply to any type derived
 * from the base class.  In particular, this makes sure it does
 * not apply to any other specializations of this template class as
 * otherwise any conflict in specializations would simply point
 * to the private constructor.
 *
 * A factory method is added to be able to perform the conversion explicitly,
 * with an explicit specification of the template arguments.
 */
================================================================================

文件路径: ./interface/template_cpp.cc
注释行数: 25
注释内容:
/* Print a "declaration" for the given template class specialization.
 * In particular, print the class definition and the method declarations.
 *
 * The template parameters are the distinct variable names
 * in the instance kind.
 *
 * Each instance of the template class derives from the corresponding
 * plain C++ interface class.
 *
 * All (other) template classes are made friends of this template class
 * to allow them to call the private constructor taking an object
 * of the plain interface.
 *
 * Besides the constructors and methods that forward
 * to the corresponding methods in the plain C++ interface class,
 * some extra constructors are defined.
 * The default zero-argument constructor is useful for declaring
 * a variable that only gets assigned a value at a later stage.
 * The constructor taking an instance with more specialized
 * template arguments is useful for lifting the class hierarchy
 * of the template arguments to the template class.
 * The constructor taking an instance of the base class
 * is useful for (explicitly) constructing a template type
 * from a plain type.
 */
================================================================================

文件路径: ./interface/python.cc
注释行数: 32
注释内容:
/*
 * Copyright 2011,2015 Sven Verdoolaege. All rights reserved.
 * 
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 
 *    1. Redistributions of source code must retain the above copyright
 *       notice, this list of conditions and the following disclaimer.
 * 
 *    2. Redistributions in binary form must reproduce the above
 *       copyright notice, this list of conditions and the following
 *       disclaimer in the documentation and/or other materials provided
 *       with the distribution.
 * 
 * THIS SOFTWARE IS PROVIDED BY SVEN VERDOOLAEGE ''AS IS'' AND ANY
 * EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
 * PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL SVEN VERDOOLAEGE OR
 * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
 * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
 * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA,
 * OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
 * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
 * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 * 
 * The views and conclusions contained in the software and documentation
 * are those of the authors and should not be interpreted as
 * representing official policies, either expressed or implied, of
 * Sven Verdoolaege.
 */
================================================================================

文件路径: ./interface/python.cc
注释行数: 11
注释内容:
/* Print a check that the argument in position "pos" is of type "type"
 * with the given indentation.
 * If this fails and if "upcast" is set, then convert the first
 * argument to "super" and call the method "name" on it, passing
 * the remaining of the "n" arguments.
 * If the check fails and "upcast" is not set, then simply raise
 * an exception.
 * If "upcast" is not set, then the "super", "name" and "n" arguments
 * to this function are ignored.
 * "fmt" is the format for printing Python method arguments.
 */
================================================================================

文件路径: ./interface/python.cc
注释行数: 10
注释内容:
/* For each of the "n" initial arguments of the function "method"
 * that refer to an isl structure,
 * including the object on which the method is called,
 * check if the corresponding actual argument is of the right type.
 * If not, try and convert it to the right type.
 * If that doesn't work and if "super" contains at least one element,
 * try and convert self to the type of the first superclass in "super" and
 * call the corresponding method.
 * If "first_is_ctx" is set, then the first argument is skipped.
 */
================================================================================

文件路径: ./interface/python.cc
注释行数: 17
注释内容:
/* Construct a wrapper for callback argument "param" (at position "arg").
 * Assign the wrapper to "cb".  We assume here that a function call
 * has at most one callback argument.
 *
 * The wrapper converts the arguments of the callback to python types,
 * taking a copy if the C callback does not take its arguments.
 * If any exception is thrown, the wrapper keeps track of it in exc_info[0]
 * and returns a value indicating an error.  Otherwise the wrapper
 * returns a value indicating success.
 * In case the C callback is expected to return an isl_stat,
 * the error value is -1 and the success value is 0.
 * In case the C callback is expected to return an isl_bool,
 * the error value is -1 and the success value is 1 or 0 depending
 * on the result of the Python callback.
 * Otherwise, None is returned to indicate an error and
 * a copy of the object in case of success.
 */
================================================================================

文件路径: ./interface/python.cc
注释行数: 19
注释内容:
/* Print the argument at position "arg" in call to "fd".
 * "fmt" is the format for printing Python method arguments.
 * "skip" is the number of initial arguments of "fd" that are
 * skipped in the Python method.
 *
 * If the (first) argument is an isl_ctx, then print "ctx",
 * assuming that the caller has made the context available
 * in a "ctx" variable.
 * Otherwise, if the argument is a callback, then print a reference to
 * the callback wrapper "cb".
 * Otherwise, if the argument is marked as consuming a reference,
 * then pass a copy of the pointer stored in the corresponding
 * argument passed to the Python method.
 * Otherwise, if the argument is a string, then the python string is first
 * encoded as a byte sequence, using 'ascii' as encoding.  This assumes
 * that all strings passed to isl can be converted to 'ascii'.
 * Otherwise, if the argument is a pointer, then pass this pointer itself.
 * Otherwise, pass the argument directly.
 */
================================================================================

文件路径: ./interface/python.cc
注释行数: 26
注释内容:
/* Print the return statement of the python method corresponding
 * to the C function "method" with the given indentation.
 * If the object on which the method was called
 * may have a persistent callback, then first check if any of those failed.
 * "fmt" is the format for printing Python method arguments.
 *
 * If the method returns a new instance of the same object type and
 * if the class has any persistent callbacks, then the data
 * for these callbacks are copied from the original to the new object.
 * If the method it itself setting a persistent callback,
 * then keep track of the constructed C callback (such that it doesn't
 * get destroyed) and the data structure that holds the captured exception
 * (such that it can be raised again).
 *
 * If the return type is a (const) char *, then convert the result
 * to a Python string, raising an error on NULL and freeing
 * the C string if needed.  For python 3 compatibility, the string returned
 * by isl is explicitly decoded as an 'ascii' string.  This is correct
 * as all strings returned by isl are expected to be 'ascii'.
 *
 * If the return type is isl_stat, isl_bool or isl_size, then
 * raise an error on isl_stat_error, isl_bool_error or isl_size_error.
 * In case of isl_bool, the result is converted to
 * a Python boolean.
 * In case of isl_size, the result is converted to a Python int.
 */
================================================================================

文件路径: ./interface/python.cc
注释行数: 12
注释内容:
/* Print a call to "method", along with the corresponding
 * return statement, with the given indentation.
 * "drop_ctx" is set if the first argument is an isl_ctx.
 * "drop_user" is set if the last argument is a "user" argument
 * corresponding to a callback argument.
 *
 * A "ctx" variable is first initialized as it may be needed
 * in the first call to print_arg_in_call and in print_method_return.
 *
 * If the method has a callback function, then any exception
 * thrown in the callback also need to be rethrown.
 */
================================================================================

文件路径: ./interface/python.cc
注释行数: 24
注释内容:
/* Print a python method corresponding to the C function "method".
 * "super" contains the superclasses of the class to which the method belongs,
 * with the first element corresponding to the annotation that appears
 * closest to the annotated type.  This superclass is the least
 * general extension of the annotated type in the linearization
 * of the class hierarchy.
 *
 * If the first argument of "method" is something other than an instance
 * of the class, then mark the python method as static.
 * If, moreover, this first argument is an isl_ctx, then remove
 * it from the arguments of the Python method.
 *
 * If the function has a callback argument, then it also has a "user"
 * argument.  Since Python has closures, there is no need for such
 * a user argument in the Python interface, so we simply drop it.
 * We also create a wrapper ("cb") for the callback.
 *
 * If the function consumes a reference, then we pass it a copy of
 * the actual argument.
 *
 * For methods that are identified as "get" methods, also
 * print a variant of the method using a name that includes
 * the "get_" prefix.
 */
================================================================================

文件路径: ./interface/python.cc
注释行数: 14
注释内容:
/* Print a test that checks whether the arguments passed
 * to the Python method correspond to the arguments
 * expected by "fd".
 * "drop_ctx" is set if the first argument of "fd" is an isl_ctx,
 * which does not appear as an argument to the Python method.
 *
 * If an automatic conversion function is available for any
 * of the argument types, then also allow the argument
 * to be of the type as prescribed by the second input argument
 * of the conversion function.
 * The corresponding arguments are then converted to the expected types
 * if needed.  The argument tuple first needs to be converted to a list
 * in order to be able to modify the entries.
 */
================================================================================

文件路径: ./interface/python.cc
注释行数: 12
注释内容:
/* Print a python method "name" corresponding to "fd" setting
 * the enum value "value".
 * "super" contains the superclasses of the class to which the method belongs,
 * with the first element corresponding to the annotation that appears
 * closest to the annotated type.
 *
 * The last argument of the C function does not appear in the method call,
 * but is fixed to "value" instead.
 * Other than that, the method printed here is similar to one
 * printed by python_generator::print_method, except that
 * some of the special cases do not occur.
 */
================================================================================

文件路径: ./interface/python.cc
注释行数: 15
注释内容:
/* Print declarations for methods printing the class representation,
 * provided there is a corresponding *_to_str function.
 *
 * In particular, provide an implementation of __str__ and __repr__ methods to
 * override the default representation used by python. Python uses __str__ to
 * pretty print the class (e.g., when calling print(obj)) and uses __repr__
 * when printing a precise representation of an object (e.g., when dumping it
 * in the REPL console).
 *
 * Check the type of the argument before calling the *_to_str function
 * on it in case the method was called on an object from a subclass.
 *
 * The return value of the *_to_str function is decoded to a python string
 * assuming an 'ascii' encoding.  This is necessary for python 3 compatibility.
 */
================================================================================

文件路径: ./interface/python.cc
注释行数: 10
注释内容:
/* Print code to set method type signatures.
 *
 * To be able to call C functions it is necessary to explicitly set their
 * argument and result types.  Do this for all exported constructors and
 * methods (including those that set a persistent callback and
 * those that set an enum value),
 * as well as for the *_to_str and the type function, if they exist.
 * Assuming each exported class has a *_copy and a *_free method,
 * also unconditionally set the type of such methods.
 */
================================================================================

文件路径: ./interface/python.cc
注释行数: 17
注释内容:
/* Print out the definition of this isl_class.
 *
 * We first check if this isl_class is a subclass of one or more other classes.
 * If it is, we make sure those superclasses are printed out first.
 *
 * Then we print a constructor with several cases, one for constructing
 * a Python object from a return value, one for each function that
 * was marked as a constructor and for each type based subclass.
 *
 * Next, we print out some common methods and the methods corresponding
 * to functions that are not marked as constructors, including those
 * that set a persistent callback and those that set an enum value.
 *
 * Finally, we tell ctypes about the types of the arguments of the
 * constructor functions and the return types of those function returning
 * an isl object.
 */
================================================================================

文件路径: ./interface/cpp.h
注释行数: 12
注释内容:
/* A generated method that performs one or more argument conversions and
 * then calls the original method.
 *
 * A ConversionMethod inherits from a NoCopyMethod, because
 * unlike methods that call an isl C function,
 * a conversion method never calls release() on an isl type argument,
 * so they can all be passed as const references.
 *
 * "this_type" is the name of the type to which "this" should be converted
 * (if different from clazz.name).
 * "get_param_fn" returns the method argument at position "pos".
 */
================================================================================

文件路径: ./interface/plain_cpp.cc
注释行数: 32
注释内容:
/*
 * Copyright 2016, 2017 Tobias Grosser. All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 *
 *    1. Redistributions of source code must retain the above copyright
 *       notice, this list of conditions and the following disclaimer.
 *
 *    2. Redistributions in binary form must reproduce the above
 *       copyright notice, this list of conditions and the following
 *       disclaimer in the documentation and/or other materials provided
 *       with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY TOBIAS GROSSER ''AS IS'' AND ANY
 * EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
 * PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL TOBIAS GROSSER OR
 * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
 * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
 * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA,
 * OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
 * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
 * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 *
 * The views and conclusions contained in the software and documentation
 * are those of the authors and should not be interpreted as
 * representing official policies, either expressed or implied, of
 * Tobias Grosser.
 */
================================================================================

文件路径: ./interface/plain_cpp.cc
注释行数: 10
注释内容:
/* Generate a cpp interface based on the extracted types and functions.
 *
 * Print first a set of forward declarations for all isl wrapper
 * classes, then the declarations of the classes, and at the end all
 * implementations.
 *
 * If checked C++ bindings are being generated,
 * then wrap them in a namespace to avoid conflicts
 * with the default C++ bindings (with automatic checks using exceptions).
 */
================================================================================

文件路径: ./interface/plain_cpp.cc
注释行数: 13
注释内容:
/* Print declarations for class "clazz" to "os".
 *
 * If "clazz" is a subclass based on a type function,
 * then it is made to inherit from the (immediate) superclass and
 * a "type" attribute is added for use in the "as" and "isa"
 * methods of the superclass.
 *
 * Conversely, if "clazz" is a superclass with a type function,
 * then declare those "as" and "isa" methods.
 *
 * The pointer to the isl object is only added for classes that
 * are not subclasses, since subclasses refer to the same isl object.
 */
================================================================================

文件路径: ./interface/plain_cpp.cc
注释行数: 19
注释内容:
/* Print global factory functions.
 *
 * Each class has two global factory functions:
 *
 * 	set manage(__isl_take isl_set *ptr);
 * 	set manage_copy(__isl_keep isl_set *ptr);
 *
 * A user can construct isl C++ objects from a raw pointer and indicate whether
 * they intend to take the ownership of the object or not through these global
 * factory functions. This ensures isl object creation is very explicit and
 * pointers are not converted by accident. Thanks to overloading, manage() and
 * manage_copy() can be called on any isl raw pointer and the corresponding
 * object is automatically created, without the user having to choose the right
 * isl object type.
 *
 * For a subclass based on a type function, no factory functions
 * are introduced because they share the C object type with
 * the superclass.
 */
================================================================================

文件路径: ./interface/plain_cpp.cc
注释行数: 13
注释内容:
/* Print declarations of protected constructors.
 *
 * Each class has currently one protected constructor:
 *
 * 	1) Constructor from a plain isl_* C pointer
 *
 * Example:
 *
 * 	set(__isl_take isl_set *ptr);
 *
 * The raw pointer constructor is kept protected. Object creation is only
 * possible through manage() or manage_copy().
 */
================================================================================

文件路径: ./interface/plain_cpp.cc
注释行数: 12
注释内容:
/* Print declarations of public constructors.
 *
 * Each class currently has two public constructors:
 *
 * 	1) A default constructor
 * 	2) A copy constructor
 *
 * Example:
 *
 *	set();
 *	set(const set &set);
 */
================================================================================

文件路径: ./interface/plain_cpp.cc
注释行数: 34
注释内容:
/* Print declaration of pointer functions.
 * Since type based subclasses share the pointer with their superclass,
 * they can also reuse these functions from the superclass.
 *
 * To obtain a raw pointer three functions are provided:
 *
 * 	1) __isl_give isl_set *copy()
 *
 * 	  Returns a pointer to a _copy_ of the internal object
 *
 * 	2) __isl_keep isl_set *get()
 *
 * 	  Returns a pointer to the internal object
 *
 * 	3) __isl_give isl_set *release()
 *
 * 	  Returns a pointer to the internal object and resets the
 * 	  internal pointer to nullptr.
 *
 * We also provide functionality to explicitly check if a pointer is
 * currently managed by this object.
 *
 * 	4) bool is_null()
 *
 * 	  Check if the current object is a null pointer.
 *
 * The functions get() and release() model the value_ptr proposed in
 * http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2012/n3339.pdf.
 * The copy() function is an extension to allow the user to explicitly
 * copy the underlying object.
 *
 * Also generate a declaration to delete copy() for r-values, for
 * r-values release() should be used to avoid unnecessary copies.
 */
================================================================================

文件路径: ./interface/plain_cpp.cc
注释行数: 11
注释内容:
/* Print a template declaration with given indentation
 * for the "isa_type" method that ensures it is only enabled
 * when called with a template argument
 * that represents a type that is equal to that
 * of the return type of the type function of "super".
 * In particular, "isa_type" gets called from "isa"
 * with as template argument the type of the "type" field
 * of the subclass.
 * The check ensures that this subclass is in fact a direct subclass
 * of "super".
 */
================================================================================

文件路径: ./interface/plain_cpp.cc
注释行数: 10
注释内容:
/* Print declarations for the "as" and "isa" methods, if the printed class
 * is a superclass with a type function.
 *
 * "isa" checks whether an object is of a given subclass type.
 * "isa_type" does the same, but gets passed the value of the type field
 * of the subclass as a function argument and the type of this field
 * as a template argument.
 * "as" tries to cast an object to a given subclass type, returning
 * an invalid object if the object is not of the given type.
 */
================================================================================

文件路径: ./interface/plain_cpp.cc
注释行数: 10
注释内容:
/* Given a method "method" for setting a persistent callback,
 * print the fields that are needed for marshalling the callback.
 *
 * In particular, print
 * - the declaration of a data structure for storing the C++ callback function
 * - a shared pointer to such a data structure
 * - the declaration of a static inline method
 *   for use as the C callback function
 * - the declaration of a private method for setting the callback function
 */
================================================================================

文件路径: ./interface/plain_cpp.cc
注释行数: 12
注释内容:
/* Print an operator for inserting objects of the class
 * into an output stream.
 *
 * Unless checked C++ bindings are being generated,
 * the operator requires its argument to be non-NULL.
 * An exception is thrown if anything went wrong during the printing.
 * During this printing, isl is made not to print any error message
 * because the error message is included in the exception.
 *
 * If checked C++ bindings are being generated and anything went wrong,
 * then record this failure in the output stream.
 */
================================================================================

文件路径: ./interface/plain_cpp.cc
注释行数: 18
注释内容:
/* Print implementation of global factory functions.
 *
 * Each class has two global factory functions:
 *
 * 	set manage(__isl_take isl_set *ptr);
 * 	set manage_copy(__isl_keep isl_set *ptr);
 *
 * Unless checked C++ bindings are being generated,
 * both functions require the argument to be non-NULL.
 * An exception is thrown if anything went wrong during the copying
 * in manage_copy.
 * During the copying, isl is made not to print any error message
 * because the error message is included in the exception.
 *
 * For a subclass based on a type function, no factory functions
 * are introduced because they share the C object type with
 * the superclass.
 */
================================================================================

文件路径: ./interface/plain_cpp.cc
注释行数: 17
注释内容:
/* Print implementations of public constructors.
 *
 * The pointer to the isl object is either initialized directly or
 * through the (immediate) superclass.
 *
 * If the class has any persistent callbacks, then copy them
 * from the original object in the copy constructor.
 * If the class is a subclass, then the persistent callbacks
 * are assumed to be copied by the copy constructor of the superclass.
 *
 * Throw an exception from the copy constructor if anything went wrong
 * during the copying or if the input is NULL, if any copying is performed.
 * During the copying, isl is made not to print any error message
 * because the error message is included in the exception.
 * No exceptions are thrown if checked C++ bindings
 * are being generated,
 */
================================================================================

文件路径: ./interface/plain_cpp.cc
注释行数: 21
注释内容:
/* Print definition for "method",
 * without any automatic type conversions.
 *
 * This method distinguishes three kinds of methods: member methods, static
 * methods, and constructors.
 *
 * Member methods and static methods return a newly managed
 * isl C++ object.
 *
 * Constructors create a new object from a given set of input parameters. They
 * do not return a value, but instead update the pointer stored inside the
 * newly created object.
 *
 * Unless checked C++ bindings are being generated,
 * the inputs of the method are first checked for being valid isl objects and
 * a copy of the associated isl::ctx is saved (if needed).
 * If any failure occurs, either during the check for the inputs or
 * during the isl function call, an exception is thrown.
 * During the function call, isl is made not to print any error message
 * because the error message is included in the exception.
 */
================================================================================

文件路径: ./interface/plain_cpp.cc
注释行数: 16
注释内容:
/* Print a definition for "method",
 * where "this" or at least one of the argument types needs to be converted.
 *
 * "method" is assumed to be a member method.
 *
 * The generated method performs the required conversion(s) and
 * calls the method generated without conversions.
 *
 * Perform a conversion from the argument in the method declaration
 * (as specified by Method::get_param) to the argument of the C function,
 * if needed.
 * Such a conversion may require the isl_ctx to be available.
 * In order to be able to use this isl_ctx, the current object needs
 * to valid.  The validity of other arguments is checked
 * by the called method.
 */
================================================================================

文件路径: ./interface/plain_cpp.cc
注释行数: 15
注释内容:
/* Print implementations for the "as" and "isa" methods, if the printed class
 * is a superclass with a type function.
 *
 * "isa" checks whether an object is of a given subclass type.
 * "isa_type" does the same, but gets passed the value of the type field
 * of the subclass as a function argument and the type of this field
 * as a template argument.
 * "as" casts an object to a given subclass type, erroring out
 * if the object is not of the given type.
 *
 * If the input is an invalid object, then these methods raise
 * an exception.
 * If checked bindings are being generated,
 * then an invalid boolean or object is returned instead.
 */
================================================================================

文件路径: ./interface/plain_cpp.cc
注释行数: 12
注释内容:
/* Print code for saving a copy of the isl::ctx available at the start
 * of the method "method" in a "saved_ctx" variable,
 * for use in exception handling.
 *
 * If checked bindings are being generated,
 * then the "saved_ctx" variable is not needed.
 * If "method" is a member function, then obtain the isl_ctx from
 * the "this" object.
 * If the first argument of the method is an isl::ctx, then use that one.
 * Otherwise, save a copy of the isl::ctx associated to the first argument
 * of isl object type.
 */
================================================================================

文件路径: ./interface/plain_cpp.cc
注释行数: 12
注释内容:
/* Print code to make isl not print an error message when an error occurs
 * within the current scope (if exceptions are available),
 * since the error message will be included in the exception.
 * If exceptions are not available, then exception::on_error
 * is set to ISL_ON_ERROR_ABORT and isl is therefore made to abort instead.
 *
 * If checked bindings are being generated,
 * then leave it to the user to decide what isl should do on error.
 * Otherwise, assume that a valid isl::ctx is available
 * in the "saved_ctx" variable,
 * e.g., through a prior call to print_save_ctx.
 */
================================================================================

文件路径: ./interface/plain_cpp.cc
注释行数: 17
注释内容:
/* Print code that checks whether the execution of the core of "method"
 * was successful.
 *
 * If checked bindings are being generated,
 * then no checks are performed.
 *
 * Otherwise, first check if any of the callbacks failed with
 * an exception.  If so, the "eptr" in the corresponding data structure
 * contains the exception that was caught and that needs to be rethrown.
 * Then check if the function call failed in any other way and throw
 * the appropriate exception.
 * In particular, if the return type is isl_stat, isl_bool or isl_size,
 * then a negative value indicates a failure.  If the return type
 * is an isl type, then a NULL value indicates a failure.
 * Assume print_save_ctx has made sure that a valid isl::ctx
 * is available in the "ctx" variable.
 */
================================================================================

文件路径: ./interface/plain_cpp.cc
注释行数: 19
注释内容:
/* Print the return statement of the C++ method "method".
 *
 * The result of the corresponding isl function is returned as a new
 * object if the underlying isl function returns an isl_* ptr, as a bool
 * if the isl function returns an isl_bool, as void if the isl functions
 * returns an isl_stat,
 * as std::string if the isl function returns 'const char *', and as
 * unmodified return value otherwise.
 * If checked C++ bindings are being generated,
 * then an isl_bool return type is transformed into a boolean and
 * an isl_stat into a stat since no exceptions can be generated
 * on negative results from the isl function.
 * If the method returns a new instance of the same object type and
 * if the class has any persistent callbacks, then the data
 * for these callbacks are copied from the original to the new object.
 * If "clazz" is a subclass that is based on a type function and
 * if the return type corresponds to the superclass data type,
 * then it is replaced by the subclass data type.
 */
================================================================================

文件路径: ./interface/plain_cpp.cc
注释行数: 10
注释内容:
/* Print the call to the C++ callback function "call",
 * with the given indentation, wrapped
 * for use inside the lambda function that is used as the C callback function,
 * in the case where checked C++ bindings are being generated.
 *
 * In particular, print
 *
 *        auto ret = @call@;
 *        return ret.release();
 */
================================================================================

文件路径: ./interface/plain_cpp.cc
注释行数: 38
注释内容:
/* Print the call to the C++ callback function "call",
 * with the given indentation and with return type "rtype", wrapped
 * for use inside the lambda function that is used as the C callback function.
 *
 * In particular, print
 *
 *        ISL_CPP_TRY {
 *          @call@;
 *          return isl_stat_ok;
 *        } ISL_CPP_CATCH_ALL {
 *          data->eptr = std::current_exception();
 *          return isl_stat_error;
 *        }
 * or
 *        ISL_CPP_TRY {
 *          auto ret = @call@;
 *          return ret ? isl_bool_true : isl_bool_false;
 *        } ISL_CPP_CATCH_ALL {
 *          data->eptr = std::current_exception();
 *          return isl_bool_error;
 *        }
 * or
 *        ISL_CPP_TRY {
 *          auto ret = @call@;
 *          return ret.release();
 *        } ISL_CPP_CATCH_ALL {
 *          data->eptr = std::current_exception();
 *          return NULL;
 *        }
 *
 * depending on the return type.
 *
 * where ISL_CPP_TRY is defined to "try" and ISL_CPP_CATCH_ALL to "catch (...)"
 * (if exceptions are available).
 *
 * If checked C++ bindings are being generated, then
 * the call is wrapped differently.
 */
================================================================================

文件路径: ./interface/plain_cpp.cc
注释行数: 22
注释内容:
/* Print the declaration for a "prefix"_data data structure
 * that can be used for passing to a C callback function
 * containing a copy of the C++ callback function "param",
 * along with an std::exception_ptr that is used to store any
 * exceptions thrown in the C++ callback.
 *
 * If the C callback is of the form
 *
 *      isl_stat (*fn)(__isl_take isl_map *map, void *user)
 *
 * then the following declaration is printed:
 *
 *      struct <prefix>_data {
 *        std::function<stat(map)> func;
 *        std::exception_ptr eptr;
 *      }
 *
 * (without a newline or a semicolon).
 *
 * The std::exception_ptr object is not added to "prefix"_data
 * if checked C++ bindings are being generated.
 */
================================================================================

文件路径: ./interface/plain_cpp.cc
注释行数: 14
注释内容:
/* Given a group of methods with the same name,
 * should extra methods be added that take as arguments
 * those types that can be converted to the original argument type
 * through a unary constructor?
 *
 * Note that even if this method returns true,
 * the extra methods are only printed by the caller
 * if exactly one of the methods in the group was originally defined
 * in the printed class.
 * Signal that they should be printed if the group contains
 * both methods originally defined in the printed class and
 * methods that have been copied from an ancestor
 * by checking whether there are at least two methods in the group.
 */
================================================================================

文件路径: ./interface/plain_cpp.cc
注释行数: 28
注释内容:
/* Print the body of C function callback with the given indentation
 * that can be use as an argument to "param" for marshalling
 * the corresponding C++ callback.
 * The data structure that contains the C++ callback is of type
 * "prefix"_data.
 *
 * For a callback of the form
 *
 *      isl_stat (*fn)(__isl_take isl_map *map, void *user)
 *
 * the following code is generated:
 *
 *        auto *data = static_cast<struct <prefix>_data *>(arg_1);
 *        ISL_CPP_TRY {
 *          stat ret = (data->func)(manage(arg_0));
 *          return isl_stat_ok;
 *        } ISL_CPP_CATCH_ALL {
 *          data->eptr = std::current_exception();
 *          return isl_stat_error;
 *        }
 *
 * If checked C++ bindings are being generated, then
 * generate the following code:
 *
 *        auto *data = static_cast<struct <prefix>_data *>(arg_1);
 *        stat ret = (data->func)(manage(arg_0));
 *        return isl_stat(ret);
 */
================================================================================

文件路径: ./interface/plain_cpp.cc
注释行数: 50
注释内容:
/* Print the local variables that are needed for a callback argument,
 * in particular, print a lambda function that wraps the callback and
 * a pointer to the actual C++ callback function.
 *
 * For a callback of the form
 *
 *      isl_stat (*fn)(__isl_take isl_map *map, void *user)
 *
 * the following lambda function is generated:
 *
 *      auto fn_lambda = [](isl_map *arg_0, void *arg_1) -> isl_stat {
 *        auto *data = static_cast<struct fn_data *>(arg_1);
 *        try {
 *          stat ret = (data->func)(manage(arg_0));
 *          return isl_stat_ok;
 *        } catch (...) {
 *          data->eptr = std::current_exception();
 *          return isl_stat_error;
 *        }
 *      };
 *
 * A copy of the std::function C++ callback function is stored in
 * a fn_data data structure for passing to the C callback function,
 * along with an std::exception_ptr that is used to store any
 * exceptions thrown in the C++ callback.
 *
 *      struct fn_data {
 *        std::function<stat(map)> func;
 *        std::exception_ptr eptr;
 *      } fn_data = { fn };
 *
 * This std::function object represents the actual user
 * callback function together with the locally captured state at the caller.
 *
 * The lambda function is expected to be used as a C callback function
 * where the lambda itself is provided as the function pointer and
 * where the user void pointer is a pointer to fn_data.
 * The std::function object is extracted from the pointer to fn_data
 * inside the lambda function.
 *
 * The std::exception_ptr object is not added to fn_data
 * if checked C++ bindings are being generated.
 * The body of the generated lambda function then is as follows:
 *
 *        stat ret = (data->func)(manage(arg_0));
 *        return isl_stat(ret);
 *
 * If the C callback does not take its arguments, then
 * manage_copy is used instead of manage.
 */
================================================================================

文件路径: ./interface/cpp_conversion.cc
注释行数: 15
注释内容:
/* Print functions for converting objects of "clazz"
 * between the default and the checked C++ bindings.
 *
 * The conversion from default to checked is called "check".
 * The inverse conversion is called "uncheck".
 * For example, to "set", the following two functions are generated:
 *
 *	checked::set check(set obj) {
 *		return checked::manage(obj.copy());
 *	}
 *
 *	set uncheck(checked::set obj) {
 *		return manage(obj.copy());
 *	}
 */
================================================================================

文件路径: ./interface/cpp.cc
注释行数: 32
注释内容:
/*
 * Copyright 2016, 2017 Tobias Grosser. All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 *
 *    1. Redistributions of source code must retain the above copyright
 *       notice, this list of conditions and the following disclaimer.
 *
 *    2. Redistributions in binary form must reproduce the above
 *       copyright notice, this list of conditions and the following
 *       disclaimer in the documentation and/or other materials provided
 *       with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY TOBIAS GROSSER ''AS IS'' AND ANY
 * EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
 * PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL TOBIAS GROSSER OR
 * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
 * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
 * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA,
 * OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
 * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
 * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 *
 * The views and conclusions contained in the software and documentation
 * are those of the authors and should not be interpreted as
 * representing official policies, either expressed or implied, of
 * Tobias Grosser.
 */
================================================================================

文件路径: ./interface/cpp.cc
注释行数: 10
注释内容:
/* Construct a generator for C++ bindings.
 *
 * The classes and methods are extracted by the constructor
 * of the generator superclass.
 *
 * Additionally extract information about types
 * that can be converted to a class and copy all methods
 * from superclasses that can be converted to a given class
 * to that class.
 */
================================================================================

文件路径: ./interface/cpp.cc
注释行数: 15
注释内容:
/* Is the method derived from "fd", with method name "name" and
 * with distance to the original ancestor "depth",
 * overridden by a method already in "clazz"?
 *
 * A method is considered to have been overridden if there
 * is a method with the same name in "clazz" that has the same signature and
 * that comes from an ancestor closer to "clazz",
 * where an ancestor is closer if the distance in the class hierarchy
 * is smaller or the distance is the same and the ancestor appears
 * closer in the declaration of the type (in which case it gets added first).
 *
 * If a method with the same signature has already been added,
 * but it does not override the method derived from "fd",
 * then this method is removed since it is overridden by "fd".
 */
================================================================================

文件路径: ./interface/cpp.cc
注释行数: 10
注释内容:
/* Copy methods from the superclasses of "clazz"
 * if an object of this class can be implicitly converted to an object
 * from the superclass, keeping track
 * of the classes that have already been handled in "done".
 *
 * Make sure the superclasses have copied methods from their superclasses first
 * since those methods could be copied further down to this class.
 *
 * Consider the superclass that appears closest to the subclass first.
 */
================================================================================

文件路径: ./interface/cpp.cc
注释行数: 11
注释内容:
/* For each (proper) class, copy methods from its superclasses,
 * if an object from the class can be converted to an object
 * from the superclass.
 *
 * Type based subclasses are not considered for now since
 * they do not have any explicit superclasses.
 *
 * Iterate through all (proper) classes and copy methods
 * from their superclasses,
 * unless they have already been determined by a recursive call.
 */
================================================================================

文件路径: ./interface/cpp.cc
注释行数: 12
注释内容:
/* Print declarations or implementations of constructors.
 *
 * For each isl function that is marked as __isl_constructor,
 * add a corresponding C++ constructor.
 *
 * Example of declarations:
 *
 * 	inline /\* implicit *\/ union_set(basic_set bset);
 * 	inline /\* implicit *\/ union_set(set set);
 * 	inline explicit val(ctx ctx, long i);
 * 	inline explicit val(ctx ctx, const std::string &str);
 */
================================================================================

文件路径: ./interface/cpp.cc
注释行数: 16
注释内容:
/* Update "convert" to reflect the next combination of automatic conversions
 * for the arguments of "fd",
 * returning false if there are no more combinations.
 *
 * In particular, find the last argument for which an automatic
 * conversion function is available mapping to the type of this argument and
 * that is not already marked for conversion.
 * Mark this argument, if any, for conversion and clear the markings
 * of all subsequent arguments.
 * Repeated calls to this method therefore run through
 * all possible combinations.
 *
 * Note that the first function argument is never considered
 * for automatic conversion since this is the argument
 * from which the isl_ctx used in the conversion is extracted.
 */
================================================================================

文件路径: ./interface/cpp.cc
注释行数: 22
注释内容:
/* Print a declaration or definition for a method called "name"
 * derived from "fd".
 *
 * If the method was copied from a superclass, then print a definition
 * that calls the corresponding method in the superclass.
 * Otherwise, for methods that are identified as "get" methods, also
 * print a declaration or definition for the method
 * using a name that includes the "get_" prefix.
 *
 * If the generated method is an object method, then check
 * whether any of its arguments can be automatically converted
 * from something else, and, if so, generate a method
 * for each combination of converted arguments.
 * Do so by constructing a ConversionMethod that changes the converted arguments
 * to those of the sources of the conversions.
 *
 * Note that a method may be both copied from a superclass and
 * have arguments that can be automatically converted.
 * In this case, the conversion methods for the arguments
 * call the corresponding method in this class, which
 * in turn will call the method in the superclass.
 */
================================================================================

文件路径: ./interface/cpp.cc
注释行数: 21
注释内容:
/* Print the use of the argument at position "pos" to "os".
 *
 * Member methods pass the isl object corresponding to "this"
 * as first argument (at position 0).
 * Any other arguments are passed along from the method arguments.
 *
 * If the argument value is loaded from a this pointer, the original
 * value must be preserved and must consequently be copied.  Values that are
 * loaded from method parameters do not need to be preserved, as such values
 * will already be copies of the actual parameters.  It is consequently possible
 * to directly take the pointer from these values, which saves
 * an unnecessary copy.
 *
 * In case the parameter is a callback function, two parameters get printed,
 * a wrapper for the callback function and a pointer to the actual
 * callback function.  The wrapper is expected to be available
 * in a previously declared variable <name>_lambda, while
 * the actual callback function is expected to be stored
 * in a structure called <name>_data.
 * The caller of this function must ensure that these variables exist.
 */
================================================================================

文件路径: ./interface/cpp.cc
注释行数: 43
注释内容:
/* Print the header for "method", without newline or semicolon,
 * using "type_printer" to print argument and return types.
 *
 * Print the header of a declaration if this->declarations is set,
 * otherwise print the header of a method definition.
 *
 * This function prints headers for member methods, static methods, and
 * constructors, either for their declaration or definition.
 *
 * Member functions are declared as "const", as they do not change the current
 * object, but instead create a new object. They always retrieve the first
 * parameter of the original isl function from the this-pointer of the object,
 * such that only starting at the second parameter the parameters of the
 * original function become part of the method's interface.
 *
 * A function
 *
 * 	__isl_give isl_set *isl_set_intersect(__isl_take isl_set *s1,
 * 		__isl_take isl_set *s2);
 *
 * is translated into:
 *
 * 	inline set intersect(set set2) const
 *
 * For static functions and constructors all parameters of the original isl
 * function are exposed.
 *
 * Parameters of which no copy is required, are passed
 * as const reference, which allows the compiler to optimize the parameter
 * transfer.
 *
 * Constructors are marked as explicit using the C++ keyword 'explicit' or as
 * implicit using a comment in place of the explicit keyword. By annotating
 * implicit constructors with a comment, users of the interface are made
 * aware of the potential danger that implicit construction is possible
 * for these constructors, whereas without a comment not every user would
 * know that implicit construction is allowed in absence of an explicit keyword.
 *
 * Note that in case "method" is a ConversionMethod, the argument returned
 * by Method::get_param may be different from the original argument.
 * The name of the argument is, however, derived from the original
 * function argument.
 */
================================================================================

文件路径: ./interface/cpp.cc
注释行数: 16
注释内容:
/* Generate the list of argument types for a callback function of
 * type "type", appearing in argument position "arg".
 * If "cpp" is set, then generate the C++ type list, otherwise
 * the C type list.
 *
 * For a callback of type
 *
 *      isl_stat (*)(__isl_take isl_map *map, void *user)
 *
 * the following C++ argument list is generated:
 *
 *      map
 *
 * The arguments of the callback are considered to appear
 * after the position of the callback itself.
 */
================================================================================

文件路径: ./interface/cpp.cc
注释行数: 11
注释内容:
/* Generate the full cpp type of a callback function of type "type",
 * appearing in argument position "arg".
 *
 * For a callback of type
 *
 *      isl_stat (*)(__isl_take isl_map *map, void *user)
 *
 * the following type is generated:
 *
 *      std::function<stat(map)>
 */
================================================================================

文件路径: ./interface/cpp.cc
注释行数: 12
注释内容:
/* Return the number of parameters of the corresponding C function.
 *
 * If the method has a callback argument, we reduce the number of parameters
 * that are exposed by one to hide the user pointer from the interface. On
 * the C++ side no user pointer is needed, as arguments can be forwarded
 * as part of the std::function argument which specifies the callback function.
 *
 * The user pointer is also removed from the number of parameters
 * of the C function because the pair of callback and user pointer
 * is considered as a single argument that is printed as a whole
 * by Method::print_param_use.
 */
================================================================================

文件路径: ./interface/cpp.cc
注释行数: 12
注释内容:
/* Should the parameter at position "pos" be a copy (rather than
 * a const reference)?
 *
 * Strictly speaking, a copy is only needed on isl types that are
 * not marked __isl_keep, since those will be release()'d
 * by code printed by Method::print_param_use.
 *
 * However, there may be other arguments such as integer types
 * that are more naturally passed as a copy.
 * The default is therefore to require a copy, except for
 * arguments marked __isl_keep, string arguments or callback arguments.
 */
================================================================================

文件路径: ./interface/generator.h
注释行数: 33
注释内容:
/* isl_class collects all constructors and methods for an isl "class".
 * "name" is the name of the class.
 * If this object describes a subclass of a C type, then
 * "subclass_name" is the name of that subclass and "superclass_name"
 * is the name of the immediate superclass of that subclass.  Otherwise,
 * "subclass_name" is equal to "name" and "superclass_name" is undefined.
 * "type" is the declaration that introduces the type.
 * "persistent_callbacks" contains the set of functions that
 * set a persistent callback.
 * "set_enums" maps the set of functions that set an enum value
 * to information associated to each value.
 * A function is considered to set an enum value if it returns
 * an object of the same type and if its last argument is of an enum type.
 * "methods" contains the set of methods, grouped by method name.
 * "fn_to_str" is a reference to the *_to_str method of this class, if any.
 * "fn_copy" is a reference to the *_copy method of this class, if any.
 * "fn_free" is a reference to the *_free method of this class, if any.
 * "fn_type" is a reference to a function that described subclasses, if any.
 * If "fn_type" is set, then "type_subclasses" maps the values returned
 * by that function to the names of the corresponding subclasses.
 *
 * The following fields are only used for the C++ bindings.
 * For methods that are not derived from a function that applies
 * directly to this class, but are rather copied from some ancestor,
 * "copied_from" records the direct superclass from which the method
 * was copied (where it may have been copied from a further ancestor) and
 * "copy_depth" records the distance to the ancestor to which
 * the function applies.
 * "construction_types" contains the set of isl classes that can be
 * implicitly converted to this class through a unary constructor,
 * mapped to the single argument
 * of this unary constructor.
 */
================================================================================

文件路径: ./include/isl/hmap_templ.c
注释行数: 11
注释内容:
/*
 * Copyright 2011      INRIA Saclay
 * Copyright 2013      Ecole Normale Superieure
 *
 * Use of this software is governed by the MIT license
 *
 * Written by Sven Verdoolaege, INRIA Saclay - Ile-de-France,
 * Parc Club Orsay Universite, ZAC des vignes, 4 rue Jacques Monod,
 * 91893 Orsay, France
 * and Ecole Normale Superieure, 45 rue d’Ulm, 75230 Paris, France
 */
================================================================================

文件路径: ./include/isl/ctx.h
注释行数: 24
注释内容:
/* Nearly all isa functions require a struct isl_ctx allocated using
 * isl_ctx_alloc.  This ctx contains (or will contain) options that
 * control the behavior of the library and some caches.
 *
 * An object allocated within a given ctx should never be used inside
 * another ctx.  Functions for moving objects from one ctx to another
 * will be added as the need arises.
 *
 * A given context should only be used inside a single thread.
 * A global context for synchronization between different threads
 * as well as functions for moving a context to a different thread
 * will be added as the need arises.
 *
 * If anything goes wrong (out of memory, failed assertion), then
 * the library will currently simply abort.  This will be made
 * configurable in the future.
 * Users of the library should expect functions that return
 * a pointer to a structure, to return NULL, indicating failure.
 * Any function accepting a pointer to a structure will treat
 * a NULL argument as a failure, resulting in the function freeing
 * the remaining structures (if any) and returning NULL itself
 * (in case of pointer return type).
 * The only exception is the isl_ctx argument, which should never be NULL.
 */
================================================================================

文件路径: ./include/isl/root_headfile/isl_stream_private.h
注释行数: 17
注释内容:
/* An input stream that may be either a file or a string.
 *
 * line and col are the line and column number of the next character (1-based).
 * start_line and start_col are set by isl_stream_getc to point
 * to the position of the returned character.
 * last_line is the line number of the previous token.
 *
 * yaml_state and yaml_indent keep track of the currently active YAML
 * elements.  yaml_size is the size of these arrays, while yaml_depth
 * is the number of elements currently in use.
 * yaml_state and yaml_indent may be NULL if no YAML parsing is being
 * performed.
 * yaml_state keeps track of what is expected next at each level.
 * yaml_indent keeps track of the indentation at each level, with
 * ISL_YAML_INDENT_FLOW meaning that the element is in flow format
 * (such that the indentation is not relevant).
 */
================================================================================

文件路径: ./include/isl/root_headfile/isl_map_private.h
注释行数: 10
注释内容:
/* A "basic map" is a relation between two sets of variables,
 * called the "in" and "out" variables.
 * A "basic set" is a basic map with a zero-dimensional
 * domain.
 *
 * It is implemented as a set with two extra fields:
 * n_in is the number of in variables
 * n_out is the number of out variables
 * n_in + n_out should be equal to set.dim
 */
================================================================================

文件路径: ./include/isl/root_headfile/isl_map_private.h
注释行数: 11
注释内容:
/* A "map" is a (possibly disjoint) union of basic maps.
 * A "set" is a (possibly disjoint) union of basic sets.
 *
 * Currently, the isl_set structure is identical to the isl_map structure
 * and the library depends on this correspondence internally.
 * However, users should not depend on this correspondence.
 *
 * "cached_simple_hull" contains copies of the unshifted and shifted
 * simple hulls, if they have already been computed.  Otherwise,
 * the entries are NULL.
 */
================================================================================

文件路径: ./include/isl/root_headfile/isl_schedule_tree.h
注释行数: 40
注释内容:
/* A schedule (sub)tree.
 *
 * The leaves of a tree are not explicitly represented inside
 * the isl_schedule_tree, except when the tree consists of only a leaf.
 *
 * The "band" field is valid when type is isl_schedule_node_band.
 * The "context" field is valid when type is isl_schedule_node_context
 * and represents constraints on the flat product of the outer band nodes,
 * possibly introducing additional parameters.
 * The "domain" field is valid when type is isl_schedule_node_domain
 * and introduces the statement instances scheduled by the tree.
 *
 * The "contraction" and "expansion" fields are valid when type
 * is isl_schedule_node_expansion.
 * "expansion" expands the reaching domain elements to one or more
 * domain elements for the subtree.
 * "contraction" maps these elements back to the corresponding
 * reaching domain element.  It does not involve any domain constraints.
 *
 * The "extension" field is valid when the is isl_schedule_node_extension
 * maps outer schedule dimensions (the flat product of the outer band nodes)
 * to additional iteration domains.
 *
 * The "filter" field is valid when type is isl_schedule_node_filter
 * and represents the statement instances selected by the node.
 *
 * The "guard" field is valid when type is isl_schedule_node_guard
 * and represents constraints on the flat product of the outer band nodes
 * that need to be enforced by the outer nodes in the generated AST.
 *
 * The "mark" field is valid when type is isl_schedule_node_mark and
 * identifies the mark.
 *
 * The "children" field is valid for all types except
 * isl_schedule_node_leaf.  This field is NULL if there are
 * no children (except for the implicit leaves).
 *
 * anchored is set if the node or any of its descendants depends
 * on its position in the schedule tree.
 */
================================================================================

文件路径: ./include/isl/root_headfile/isl_multi_templ.h
注释行数: 10
注释内容:
/* A multiple expression with base expressions of type EL.
 *
 * "space" is the space in which the multiple expression lives.
 * "n" is the number of base expression and is equal
 * to the output or set dimension of "space".
 * "p" is an array of size "n" of base expressions.
 * The array is only accessible when n > 0.
 * "dom" is the explicit domain, if present
 * The explicit domain is only accessible when n == 0.
 */
================================================================================

文件路径: ./include/isl/root_headfile/isl_ast_build_private.h
注释行数: 134
注释内容:
/* An isl_ast_build represents the context in which AST is being
 * generated.  That is, it (mostly) contains information about outer
 * loops that can be used to simplify inner loops.
 *
 * "domain" represents constraints on the internal schedule domain,
 * corresponding to the context of the AST generation and the constraints
 * implied by the loops that have already been generated.
 * When an isl_ast_build is first created, outside any AST generation,
 * the domain is typically a parameter set.  It is only when a AST
 * generation phase is initiated that the domain of the isl_ast_build
 * is changed to refer to the internal schedule domain.
 * The domain then lives in a space of the form
 *
 *	S
 *
 *  or
 *
 *	[O -> S]
 *
 * O represents the loops generated in outer AST generations.
 * S represents the loops (both generated and to be generated)
 * of the current AST generation.
 * Both include eliminated loops.
 * "domain" is expected not to have any unknown divs because
 * it is used as the context argument in a call to isl_basic_set_gist
 * in isl_ast_build_compute_gist_basic_set.
 *
 * "depth" is equal to the number of loops that have already
 * been generated (including those in outer AST generations).
 * "outer_pos" is equal to the number of loops in outer AST generations.
 *
 * "generated" is a superset of "domain" corresponding to those
 * constraints that were either given by the user or that have
 * effectively been generated (as bounds on a for loop).
 *
 * "pending" is a superset of "domain" corresponding to the constraints
 * that still need to be generated (as guards), but that may end up
 * not getting generated if they are implied by any constraints
 * enforced by inner loops.
 *
 * "strides" contains the stride of each loop.  The number of elements
 * is equal to the number of dimensions in "domain".
 * "offsets" contains the offsets of strided loops.  If s is the stride
 * for a given dimension and f is the corresponding offset, then the
 * dimension takes on values
 *
 *	f + s a
 *
 * with a an integer.  For non-strided loops, the offset is zero.
 *
 * "iterators" contains the loop iterators of both generated and
 * to be generated loops.  The number of elements is at least as
 * large as the dimension of the internal schedule domain.  The
 * number may be larger, in which case the additional ids can be
 * used in a nested AST generation should the schedule be non-injective.
 *
 * "values" lives in the space
 *
 *	[O -> S] -> [O -> S]		(or S -> S)
 *
 * and expresses (if possible) loop iterators in terms of parameters
 * and outer loop iterators.  If the value of a given loop iterator
 * cannot be expressed as an affine expression (either because the iterator
 * attains multiple values or because the single value is a piecewise
 * affine expression), then it is expressed in "values" as being equal
 * to itself.
 *
 * "value" is the value of the loop iterator at the current depth.
 * It is NULL if it has not been computed yet or if the value of the
 * given loop iterator cannot be expressed as a piecewise affine expression
 * (because the iterator attains multiple values).
 *
 * "schedule_map" maps the internal schedule domain to the external schedule
 * domain.  It may be NULL if it hasn't been computed yet.
 * See isl_ast_build_get_schedule_map_multi_aff.
 *
 * "internal2input" maps the internal schedule domain to the original
 * input schedule domain.  In case of a schedule tree input, the original
 * input schedule domain consist of the flat product of all outer
 * band node spaces, including the current band node.
 * It may be NULL if there no longer is such a uniform mapping
 * (because different iterations have been rescheduled differently).
 *
 * "options" contains the AST build options in case we are generating
 * an AST from a flat schedule map.  When creating an AST from a schedule
 * tree, this field is ignored.
 *
 * The "create_leaf" callback is called for every leaf in the generated AST.
 * The callback is responsible for creating the node to be placed at those
 * leaves.  If this callback is not set, then isl will generated user
 * nodes with call expressions corresponding to an element of the domain.
 *
 * The "at_each_domain" callback is called on every node created to represent
 * an element of the domain.  Each of these nodes is a user node
 * with as expression a call expression.
 *
 * The "before_each_for" callback is called on each for node before
 * its children have been created.
 *
 * The "after_each_for" callback is called on each for node after
 * its children have been created.
 *
 * The "before_each_mark" callback is called before we handle the subtree
 * of an isl_schedule_node_mark node.
 *
 * The "after_each_mark" callback is called after we have handled the subtree
 * of an isl_schedule_node_mark node.
 *
 * "executed" contains the inverse schedule at this point
 * of the AST generation.
 * It is currently only used in isl_ast_build_get_schedule, which is
 * in turn only used by user code from within a callback.
 * The value is set right before we may be calling such a callback.
 *
 * "single_valued" is set if the current inverse schedule (which may or may
 * not be stored in "executed") is known to be single valued, specifically
 * an inverse schedule that was not (appeared not to be) single valued
 * is extended to a single valued inverse schedule.  This is mainly used
 * to avoid an infinite recursion when we fail to detect later on that
 * the extended inverse schedule is single valued.
 *
 * "node" points to the current band node in case we are generating
 * an AST from a schedule tree.  It may be NULL if we are not generating
 * an AST from a schedule tree or if we are not inside a band node.
 *
 * "loop_type" originally contains loop AST generation types for
 * the "n" members of "node" and it is updated (along with "n") when
 * a schedule dimension is inserted.
 * It is NULL if "node" is NULL.
 *
 * "isolated" is the piece of the schedule domain isolated by the isolate
 * option on the current band.  This set may be NULL if we have not checked
 * for the isolate option yet.
 */
================================================================================

文件路径: ./include/isl/root_headfile/isl_schedule_band.h
注释行数: 21
注释内容:
/* Information about a band within a schedule.
 *
 * n is the number of scheduling dimensions within the band.
 * coincident is an array of length n, indicating whether a scheduling dimension
 *	satisfies the coincidence constraints in the sense that
 *	the corresponding dependence distances are zero.
 * permutable is set if the band is permutable.
 * mupa is the partial schedule corresponding to this band.  The dimension
 *	of mupa is equal to n.
 * loop_type contains the loop AST generation types for the members
 * in the band.  It may be NULL, if all members are
 * of type isl_ast_loop_default.
 * isolate_loop_type contains the loop AST generation types for the members
 * in the band for the isolated part.  It may be NULL, if all members are
 * of type isl_ast_loop_default.
 * ast_build_options are the remaining AST build options associated
 * to the band.
 * anchored is set if the node depends on its position in the schedule tree.
 *	In particular, it is set if the AST build options include
 *	an isolate option.
 */
================================================================================

文件路径: ./include/isl/root_headfile/isl_output_private.h
注释行数: 11
注释内容:
/* Internal data structure for isl_print_space.
 *
 * latex is set if that is the output format.
 * print_dim (if not NULL) is called on each dimension.
 * user is set by the caller of print_space and may be used inside print_dim.
 *
 * space is the global space that is being printed.  This field is set by
 *	print_space.
 * type is the tuple of the global space that is currently being printed.
 *	This field is set by print_space.
 */
================================================================================

文件路径: ./include/isl/root_headfile/isl_ast_graft_private.h
注释行数: 15
注释内容:
/* Representation of part of an AST ("node") with some additional polyhedral
 * information about the tree.
 *
 * "guard" contains conditions that should still be enforced by
 * some ancestor of the current tree.  In particular, the already
 * generated tree assumes that these conditions hold, but may not
 * have enforced them itself.
 * The guard should not contain any unknown divs as it will be used
 * to generate an if condition.
 *
 * "enforced" expresses constraints that are already enforced by the for
 * nodes in the current tree and that therefore do not need to be enforced
 * by any ancestor.
 * The constraints only involve outer loop iterators.
 */
================================================================================

文件路径: ./include/isl/root_headfile/isl_tarjan.h
注释行数: 10
注释内容:
/* Structure for representing the graph being traversed
 * using Tarjan's algorithm.
 * len is the number of nodes
 * node is an array of nodes
 * stack contains the nodes on the path from the root to the current node
 * sp is the stack pointer
 * index is the index of the last node visited
 * order contains the elements of the components separated by -1
 * op represents the current position in order
 */
================================================================================

文件路径: ./include/isl/root_headfile/isl_int_sioimath.h
注释行数: 41
注释内容:
/* The type to represent integers optimized for small values. It is either a
 * pointer to an mp_int ( = mpz_t*; big representation) or an int32_t (small
 * represenation) with a discriminator at the least significant bit. In big
 * representation it will be always zero because of heap alignment. It is set
 * to 1 for small representation and use the 32 most significant bits for the
 * int32_t.
 *
 * Structure on 64 bit machines, with 8-byte aligment (3 bits):
 *
 * Big representation:
 * MSB                                                          LSB
 * |------------------------------------------------------------000
 * |                            mpz_t*                            |
 * |                           != NULL                            |
 *
 * Small representation:
 * MSB                           32                             LSB
 * |------------------------------|00000000000000000000000000000001
 * |          int32_t             |
 * |  2147483647 ... -2147483647  |
 *                                                                ^
 *                                                                |
 *                                                        discriminator bit
 *
 * On 32 bit machines isl_sioimath type is blown up to 8 bytes, i.e.
 * isl_sioimath is guaranteed to be at least 8 bytes. This is to ensure the
 * int32_t can be hidden in that type without data loss. In the future we might
 * optimize this to use 31 hidden bits in a 32 bit pointer. We may also use 63
 * bits on 64 bit machines, but this comes with the cost of additional overflow
 * checks because there is no standardized 128 bit integer we could expand to.
 *
 * We use native integer types and avoid union structures to avoid assumptions
 * on the machine's endianness.
 *
 * This implementation makes the following assumptions:
 * - long can represent any int32_t
 * - mp_small is signed long
 * - mp_usmall is unsigned long
 * - adresses returned by malloc are aligned to 2-byte boundaries (leastmost
 *   bit is zero)
 */
================================================================================

文件路径: ./include/isl/root_headfile/isl_int_sioimath.h
注释行数: 11
注释内容:
/* The negation of the smallest possible number in int32_t, INT32_MIN
 * (0x80000000u, -2147483648), cannot be represented in an int32_t, therefore
 * every operation that may produce this value needs to special-case it.
 * The operations are:
 * abs(INT32_MIN)
 * -INT32_MIN   (negation)
 * -1 * INT32_MIN (multiplication)
 * INT32_MIN/-1 (any division: divexact, fdiv, cdiv, tdiv)
 * To avoid checking these cases, we exclude INT32_MIN from small
 * representation.
 */
================================================================================

文件路径: ./include/isl/root_headfile/isl_int_sioimath.h
注释行数: 22
注释内容:
/* A common situation is to call an IMath function with at least one argument
 * that is currently in small representation or an integer parameter, i.e. a big
 * representation of the same number is required. Promoting the original
 * argument comes with multiple problems, such as modifying a read-only
 * argument, the responsibility of deallocation and the execution cost. Instead,
 * we make a copy by 'faking' the IMath internal structure.
 *
 * We reserve the maximum number of required digits on the stack to avoid heap
 * allocations.
 *
 * mp_digit can be uint32_t or uint16_t. This code must work for little and big
 * endian digits. The structure for an uint64_t argument and 32-bit mp_digits is
 * sketched below.
 *
 * |----------------------------|
 *            uint64_t
 *
 * |-------------||-------------|
 *    mp_digit        mp_digit
 *    digits[1]       digits[0]
 * Most sig digit  Least sig digit
 */
================================================================================

文件路径: ./include/isl/root_headfile/isl_int_sioimath.h
注释行数: 12
注释内容:
/* Convert a native integer to IMath's digit representation. A native integer
 * might be big- or little endian, but IMath always stores the least significant
 * digit in the lowest array indices.  memcpy therefore is not possible.
 *
 * We also have to consider that long and mp_digit can be of different sizes,
 * depending on the compiler (LP64, LLP64) and IMath's USE_64BIT_WORDS. This
 * macro should work for all of them.
 *
 * "used" is set to the number of written digits. It must be minimal (IMath
 * checks zeroness using the used field), but always at least one.  Also note
 * that the result of num>>(sizeof(num)*CHAR_BIT) is undefined.
 */
================================================================================

文件路径: ./include/isl/root_headfile/isl_printer_private.h
注释行数: 16
注释内容:
/* A printer to a file or a string.
 *
 * "dump" is set if the printing is performed from an isl_*_dump function.
 *
 * yaml_style is the YAML style in which the next elements should
 * be printed and may be either ISL_YAML_STYLE_BLOCK or ISL_YAML_STYLE_FLOW,
 * with ISL_YAML_STYLE_FLOW being the default.
 * yaml_state keeps track of the currently active YAML elements.
 * yaml_size is the size of this arrays, while yaml_depth
 * is the number of elements currently in use.
 * yaml_state may be NULL if no YAML printing is being performed.
 *
 * notes keeps track of arbitrary notes as a mapping between
 * name identifiers and note identifiers.  It may be NULL
 * if there are no notes yet.
 */
================================================================================

文件路径: ./include/isl/root_headfile/isl_tab.h
注释行数: 61
注释内容:
/* The tableau maintains equality relations.
 * Each column and each row is associated to a variable or a constraint.
 * The "value" of an inequality constraint is the value of the corresponding
 * slack variable.
 * The "row_var" and "col_var" arrays map column and row indices
 * to indices in the "var" and "con" arrays.  The elements of these
 * arrays maintain extra information about the variables and the constraints.
 * Each row expresses the corresponding row variable as an affine expression
 * of the column variables.
 * The first two columns in the matrix contain the common denominator of
 * the row and the numerator of the constant term.
 * If "M" is set, then the third column represents the "big parameter".
 * The third (M = 0) or fourth (M = 1) column
 * in the matrix is called column 0 with respect to the col_var array.
 * The sample value of the tableau is the value that assigns zero
 * to all the column variables and the constant term of each affine
 * expression to the corresponding row variable.
 * The operations on the tableau maintain the property that the sample
 * value satisfies the non-negativity constraints (usually on the slack
 * variables).
 *
 * The big parameter represents an arbitrarily big (and divisible)
 * positive number.  If present, then the sign of a row is determined
 * lexicographically, with the sign of the big parameter coefficient
 * considered first.  The big parameter is only used while
 * solving PILP problems.
 *
 * The first n_dead column variables have their values fixed to zero.
 * The corresponding tab_vars are flagged "is_zero".
 * Some of the rows that have have zero coefficients in all but
 * the dead columns are also flagged "is_zero".
 *
 * The first n_redundant rows correspond to inequality constraints
 * that are always satisfied for any value satisfying the non-redundant
 * rows.  The corresponding tab_vars are flagged "is_redundant".
 * A row variable that is flagged "is_zero" is also flagged "is_redundant"
 * since the constraint has been reduced to 0 = 0 and is therefore always
 * satisfied.
 *
 * There are "n_var" variables in total.  The first "n_param" of these
 * are called parameters and the last "n_div" of these are called divs.
 * The basic tableau operations makes no distinction between different
 * kinds of variables.  These special variables are only used while
 * solving PILP problems.
 *
 * Dead columns and redundant rows are detected on the fly.
 * However, the basic operations do not ensure that all dead columns
 * or all redundant rows are detected.
 * isl_tab_detect_implicit_equalities and isl_tab_detect_redundant can be used
 * to perform an exhaustive search for dead columns and redundant rows.
 *
 * The samples matrix contains "n_sample" integer points that have at some
 * point been elements satisfying the tableau.  The first "n_outside"
 * of them no longer satisfy the tableau.  They are kept because they
 * can be reinstated during rollback when the constraint that cut them
 * out is removed.  These samples are only maintained for the context
 * tableau while solving PILP problems.
 *
 * If "preserve" is set, then we want to keep all constraints in the
 * tableau, even if they turn out to be redundant.
 */
================================================================================

文件路径: ./include/isl/root_headfile/isl_schedule_node_private.h
注释行数: 16
注释内容:
/* An isl_schedule_node points to a particular location in a schedule tree.
 *
 * "schedule" is the schedule that the node is pointing to.
 * "ancestors" is a list of the n ancestors of the node
 * that is being pointed to.
 * The first ancestor is the root of "schedule", while the last ancestor
 * is the parent of the specified location.
 * "child_pos" is an array of child positions of the same length as "ancestors",
 * where ancestor i (i > 0) appears in child_pos[i - 1] of ancestor i - 1 and
 * "tree" appears in child_pos[n - 1] of ancestor n - 1.
 * "tree" is the subtree at the specified location.
 *
 * Note that the same isl_schedule_tree object may appear several times
 * in a schedule tree and therefore does not uniquely identify a position
 * in the schedule tree.
 */
================================================================================
