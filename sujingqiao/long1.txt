
文件路径: ./isl_ast_graft.c
注释行数: 13
注释内容:
/*
 * Copyright 2012      Ecole Normale Superieure
 * Copyright 2014      INRIA Rocquencourt
 * Copyright 2019      Cerebras Systems
 *
 * Use of this software is governed by the MIT license
 *
 * Written by Sven Verdoolaege,
 * Ecole Normale Superieure, 45 rue d’Ulm, 75230 Paris, France
 * and Inria Paris - Rocquencourt, Domaine de Voluceau - Rocquencourt,
 * B.P. 105 - 78153 Le Chesnay, France
 * and Cerebras Systems, 175 S San Antonio Rd, Los Altos, CA, USA
 */
================================================================================

文件路径: ./isl_ast_graft.c
注释行数: 26
注释内容:
/* Extract a common guard from the grafts in "list" that can be hoisted
 * out of the current level.  If no such guard can be found, then return
 * a universal set.
 *
 * If all the grafts in the list have the same guard and if this guard
 * is independent of the current level, then it can be hoisted out.
 * If there is only one graft in the list and if its guard
 * depends on the current level, then we eliminate this level and
 * return the result.
 *
 * Otherwise, we return the unshifted simple hull of the guards.
 * In order to be able to hoist as many constraints as possible,
 * but at the same time avoid hoisting constraints that did not
 * appear in the guards in the first place, we intersect the guards
 * with all the information that is available (i.e., the domain
 * from the build and the enforced constraints of the graft) and
 * compute the unshifted hull of the result using only constraints
 * from the original guards.
 * In particular, intersecting the guards with other known information
 * allows us to hoist guards that are only explicit is some of
 * the grafts and implicit in the others.
 *
 * The special case for equal guards is needed in case those guards
 * are non-convex.  Taking the simple hull would remove information
 * and would not allow for these guards to be hoisted completely.
 */
================================================================================

文件路径: ./isl_ast_graft.c
注释行数: 16
注释内容:
/* For each graft in "list",
 * insert an if node around graft->node testing the condition encoded
 * in graft->guard, assuming graft->guard involves any conditions.
 *
 * We keep track of a list of generated if nodes that can be extended
 * without changing the order of the elements in "list".
 * If the guard of a graft is a subset of either the guard or its complement
 * of one of those if nodes, then the node
 * of the new graft is inserted into the then or else branch of the last graft
 * and the current graft is discarded.
 * The guard of the node is then simplified based on the conditions
 * enforced at that then or else branch.
 * Otherwise, the current graft is appended to the list.
 *
 * We only construct else branches if allowed by the user.
 */
================================================================================

文件路径: ./isl_ast_graft.c
注释行数: 10
注释内容:
/* Allocate a graft in "build" based on the list of grafts in "sub_build".
 * "guard" and "enforced" are the guard and enforced constraints
 * of the allocated graft.  The guard is used to simplify the guards
 * of the elements in "list".
 *
 * The node is initialized to either a block containing the nodes of "children"
 * or, if there is only a single child, the node of that child.
 * If the current level requires a for node, it should be inserted by
 * a subsequent call to isl_ast_graft_insert_for.
 */
================================================================================

文件路径: ./isl_ast_graft.c
注释行数: 15
注释内容:
/* Combine the grafts in the list into a single graft.
 *
 * The guard is initialized to the shared guard of the list elements (if any),
 * provided it does not depend on the current dimension.
 * The guards in the elements are then simplified with respect to the
 * hoisted guard and materialized as if nodes around the contained AST nodes
 * in the context of "sub_build".
 *
 * The enforced set is initialized to the simple hull of the enforced sets
 * of the elements, provided the ast_build_exploit_nested_bounds option is set
 * or the new graft will be used at the same level.
 *
 * The node is initialized to either a block containing the nodes of "list"
 * or, if there is only a single element, the node of that element.
 */
================================================================================

文件路径: ./isl_ast_graft.c
注释行数: 14
注释内容:
/* Reformulate the "graft", which was generated in the context
 * of an inner code generation, in terms of the outer code generation
 * AST build.
 *
 * If "product" is set, then the domain of the inner code generation build is
 *
 *	[O -> S]
 *
 * with O the domain of the outer code generation build.
 * We essentially need to project out S.
 *
 * If "product" is not set, then we need to project the domains onto
 * their parameter spaces.
 */
================================================================================

文件路径: ./isl_ast_graft.c
注释行数: 22
注释内容:
/* Merge the given two lists into a single list of grafts,
 * merging grafts with the same guard into a single graft.
 *
 * "list2" has been sorted using isl_ast_graft_list_sort.
 * "list1" may be the result of a previous call to isl_ast_graft_list_merge
 * and may therefore not be completely sorted.
 *
 * The elements in "list2" need to be executed after those in "list1",
 * but if the guard of a graft in "list2" is disjoint from the guards
 * of some final elements in "list1", then it can be moved up to before
 * those final elements.
 *
 * In particular, we look at each element g of "list2" in turn
 * and move it up beyond elements of "list1" that would be sorted
 * after g as long as each of these elements has a guard that is disjoint
 * from that of g.
 *
 * We do not allow the second or any later element of "list2" to be moved
 * before a previous elements of "list2" even if the reason that
 * that element didn't move up further was that its guard was not disjoint
 * from that of the previous element in "list1".
 */
================================================================================

文件路径: ./isl_local_space.c
注释行数: 11
注释内容:
/*
 * Copyright 2011      INRIA Saclay
 * Copyright 2012-2014 Ecole Normale Superieure
 *
 * Use of this software is governed by the MIT license
 *
 * Written by Sven Verdoolaege, INRIA Saclay - Ile-de-France,
 * Parc Club Orsay Universite, ZAC des vignes, 4 rue Jacques Monod,
 * 91893 Orsay, France
 * and Ecole Normale Superieure, 45 rue d’Ulm, 75230 Paris, France
 */
================================================================================

文件路径: ./isl_local_space.c
注释行数: 16
注释内容:
/* Plug in the affine expressions "subs" of length "subs_len" (including
 * the denominator and the constant term) into the variable at position "pos"
 * of the "n" div expressions starting at "first".
 *
 * Let i be the dimension to replace and let "subs" be of the form
 *
 *	f/d
 *
 * Any integer division starting at "first" with a non-zero coefficient for i,
 *
 *	floor((a i + g)/m)
 *
 * is replaced by
 *
 *	floor((a f + d g)/(m d))
 */
================================================================================

文件路径: ./isl_local_space.c
注释行数: 15
注释内容:
/* Plug in "subs" for dimension "type", "pos" in the integer divisions
 * of "ls".
 *
 * Let i be the dimension to replace and let "subs" be of the form
 *
 *	f/d
 *
 * Any integer division with a non-zero coefficient for i,
 *
 *	floor((a i + g)/m)
 *
 * is replaced by
 *
 *	floor((a f + d g)/(m d))
 */
================================================================================

文件路径: ./isl_local_space.c
注释行数: 11
注释内容:
/* Does the linear part of "constraint" correspond to
 * integer division "div" in "ls"?
 *
 * That is, given div = floor((c + f)/m), is the constraint of the form
 *
 *		f - m d + c' >= 0		[sign = 1]
 * or
 *		-f + m d + c'' >= 0		[sign = -1]
 * ?
 * If so, set *sign to the corresponding value.
 */
================================================================================

文件路径: ./isl_local_space.c
注释行数: 12
注释内容:
/* Check if the constraints pointed to by "constraint" is a div
 * constraint corresponding to div "div" in "ls".
 *
 * That is, if div = floor(f/m), then check if the constraint is
 *
 *		f - m d >= 0
 * or
 *		-(f-(m-1)) + m d >= 0
 *
 * First check if the linear part is of the right form and
 * then check the constant term.
 */
================================================================================

文件路径: ./isl_local_space.c
注释行数: 15
注释内容:
/* Is the constraint pointed to by "constraint" one
 * of an equality that corresponds to integer division "div" in "ls"?
 *
 * That is, given an integer division of the form
 *
 *	a = floor((f + c)/m)
 *
 * is the equality of the form
 *
 *		-f + m d + c' = 0
 * ?
 * Note that the constant term is not checked explicitly, but given
 * that this is a valid equality constraint, the constant c' necessarily
 * has a value close to -c.
 */
================================================================================

文件路径: ./isl_local_space.c
注释行数: 19
注释内容:
/* Compute the preimage of "ls" under the function represented by "ma".
 * In other words, plug in "ma" in "ls".  The result is a local space
 * that is part of the domain space of "ma".
 *
 * If the divs in "ls" are represented as
 *
 *	floor((a_i(p) + b_i x + c_i(divs))/n_i)
 *
 * and ma is represented by
 *
 *	x = D(p) + F(y) + G(divs')
 *
 * then the resulting divs are
 *
 *	floor((a_i(p) + b_i D(p) + b_i F(y) + B_i G(divs') + c_i(divs))/n_i)
 *
 * We first copy over the divs from "ma" and then
 * we add the modified divs from "ls".
 */
================================================================================

文件路径: ./isl_ilp.c
注释行数: 16
注释内容:
/* Find an integer point in "bset" that minimizes f (in any) such that
 * the value of f lies inside the interval [l, u].
 * Return this integer point if it can be found.
 * Otherwise, return sol.
 *
 * We perform a number of steps until l > u.
 * In each step, we look for an integer point with value in either
 * the whole interval [l, u] or half of the interval [l, l+floor(u-l-1/2)].
 * The choice depends on whether we have found an integer point in the
 * previous step.  If so, we look for the next point in half of the remaining
 * interval.
 * If we find a point, the current solution is updated and u is set
 * to its value minus 1.
 * If no point can be found, we update l to the upper bound of the interval
 * we checked (u or l+floor(u-l-1/2)) plus 1.
 */
================================================================================

文件路径: ./isl_ilp.c
注释行数: 13
注释内容:
/* Find an integer point in "bset" that minimizes f (if any).
 * If sol_p is not NULL then the integer point is returned in *sol_p.
 * The optimal value of f is returned in *opt.
 *
 * The algorithm maintains a currently best solution and an interval [l, u]
 * of values of f for which integer solutions could potentially still be found.
 * The initial value of the best solution so far is any solution.
 * The initial value of l is minimal value of f over the rationals
 * (rounded up to the nearest integer).
 * The initial value of u is the value of f at the initial solution minus 1.
 *
 * We then call solve_ilp_search to perform a binary search on the interval.
 */
================================================================================

文件路径: ./isl_ilp.c
注释行数: 10
注释内容:
/* Convert the result of a function that returns an isl_lp_result
 * to an isl_val.  The numerator of "v" is set to the optimal value
 * if lp_res is isl_lp_ok.  "max" is set if a maximum was computed.
 *
 * Return "v" with denominator set to 1 if lp_res is isl_lp_ok.
 * Return NULL on error.
 * Return a NaN if lp_res is isl_lp_empty.
 * Return infinity or negative infinity if lp_res is isl_lp_unbounded,
 * depending on "max".
 */
================================================================================

文件路径: ./isl_test.c
注释行数: 16
注释内容:
/*
 * Copyright 2008-2009 Katholieke Universiteit Leuven
 * Copyright 2010      INRIA Saclay
 * Copyright 2012-2013 Ecole Normale Superieure
 * Copyright 2014      INRIA Rocquencourt
 *
 * Use of this software is governed by the MIT license
 *
 * Written by Sven Verdoolaege, K.U.Leuven, Departement
 * Computerwetenschappen, Celestijnenlaan 200A, B-3001 Leuven, Belgium
 * and INRIA Saclay - Ile-de-France, Parc Club Orsay Universite,
 * ZAC des vignes, 4 rue Jacques Monod, 91893 Orsay, France
 * and Ecole Normale Superieure, 45 rue d’Ulm, 75230 Paris, France
 * and Inria Paris - Rocquencourt, Domaine de Voluceau - Rocquencourt,
 * B.P. 105 - 78153 Le Chesnay, France
 */
================================================================================

文件路径: ./isl_test.c
注释行数: 11
注释内容:
/* Check that calling isl_set_coalesce on the intersection of
 * the sets described by "s1" and "s2" does not leave other sets
 * that may share some information with the input to isl_set_coalesce
 * in an inconsistent state.
 * In particular, when isl_set_coalesce detects equality constraints,
 * it does not immediately perform Gaussian elimination on them,
 * but then it needs to ensure that it is performed at some point.
 * The input set has implicit equality constraints in the first disjunct.
 * It is constructed as an intersection, because otherwise
 * those equality constraints would already be detected during parsing.
 */
================================================================================

文件路径: ./isl_test.c
注释行数: 10
注释内容:
/* Input for testing of schedule construction based on
 * conditional constraints.
 *
 * domain is the iteration domain
 * flow are the flow dependences, which determine the validity and
 * 	proximity constraints
 * condition are the conditions on the conditional validity constraints
 * conditional_validity are the conditional validity constraints
 * outer_band_n is the expected number of members in the outer band
 */
================================================================================

文件路径: ./isl_test.c
注释行数: 17
注释内容:
/* Contrived example that illustrates that we need to keep
	 * track of tagged condition dependences and
	 * tagged conditional validity dependences
	 * in isl_sched_edge separately.
	 * In particular, the conditional validity constraints on A
	 * cannot be satisfied,
	 * but they can be ignored because there are no corresponding
	 * condition constraints.  However, we do have an additional
	 * conditional validity constraint that maps to the same
	 * dependence relation
	 * as the condition constraint on B.  If we did not make a distinction
	 * between tagged condition and tagged conditional validity
	 * dependences, then we
	 * could end up treating this shared dependence as an condition
	 * constraint on A, forcing a localization of the conditions,
	 * which is impossible.
	 */
================================================================================

文件路径: ./isl_test.c
注释行数: 10
注释内容:
/* This function is called before each for loop in the AST generated
 * from test_ast_gen1.
 *
 * Increment the number of calls and the depth.
 * Check that the space returned by isl_ast_build_get_schedule_space
 * matches the target space of the schedule returned by
 * isl_ast_build_get_schedule.
 * Return an isl_id that is checked by the corresponding call
 * to after_for.
 */
================================================================================

文件路径: ./isl_test.c
注释行数: 10
注释内容:
/* Check that we do not lose any information when going back and
 * forth between internal and external schedule.
 *
 * In particular, we create an AST where we unroll the only
 * non-constant dimension in the schedule.  We therefore do
 * not expect any for loops in the AST.  However, older versions
 * of isl would not pass along enough information about the outer
 * schedule when performing an inner code generation from a create_leaf
 * callback, resulting in the inner code generation producing a for loop.
 */
================================================================================

文件路径: ./isl_test.c
注释行数: 11
注释内容:
/* Check that the expression
 *
 *	[n] -> { [n/2] : n <= 0 and n % 2 = 0; [0] : n > 0 }
 *
 * is not combined into
 *
 *	min(n/2, 0)
 *
 * as this would result in n/2 being evaluated in parts of
 * the definition domain where n is not a multiple of 2.
 */
================================================================================

文件路径: ./isl_schedule_constraints.c
注释行数: 21
注释内容:
/* The constraints that need to be satisfied by a schedule on "domain".
 *
 * "context" specifies extra constraints on the parameters.
 *
 * "validity" constraints map domain elements i to domain elements
 * that should be scheduled after i.  (Hard constraint)
 * "proximity" constraints map domain elements i to domains elements
 * that should be scheduled as early as possible after i (or before i).
 * (Soft constraint)
 *
 * "condition" and "conditional_validity" constraints map possibly "tagged"
 * domain elements i -> s to "tagged" domain elements j -> t.
 * The elements of the "conditional_validity" constraints, but without the
 * tags (i.e., the elements i -> j) are treated as validity constraints,
 * except that during the construction of a tilable band,
 * the elements of the "conditional_validity" constraints may be violated
 * provided that all adjacent elements of the "condition" constraints
 * are local within the band.
 * A dependence is local within a band if domain and range are mapped
 * to the same schedule point by the band.
 */
================================================================================

文件路径: ./isl_schedule_constraints.c
注释行数: 15
注释内容:
/* Apply "umap" to the domains of the wrapped relations
 * inside the domain and range of "c".
 *
 * That is, for each map of the form
 *
 *	[D -> S] -> [E -> T]
 *
 * in "c", apply "umap" to D and E.
 *
 * D is exposed by currying the relation to
 *
 *	D -> [S -> [E -> T]]
 *
 * E is exposed by doing the same to the inverse of "c".
 */
================================================================================

文件路径: ./isl_stream_private.h
注释行数: 17
注释内容:
/* An input stream that may be either a file or a string.
 *
 * line and col are the line and column number of the next character (1-based).
 * start_line and start_col are set by isl_stream_getc to point
 * to the position of the returned character.
 * last_line is the line number of the previous token.
 *
 * yaml_state and yaml_indent keep track of the currently active YAML
 * elements.  yaml_size is the size of these arrays, while yaml_depth
 * is the number of elements currently in use.
 * yaml_state and yaml_indent may be NULL if no YAML parsing is being
 * performed.
 * yaml_state keeps track of what is expected next at each level.
 * yaml_indent keeps track of the indentation at each level, with
 * ISL_YAML_INDENT_FLOW meaning that the element is in flow format
 * (such that the indentation is not relevant).
 */
================================================================================

文件路径: ./isl_map_private.h
注释行数: 10
注释内容:
/* A "basic map" is a relation between two sets of variables,
 * called the "in" and "out" variables.
 * A "basic set" is a basic map with a zero-dimensional
 * domain.
 *
 * It is implemented as a set with two extra fields:
 * n_in is the number of in variables
 * n_out is the number of out variables
 * n_in + n_out should be equal to set.dim
 */
================================================================================

文件路径: ./isl_map_private.h
注释行数: 11
注释内容:
/* A "map" is a (possibly disjoint) union of basic maps.
 * A "set" is a (possibly disjoint) union of basic sets.
 *
 * Currently, the isl_set structure is identical to the isl_map structure
 * and the library depends on this correspondence internally.
 * However, users should not depend on this correspondence.
 *
 * "cached_simple_hull" contains copies of the unshifted and shifted
 * simple hulls, if they have already been computed.  Otherwise,
 * the entries are NULL.
 */
================================================================================

文件路径: ./isl_bind_domain_templ.c
注释行数: 10
注释内容:
/* Given a function living in a space of the form [A -> B] -> C and
 * a tuple of identifiers in A, bind the domain dimensions of the relation
 * wrapped in the domain of "obj" with identifiers specified by "tuple",
 * returning a function in the space B -> C.
 *
 * If no parameters with these identifiers appear in "obj" already,
 * then the domain dimensions are simply reinterpreted as parameters.
 * Otherwise, the parameters are first equated to the corresponding
 * domain dimensions.
 */
================================================================================

文件路径: ./isl_aff_lex_templ.c
注释行数: 13
注释内容:
/* Return a map containing pairs of elements in the domains of "mpa1" and "mpa2"
 * where the function value of "mpa1" lexicographically compares as "ORDER"
 * to that of "mpa2".  "space" is the space of the result.
 * The parameters of "mpa1" and "mpa2" are assumed to have been aligned.
 *
 * "mpa1" is in the given lexicographic order compared to "mpa2"
 * if, for some i, the i-th element of "mpa1" is in that order compared to
 * the i-th element of "mpa2" while all previous elements are
 * pairwise equal, where the order needs to be strict (not-equal)
 * if i corresponds to anything but the last element.
 * The strict version of "ORDER" is defined by "STRICT_ORDER",
 * which is the same if "ORDER" itself is strict.
 */
================================================================================

文件路径: ./isl_dim_map.c
注释行数: 11
注释内容:
/*
 * Copyright 2008-2009 Katholieke Universiteit Leuven
 * Copyright 2010-2011 INRIA Saclay
 *
 * Use of this software is governed by the MIT license
 *
 * Written by Sven Verdoolaege, K.U.Leuven, Departement
 * Computerwetenschappen, Celestijnenlaan 200A, B-3001 Leuven, Belgium
 * and INRIA Saclay - Ile-de-France, Parc Club Orsay Universite,
 * ZAC des vignes, 4 rue Jacques Monod, 91893 Orsay, France 
 */
================================================================================

文件路径: ./codegen.c
注释行数: 10
注释内容:
/* This program prints an AST that scans the domain elements of
 * the domain of a given schedule in the order specified by
 * the schedule tree or by their image(s) in the schedule map.
 *
 * The input consists of either a schedule tree or
 * a sequence of three sets/relations.
 * - a schedule map
 * - a context
 * - a relation describing AST generation options
 */
================================================================================

文件路径: ./isl_ast.c
注释行数: 10
注释内容:
/* Traverse the descendants of "node" (including the node itself)
 * in depth first preorder.
 *
 * If "fn" returns isl_bool_error on any of the nodes, then the traversal
 * is aborted.
 * If "fn" returns isl_bool_false on any of the nodes, then the subtree rooted
 * at that node is skipped.
 *
 * Return isl_stat_ok on success and isl_stat_error on failure.
 */
================================================================================

文件路径: ./isl_ast.c
注释行数: 18
注释内容:
/* Do we need/want parentheses around "expr" as a subexpression of
 * an "op" operation?  If "left" is set, then "expr" is the left-most
 * operand.
 *
 * We only need parentheses if "expr" represents an operation.
 *
 * If op has a higher precedence than expr->u.op.op, then we need
 * parentheses.
 * If op and expr->u.op.op have the same precedence, but the operations
 * are performed in an order that is different from the associativity,
 * then we need parentheses.
 *
 * An and inside an or technically does not require parentheses,
 * but some compilers complain about that, so we add them anyway.
 *
 * Computations such as "a / b * c" and "a % b + c" can be somewhat
 * difficult to read, so we add parentheses for those as well.
 */
================================================================================

文件路径: ./isl_ast.c
注释行数: 14
注释内容:
/* Do we need to print a block around the body "node" of a for or if node?
 *
 * If the node is a block, then we need to print a block.
 * Also if the node is a degenerate for then we will print it as
 * an assignment followed by the body of the for loop, so we need a block
 * as well.
 * If the node is an if node with an else, then we print a block
 * to avoid spurious dangling else warnings emitted by some compilers.
 * If the node is a mark, then in principle, we would have to check
 * the child of the mark node.  However, even if the child would not
 * require us to print a block, for readability it is probably best
 * to print a block anyway.
 * If the ast_always_print_block option has been set, then we print a block.
 */
================================================================================

文件路径: ./isl_ast.c
注释行数: 20
注释内容:
/* Print the body "node" of a for or if node.
 * If "else_node" is set, then it is printed as well.
 * If "force_block" is set, then print out the body as a block.
 *
 * We first check if we need to print out a block.
 * We always print out a block if there is an else node to make
 * sure that the else node is matched to the correct if node.
 * For consistency, the corresponding else node is also printed as a block.
 *
 * If the else node is itself an if, then we print it as
 *
 *	} else if (..) {
 *	}
 *
 * Otherwise the else node is printed as
 *
 *	} else {
 *	  node
 *	}
 */
================================================================================

文件路径: ./isl_ast.c
注释行数: 19
注释内容:
/* Print the for node "node".
 *
 * If the for node is degenerate, it is printed as
 *
 *	type iterator = init;
 *	body
 *
 * Otherwise, it is printed as
 *
 *	for (type iterator = init; cond; iterator += inc)
 *		body
 *
 * "in_block" is set if we are currently inside a block.
 * "in_list" is set if the current node is not alone in the block.
 * If we are not in a block or if the current not is not alone in the block
 * then we print a block around a degenerate for loop such that the variable
 * declaration will not conflict with any potential other declaration
 * of the same variable.
 */
================================================================================

文件路径: ./isl_schedule_tree.h
注释行数: 40
注释内容:
/* A schedule (sub)tree.
 *
 * The leaves of a tree are not explicitly represented inside
 * the isl_schedule_tree, except when the tree consists of only a leaf.
 *
 * The "band" field is valid when type is isl_schedule_node_band.
 * The "context" field is valid when type is isl_schedule_node_context
 * and represents constraints on the flat product of the outer band nodes,
 * possibly introducing additional parameters.
 * The "domain" field is valid when type is isl_schedule_node_domain
 * and introduces the statement instances scheduled by the tree.
 *
 * The "contraction" and "expansion" fields are valid when type
 * is isl_schedule_node_expansion.
 * "expansion" expands the reaching domain elements to one or more
 * domain elements for the subtree.
 * "contraction" maps these elements back to the corresponding
 * reaching domain element.  It does not involve any domain constraints.
 *
 * The "extension" field is valid when the is isl_schedule_node_extension
 * maps outer schedule dimensions (the flat product of the outer band nodes)
 * to additional iteration domains.
 *
 * The "filter" field is valid when type is isl_schedule_node_filter
 * and represents the statement instances selected by the node.
 *
 * The "guard" field is valid when type is isl_schedule_node_guard
 * and represents constraints on the flat product of the outer band nodes
 * that need to be enforced by the outer nodes in the generated AST.
 *
 * The "mark" field is valid when type is isl_schedule_node_mark and
 * identifies the mark.
 *
 * The "children" field is valid for all types except
 * isl_schedule_node_leaf.  This field is NULL if there are
 * no children (except for the implicit leaves).
 *
 * anchored is set if the node or any of its descendants depends
 * on its position in the schedule tree.
 */
================================================================================

文件路径: ./isl_ast_build.c
注释行数: 11
注释内容:
/*
 * Copyright 2012-2013 Ecole Normale Superieure
 * Copyright 2014      INRIA Rocquencourt
 *
 * Use of this software is governed by the MIT license
 *
 * Written by Sven Verdoolaege,
 * Ecole Normale Superieure, 45 rue d’Ulm, 75230 Paris, France
 * and Inria Paris - Rocquencourt, Domaine de Voluceau - Rocquencourt,
 * B.P. 105 - 78153 Le Chesnay, France
 */
================================================================================

文件路径: ./isl_ast_build.c
注释行数: 18
注释内容:
/* Return a mapping from the internal schedule space to the external
 * schedule space in the form of an isl_multi_aff.
 * The internal schedule space originally corresponds to that of the
 * input schedule.  This may change during the code generation if
 * if isl_ast_build_insert_dim is ever called.
 * The external schedule space corresponds to the
 * loops that have been generated.
 *
 * Currently, the only difference between the internal schedule domain
 * and the external schedule domain is that some dimensions are projected
 * out in the external schedule domain.  In particular, the dimensions
 * for which no code has been generated yet and the dimensions that correspond
 * to eliminated loops.
 *
 * We cache a copy of the schedule_map in build->schedule_map.
 * The cache is cleared through isl_ast_build_reset_schedule_map
 * whenever anything changes that might affect the result of this function.
 */
================================================================================

文件路径: ./isl_ast_build.c
注释行数: 17
注释内容:
/* Check if the given bounds on the current dimension (together with
 * the stride constraint, if any) imply that
 * this current dimension attains only a single value (in terms of
 * parameters and outer dimensions).
 * If so, we record it in build->value.
 * If, moreover, this value can be represented as a single affine expression,
 * then we also update build->values, effectively marking the current
 * dimension as "eliminated".
 *
 * When computing the gist of the fixed value that can be represented
 * as a single affine expression, it is important to only take into
 * account the domain constraints in the original AST build and
 * not the domain of the affine expression itself.
 * Otherwise, a [i/3] is changed into a i/3 because we know that i
 * is a multiple of 3, but then we end up not expressing anywhere
 * in the context that i is a multiple of 3.
 */
================================================================================

文件路径: ./isl_ast_build.c
注释行数: 31
注释内容:
/* Update the AST build based on the given loop bounds for
 * the current dimension and the stride information available in the build.
 *
 * We first make sure that the bounds do not refer to any iterators
 * that have already been eliminated.
 * Then, we check if the bounds imply that the current iterator
 * has a fixed value.
 * If they do and if this fixed value can be expressed as a single
 * affine expression, we eliminate the iterators from the bounds.
 * Note that we cannot simply plug in this single value using
 * isl_basic_set_preimage_multi_aff as the single value may only
 * be defined on a subset of the domain.  Plugging in the value
 * would restrict the build domain to this subset, while this
 * restriction may not be reflected in the generated code.
 * Finally, we intersect build->domain with the updated bounds.
 * We also add the stride constraint unless we have been able
 * to find a fixed value expressed as a single affine expression.
 *
 * Note that the check for a fixed value in update_values requires
 * us to intersect the bounds with the current build domain.
 * When we intersect build->domain with the updated bounds in
 * the final step, we make sure that these updated bounds have
 * not been intersected with the old build->domain.
 * Otherwise, we would indirectly intersect the build domain with itself,
 * which can lead to inefficiencies, in particular if the build domain
 * contains any unknown divs.
 *
 * The pending and generated sets are not updated by this function to
 * match the updated domain.
 * The caller still needs to call isl_ast_build_set_pending_generated.
 */
================================================================================

文件路径: ./isl_ast_build.c
注释行数: 11
注释内容:
/* Return a set expressing the stride constraint at the current depth.
 *
 * In particular, if the current iterator (i) is known to attain values
 *
 *	f + s a
 *
 * where f is the offset and s is the stride, then the returned set
 * expresses the constraint
 *
 *	(f - i) mod s = 0
 */
================================================================================

文件路径: ./isl_ast_build.c
注释行数: 11
注释内容:
/* Return the expansion implied by the stride and offset at the current
 * depth.
 *
 * That is, return the mapping
 *
 *	[i_0, ..., i_{d-1}, i_d, i_{d+1}, ...]
 *		-> [i_0, ..., i_{d-1}, s * i_d + offset(i),  i_{d+1}, ...]
 *
 * where s is the stride at the current depth d and offset(i) is
 * the corresponding offset.
 */
================================================================================

文件路径: ./isl_ast_build.c
注释行数: 11
注释内容:
/* Check if the constraints in "set" imply any stride on the current
 * dimension and, if so, record the stride information in "build"
 * and return the updated "build".
 *
 * We assume that inner dimensions have been eliminated from "set"
 * by the caller.  This is needed because the common stride
 * may be imposed by different inner dimensions on different parts of
 * the domain.
 * The assumption ensures that the lower bound does not depend
 * on inner dimensions.
 */
================================================================================

文件路径: ./isl_ast_build.c
注释行数: 21
注释内容:
/* Update the "options" to reflect the insertion of a dimension
 * at position "pos" in the schedule domain space.
 * "space" is the original domain space before the insertion and
 * may be named and/or structured.
 *
 * The (relevant) input options all have "space" as domain, which
 * has to be mapped to the extended space.
 * The values of the ranges also refer to the schedule domain positions
 * and they therefore also need to be adjusted.  In particular, values
 * smaller than pos do not need to change, while values greater than or
 * equal to pos need to be incremented.
 * That is, we need to apply the following map.
 *
 *	{ atomic[i] -> atomic[i] : i < pos; [i] -> [i + 1] : i >= pos;
 *	  unroll[i] -> unroll[i] : i < pos; [i] -> [i + 1] : i >= pos;
 *	  separate[i] -> separate[i] : i < pos; [i] -> [i + 1] : i >= pos;
 *	  separation_class[[i] -> [c]]
 *		-> separation_class[[i] -> [c]] : i < pos;
 *	  separation_class[[i] -> [c]]
 *		-> separation_class[[i + 1] -> [c]] : i >= pos }
 */
================================================================================

文件路径: ./isl_ast_build.c
注释行数: 18
注释内容:
/* Insert a single dimension in the schedule domain at position "pos".
 * The new dimension is given an isl_id with the empty string as name.
 *
 * The main difficulty is updating build->options to reflect the
 * extra dimension.  This is handled in options_insert_dim.
 *
 * Note that because of the dimension manipulations, the resulting
 * schedule domain space will always be unnamed and unstructured.
 * However, the original schedule domain space may be named and/or
 * structured, so we have to take this possibility into account
 * while performing the transformations.
 *
 * Since the inserted schedule dimension is used by the caller
 * to differentiate between different domain spaces, there is
 * no longer a uniform mapping from the internal schedule space
 * to the input schedule space.  The internal2input mapping is
 * therefore removed.
 */
================================================================================

文件路径: ./isl_ast_build.c
注释行数: 15
注释内容:
/* Scale down the current dimension by a factor of "m".
 * "umap" is an isl_union_map that implements the scaling down.
 * That is, it is of the form
 *
 *	{ [.... i ....] -> [.... i' ....] : i = m i' }
 *
 * This function is called right after the strides have been
 * detected, but before any constraints on the current dimension
 * have been included in build->domain.
 * We therefore only need to update stride, offset, the options and
 * the mapping from internal schedule space to the original schedule
 * space, if we are still keeping track of such a mapping.
 * The latter mapping is updated by plugging in
 * { [... i ...] -> [... m i ... ] }.
 */
================================================================================

文件路径: ./isl_ast_build.c
注释行数: 24
注释内容:
/* Embed "options" into the given isl_ast_build space.
 *
 * This function is called from within a nested call to
 * isl_ast_build_node_from_schedule_map.
 * "options" refers to the additional schedule,
 * while space refers to both the space of the outer isl_ast_build and
 * that of the additional schedule.
 * Specifically, space is of the form
 *
 *	[I -> S]
 *
 * while options lives in the space(s)
 *
 *	S -> *
 *
 * We compute
 *
 *	[I -> S] -> S
 *
 * and compose this with options, to obtain the new options
 * living in the space(s)
 *
 *	[I -> S] -> *
 */
================================================================================

文件路径: ./isl_ast_build.c
注释行数: 22
注释内容:
/* Update "build" for use in a (possibly nested) code generation.  That is,
 * extend "build" from an AST build on some domain O to an AST build
 * on domain [O -> S], with S corresponding to "space".
 * If the original domain is a parameter domain, then the new domain is
 * simply S.
 * "iterators" is a list of iterators for S, but the number of elements
 * may be smaller or greater than the number of set dimensions of S.
 * If "keep_iterators" is set, then any extra ids in build->iterators
 * are reused for S.  Otherwise, these extra ids are dropped.
 *
 * We first update build->outer_pos to the current depth.
 * This depth is zero in case this is the outermost code generation.
 *
 * We then add additional ids such that the number of iterators is at least
 * equal to the dimension of the new build domain.
 *
 * If the original domain is parametric, then we are constructing
 * an isl_ast_build for the outer code generation and we pass control
 * to isl_ast_build_init.
 *
 * Otherwise, we adjust the fields of "build" to include "space".
 */
================================================================================

文件路径: ./isl_ast_build.c
注释行数: 15
注释内容:
/* Extract the schedule domain of the given type from build->options
 * at the current depth.
 *
 * In particular, find the subset of build->options that is of
 * the following form
 *
 *	schedule_domain -> type[depth]
 *
 * and return the corresponding domain, after eliminating inner dimensions
 * and divs that depend on the current dimension.
 *
 * Note that the domain of build->options has been reformulated
 * in terms of the internal build space in embed_options,
 * but the position is still that within the current code generation.
 */
================================================================================

文件路径: ./isl_ast_build.c
注释行数: 11
注释内容:
/* How does the user want the current schedule dimension to be generated?
 * These choices have been extracted from the schedule node
 * in extract_loop_types and stored in build->loop_type.
 * They have been updated to reflect any dimension insertion in
 * node_insert_dim.
 * Return isl_ast_domain_error on error.
 *
 * If "isolated" is set, then we get the loop AST generation type
 * directly from the band node since node_insert_dim cannot have been
 * called on a band with the isolate option.
 */
================================================================================

文件路径: ./isl_ast_build.c
注释行数: 17
注释内容:
/* Extract the isolated set from the isolate option, if any,
 * and store in the build.
 * If there is no isolate option, then the isolated set is
 * set to the empty set.
 *
 * The isolate option is of the form
 *
 *	isolate[[outer bands] -> current_band]
 *
 * We flatten this set and then map it back to the internal
 * schedule space.
 *
 * If we have already extracted the isolated set
 * or if internal2input is no longer set, then we do not
 * need to do anything.  In the latter case, we know
 * that the current band cannot have any isolate option.
 */
================================================================================

文件路径: ./isl_ast_build.c
注释行数: 13
注释内容:
/* Extract the separation class mapping at the current depth.
 *
 * In particular, find and return the subset of build->options that is of
 * the following form
 *
 *	schedule_domain -> separation_class[[depth] -> [class]]
 *
 * The caller is expected to eliminate inner dimensions from the domain.
 *
 * Note that the domain of build->options has been reformulated
 * in terms of the internal build space in embed_options,
 * but the position is still that within the current code generation.
 */
================================================================================

文件路径: ./isl_lp.c
注释行数: 10
注释内容:
/* Given a basic map "bmap" and an affine combination of the variables "f"
 * with denominator "denom", set *opt / *opt_denom to the minimal
 * (or maximal if "maximize" is true) value attained by f/d over "bmap",
 * assuming the basic map is not empty and the expression cannot attain
 * arbitrarily small (or large) values.
 * If opt_denom is NULL, then *opt is rounded up (or down)
 * to the nearest integer.
 * The return value reflects the nature of the result (empty, unbounded,
 * minimal or maximal value returned in *opt).
 */
================================================================================

文件路径: ./isl_lp.c
注释行数: 10
注释内容:
/* Return the optimal (rational) value of "obj" over "bset", assuming
 * that "obj" and "bset" have aligned parameters and divs.
 * If "max" is set, then the maximal value is computed.
 * Otherwise, the minimal value is computed.
 *
 * Return infinity or negative infinity if the optimal value is unbounded and
 * NaN if "bset" is empty.
 *
 * Call isl_basic_set_solve_lp and translate the results.
 */
================================================================================

文件路径: ./isl_lp.c
注释行数: 10
注释内容:
/* Return the optimal (rational) value of "obj" over "bset", assuming
 * that "obj" and "bset" have aligned parameters.
 * If "max" is set, then the maximal value is computed.
 * Otherwise, the minimal value is computed.
 *
 * Return infinity or negative infinity if the optimal value is unbounded and
 * NaN if "bset" is empty.
 *
 * Align the divs of "bset" and "obj" and call basic_set_opt_lp.
 */
================================================================================

文件路径: ./isl_pw_eval.c
注释行数: 11
注释内容:
/*
 * Copyright 2010      INRIA Saclay
 * Copyright 2013      Ecole Normale Superieure
 *
 * Use of this software is governed by the MIT license
 *
 * Written by Sven Verdoolaege, INRIA Saclay - Ile-de-France,
 * Parc Club Orsay Universite, ZAC des vignes, 4 rue Jacques Monod,
 * 91893 Orsay, France
 * and Ecole Normale Superieure, 45 rue d'Ulm, 75230 Paris, France
 */
================================================================================

文件路径: ./isl_ast_build_expr.c
注释行数: 11
注释内容:
/*
 * Copyright 2012-2014 Ecole Normale Superieure
 * Copyright 2014      INRIA Rocquencourt
 *
 * Use of this software is governed by the MIT license
 *
 * Written by Sven Verdoolaege,
 * Ecole Normale Superieure, 45 rue d’Ulm, 75230 Paris, France
 * and Inria Paris - Rocquencourt, Domaine de Voluceau - Rocquencourt,
 * B.P. 105 - 78153 Le Chesnay, France
 */
================================================================================

文件路径: ./isl_ast_build_expr.c
注释行数: 20
注释内容:
/* Given the numerator "aff" of the argument of an integer division
 * with denominator "d", check if it can be made non-negative over
 * data->build->domain by stealing part of the constant term of
 * the expression in which the integer division appears.
 *
 * In particular, the outer expression is of the form
 *
 *	v * floor(aff/d) + cst
 *
 * We already know that "aff" itself may attain negative values.
 * Here we check if aff + d*floor(cst/v) is non-negative, such
 * that we could rewrite the expression to
 *
 *	v * floor((aff + d*floor(cst/v))/d) + cst - v*floor(cst/v)
 *
 * Note that aff + d*floor(cst/v) can only possibly be non-negative
 * if data->cst and data->v have the same sign.
 * Similarly, if floor(cst/v) is zero, then there is no point in
 * checking again.
 */
================================================================================

文件路径: ./isl_ast_build_expr.c
注释行数: 26
注释内容:
/* Given the numerator "aff' of the argument of an integer division
 * with denominator "d", steal part of the constant term of
 * the expression in which the integer division appears to make it
 * non-negative over data->build->domain.
 *
 * In particular, the outer expression is of the form
 *
 *	v * floor(aff/d) + cst
 *
 * We know that "aff" itself may attain negative values,
 * but that aff + d*floor(cst/v) is non-negative.
 * Find the minimal positive value that we need to add to "aff"
 * to make it positive and adjust data->cst accordingly.
 * That is, compute the minimal value "m" of "aff" over
 * data->build->domain and take
 *
 *	s = ceil(m/d)
 *
 * such that
 *
 *	aff + d * s >= 0
 *
 * and rewrite the expression to
 *
 *	v * floor((aff + s*d)/d) + (cst - v*s)
 */
================================================================================

文件路径: ./isl_ast_build_expr.c
注释行数: 34
注释内容:
/* Create an isl_ast_expr evaluating the div at position "pos" in "ls".
 * The result is simplified in terms of data->build->domain.
 * This function may change (the sign of) data->v.
 *
 * "ls" is known to be non-NULL.
 *
 * Let the div be of the form floor(e/d).
 * If the ast_build_prefer_pdiv option is set then we check if "e"
 * is non-negative, so that we can generate
 *
 *	(pdiv_q, expr(e), expr(d))
 *
 * instead of
 *
 *	(fdiv_q, expr(e), expr(d))
 *
 * If the ast_build_prefer_pdiv option is set and
 * if "e" is not non-negative, then we check if "-e + d - 1" is non-negative.
 * If so, we can rewrite
 *
 *	floor(e/d) = -ceil(-e/d) = -floor((-e + d - 1)/d)
 *
 * and still use pdiv_q, while changing the sign of data->v.
 *
 * Otherwise, we check if
 *
 *	e + d*floor(cst/v)
 *
 * is non-negative and if so, replace floor(e/d) by
 *
 *	floor((e + s*d)/d) - s
 *
 * with s the minimal shift that makes the argument non-negative.
 */
================================================================================

文件路径: ./isl_ast_build_expr.c
注释行数: 11
注释内容:
/* Subtract expr2 from expr1.
 *
 * If expr2 is zero, we simply return expr1.
 * If expr1 is zero, we return
 *
 *	(isl_ast_expr_op_minus, expr2)
 *
 * Otherwise, we return
 *
 *	(isl_ast_expr_op_sub, expr1, expr2)
 */
================================================================================

文件路径: ./isl_ast_build_expr.c
注释行数: 11
注释内容:
/* Create an isl_ast_expr that scales "expr" by "v".
 *
 * If v is 1, we simply return expr.
 * If v is -1, we return
 *
 *	(isl_ast_expr_op_minus, expr)
 *
 * Otherwise, we return
 *
 *	(isl_ast_expr_op_mul, expr(v), expr)
 */
================================================================================

文件路径: ./isl_ast_build_expr.c
注释行数: 23
注释内容:
/* Add an expression for "*v" times the specified dimension of "ls"
 * to expr.
 * If the dimension is an integer division, then this function
 * may modify data->cst in order to make the numerator non-negative.
 * The result is simplified in terms of data->build->domain.
 *
 * Let e be the expression for the specified dimension,
 * multiplied by the absolute value of "*v".
 * If "*v" is negative, we create
 *
 *	(isl_ast_expr_op_sub, expr, e)
 *
 * except when expr is trivially zero, in which case we create
 *
 *	(isl_ast_expr_op_minus, e)
 *
 * instead.
 *
 * If "*v" is positive, we simply create
 *
 *	(isl_ast_expr_op_add, expr, e)
 *
 */
================================================================================

文件路径: ./isl_ast_build_expr.c
注释行数: 22
注释内容:
/* Internal data structure used inside extract_modulos.
 *
 * If any modulo expressions are detected in "aff", then the
 * expression is removed from "aff" and added to either "pos" or "neg"
 * depending on the sign of the coefficient of the modulo expression
 * inside "aff".
 *
 * "add" is an expression that needs to be added to "aff" at the end of
 * the computation.  It is NULL as long as no modulos have been extracted.
 *
 * "i" is the position in "aff" of the div under investigation
 * "v" is the coefficient in "aff" of the div
 * "div" is the argument of the div, with the denominator removed
 * "d" is the original denominator of the argument of the div
 *
 * "nonneg" is an affine expression that is non-negative over "build"
 * and that can be used to extract a modulo expression from "div".
 * In particular, if "sign" is 1, then the coefficients of "nonneg"
 * are equal to those of "div" modulo "d".  If "sign" is -1, then
 * the coefficients of "nonneg" are opposite to those of "div" modulo "d".
 * If "sign" is 0, then no such affine expression has been found (yet).
 */
================================================================================

文件路径: ./isl_ast_build_expr.c
注释行数: 13
注释内容:
/* Does
 *
 *	arg mod data->d
 *
 * represent (a special case of) a test for some linear expression
 * being even?
 *
 * In particular, is it of the form
 *
 *	(lin - 1) mod 2
 *
 * ?
 */
================================================================================

文件路径: ./isl_ast_build_expr.c
注释行数: 29
注释内容:
/* Given that data->v * div_i in data->aff is equal to
 *
 *	f * (term - (arg mod d))
 *
 * with data->d * f = data->v and "arg" non-negative on data->build, add
 *
 *	f * term
 *
 * to data->add and
 *
 *	abs(f) * (arg mod d)
 *
 * to data->neg or data->pos depending on the sign of -f.
 *
 * In the special case that "arg mod d" is of the form "(lin - 1) mod 2",
 * with "lin" some linear expression, first replace
 *
 *	f * (term - ((lin - 1) mod 2))
 *
 * by
 *
 *	-f * (1 - term - (lin mod 2))
 *
 * These two are equal because
 *
 *	((lin - 1) mod 2) + (lin mod 2) = 1
 *
 * Also, if "lin - 1" is non-negative, then "lin" is non-negative too.
 */
================================================================================

文件路径: ./isl_ast_build_expr.c
注释行数: 18
注释内容:
/* Given that data->v * div_i in data->aff is of the form
 *
 *	f * d * floor(div/d)
 *
 * with div nonnegative on data->build, rewrite it as
 *
 *	f * (div - (div mod d)) = f * div - f * (div mod d)
 *
 * and add
 *
 *	f * div
 *
 * to data->add and
 *
 *	abs(f) * (div mod d)
 *
 * to data->neg or data->pos depending on the sign of -f.
 */
================================================================================

文件路径: ./isl_ast_build_expr.c
注释行数: 18
注释内容:
/* Given that data->v * div_i in data->aff is of the form
 *
 *	f * d * floor(div/d)					(1)
 *
 * check if div is non-negative on data->build and, if so,
 * extract the corresponding modulo from data->aff.
 * If not, then check if
 *
 *	-div + d - 1
 *
 * is non-negative on data->build.  If so, replace (1) by
 *
 *	-f * d * floor((-div + d - 1)/d)
 *
 * and extract the corresponding modulo from data->aff.
 *
 * This function may modify data->div.
 */
================================================================================

文件路径: ./isl_ast_build_expr.c
注释行数: 11
注释内容:
/* Is the affine expression of constraint "c" "simpler" than data->nonneg
 * for use in extracting a modulo expression?
 *
 * We currently only consider the constant term of the affine expression.
 * In particular, we prefer the affine expression with the smallest constant
 * term.
 * This means that if there are two constraints, say x >= 0 and -x + 10 >= 0,
 * then we would pick x >= 0
 *
 * More detailed heuristics could be used if it turns out that there is a need.
 */
================================================================================

文件路径: ./isl_ast_build_expr.c
注释行数: 21
注释内容:
/* Check if the coefficients of "c" are either equal or opposite to those
 * of data->div modulo data->d.  If so, and if "c" is "simpler" than
 * data->nonneg, then replace data->nonneg by the affine expression of "c"
 * and set data->sign accordingly.
 *
 * Both "c" and data->div are assumed not to involve any integer divisions.
 *
 * Before we start the actual comparison, we first quickly check if
 * "c" and data->div have the same non-zero coefficients.
 * If not, then we assume that "c" is not of the desired form.
 * Note that while the coefficients of data->div can be reasonably expected
 * not to involve any coefficients that are multiples of d, "c" may
 * very well involve such coefficients.  This means that we may actually
 * miss some cases.
 *
 * If the constant term is "too large", then the constraint is rejected,
 * where "too large" is fairly arbitrarily set to 1 << 15.
 * We do this to avoid picking up constraints that bound a variable
 * by a very large number, say the largest or smallest possible
 * variable in the representation of some integer type.
 */
================================================================================

文件路径: ./isl_ast_build_expr.c
注释行数: 79
注释内容:
/* Given that data->v * div_i in data->aff is of the form
 *
 *	f * d * floor(div/d)					(1)
 *
 * see if we can find an expression div' that is non-negative over data->build
 * and that is related to div through
 *
 *	div' = div + d * e
 *
 * or
 *
 *	div' = -div + d - 1 + d * e
 *
 * with e some affine expression.
 * If so, we write (1) as
 *
 *	f * div + f * (div' mod d)
 *
 * or
 *
 *	-f * (-div + d - 1) - f * (div' mod d)
 *
 * exploiting (in the second case) the fact that
 *
 *	f * d * floor(div/d) =	-f * d * floor((-div + d - 1)/d)
 *
 *
 * We first try to find an appropriate expression for div'
 * from the constraints of data->build->domain (which is therefore
 * guaranteed to be non-negative on data->build), where we remove
 * any integer divisions from the constraints and skip this step
 * if "div" itself involves any integer divisions.
 * If we cannot find an appropriate expression this way, then
 * we pass control to extract_nonneg_mod where check
 * if div or "-div + d -1" themselves happen to be
 * non-negative on data->build.
 *
 * While looking for an appropriate constraint in data->build->domain,
 * we ignore the constant term, so after finding such a constraint,
 * we still need to fix up the constant term.
 * In particular, if a is the constant term of "div"
 * (or d - 1 - the constant term of "div" if data->sign < 0)
 * and b is the constant term of the constraint, then we need to find
 * a non-negative constant c such that
 *
 *	b + c \equiv a	mod d
 *
 * We therefore take
 *
 *	c = (a - b) mod d
 *
 * and add it to b to obtain the constant term of div'.
 * If this constant term is "too negative", then we add an appropriate
 * multiple of d to make it positive.
 *
 *
 * Note that the above is a only a very simple heuristic for finding an
 * appropriate expression.  We could try a bit harder by also considering
 * sums of constraints that involve disjoint sets of variables or
 * we could consider arbitrary linear combinations of constraints,
 * although that could potentially be much more expensive as it involves
 * the solution of an LP problem.
 *
 * In particular, if v_i is a column vector representing constraint i,
 * w represents div and e_i is the i-th unit vector, then we are looking
 * for a solution of the constraints
 *
 *	\sum_i lambda_i v_i = w + \sum_i alpha_i d e_i
 *
 * with \lambda_i >= 0 and alpha_i of unrestricted sign.
 * If we are not just interested in a non-negative expression, but
 * also in one with a minimal range, then we don't just want
 * c = \sum_i lambda_i v_i to be non-negative over the domain,
 * but also beta - c = \sum_i mu_i v_i, where beta is a scalar
 * that we want to minimize and we now also have to take into account
 * the constant terms of the constraints.
 * Alternatively, we could first compute the dual of the domain
 * and plug in the constraints on the coefficients.
 */
================================================================================

文件路径: ./isl_ast_build_expr.c
注释行数: 31
注释内容:
/* Check if "data->aff" involves any (implicit) modulo computations based
 * on div "data->i".
 * If so, remove them from aff and add expressions corresponding
 * to those modulo computations to data->pos and/or data->neg.
 *
 * "aff" is assumed to be an integer affine expression.
 *
 * In particular, check if (v * div_j) is of the form
 *
 *	f * m * floor(a / m)
 *
 * and, if so, rewrite it as
 *
 *	f * (a - (a mod m)) = f * a - f * (a mod m)
 *
 * and extract out -f * (a mod m).
 * In particular, if f > 0, we add (f * (a mod m)) to *neg.
 * If f < 0, we add ((-f) * (a mod m)) to *pos.
 *
 * Note that in order to represent "a mod m" as
 *
 *	(isl_ast_expr_op_pdiv_r, a, m)
 *
 * we need to make sure that a is non-negative.
 * If not, we check if "-a + m - 1" is non-negative.
 * If so, we can rewrite
 *
 *	floor(a/m) = -ceil(-a/m) = -floor((-a + m - 1)/m)
 *
 * and still extract a modulo.
 */
================================================================================

文件路径: ./isl_ast_build_expr.c
注释行数: 23
注释内容:
/* Check if "aff" involves any (implicit) modulo computations.
 * If so, remove them from aff and add expressions corresponding
 * to those modulo computations to *pos and/or *neg.
 * We only do this if the option ast_build_prefer_pdiv is set.
 *
 * "aff" is assumed to be an integer affine expression.
 *
 * A modulo expression is of the form
 *
 *	a mod m = a - m * floor(a / m)
 *
 * To detect them in aff, we look for terms of the form
 *
 *	f * m * floor(a / m)
 *
 * rewrite them as
 *
 *	f * (a - (a mod m)) = f * a - f * (a mod m)
 *
 * and extract out -f * (a mod m).
 * In particular, if f > 0, we add (f * (a mod m)) to *neg.
 * If f < 0, we add ((-f) * (a mod m)) to *pos.
 */
================================================================================

文件路径: ./isl_ast_build_expr.c
注释行数: 26
注释内容:
/* Check if the equality
 *
 *	aff = 0
 *
 * represents a stride constraint on the integer division "pos".
 *
 * In particular, if the integer division "pos" is equal to
 *
 *	floor(e/d)
 *
 * then check if aff is equal to
 *
 *	e - d floor(e/d)
 *
 * or its opposite.
 *
 * If so, the equality is exactly
 *
 *	e mod d = 0
 *
 * Note that in principle we could also accept
 *
 *	e - d floor(e'/d)
 *
 * where e and e' differ by a constant.
 */
================================================================================

文件路径: ./isl_ast_build_expr.c
注释行数: 21
注释内容:
/* Give an equality of the form
 *
 *	aff = e - d floor(e/d) = 0
 *
 * or
 *
 *	aff = -e + d floor(e/d) = 0
 *
 * with the integer division "pos" equal to floor(e/d),
 * construct the AST expression
 *
 *	(isl_ast_expr_op_eq,
 *		(isl_ast_expr_op_zdiv_r, expr(e), expr(d)), expr(0))
 *
 * If e only has negative coefficients, then construct
 *
 *	(isl_ast_expr_op_eq,
 *		(isl_ast_expr_op_zdiv_r, expr(-e), expr(d)), expr(0))
 *
 * instead.
 */
================================================================================

文件路径: ./isl_ast_build_expr.c
注释行数: 37
注释内容:
/* Construct an isl_ast_expr that evaluates the condition "constraint",
 * The result is simplified in terms of build->domain.
 *
 * We first check if the constraint is an equality of the form
 *
 *	e - d floor(e/d) = 0
 *
 * i.e.,
 *
 *	e mod d = 0
 *
 * If so, we convert it to
 *
 *	(isl_ast_expr_op_eq,
 *		(isl_ast_expr_op_zdiv_r, expr(e), expr(d)), expr(0))
 *
 * Otherwise, let the constraint by either "a >= 0" or "a == 0".
 * We first extract hidden modulo computations from "a"
 * and then collect all the terms with a positive coefficient in cons_pos
 * and the terms with a negative coefficient in cons_neg.
 *
 * The result is then of the form
 *
 *	(isl_ast_expr_op_ge, expr(pos), expr(-neg)))
 *
 * or
 *
 *	(isl_ast_expr_op_eq, expr(pos), expr(-neg)))
 *
 * However, if the first expression is an integer constant (and the second
 * is not), then we swap the two expressions.  This ensures that we construct,
 * e.g., "i <= 5" rather than "5 >= i".
 *
 * Furthermore, is there are no terms with positive coefficients (or no terms
 * with negative coefficients), then the constant term is added to "pos"
 * (or "neg"), ignoring the sign of the constant term.
 */
================================================================================

文件路径: ./isl_ast_build_expr.c
注释行数: 20
注释内容:
/* Construct an isl_ast_expr that evaluates the conditions defining "bset".
 * The result is simplified in terms of build->domain.
 *
 * If "bset" is not bounded by any constraint, then we construct
 * the expression "1", i.e., "true".
 *
 * Otherwise, we sort the constraints, putting constraints that involve
 * integer divisions after those that do not, and construct an "and"
 * of the ast expressions of the individual constraints.
 *
 * Each constraint is added to the generated constraints of the build
 * after it has been converted to an AST expression so that it can be used
 * to simplify the following constraints.  This may change the truth value
 * of subsequent constraints that do not satisfy the earlier constraints,
 * but this does not affect the outcome of the conjunction as it is
 * only true if all the conjuncts are true (no matter in what order
 * they are evaluated).  In particular, the constraints that do not
 * involve integer divisions may serve to simplify some constraints
 * that do involve integer divisions.
 */
================================================================================

文件路径: ./isl_ast_build_expr.c
注释行数: 21
注释内容:
/* Construct an isl_ast_expr that evaluates the conditions defining "set".
 * The result is simplified in terms of build->domain.
 *
 * If "set" is an (obviously) empty set, then return the expression "0".
 *
 * If there are multiple disjuncts in the description of the set,
 * then subsequent disjuncts are simplified in a context where
 * the previous disjuncts have been removed from build->domain.
 * In particular, constraints that ensure that there is no overlap
 * with these previous disjuncts, can be removed.
 * This is mostly useful for disjuncts that are only defined by
 * a single constraint (relative to the build domain) as the opposite
 * of that single constraint can then be removed from the other disjuncts.
 * In order not to increase the number of disjuncts in the build domain
 * after subtracting the previous disjuncts of "set", the simple hull
 * is computed after taking the difference with each of these disjuncts.
 * This means that constraints that prevent overlap with a union
 * of multiple previous disjuncts are not removed.
 *
 * "set" lives in the internal schedule space.
 */
================================================================================

文件路径: ./isl_ast_build_expr.c
注释行数: 12
注释内容:
/* Construct an isl_ast_expr that evaluates the conditions defining "set".
 * The result is simplified in terms of build->domain.
 *
 * If "set" is an (obviously) empty set, then return the expression "0".
 *
 * "set" lives in the external schedule space.
 *
 * The internal AST expression generation assumes that there are
 * no unknown divs, so make sure an explicit representation is available.
 * Since the set comes from the outside, it may have constraints that
 * are redundant with respect to the build domain.  Remove them first.
 */
================================================================================

文件路径: ./isl_ast_build_expr.c
注释行数: 17
注释内容:
/* Internal date structure representing a single piece in the input of
 * isl_ast_build_expr_from_pw_aff_internal.
 *
 * If "state" is isl_state_none, then "set_list" and "aff_list" are not used.
 * If "state" is isl_state_single, then "set_list" and "aff_list" contain the
 * single previous subpiece.
 * If "state" is isl_state_min, then "set_list" and "aff_list" contain
 * a sequence of several previous subpieces that are equal to the minimum
 * of the entries in "aff_list" over the union of "set_list"
 * If "state" is isl_state_max, then "set_list" and "aff_list" contain
 * a sequence of several previous subpieces that are equal to the maximum
 * of the entries in "aff_list" over the union of "set_list"
 *
 * During the construction of the pieces, "set" is NULL.
 * After the construction, "set" is set to the union of the elements
 * in "set_list", at which point "set_list" is set to NULL.
 */
================================================================================

文件路径: ./isl_ast_build_expr.c
注释行数: 12
注释内容:
/* Internal data structure for isl_ast_build_expr_from_pw_aff_internal.
 *
 * "build" specifies the domain against which the result is simplified.
 * "dom" is the domain of the entire isl_pw_aff.
 *
 * "n" is the number of pieces constructed already.
 * In particular, during the construction of the pieces, "n" points to
 * the piece that is being constructed.  After the construction of the
 * pieces, "n" is set to the total number of pieces.
 * "max" is the total number of allocated entries.
 * "p" contains the individual pieces.
 */
================================================================================

文件路径: ./isl_ast_build_expr.c
注释行数: 13
注释内容:
/* Extend the expression in "next" to take into account
 * the piece at position "pos" in "data", allowing for a further extension
 * for the next piece(s).
 * In particular, "next" is set to a select operation that selects
 * an isl_ast_expr corresponding to data->aff_list on data->set and
 * to an expression that will be filled in by later calls.
 * Return a pointer to this location.
 * Afterwards, the state of "data" is set to isl_state_none.
 *
 * The constraints of data->set are added to the generated
 * constraints of the build such that they can be exploited to simplify
 * the AST expression constructed from data->aff_list.
 */
================================================================================

文件路径: ./isl_ast_build_expr.c
注释行数: 10
注释内容:
/* Extend the expression in "next" to take into account
 * the final piece, located at position "pos" in "data".
 * In particular, "next" is set to evaluate data->aff_list
 * and the domain is ignored.
 * Return isl_stat_ok on success and isl_stat_error on failure.
 *
 * The constraints of data->set are however added to the generated
 * constraints of the build such that they can be exploited to simplify
 * the AST expression constructed from data->aff_list.
 */
================================================================================

文件路径: ./isl_ast_build_expr.c
注释行数: 13
注释内容:
/* Construct an isl_ast_expr from the pieces in "data".
 * Return the result or NULL on failure.
 *
 * When this function is called, data->n points to the current piece.
 * If this is an effective piece, then first increment data->n such
 * that data->n contains the number of pieces.
 * The "set_list" fields are subsequently replaced by the corresponding
 * "set" fields, after which the pieces are sorted according to
 * the number of disjuncts in these "set" fields.
 *
 * Construct intermediate AST expressions for the initial pieces and
 * finish off with the final pieces.
 */
================================================================================

文件路径: ./isl_ast_build_expr.c
注释行数: 19
注释内容:
/* Can the list of subpieces in the last piece of "data" be extended with
 * "set" and "aff" based on "test"?
 * In particular, is it the case for each entry (set_i, aff_i) that
 *
 *	test(aff, aff_i) holds on set_i, and
 *	test(aff_i, aff) holds on set?
 *
 * "test" returns the set of elements where the tests holds, meaning
 * that test(aff_i, aff) holds on set if set is a subset of test(aff_i, aff).
 *
 * This function is used to detect min/max expressions.
 * If the ast_build_detect_min_max option is turned off, then
 * do not even try and perform any detection and return false instead.
 *
 * Rational affine expressions are not considered for min/max expressions
 * since the combined expression will be defined on the union of the domains,
 * while a rational expression may only yield integer values
 * on its own definition domain.
 */
================================================================================

文件路径: ./isl_ast_build_expr.c
注释行数: 18
注释内容:
/* This function is called during the construction of an isl_ast_expr
 * that evaluates an isl_pw_aff.
 * If the last piece of "data" contains a single subpiece and
 * if its affine function is equal to "aff" on a part of the domain
 * that includes either "set" or the domain of that single subpiece,
 * then extend the domain of that single subpiece with "set".
 * If it was the original domain of the single subpiece where
 * the two affine functions are equal, then also replace
 * the affine function of the single subpiece by "aff".
 * If the last piece of "data" contains either a single subpiece
 * or a minimum, then check if this minimum expression can be extended
 * with (set, aff).
 * If so, extend the sequence and return.
 * Perform the same operation for maximum expressions.
 * If no such extension can be performed, then move to the next piece
 * in "data" (if the current piece contains any data), and then store
 * the current subpiece in the current piece of "data" for later handling.
 */
================================================================================

文件路径: ./isl_ast_build_expr.c
注释行数: 10
注释内容:
/* Construct an isl_ast_expr of type "type" that calls or accesses
 * the element specified by "mpa".
 * The first argument is obtained from the output tuple name.
 * The remaining arguments are given by the piecewise affine expressions.
 *
 * If the range of "mpa" is a mapped relation, then we assume it
 * represents an access to a member of a structure.
 *
 * The domain of "mpa" is assumed to live in the internal schedule domain.
 */
================================================================================

文件路径: ./isl_tarjan.c
注释行数: 11
注释内容:
/*
 * Copyright 2010-2011 INRIA Saclay
 * Copyright 2012      Ecole Normale Superieure
 *
 * Use of this software is governed by the MIT license
 *
 * Written by Sven Verdoolaege, INRIA Saclay - Ile-de-France,
 * Parc Club Orsay Universite, ZAC des vignes, 4 rue Jacques Monod,
 * 91893 Orsay, France
 * and Ecole Normale Superieure, 45 rue d’Ulm, 75230 Paris, France
 */
================================================================================

文件路径: ./basis_reduction_templ.c
注释行数: 11
注释内容:
/*
 * Copyright 2006-2007 Universiteit Leiden
 * Copyright 2008-2009 Katholieke Universiteit Leuven
 *
 * Use of this software is governed by the MIT license
 *
 * Written by Sven Verdoolaege, Leiden Institute of Advanced Computer Science,
 * Universiteit Leiden, Niels Bohrweg 1, 2333 CA Leiden, The Netherlands
 * and K.U.Leuven, Departement Computerwetenschappen, Celestijnenlaan 200A,
 * B-3001 Leuven, Belgium
 */
================================================================================

文件路径: ./basis_reduction_templ.c
注释行数: 21
注释内容:
/* Compute a reduced basis for the set represented by the tableau "tab".
 * tab->basis, which must be initialized by the calling function to an affine
 * unimodular basis, is updated to reflect the reduced basis.
 * The first tab->n_zero rows of the basis (ignoring the constant row)
 * are assumed to correspond to equalities and are left untouched.
 * tab->n_zero is updated to reflect any additional equalities that
 * have been detected in the first rows of the new basis.
 * The final tab->n_unbounded rows of the basis are assumed to correspond
 * to unbounded directions and are also left untouched.
 * In particular this means that the remaining rows are assumed to
 * correspond to bounded directions.
 *
 * This function implements the algorithm described in
 * "An Implementation of the Generalized Basis Reduction Algorithm
 *  for Integer Programming" of Cook el al. to compute a reduced basis.
 * We use \epsilon = 1/4.
 *
 * If ctx->opt->gbr_only_first is set, the user is only interested
 * in the first direction.  In this case we stop the basis reduction when
 * the width in the first direction becomes smaller than 2.
 */
================================================================================

文件路径: ./isl_sample.c
注释行数: 23
注释内容:
/* Perform a greedy search for an integer point in the set represented
 * by "tab", given that the minimal rational value (rounded up to the
 * nearest integer) at "level" is smaller than the maximal rational
 * value (rounded down to the nearest integer).
 *
 * Return 1 if we have found an integer point (if tab->n_unbounded > 0
 * then we may have only found integer values for the bounded dimensions
 * and it is the responsibility of the caller to extend this solution
 * to the unbounded dimensions).
 * Return 0 if greedy search did not result in a solution.
 * Return -1 if some error occurred.
 *
 * We assign a value half-way between the minimum and the maximum
 * to the current dimension and check if the minimal value of the
 * next dimension is still smaller than (or equal) to the maximal value.
 * We continue this process until either
 * - the minimal value (rounded up) is greater than the maximal value
 *	(rounded down).  In this case, greedy search has failed.
 * - we have exhausted all bounded dimensions, meaning that we have
 *	found a solution.
 * - the sample value of the tableau is integral.
 * - some error has occurred.
 */
================================================================================

文件路径: ./isl_sample.c
注释行数: 55
注释内容:
/* Given a tableau representing a set, find and return
 * an integer point in the set, if there is any.
 *
 * We perform a depth first search
 * for an integer point, by scanning all possible values in the range
 * attained by a basis vector, where an initial basis may have been set
 * by the calling function.  Otherwise an initial basis that exploits
 * the equalities in the tableau is created.
 * tab->n_zero is currently ignored and is clobbered by this function.
 *
 * The tableau is allowed to have unbounded direction, but then
 * the calling function needs to set an initial basis, with the
 * unbounded directions last and with tab->n_unbounded set
 * to the number of unbounded directions.
 * Furthermore, the calling functions needs to add shifted copies
 * of all constraints involving unbounded directions to ensure
 * that any feasible rational value in these directions can be rounded
 * up to yield a feasible integer value.
 * In particular, let B define the given basis x' = B x
 * and let T be the inverse of B, i.e., X = T x'.
 * Let a x + c >= 0 be a constraint of the set represented by the tableau,
 * or a T x' + c >= 0 in terms of the given basis.  Assume that
 * the bounded directions have an integer value, then we can safely
 * round up the values for the unbounded directions if we make sure
 * that x' not only satisfies the original constraint, but also
 * the constraint "a T x' + c + s >= 0" with s the sum of all
 * negative values in the last n_unbounded entries of "a T".
 * The calling function therefore needs to add the constraint
 * a x + c + s >= 0.  The current function then scans the first
 * directions for an integer value and once those have been found,
 * it can compute "T ceil(B x)" to yield an integer point in the set.
 * Note that during the search, the first rows of B may be changed
 * by a basis reduction, but the last n_unbounded rows of B remain
 * unaltered and are also not mixed into the first rows.
 *
 * The search is implemented iteratively.  "level" identifies the current
 * basis vector.  "init" is true if we want the first value at the current
 * level and false if we want the next value.
 *
 * At the start of each level, we first check if we can find a solution
 * using greedy search.  If not, we continue with the exhaustive search.
 *
 * The initial basis is the identity matrix.  If the range in some direction
 * contains more than one integer value, we perform basis reduction based
 * on the value of ctx->opt->gbr
 *	- ISL_GBR_NEVER:	never perform basis reduction
 *	- ISL_GBR_ONCE:		only perform basis reduction the first
 *				time such a range is encountered
 *	- ISL_GBR_ALWAYS:	always perform basis reduction when
 *				such a range is encountered
 *
 * When ctx->opt->gbr is set to ISL_GBR_ALWAYS, then we allow the basis
 * reduction computation to return early.  That is, as soon as it
 * finds a reasonable first direction.
 */
================================================================================

文件路径: ./isl_sample.c
注释行数: 12
注释内容:
/* Given a basic set "bset" and a value "sample" for the first coordinates
 * of bset, plug in these values and drop the corresponding coordinates.
 *
 * We do this by computing the preimage of the transformation
 *
 *	     [ 1 0 ]
 *	x =  [ s 0 ] x'
 *	     [ 0 I ]
 *
 * where [1 s] is the sample value and I is the identity matrix of the
 * appropriate dimension.
 */
================================================================================

文件路径: ./isl_sample.c
注释行数: 33
注释内容:
/* Given a linear cone "cone" and a rational point "vec",
 * construct a polyhedron with shifted copies of the constraints in "cone",
 * i.e., a polyhedron with "cone" as its recession cone, such that each
 * point x in this polyhedron is such that the unit box positioned at x
 * lies entirely inside the affine cone 'vec + cone'.
 * Any rational point in this polyhedron may therefore be rounded up
 * to yield an integer point that lies inside said affine cone.
 *
 * Denote the constraints of cone by "<a_i, x> >= 0" and the rational
 * point "vec" by v/d.
 * Let b_i = <a_i, v>.  Then the affine cone 'vec + cone' is given
 * by <a_i, x> - b/d >= 0.
 * The polyhedron <a_i, x> - ceil{b/d} >= 0 is a subset of this affine cone.
 * We prefer this polyhedron over the actual affine cone because it doesn't
 * require a scaling of the constraints.
 * If each of the vertices of the unit cube positioned at x lies inside
 * this polyhedron, then the whole unit cube at x lies inside the affine cone.
 * We therefore impose that x' = x + \sum e_i, for any selection of unit
 * vectors lies inside the polyhedron, i.e.,
 *
 *	<a_i, x'> - ceil{b/d} = <a_i, x> + sum a_i - ceil{b/d} >= 0
 *
 * The most stringent of these constraints is the one that selects
 * all negative a_i, so the polyhedron we are looking for has constraints
 *
 *	<a_i, x> + sum_{a_i < 0} a_i - ceil{b/d} >= 0
 *
 * Note that if cone were known to have only non-negative rays
 * (which can be accomplished by a unimodular transformation),
 * then we would only have to check the points x' = x + e_i
 * and we only have to add the smallest negative a_i (if any)
 * instead of the sum of all negative a_i.
 */
================================================================================

文件路径: ./isl_sample.c
注释行数: 11
注释内容:
/* Given a rational point vec in a (transformed) basic set,
 * such that cone is the recession cone of the original basic set,
 * "round up" the rational point to an integer point.
 *
 * We first check if the rational point just happens to be integer.
 * If not, we transform the cone in the same way as the basic set,
 * pick a point x in this cone shifted to the rational point such that
 * the whole unit cube at x is also inside this affine cone.
 * Then we simply round up the coordinates of x and return the
 * resulting integer point.
 */
================================================================================

文件路径: ./isl_sample.c
注释行数: 37
注释内容:
/* Give a basic set "bset" with recession cone "cone", compute and
 * return an integer point in bset, if any.
 *
 * If the recession cone is full-dimensional, then we know that
 * bset contains an infinite number of integer points and it is
 * fairly easy to pick one of them.
 * If the recession cone is not full-dimensional, then we first
 * transform bset such that the bounded directions appear as
 * the first dimensions of the transformed basic set.
 * We do this by using a unimodular transformation that transforms
 * the equalities in the recession cone to equalities on the first
 * dimensions.
 *
 * The transformed set is then projected onto its bounded dimensions.
 * Note that to compute this projection, we can simply drop all constraints
 * involving any of the unbounded dimensions since these constraints
 * cannot be combined to produce a constraint on the bounded dimensions.
 * To see this, assume that there is such a combination of constraints
 * that produces a constraint on the bounded dimensions.  This means
 * that some combination of the unbounded dimensions has both an upper
 * bound and a lower bound in terms of the bounded dimensions, but then
 * this combination would be a bounded direction too and would have been
 * transformed into a bounded dimensions.
 *
 * We then compute a sample value in the bounded dimensions.
 * If no such value can be found, then the original set did not contain
 * any integer points and we are done.
 * Otherwise, we plug in the value we found in the bounded dimensions,
 * project out these bounded dimensions and end up with a set with
 * a full-dimensional recession cone.
 * A sample point in this set is computed by "rounding up" any
 * rational point in the set.
 *
 * The sample points in the bounded and unbounded dimensions are
 * then combined into a single sample point and transformed back
 * to the original space.
 */
================================================================================

文件路径: ./isl_sample.c
注释行数: 17
注释内容:
/* Given a tableau "tab", a tableau "tab_cone" that corresponds
 * to the recession cone and the inverse of a new basis U = inv(B),
 * with the unbounded directions in B last,
 * add constraints to "tab" that ensure any rational value
 * in the unbounded directions can be rounded up to an integer value.
 *
 * The new basis is given by x' = B x, i.e., x = U x'.
 * For any rational value of the last tab->n_unbounded coordinates
 * in the update tableau, the value that is obtained by rounding
 * up this value should be contained in the original tableau.
 * For any constraint "a x + c >= 0", we therefore need to add
 * a constraint "a x + c + s >= 0", with s the sum of all negative
 * entries in the last elements of "a U".
 *
 * Since we are not interested in the first entries of any of the "a U",
 * we first drop the columns of U that correpond to bounded directions.
 */
================================================================================

文件路径: ./isl_sample.c
注释行数: 14
注释内容:
/* Compute and return an initial basis for the possibly
 * unbounded tableau "tab".  "tab_cone" is a tableau
 * for the corresponding recession cone.
 * Additionally, add constraints to "tab" that ensure
 * that any rational value for the unbounded directions
 * can be rounded up to an integer value.
 *
 * If the tableau is bounded, i.e., if the recession cone
 * is zero-dimensional, then we just use inital_basis.
 * Otherwise, we construct a basis whose first directions
 * correspond to equalities, followed by bounded directions,
 * i.e., equalities in the recession cone.
 * The remaining directions are then unbounded.
 */
================================================================================

文件路径: ./isl_list_templ.c
注释行数: 14
注释内容:
/*
 * Copyright 2008-2009 Katholieke Universiteit Leuven
 * Copyright 2011      INRIA Saclay
 * Copyright 2012-2013 Ecole Normale Superieure
 * Copyright 2017      Sven Verdoolaege
 *
 * Use of this software is governed by the MIT license
 *
 * Written by Sven Verdoolaege, K.U.Leuven, Departement
 * Computerwetenschappen, Celestijnenlaan 200A, B-3001 Leuven, Belgium
 * and INRIA Saclay - Ile-de-France, Parc Club Orsay Universite,
 * ZAC des vignes, 4 rue Jacques Monod, 91893 Orsay, France
 * and Ecole Normale Superieure, 45 rue d’Ulm, 75230 Paris, France
 */
================================================================================

文件路径: ./isl_list_templ.c
注释行数: 10
注释内容:
/* Return the element at position "index" of "list".
 * This may be either a copy or the element itself
 * if there is only one reference to "list".
 * This allows the element to be modified inplace
 * if both the list and the element have only a single reference.
 * The caller is not allowed to modify "list" between
 * this call to isl_list_*_take_* and a subsequent call
 * to isl_list_*_restore_*.
 * The only exception is that isl_list_*_free can be called instead.
 */
================================================================================

文件路径: ./isl_list_templ.c
注释行数: 12
注释内容:
/* Call "fn" on each of the strongly connected components (SCCs) of
 * the graph with as vertices the elements of "list" and
 * a directed edge from node b to node a iff follows(a, b)
 * returns 1.  follows should return -1 on error.
 *
 * If SCC a contains a node i that follows a node j in another SCC b
 * (i.e., follows(i, j, user) returns 1), then fn will be called on SCC a
 * after being called on SCC b.
 *
 * We simply call isl_tarjan_graph_init, extract the SCCs from the result and
 * call fn on each of them.
 */
================================================================================

文件路径: ./isl_equalities.c
注释行数: 11
注释内容:
/*
 * Copyright 2008-2009 Katholieke Universiteit Leuven
 * Copyright 2010      INRIA Saclay
 *
 * Use of this software is governed by the MIT license
 *
 * Written by Sven Verdoolaege, K.U.Leuven, Departement
 * Computerwetenschappen, Celestijnenlaan 200A, B-3001 Leuven, Belgium
 * and INRIA Saclay - Ile-de-France, Parc Club Orsay Universite,
 * ZAC des vignes, 4 rue Jacques Monod, 91893 Orsay, France
 */
================================================================================

文件路径: ./isl_equalities.c
注释行数: 46
注释内容:
/* Given a set of modulo constraints
 *
 *		c + A y = 0 mod d
 *
 * this function computes a particular solution y_0
 *
 * The input is given as a matrix B = [ c A ] and a vector d.
 *
 * The output is matrix containing the solution y_0 or
 * a zero-column matrix if the constraints admit no integer solution.
 *
 * The given set of constrains is equivalent to
 *
 *		c + A y = -D x
 *
 * with D = diag d and x a fresh set of variables.
 * Reducing both c and A modulo d does not change the
 * value of y in the solution and may lead to smaller coefficients.
 * Let M = [ D A ] and [ H 0 ] = M U, the Hermite normal form of M.
 * Then
 *		  [ x ]
 *		M [ y ] = - c
 * and so
 *		               [ x ]
 *		[ H 0 ] U^{-1} [ y ] = - c
 * Let
 *		[ A ]          [ x ]
 *		[ B ] = U^{-1} [ y ]
 * then
 *		H A + 0 B = -c
 *
 * so B may be chosen arbitrarily, e.g., B = 0, and then
 *
 *		       [ x ] = [ -c ]
 *		U^{-1} [ y ] = [  0 ]
 * or
 *		[ x ]     [ -c ]
 *		[ y ] = U [  0 ]
 * specifically,
 *
 *		y = U_{2,1} (-c)
 *
 * If any of the coordinates of this y are non-integer
 * then the constraints admit no integer solution and
 * a zero-column matrix is returned.
 */
================================================================================

文件路径: ./isl_equalities.c
注释行数: 13
注释内容:
/* Compute a common lattice of solutions to the linear modulo
 * constraints specified by B and d.
 * See also the documentation of isl_mat_parameter_compression.
 * We put the matrix
 * 
 *		A = [ L_1^{-T} L_2^{-T} ... L_k^{-T} ]
 *
 * on a common denominator.  This denominator D is the lcm of modulos d.
 * Since L_i = U_i^{-1} diag(d_i, 1, ... 1), we have
 * L_i^{-T} = U_i^T diag(d_i, 1, ... 1)^{-T} = U_i^T diag(1/d_i, 1, ..., 1).
 * Putting this on the common denominator, we have
 * D * L_i^{-T} = U_i^T diag(D/d_i, D, ..., D).
 */
================================================================================

文件路径: ./isl_equalities.c
注释行数: 94
注释内容:
/* Given a set of modulo constraints
 *
 *		c + A y = 0 mod d
 *
 * this function returns an affine transformation T,
 *
 *		y = T y'
 *
 * that bijectively maps the integer vectors y' to integer
 * vectors y that satisfy the modulo constraints.
 *
 * This function is inspired by Section 2.5.3
 * of B. Meister, "Stating and Manipulating Periodicity in the Polytope
 * Model.  Applications to Program Analysis and Optimization".
 * However, the implementation only follows the algorithm of that
 * section for computing a particular solution and not for computing
 * a general homogeneous solution.  The latter is incomplete and
 * may remove some valid solutions.
 * Instead, we use an adaptation of the algorithm in Section 7 of
 * B. Meister, S. Verdoolaege, "Polynomial Approximations in the Polytope
 * Model: Bringing the Power of Quasi-Polynomials to the Masses".
 *
 * The input is given as a matrix B = [ c A ] and a vector d.
 * Each element of the vector d corresponds to a row in B.
 * The output is a lower triangular matrix.
 * If no integer vector y satisfies the given constraints then
 * a matrix with zero columns is returned.
 *
 * We first compute a particular solution y_0 to the given set of
 * modulo constraints in particular_solution.  If no such solution
 * exists, then we return a zero-columned transformation matrix.
 * Otherwise, we compute the generic solution to
 *
 *		A y = 0 mod d
 *
 * That is we want to compute G such that
 *
 *		y = G y''
 *
 * with y'' integer, describes the set of solutions.
 *
 * We first remove the common factors of each row.
 * In particular if gcd(A_i,d_i) != 1, then we divide the whole
 * row i (including d_i) by this common factor.  If afterwards gcd(A_i) != 1,
 * then we divide this row of A by the common factor, unless gcd(A_i) = 0.
 * In the later case, we simply drop the row (in both A and d).
 *
 * If there are no rows left in A, then G is the identity matrix. Otherwise,
 * for each row i, we now determine the lattice of integer vectors
 * that satisfies this row.  Let U_i be the unimodular extension of the
 * row A_i.  This unimodular extension exists because gcd(A_i) = 1.
 * The first component of
 *
 *		y' = U_i y
 *
 * needs to be a multiple of d_i.  Let y' = diag(d_i, 1, ..., 1) y''.
 * Then,
 *
 *		y = U_i^{-1} diag(d_i, 1, ..., 1) y''
 *
 * for arbitrary integer vectors y''.  That is, y belongs to the lattice
 * generated by the columns of L_i = U_i^{-1} diag(d_i, 1, ..., 1).
 * If there is only one row, then G = L_1.
 *
 * If there is more than one row left, we need to compute the intersection
 * of the lattices.  That is, we need to compute an L such that
 *
 *		L = L_i L_i'	for all i
 *
 * with L_i' some integer matrices.  Let A be constructed as follows
 *
 *		A = [ L_1^{-T} L_2^{-T} ... L_k^{-T} ]
 *
 * and computed the Hermite Normal Form of A = [ H 0 ] U
 * Then,
 *
 *		L_i^{-T} = H U_{1,i}
 *
 * or
 *
 *		H^{-T} = L_i U_{1,i}^T
 *
 * In other words G = L = H^{-T}.
 * To ensure that G is lower triangular, we compute and use its Hermite
 * normal form.
 *
 * The affine transformation matrix returned is then
 *
 *		[  1   0  ]
 *		[ y_0  G  ]
 *
 * as any y = y_0 + G y' with y' integer is a solution to the original
 * modulo constraints.
 */
================================================================================

文件路径: ./isl_equalities.c
注释行数: 26
注释内容:
/* Given a set of equalities
 *
 *		B(y) + A x = 0						(*)
 *
 * compute and return an affine transformation T,
 *
 *		y = T y'
 *
 * that bijectively maps the integer vectors y' to integer
 * vectors y that satisfy the modulo constraints for some value of x.
 *
 * Let [H 0] be the Hermite Normal Form of A, i.e.,
 *
 *		A = [H 0] Q
 *
 * Then y is a solution of (*) iff
 *
 *		H^-1 B(y) (= - [I 0] Q x)
 *
 * is an integer vector.  Let d be the common denominator of H^-1.
 * We impose
 *
 *		d H^-1 B(y) = 0 mod d
 *
 * and compute the solution using isl_mat_parameter_compression.
 */
================================================================================

文件路径: ./isl_equalities.c
注释行数: 47
注释内容:
/* Given a set of equalities
 *
 *		-C(y) + M x = 0
 *
 * this function computes a unimodular transformation from a lower-dimensional
 * space to the original space that bijectively maps the integer points x'
 * in the lower-dimensional space to the integer points x in the original
 * space that satisfy the equalities.
 *
 * The input is given as a matrix B = [ -C M ] and the output is a
 * matrix that maps [1 x'] to [1 x].
 * The number of equality constraints in B is assumed to be smaller than
 * or equal to the number of variables x.
 * "first" is the position of the first x variable.
 * The preceding variables are considered to be y-variables.
 * If T2 is not NULL, then *T2 is set to a matrix mapping [1 x] to [1 x'].
 *
 * First compute the (left) Hermite normal form of M,
 *
 *		M [U1 U2] = M U = H = [H1 0]
 * or
 *		              M = H Q = [H1 0] [Q1]
 *                                             [Q2]
 *
 * with U, Q unimodular, Q = U^{-1} (and H lower triangular).
 * Define the transformed variables as
 *
 *		x = [U1 U2] [ x1' ] = [U1 U2] [Q1] x
 *		            [ x2' ]           [Q2]
 *
 * The equalities then become
 *
 *		-C(y) + H1 x1' = 0   or   x1' = H1^{-1} C(y) = C'(y)
 *
 * If the denominator of the constant term does not divide the
 * the common denominator of the coefficients of y, then every
 * integer point is mapped to a non-integer point and then the original set
 * has no integer solutions (since the x' are a unimodular transformation
 * of the x).  In this case, a zero-column matrix is returned.
 * Otherwise, the transformation is given by
 *
 *		x = U1 H1^{-1} C(y) + U2 x2'
 *
 * The inverse transformation is simply
 *
 *		x2' = Q2 x
 */
================================================================================

文件路径: ./isl_equalities.c
注释行数: 15
注释内容:
/* Given a set of equalities
 *
 *		M x - c = 0
 *
 * this function computes a unimodular transformation from a lower-dimensional
 * space to the original space that bijectively maps the integer points x'
 * in the lower-dimensional space to the integer points x in the original
 * space that satisfy the equalities.
 *
 * The input is given as a matrix B = [ -c M ] and the output is a
 * matrix that maps [1 x'] to [1 x].
 * The number of equality constraints in B is assumed to be smaller than
 * or equal to the number of variables x.
 * If T2 is not NULL, then *T2 is set to a matrix mapping [1 x] to [1 x'].
 */
================================================================================

文件路径: ./isl_transitive_closure.c
注释行数: 17
注释内容:
/* Check whether the overapproximation of the power of "map" is exactly
 * the power of "map".  Let R be "map" and A_k the overapproximation.
 * The approximation is exact if
 *
 *	A_1 = R
 *	A_k = A_{k-1} \circ R			k >= 2
 *
 * Since A_k is known to be an overapproximation, we only need to check
 *
 *	A_1 \subset R
 *	A_k \subset A_{k-1} \circ R		k >= 2
 *
 * In practice, "app" has an extra input and output coordinate
 * to encode the length of the path.  So, we first need to add
 * this coordinate to "map" and set the length of the path to
 * one.
 */
================================================================================

文件路径: ./isl_transitive_closure.c
注释行数: 21
注释内容:
/* Check whether the overapproximation of the power of "map" is exactly
 * the power of "map", possibly after projecting out the power (if "project"
 * is set).
 *
 * If "project" is set and if "steps" can only result in acyclic paths,
 * then we check
 *
 *	A = R \cup (A \circ R)
 *
 * where A is the overapproximation with the power projected out, i.e.,
 * an overapproximation of the transitive closure.
 * More specifically, since A is known to be an overapproximation, we check
 *
 *	A \subset R \cup (A \circ R)
 *
 * Otherwise, we check if the power is exact.
 *
 * Note that "app" has an extra input and output coordinate to encode
 * the length of the part.  If we are only interested in the transitive
 * closure, then we can simply project out these coordinates first.
 */
================================================================================

文件路径: ./isl_transitive_closure.c
注释行数: 12
注释内容:
/* Given a set of n offsets v_i (the rows of "steps"), construct a relation
 * of the given dimension specification (Z^{n+1} -> Z^{n+1})
 * that maps an element x to any element that can be reached
 * by taking a non-negative number of steps along any of
 * the extended offsets v'_i = [v_i 1].
 * That is, construct
 *
 * { [x] -> [y] : exists k_i >= 0, y = x + \sum_i k_i v'_i }
 *
 * For any element in this relation, the number of steps taken
 * is equal to the difference in the final coordinates.
 */
================================================================================

文件路径: ./isl_transitive_closure.c
注释行数: 55
注释内容:
/* Given a set of offsets "delta", construct a relation of the
 * given dimension specification (Z^{n+1} -> Z^{n+1}) that
 * is an overapproximation of the relations that
 * maps an element x to any element that can be reached
 * by taking a non-negative number of steps along any of
 * the elements in "delta".
 * That is, construct an approximation of
 *
 *	{ [x] -> [y] : exists f \in \delta, k \in Z :
 *					y = x + k [f, 1] and k >= 0 }
 *
 * For any element in this relation, the number of steps taken
 * is equal to the difference in the final coordinates.
 *
 * In particular, let delta be defined as
 *
 *	\delta = [p] -> { [x] : A x + a >= 0 and B p + b >= 0 and
 *				C x + C'p + c >= 0 and
 *				D x + D'p + d >= 0 }
 *
 * where the constraints C x + C'p + c >= 0 are such that the parametric
 * constant term of each constraint j, "C_j x + C'_j p + c_j",
 * can never attain positive values, then the relation is constructed as
 *
 *	{ [x] -> [y] : exists [f, k] \in Z^{n+1} : y = x + f and
 *			A f + k a >= 0 and B p + b >= 0 and
 *			C f + C'p + c >= 0 and k >= 1 }
 *	union { [x] -> [x] }
 *
 * If the zero-length paths happen to correspond exactly to the identity
 * mapping, then we return
 *
 *	{ [x] -> [y] : exists [f, k] \in Z^{n+1} : y = x + f and
 *			A f + k a >= 0 and B p + b >= 0 and
 *			C f + C'p + c >= 0 and k >= 0 }
 *
 * instead.
 *
 * Existentially quantified variables in \delta are handled by
 * classifying them as independent of the parameters, purely
 * parameter dependent and others.  Constraints containing
 * any of the other existentially quantified variables are removed.
 * This is safe, but leads to an additional overapproximation.
 *
 * If there are any impure constraints, then we also eliminate
 * the parameters from \delta, resulting in a set
 *
 *	\delta' = { [x] : E x + e >= 0 }
 *
 * and add the constraints
 *
 *			E f + k e >= 0
 *
 * to the constructed relation.
 */
================================================================================

文件路径: ./isl_transitive_closure.c
注释行数: 25
注释内容:
/* Given a union of basic maps R = \cup_i R_i \subseteq D \times D
 * and a dimension specification (Z^{n+1} -> Z^{n+1}),
 * construct a map that is an overapproximation of the map
 * that takes an element from the space D \times Z to another
 * element from the same space, such that the first n coordinates of the
 * difference between them is a sum of differences between images
 * and pre-images in one of the R_i and such that the last coordinate
 * is equal to the number of steps taken.
 * That is, let
 *
 *	\Delta_i = { y - x | (x, y) in R_i }
 *
 * then the constructed map is an overapproximation of
 *
 *	{ (x) -> (x + d) | \exists k_i >= 0, \delta_i \in \Delta_i :
 *				d = (\sum_i k_i \delta_i, \sum_i k_i) }
 *
 * The elements of the singleton \Delta_i's are collected as the
 * rows of the steps matrix.  For all these \Delta_i's together,
 * a single path is constructed.
 * For each of the other \Delta_i's, we compute an overapproximation
 * of the paths along elements of \Delta_i.
 * Since each of these paths performs an addition, composition is
 * symmetric and we can simply compose all resulting paths in any order.
 */
================================================================================

文件路径: ./isl_transitive_closure.c
注释行数: 19
注释内容:
/* Given a union of basic maps R = \cup_i R_i \subseteq D \times D
 * and a dimension specification (Z^{n+1} -> Z^{n+1}),
 * construct a map that is an overapproximation of the map
 * that takes an element from the dom R \times Z to an
 * element from ran R \times Z, such that the first n coordinates of the
 * difference between them is a sum of differences between images
 * and pre-images in one of the R_i and such that the last coordinate
 * is equal to the number of steps taken.
 * That is, let
 *
 *	\Delta_i = { y - x | (x, y) in R_i }
 *
 * then the constructed map is an overapproximation of
 *
 *	{ (x) -> (x + d) | \exists k_i >= 0, \delta_i \in \Delta_i :
 *				d = (\sum_i k_i \delta_i, \sum_i k_i) and
 *				x in dom R and x + d in ran R and
 *				\sum_i k_i >= 1 }
 */
================================================================================

文件路径: ./isl_transitive_closure.c
注释行数: 29
注释内容:
/* For each basic map in "map", except i, check whether it combines
 * with the transitive closure that is reflexive on C combines
 * to the left and to the right.
 *
 * In particular, if
 *
 *	dom map_j \subseteq C
 *
 * then right[j] is set to 1.  Otherwise, if
 *
 *	ran map_i \cap dom map_j = \emptyset
 *
 * then right[j] is set to 0.  Otherwise, composing to the right
 * is impossible.
 *
 * Similar, for composing to the left, we have if
 *
 *	ran map_j \subseteq C
 *
 * then left[j] is set to 1.  Otherwise, if
 *
 *	dom map_i \cap ran map_j = \emptyset
 *
 * then left[j] is set to 0.  Otherwise, composing to the left
 * is impossible.
 *
 * The return value is or'd with LEFT if composing to the left
 * is possible and with RIGHT if composing to the right is possible.
 */
================================================================================

文件路径: ./isl_transitive_closure.c
注释行数: 15
注释内容:
/* Compute the transitive closure of "map" incrementally by
 * computing
 *
 *	map_i^+ \cup qc^+
 *
 * or
 *
 *	map_i^+ \cup ((id \cup map_i^) \circ qc^+)
 *
 * or
 *
 *	map_i^+ \cup (qc^+ \circ (id \cup map_i^))
 *
 * depending on whether left or right are NULL.
 */
================================================================================

文件路径: ./isl_transitive_closure.c
注释行数: 15
注释内容:
/* Given a map "map", try to find a basic map such that
 * map^+ can be computed as
 *
 * map^+ = map_i^+ \cup
 *    \bigcup_j ((map_i^+ \cup Id_C)^+ \circ map_j \circ (map_i^+ \cup Id_C))^+
 *
 * with C the simple hull of the domain and range of the input map.
 * map_i^ \cup Id_C is computed by allowing the path lengths to be zero
 * and by intersecting domain and range with C.
 * Of course, we need to check that this is actually equal to map_i^ \cup Id_C.
 * Also, we only use the incremental computation if all the transitive
 * closures are exact and if the number of basic maps in the union,
 * after computing the integer divisions, is smaller than the number
 * of basic maps in the input map.
 */
================================================================================

文件路径: ./isl_transitive_closure.c
注释行数: 11
注释内容:
/* The core of the Floyd-Warshall algorithm.
 * Updates the given n x x matrix of relations in place.
 *
 * The algorithm iterates over all vertices.  In each step, the whole
 * matrix is updated to include all paths that go to the current vertex,
 * possibly stay there a while (including passing through earlier vertices)
 * and then come back.  At the start of each iteration, the diagonal
 * element corresponding to the current vertex is replaced by its
 * transitive closure to account for all indirect paths that stay
 * in the current vertex.
 */
================================================================================

文件路径: ./isl_transitive_closure.c
注释行数: 19
注释内容:
/* Given a partition of the domains and ranges of the basic maps in "map",
 * apply the Floyd-Warshall algorithm with the elements in the partition
 * as vertices.
 *
 * In particular, there are "n" elements in the partition and "group" is
 * an array of length 2 * map->n with entries in [0,n-1].
 *
 * We first construct a matrix of relations based on the partition information,
 * apply Floyd-Warshall on this matrix of relations and then take the
 * union of all entries in the matrix as the final result.
 *
 * If we are actually computing the power instead of the transitive closure,
 * i.e., when "project" is not set, then the result should have the
 * path lengths encoded as the difference between an extra pair of
 * coordinates.  We therefore apply the nested transitive closures
 * to relations that include these lengths.  In particular, we replace
 * the input relation by the cross product with the unit length relation
 * { [i] -> [i + 1] }.
 */
================================================================================

文件路径: ./isl_transitive_closure.c
注释行数: 14
注释内容:
/* Partition the domains and ranges of the n basic relations in list
 * into disjoint cells.
 *
 * To find the partition, we simply consider all of the domains
 * and ranges in turn and combine those that overlap.
 * "set" contains the partition elements and "group" indicates
 * to which partition element a given domain or range belongs.
 * The domain of basic map i corresponds to element 2 * i in these arrays,
 * while the domain corresponds to element 2 * i + 1.
 * During the construction group[k] is either equal to k,
 * in which case set[k] contains the union of all the domains and
 * ranges in the corresponding group, or is equal to some l < k,
 * with l another domain or range in the same group.
 */
================================================================================

文件路径: ./isl_transitive_closure.c
注释行数: 18
注释内容:
/* Check whether in the computation of the transitive closure
 * "list[i]" (R_1) should follow (or be part of the same component as)
 * "list[j]" (R_2).
 *
 * That is check whether
 *
 *	R_1 \circ R_2
 *
 * is a subset of
 *
 *	R_2 \circ R_1
 *
 * If so, then there is no reason for R_1 to immediately follow R_2
 * in any path.
 *
 * *check_closed is set if the subset relation holds while
 * R_1 \circ R_2 is not empty.
 */
================================================================================

文件路径: ./isl_transitive_closure.c
注释行数: 33
注释内容:
/* Given a union of basic maps R = \cup_i R_i \subseteq D \times D
 * and a dimension specification (Z^{n+1} -> Z^{n+1}),
 * construct a map that is an overapproximation of the map
 * that takes an element from the dom R \times Z to an
 * element from ran R \times Z, such that the first n coordinates of the
 * difference between them is a sum of differences between images
 * and pre-images in one of the R_i and such that the last coordinate
 * is equal to the number of steps taken.
 * If "project" is set, then these final coordinates are not included,
 * i.e., a relation of type Z^n -> Z^n is returned.
 * That is, let
 *
 *	\Delta_i = { y - x | (x, y) in R_i }
 *
 * then the constructed map is an overapproximation of
 *
 *	{ (x) -> (x + d) | \exists k_i >= 0, \delta_i \in \Delta_i :
 *				d = (\sum_i k_i \delta_i, \sum_i k_i) and
 *				x in dom R and x + d in ran R }
 *
 * or
 *
 *	{ (x) -> (x + d) | \exists k_i >= 0, \delta_i \in \Delta_i :
 *				d = (\sum_i k_i \delta_i) and
 *				x in dom R and x + d in ran R }
 *
 * if "project" is set.
 *
 * We first split the map into strongly connected components, perform
 * the above on each component and then join the results in the correct
 * order, at each join also taking in the union of both arguments
 * to allow for paths that do not go through one of the two arguments.
 */
================================================================================

文件路径: ./isl_transitive_closure.c
注释行数: 29
注释内容:
/* Given a union of basic maps R = \cup_i R_i \subseteq D \times D,
 * construct a map that is an overapproximation of the map
 * that takes an element from the space D to another
 * element from the same space, such that the difference between
 * them is a strictly positive sum of differences between images
 * and pre-images in one of the R_i.
 * The number of differences in the sum is equated to parameter "param".
 * That is, let
 *
 *	\Delta_i = { y - x | (x, y) in R_i }
 *
 * then the constructed map is an overapproximation of
 *
 *	{ (x) -> (x + d) | \exists k_i >= 0, \delta_i \in \Delta_i :
 *				d = \sum_i k_i \delta_i and k = \sum_i k_i > 0 }
 * or
 *
 *	{ (x) -> (x + d) | \exists k_i >= 0, \delta_i \in \Delta_i :
 *				d = \sum_i k_i \delta_i and \sum_i k_i > 0 }
 *
 * if "project" is set.
 *
 * If "project" is not set, then
 * we construct an extended mapping with an extra coordinate
 * that indicates the number of steps taken.  In particular,
 * the difference in the last coordinate is equal to the number
 * of steps taken to move from a domain element to the corresponding
 * image element(s).
 */
================================================================================

文件路径: ./isl_transitive_closure.c
注释行数: 29
注释内容:
/* Given a map, compute the smallest superset of this map that is of the form
 *
 *	{ i -> j : L <= j - i <= U and exists a_p: j_p - i_p = M_p a_p }
 *
 * (where p ranges over the (non-parametric) dimensions),
 * compute the transitive closure of this map, i.e.,
 *
 *	{ i -> j : exists k > 0:
 *		k L <= j - i <= k U and exists a: j_p - i_p = M_p a_p }
 *
 * and intersect domain and range of this transitive closure with
 * the given domain and range.
 *
 * If with_id is set, then try to include as much of the identity mapping
 * as possible, by computing
 *
 *	{ i -> j : exists k >= 0:
 *		k L <= j - i <= k U and exists a: j_p - i_p = M_p a_p }
 *
 * instead (i.e., allow k = 0).
 *
 * In practice, we compute the difference set
 *
 *	delta  = { j - i | i -> j in map },
 *
 * look for stride constraint on the individual dimensions and compute
 * (constant) lower and upper bounds for each individual dimension,
 * adding a constraint for each bound not equal to infinity.
 */
================================================================================

文件路径: ./isl_transitive_closure.c
注释行数: 13
注释内容:
/* Given a map, compute the smallest superset of this map that is of the form
 *
 *	{ i -> j : L <= j - i <= U and exists a_p: j_p - i_p = M_p a_p }
 *
 * (where p ranges over the (non-parametric) dimensions),
 * compute the transitive closure of this map, i.e.,
 *
 *	{ i -> j : exists k > 0:
 *		k L <= j - i <= k U and exists a: j_p - i_p = M_p a_p }
 *
 * and intersect domain and range of this transitive closure with
 * domain and range of the original map.
 */
================================================================================

文件路径: ./isl_transitive_closure.c
注释行数: 13
注释内容:
/* Given a map, compute the smallest superset of this map that is of the form
 *
 *	{ i -> j : L <= j - i <= U and exists a_p: j_p - i_p = M_p a_p }
 *
 * (where p ranges over the (non-parametric) dimensions),
 * compute the transitive and partially reflexive closure of this map, i.e.,
 *
 *	{ i -> j : exists k >= 0:
 *		k L <= j - i <= k U and exists a: j_p - i_p = M_p a_p }
 *
 * and intersect domain and range of this transitive closure with
 * the given domain.
 */
================================================================================

文件路径: ./isl_transitive_closure.c
注释行数: 28
注释内容:
/* Check if basic map M_i can be combined with all the other
 * basic maps such that
 *
 *	(\cup_j M_j)^+
 *
 * can be computed as
 *
 *	M_i \cup (\cup_{j \ne i} M_i^* \circ M_j \circ M_i^*)^+
 *
 * In particular, check if we can compute a compact representation
 * of
 *
 *		M_i^* \circ M_j \circ M_i^*
 *
 * for each j != i.
 * Let M_i^? be an extension of M_i^+ that allows paths
 * of length zero, i.e., the result of box_closure(., 1).
 * The criterion, as proposed by Kelly et al., is that
 * id = M_i^? - M_i^+ can be represented as a basic map
 * and that
 *
 *	id \circ M_j \circ id = M_j
 *
 * for each j != i.
 *
 * If this function returns 1, then tc and qc are set to
 * M_i^+ and M_i^?, respectively.
 */
================================================================================

文件路径: ./isl_transitive_closure.c
注释行数: 18
注释内容:
/* Compute an overapproximation of the transitive closure of "map"
 * using a variation of the algorithm from
 * "Transitive Closure of Infinite Graphs and its Applications"
 * by Kelly et al.
 *
 * We first check whether we can can split of any basic map M_i and
 * compute
 *
 *	(\cup_j M_j)^+
 *
 * as
 *
 *	M_i \cup (\cup_{j \ne i} M_i^* \circ M_j \circ M_i^*)^+
 *
 * using a recursive call on the remaining map.
 *
 * If not, we simply call box_closure on the whole map.
 */
================================================================================

文件路径: ./isl_tab.c
注释行数: 14
注释内容:
/*
 * Copyright 2008-2009 Katholieke Universiteit Leuven
 * Copyright 2013      Ecole Normale Superieure
 * Copyright 2014      INRIA Rocquencourt
 * Copyright 2016      Sven Verdoolaege
 *
 * Use of this software is governed by the MIT license
 *
 * Written by Sven Verdoolaege, K.U.Leuven, Departement
 * Computerwetenschappen, Celestijnenlaan 200A, B-3001 Leuven, Belgium
 * and Ecole Normale Superieure, 45 rue d'Ulm, 75230 Paris, France
 * and Inria Paris - Rocquencourt, Domaine de Voluceau - Rocquencourt,
 * B.P. 105 - 78153 Le Chesnay, France
 */
================================================================================

文件路径: ./isl_tab.c
注释行数: 13
注释内容:
/* Construct the coefficient matrix of the product tableau
 * of two tableaus.
 * mat{1,2} is the coefficient matrix of tableau {1,2}
 * row{1,2} is the number of rows in tableau {1,2}
 * col{1,2} is the number of columns in tableau {1,2}
 * off is the offset to the coefficient column (skipping the
 *	denominator, the constant term and the big parameter if any)
 * r{1,2} is the number of redundant rows in tableau {1,2}
 * d{1,2} is the number of dead columns in tableau {1,2}
 *
 * The order of the rows and columns in the result is as explained
 * in isl_tab_product.
 */
================================================================================

文件路径: ./isl_tab.c
注释行数: 18
注释内容:
/* Create a tableau that represents the Cartesian product of the sets
 * represented by tableaus tab1 and tab2.
 * The order of the rows in the product is
 *	- redundant rows of tab1
 *	- redundant rows of tab2
 *	- non-redundant rows of tab1
 *	- non-redundant rows of tab2
 * The order of the columns is
 *	- denominator
 *	- constant term
 *	- coefficient of big parameter, if any
 *	- dead columns of tab1
 *	- dead columns of tab2
 *	- live columns of tab1
 *	- live columns of tab2
 * The order of the variables and the constraints is a concatenation
 * of order in the two input tableaus.
 */
================================================================================

文件路径: ./isl_tab.c
注释行数: 20
注释内容:
/* Given the index of a column "c", return the index of a row
 * that can be used to pivot the column in, with either an increase
 * (sgn > 0) or a decrease (sgn < 0) of the corresponding variable.
 * If "var" is not NULL, then the row returned will be different from
 * the one associated with "var".
 *
 * Each row in the tableau is of the form
 *
 *	x_r = a_r0 + \sum_i a_ri x_i
 *
 * Only rows with x_r >= 0 and with the sign of a_ri opposite to "sgn"
 * impose any limit on the increase or decrease in the value of x_c
 * and this bound is equal to a_r0 / |a_rc|.  We are therefore looking
 * for the row with the smallest (most stringent) such bound.
 * Note that the common denominator of each row drops out of the fraction.
 * To check if row j has a smaller bound than row r, i.e.,
 * a_j0 / |a_jc| < a_r0 / |a_rc| or a_j0 |a_rc| < a_r0 |a_jc|,
 * we check if -sign(a_jc) (a_j0 a_rc - a_r0 a_jc) < 0,
 * where -sign(a_jc) is equal to "sgn".
 */
================================================================================

文件路径: ./isl_tab.c
注释行数: 16
注释内容:
/* Find a pivot (row and col) that will increase (sgn > 0) or decrease
 * (sgn < 0) the value of row variable var.
 * If not NULL, then skip_var is a row variable that should be ignored
 * while looking for a pivot row.  It is usually equal to var.
 *
 * As the given row in the tableau is of the form
 *
 *	x_r = a_r0 + \sum_i a_ri x_i
 *
 * we need to find a column such that the sign of a_ri is equal to "sgn"
 * (such that an increase in x_i will have the desired effect) or a
 * column with a variable that may attain negative values.
 * If a_ri is positive, then we need to move x_i in the same direction
 * to obtain the desired effect.  Otherwise, x_i has to move in the
 * opposite direction.
 */
================================================================================

文件路径: ./isl_tab.c
注释行数: 12
注释内容:
/* Mark row with index "row" as being redundant.
 * If we may need to undo the operation or if the row represents
 * a variable of the original problem, the row is kept,
 * but no longer considered when looking for a pivot row.
 * Otherwise, the row is simply removed.
 *
 * The row may be interchanged with some other row.  If it
 * is interchanged with a later row, return 1.  Otherwise return 0.
 * If the rows are checked in order in the calling function,
 * then a return value of 1 means that the row with the given
 * row number may now contain a different row that hasn't been checked yet.
 */
================================================================================

文件路径: ./isl_tab.c
注释行数: 17
注释内容:
/* Update the rows signs after a pivot of "row" and "col", with "row_sgn"
 * the original sign of the pivot element.
 * We only keep track of row signs during PILP solving and in this case
 * we only pivot a row with negative sign (meaning the value is always
 * non-positive) using a positive pivot element.
 *
 * For each row j, the new value of the parametric constant is equal to
 *
 *	a_j0 - a_jc a_r0/a_rc
 *
 * where a_j0 is the original parametric constant, a_rc is the pivot element,
 * a_r0 is the parametric constant of the pivot row and a_jc is the
 * pivot column entry of the row j.
 * Since a_r0 is non-positive and a_rc is positive, the sign of row j
 * remains the same if a_jc has the same sign as the row j or if
 * a_jc is zero.  In all other cases, we reset the sign to "unknown".
 */
================================================================================

文件路径: ./isl_tab.c
注释行数: 50
注释内容:
/* Given a row number "row" and a column number "col", pivot the tableau
 * such that the associated variables are interchanged.
 * The given row in the tableau expresses
 *
 *	x_r = a_r0 + \sum_i a_ri x_i
 *
 * or
 *
 *	x_c = 1/a_rc x_r - a_r0/a_rc + sum_{i \ne r} -a_ri/a_rc
 *
 * Substituting this equality into the other rows
 *
 *	x_j = a_j0 + \sum_i a_ji x_i
 *
 * with a_jc \ne 0, we obtain
 *
 *	x_j = a_jc/a_rc x_r + a_j0 - a_jc a_r0/a_rc + sum a_ji - a_jc a_ri/a_rc 
 *
 * The tableau
 *
 *	n_rc/d_r		n_ri/d_r
 *	n_jc/d_j		n_ji/d_j
 *
 * where i is any other column and j is any other row,
 * is therefore transformed into
 *
 * s(n_rc)d_r/|n_rc|		-s(n_rc)n_ri/|n_rc|
 * s(n_rc)d_r n_jc/(|n_rc| d_j)	(n_ji |n_rc| - s(n_rc)n_jc n_ri)/(|n_rc| d_j)
 *
 * The transformation is performed along the following steps
 *
 *	d_r/n_rc		n_ri/n_rc
 *	n_jc/d_j		n_ji/d_j
 *
 *	s(n_rc)d_r/|n_rc|	-s(n_rc)n_ri/|n_rc|
 *	n_jc/d_j		n_ji/d_j
 *
 *	s(n_rc)d_r/|n_rc|	-s(n_rc)n_ri/|n_rc|
 *	n_jc/(|n_rc| d_j)	n_ji/(|n_rc| d_j)
 *
 *	s(n_rc)d_r/|n_rc|	-s(n_rc)n_ri/|n_rc|
 *	n_jc/(|n_rc| d_j)	(n_ji |n_rc|)/(|n_rc| d_j)
 *
 *	s(n_rc)d_r/|n_rc|	-s(n_rc)n_ri/|n_rc|
 *	n_jc/(|n_rc| d_j)	(n_ji |n_rc| - s(n_rc)n_jc n_ri)/(|n_rc| d_j)
 *
 * s(n_rc)d_r/|n_rc|		-s(n_rc)n_ri/|n_rc|
 * s(n_rc)d_r n_jc/(|n_rc| d_j)	(n_ji |n_rc| - s(n_rc)n_jc n_ri)/(|n_rc| d_j)
 *
 */
================================================================================

文件路径: ./isl_tab.c
注释行数: 11
注释内容:
/* Return the sign of the maximal value of "var".
 * If the sign is not negative, then on return from this function,
 * the sample value will also be non-negative.
 *
 * If "var" is manifestly unbounded wrt positive values, we are done.
 * Otherwise, we pivot the variable up to a row if needed
 * Then we continue pivoting down until either
 *	- no more down pivots can be performed
 *	- the sample value is positive
 *	- the variable is pivoted into a manifestly unbounded column
 */
================================================================================

文件路径: ./isl_tab.c
注释行数: 17
注释内容:
/* Return a negative value if "var" can attain negative values.
 * Return a non-negative value otherwise.
 *
 * If "var" is manifestly unbounded wrt negative values, we are done.
 * Otherwise, if var is in a column, we can pivot it down to a row.
 * Then we continue pivoting down until either
 *	- the pivot would result in a manifestly unbounded column
 *	  => we don't perform the pivot, but simply return -1
 *	- no more down pivots can be performed
 *	- the sample value is negative
 * If the sample value becomes negative and the variable is supposed
 * to be nonnegative, then we undo the last pivot.
 * However, if the last pivot has made the pivoting variable
 * obviously redundant, then it may have moved to another row.
 * In that case we look for upward pivots until we reach a non-negative
 * value again.
 */
================================================================================

文件路径: ./isl_tab.c
注释行数: 12
注释内容:
/* Mark column with index "col" as representing a zero variable.
 * If we may need to undo the operation the column is kept,
 * but no longer considered.
 * Otherwise, the column is simply removed.
 *
 * The column may be interchanged with some other column.  If it
 * is interchanged with a later column, return 1.  Otherwise return 0.
 * If the columns are checked in order in the calling function,
 * then a return value of 1 means that the column with the given
 * column number may now contain a different column that
 * hasn't been checked yet.
 */
================================================================================

文件路径: ./isl_tab.c
注释行数: 17
注释内容:
/* Row variable "var" is non-negative and cannot attain any values
 * larger than zero.  This means that the coefficients of the unrestricted
 * column variables are zero and that the coefficients of the non-negative
 * column variables are zero or negative.
 * Each of the non-negative variables with a negative coefficient can
 * then also be written as the negative sum of non-negative variables
 * and must therefore also be zero.
 *
 * If "temp_var" is set, then "var" is a temporary variable that
 * will be removed after this function returns and for which
 * no information is recorded on the undo stack.
 * Do not add any undo records involving this variable in this case
 * since the variable will have been removed before any future undo
 * operations.  Also avoid marking the variable as redundant,
 * since that either adds an undo record or needlessly removes the row
 * (the caller will take care of removing the row).
 */
================================================================================

文件路径: ./isl_tab.c
注释行数: 22
注释内容:
/* Add a row to the tableau.  The row is given as an affine combination
 * of the original variables and needs to be expressed in terms of the
 * column variables.
 *
 * This function assumes that at least one more row and at least
 * one more element in the constraint array are available in the tableau.
 *
 * We add each term in turn.
 * If r = n/d_r is the current sum and we need to add k x, then
 * 	if x is a column variable, we increase the numerator of
 *		this column by k d_r
 *	if x = f/d_x is a row variable, then the new representation of r is
 *
 *		 n    k f   d_x/g n + d_r/g k f   m/d_r n + m/d_g k f
 *		--- + --- = ------------------- = -------------------
 *		d_r   d_r        d_r d_x/g                m
 *
 *	with g the gcd of d_r and d_x and m the lcm of d_r and d_x.
 *
 * If tab->M is set, then, internally, each variable x is represented
 * as x' - M.  We then also need no subtract k d_r from the coefficient of M.
 */
================================================================================

文件路径: ./isl_tab.c
注释行数: 10
注释内容:
/* Construct and return an inequality that expresses an upper bound
 * on the given div.
 * In particular, if the div is given by
 *
 *	d = floor(e/m)
 *
 * then the inequality expresses
 *
 *	m d <= e
 */
================================================================================

文件路径: ./isl_tab.c
注释行数: 15
注释内容:
/* For a div d = floor(f/m), add the constraints
 *
 *		f - m d >= 0
 *		-(f-(m-1)) + m d >= 0
 *
 * Note that the second constraint is the negation of
 *
 *		f - m d >= m
 *
 * If add_ineq is not NULL, then this function is used
 * instead of isl_tab_add_ineq to effectively add the inequalities.
 *
 * This function assumes that at least two more rows and at least
 * two more elements in the constraint array are available in the tableau.
 */
================================================================================

文件路径: ./isl_tab.c
注释行数: 11
注释内容:
/* Insert an extra div, prescribed by "div", to the tableau and
 * the associated bmap (which is assumed to be non-NULL).
 * The extra integer division is inserted at (tableau) position "pos".
 * Return "pos" or -1 if an error occurred.
 *
 * If add_ineq is not NULL, then this function is used instead
 * of isl_tab_add_ineq to add the div constraints.
 * This complication is needed because the code in isl_tab_pip
 * wants to perform some extra processing when an inequality
 * is added to the tableau.
 */
================================================================================

文件路径: ./isl_tab.c
注释行数: 10
注释内容:
/* Given a non-negative variable "var", temporarily add a new non-negative
 * variable that is the opposite of "var", ensuring that "var" can only attain
 * the value zero.  The new variable is removed again before this function
 * returns.  However, the effect of forcing "var" to be zero remains.
 * If var = n/d is a row variable, then the new variable = -n/d.
 * If var is a column variables, then the new variable = -var.
 * If the new variable cannot attain non-negative values, then
 * the resulting tableau is empty.
 * Otherwise, we know the value will be zero and we close the row.
 */
================================================================================

文件路径: ./isl_tab.c
注释行数: 17
注释内容:
/* Given a tableau "tab" and an inequality constraint "con" of the tableau,
 * relax the inequality by one.  That is, the inequality r >= 0 is replaced
 * by r' = r + 1 >= 0.
 * If r is a row variable, we simply increase the constant term by one
 * (taking into account the denominator).
 * If r is a column variable, then we need to modify each row that
 * refers to r = r' - 1 by substituting this equality, effectively
 * subtracting the coefficient of the column from the constant.
 * We should only do this if the minimum is manifestly unbounded,
 * however.  Otherwise, we may end up with negative sample values
 * for non-negative variables.
 * So, if r is a column variable with a minimum that is not
 * manifestly unbounded, then we need to move it to a row.
 * However, the sample value of this row may be negative,
 * even after the relaxation, so we need to restore it.
 * We therefore prefer to pivot a column up to a row, if possible.
 */
================================================================================

文件路径: ./isl_tab.c
注释行数: 17
注释内容:
/* Replace the variable v at position "pos" in the tableau "tab"
 * by v' = v + shift.
 *
 * If the variable is in a column, then we first check if we can
 * simply plug in v = v' - shift.  The effect on a row with
 * coefficient f/d for variable v is that the constant term c/d
 * is replaced by (c - f * shift)/d.  If shift is positive and
 * f is negative for each row that needs to remain non-negative,
 * then this is clearly safe.  In other words, if the minimum of v
 * is manifestly unbounded, then we can keep v in a column position.
 * Otherwise, we can pivot it down to a row.
 * Similarly, if shift is negative, we need to check if the maximum
 * of is manifestly unbounded.
 *
 * If the variable is in a row (from the start or after pivoting),
 * then the constant term c/d is replaced by (c + d * shift)/d.
 */
================================================================================

文件路径: ./isl_tab.c
注释行数: 11
注释内容:
/* Return an isl_tab_var that has been marked or NULL if no such
 * variable can be found.
 * The marked field has only been set for variables that
 * appear in non-redundant rows or non-dead columns.
 *
 * Pick the last constraint variable that is marked and
 * that appears in either a non-redundant row or a non-dead columns.
 * Since the returned variable is tested for being a redundant constraint or
 * an implicit equality, there is no need to return any tab variable that
 * corresponds to a variable.
 */
================================================================================

文件路径: ./isl_tab.c
注释行数: 17
注释内容:
/* Check for (near) equalities among the constraints.
 * A constraint is an equality if it is non-negative and if
 * its maximal value is either
 *	- zero (in case of rational tableaus), or
 *	- strictly less than 1 (in case of integer tableaus)
 *
 * We first mark all non-redundant and non-dead variables that
 * are not frozen and not obviously not an equality.
 * Then we iterate over all marked variables if they can attain
 * any values larger than zero or at least one.
 * If the maximal value is zero, we mark any column variables
 * that appear in the row as being zero and mark the row as being redundant.
 * Otherwise, if the maximal value is strictly less than one (and the
 * tableau is integer), then we restrict the value to being zero
 * by adding an opposite non-negative variable.
 * The order in which the variables are considered is not important.
 */
================================================================================

文件路径: ./isl_tab.c
注释行数: 33
注释内容:
/* Make the equalities that are implicit in "bmap" but that have been
 * detected in the corresponding "tab" explicit in "bmap" and update
 * "tab" to reflect the new order of the constraints.
 *
 * In particular, if inequality i is an implicit equality then
 * isl_basic_map_inequality_to_equality will move the inequality
 * in front of the other equality and it will move the last inequality
 * in the position of inequality i.
 * In the tableau, the inequalities of "bmap" are stored after the equalities
 * and so the original order
 *
 *		E E E E E A A A I B B B B L
 *
 * is changed into
 *
 *		I E E E E E A A A L B B B B
 *
 * where I is the implicit equality, the E are equalities,
 * the A inequalities before I, the B inequalities after I and
 * L the last inequality.
 * We therefore need to rotate to the right two sets of constraints,
 * those up to and including I and those after I.
 *
 * If "tab" contains any constraints that are not in "bmap" then they
 * appear after those in "bmap" and they should be left untouched.
 *
 * Note that this function only calls isl_basic_map_gauss
 * (in case some equality constraints got detected)
 * if "bmap" has more than one reference.
 * If it only has a single reference, then it is left in a temporary state,
 * because the caller may require this state.
 * Calling isl_basic_map_gauss is then the responsibility of the caller.
 */
================================================================================

文件路径: ./isl_tab.c
注释行数: 13
注释内容:
/* Check for (near) redundant constraints.
 * A constraint is redundant if it is non-negative and if
 * its minimal value (temporarily ignoring the non-negativity) is either
 *	- zero (in case of rational tableaus), or
 *	- strictly larger than -1 (in case of integer tableaus)
 *
 * We first mark all non-redundant and non-dead variables that
 * are not frozen and not obviously negatively unbounded.
 * Then we iterate over all marked variables if they can attain
 * any values smaller than zero or at most negative one.
 * If not, we mark the row as being redundant (assuming it hasn't
 * been detected as being obviously redundant in the mean time).
 */
================================================================================

文件路径: ./isl_tab.c
注释行数: 10
注释内容:
/* Return the minimal value of the affine expression "f" with denominator
 * "denom" in *opt, *opt_denom, assuming the tableau is not empty and
 * the expression cannot attain arbitrarily small values.
 * If opt_denom is NULL, then *opt is rounded up to the nearest integer.
 * The return value reflects the nature of the result (empty, unbounded,
 * minimal value returned in *opt).
 *
 * This function assumes that at least one more row and at least
 * one more element in the constraint array are available in the tableau.
 */
================================================================================

文件路径: ./isl_tab.c
注释行数: 10
注释内容:
/* Has the variable "var' of "tab" reached a value that is greater than
 * or equal (if sgn > 0) or smaller than or equal (if sgn < 0) to "target"?
 * "tmp" has been initialized by the caller and can be used
 * to perform local computations.
 *
 * If the sample value involves the big parameter, then any value
 * is reached.
 * Otherwise check if n/d >= t, i.e., n >= d * t (if sgn > 0)
 * or n/d <= t, i.e., n <= d * t (if sgn < 0).
 */
================================================================================

文件路径: ./isl_tab.c
注释行数: 16
注释内容:
/* Can variable "var" of "tab" attain the value "target" by
 * pivoting up (if sgn > 0) or down (if sgn < 0)?
 * If not, then pivot up [down] to the greatest [smallest]
 * rational value.
 * "tmp" has been initialized by the caller and can be used
 * to perform local computations.
 *
 * If the variable is manifestly unbounded in the desired direction,
 * then it can attain any value.
 * Otherwise, it can be moved to a row.
 * Continue pivoting until the target is reached.
 * If no more pivoting can be performed, the maximal [minimal]
 * rational value has been reached and the target cannot be reached.
 * If the variable would be pivoted into a manifestly unbounded column,
 * then the target can be reached.
 */
================================================================================

文件路径: ./isl_tab.c
注释行数: 19
注释内容:
/* Check if variable "var" of "tab" can only attain a single (integer)
 * value, and, if so, add an equality constraint to fix the variable
 * to this single value and store the result in "target".
 * "target" and "tmp" have been initialized by the caller.
 *
 * Given the current sample value, round it down and check
 * whether it is possible to attain a strictly smaller integer value.
 * If so, the variable is not restricted to a single integer value.
 * Otherwise, the search stops at the smallest rational value.
 * Round up this value and check whether it is possible to attain
 * a strictly greater integer value.
 * If so, the variable is not restricted to a single integer value.
 * Otherwise, the search stops at the greatest rational value.
 * If rounding down this value yields a value that is different
 * from rounding up the smallest rational value, then the variable
 * cannot attain any integer value.  Mark the tableau empty.
 * Otherwise, add an equality constraint that fixes the variable
 * to the single integer value found.
 */
================================================================================

文件路径: ./isl_tab.c
注释行数: 13
注释内容:
/* Check if variable "var" of "tab" can only attain a single (integer)
 * value, and, if so, add an equality constraint to fix the variable
 * to this single value and store the result in "value" (if "value"
 * is not NULL).
 *
 * If the current sample value involves the big parameter,
 * then the variable cannot have a fixed integer value.
 * If the variable is already fixed to a single value by its row, then
 * there is no need to add another equality constraint.
 *
 * Otherwise, allocate some temporary variables and continue
 * with detect_constant_with_tmp.
 */
================================================================================

文件路径: ./isl_tab.c
注释行数: 11
注释内容:
/* Restore the tableau to the state where the basic variables
 * are those in "col_var".
 * We first construct a list of variables that are currently in
 * the basis, but shouldn't.  Then we iterate over all variables
 * that should be in the basis and for each one that is currently
 * not in the basis, we exchange it with one of the elements of the
 * list constructed before.
 * We can always find an appropriate variable to pivot with because
 * the current basis is mapped to the old basis by a non-singular
 * matrix and so we can never end up with a zero row.
 */
================================================================================

文件路径: ./isl_tab.c
注释行数: 10
注释内容:
/* The given row "row" represents an inequality violated by all
 * points in the tableau.  Check for some special cases of such
 * separating constraints.
 * In particular, if the row has been reduced to the constant -1,
 * then we know the inequality is adjacent (but opposite) to
 * an equality in the tableau.
 * If the row has been reduced to r = c*(-1 -r'), with r' an inequality
 * of the tableau and c a positive constant, then the inequality
 * is adjacent (but opposite) to the inequality r'.
 */
================================================================================

文件路径: ./isl_multi_templ.h
注释行数: 10
注释内容:
/* A multiple expression with base expressions of type EL.
 *
 * "space" is the space in which the multiple expression lives.
 * "n" is the number of base expression and is equal
 * to the output or set dimension of "space".
 * "p" is an array of size "n" of base expressions.
 * The array is only accessible when n > 0.
 * "dom" is the explicit domain, if present
 * The explicit domain is only accessible when n == 0.
 */
================================================================================

文件路径: ./isl_polynomial.c
注释行数: 14
注释内容:
/* Reduce all divs of "qp" to have coefficients
 * in the interval [0, d-1], with d the denominator and such that the
 * last non-zero coefficient that is not equal to d/2 is smaller than d/2.
 * The modifications to the integer divisions need to be reflected
 * in the factors of the polynomial that refer to the original
 * integer divisions.  To this end, the modifications are collected
 * as a set of affine expressions and then plugged into the polynomial.
 *
 * After the reduction, some divs may have become redundant or identical,
 * so we call substitute_non_divs and sort_divs.  If these functions
 * eliminate divs or merge two or more divs into one, the coefficients
 * of the enclosing divs may have to be reduced again, so we call
 * ourselves recursively if the number of divs decreases.
 */
================================================================================

文件路径: ./isl_polynomial.c
注释行数: 10
注释内容:
/* Create a slice where the integer division "div" has the fixed value "v".
 * In particular, if "div" refers to floor(f/m), then create a slice
 *
 *	m v <= f <= m v + (m - 1)
 *
 * or
 *
 *	f - m v >= 0
 *	-f + m v + (m - 1) >= 0
 */
================================================================================

文件路径: ./isl_polynomial.c
注释行数: 15
注释内容:
/* Adjust all the integer divisions in "qp" such that they are at least
 * one over the given orthant (identified by "signs").  This ensures
 * that they will still be non-negative even after subtracting (m-1)/m.
 *
 * In particular, f is replaced by f' + v, changing f = [a/m]
 * to f' = [(a - m v)/m].
 * If the constant term k in a is smaller than m,
 * the constant term of v is set to floor(k/m) - 1.
 * For any other term, if the coefficient c and the variable x have
 * the same sign, then no changes are needed.
 * Otherwise, if the variable is positive (and c is negative),
 * then the coefficient of x in v is set to floor(c/m).
 * If the variable is negative (and c is positive),
 * then the coefficient of x in v is set to ceil(c/m).
 */
================================================================================

文件路径: ./isl_polynomial.c
注释行数: 12
注释内容:
/* Approximate each quasipolynomial by a polynomial.  If "sign" is positive,
 * the polynomial will be an overapproximation.  If "sign" is negative,
 * it will be an underapproximation.  If "sign" is zero, the approximation
 * will lie somewhere in between.
 *
 * In particular, is sign == 0, we simply drop the floors, turning
 * the integer divisions into rational divisions.
 * Otherwise, we split the domains into orthants, make all integer divisions
 * positive and then approximate each [a/m] by either a/m or (a-(m-1))/m,
 * depending on the requested sign and the sign of the term in which
 * the integer division appears.
 */
================================================================================

文件路径: ./isl_bound.c
注释行数: 11
注释内容:
/* Compute a bound on the polynomial defined over the parametric polytope
 * using either range propagation or bernstein expansion and
 * store the result in bound->pwf and bound->pwf_tight.
 * Since bernstein expansion requires bounded domains, we apply
 * range propagation on unbounded domains.  Otherwise, we respect the choice
 * of the user.
 *
 * If the polynomial does not depend on the set variables
 * then the bound is equal to the polynomial and
 * it can be added to "bound" directly.
 */
================================================================================

文件路径: ./isl_bound.c
注释行数: 18
注释内容:
/* Update bound->pwf and bound->pwf_tight with a bound
 * of type bound->type on the polynomial "poly" over the domain "bset".
 *
 * If the original problem had a wrapped relation in the domain,
 * meaning that the bound should be computed over the range
 * of this relation, then temporarily treat the domain dimensions
 * of this wrapped relation as parameters, compute a bound
 * in terms of these and the original parameters,
 * turn the parameters back into set dimensions and
 * add the results to bound->pwf and bound->pwf_tight.
 *
 * Note that even though "bset" is known to live in the same space
 * as the domain of "poly", the names of the set dimensions
 * may be different (or missing).  Make sure the naming is exactly
 * the same before turning these dimensions into parameters
 * to ensure that the spaces are still the same after
 * this operation.
 */
================================================================================

文件路径: ./isl_ast_build_private.h
注释行数: 134
注释内容:
/* An isl_ast_build represents the context in which AST is being
 * generated.  That is, it (mostly) contains information about outer
 * loops that can be used to simplify inner loops.
 *
 * "domain" represents constraints on the internal schedule domain,
 * corresponding to the context of the AST generation and the constraints
 * implied by the loops that have already been generated.
 * When an isl_ast_build is first created, outside any AST generation,
 * the domain is typically a parameter set.  It is only when a AST
 * generation phase is initiated that the domain of the isl_ast_build
 * is changed to refer to the internal schedule domain.
 * The domain then lives in a space of the form
 *
 *	S
 *
 *  or
 *
 *	[O -> S]
 *
 * O represents the loops generated in outer AST generations.
 * S represents the loops (both generated and to be generated)
 * of the current AST generation.
 * Both include eliminated loops.
 * "domain" is expected not to have any unknown divs because
 * it is used as the context argument in a call to isl_basic_set_gist
 * in isl_ast_build_compute_gist_basic_set.
 *
 * "depth" is equal to the number of loops that have already
 * been generated (including those in outer AST generations).
 * "outer_pos" is equal to the number of loops in outer AST generations.
 *
 * "generated" is a superset of "domain" corresponding to those
 * constraints that were either given by the user or that have
 * effectively been generated (as bounds on a for loop).
 *
 * "pending" is a superset of "domain" corresponding to the constraints
 * that still need to be generated (as guards), but that may end up
 * not getting generated if they are implied by any constraints
 * enforced by inner loops.
 *
 * "strides" contains the stride of each loop.  The number of elements
 * is equal to the number of dimensions in "domain".
 * "offsets" contains the offsets of strided loops.  If s is the stride
 * for a given dimension and f is the corresponding offset, then the
 * dimension takes on values
 *
 *	f + s a
 *
 * with a an integer.  For non-strided loops, the offset is zero.
 *
 * "iterators" contains the loop iterators of both generated and
 * to be generated loops.  The number of elements is at least as
 * large as the dimension of the internal schedule domain.  The
 * number may be larger, in which case the additional ids can be
 * used in a nested AST generation should the schedule be non-injective.
 *
 * "values" lives in the space
 *
 *	[O -> S] -> [O -> S]		(or S -> S)
 *
 * and expresses (if possible) loop iterators in terms of parameters
 * and outer loop iterators.  If the value of a given loop iterator
 * cannot be expressed as an affine expression (either because the iterator
 * attains multiple values or because the single value is a piecewise
 * affine expression), then it is expressed in "values" as being equal
 * to itself.
 *
 * "value" is the value of the loop iterator at the current depth.
 * It is NULL if it has not been computed yet or if the value of the
 * given loop iterator cannot be expressed as a piecewise affine expression
 * (because the iterator attains multiple values).
 *
 * "schedule_map" maps the internal schedule domain to the external schedule
 * domain.  It may be NULL if it hasn't been computed yet.
 * See isl_ast_build_get_schedule_map_multi_aff.
 *
 * "internal2input" maps the internal schedule domain to the original
 * input schedule domain.  In case of a schedule tree input, the original
 * input schedule domain consist of the flat product of all outer
 * band node spaces, including the current band node.
 * It may be NULL if there no longer is such a uniform mapping
 * (because different iterations have been rescheduled differently).
 *
 * "options" contains the AST build options in case we are generating
 * an AST from a flat schedule map.  When creating an AST from a schedule
 * tree, this field is ignored.
 *
 * The "create_leaf" callback is called for every leaf in the generated AST.
 * The callback is responsible for creating the node to be placed at those
 * leaves.  If this callback is not set, then isl will generated user
 * nodes with call expressions corresponding to an element of the domain.
 *
 * The "at_each_domain" callback is called on every node created to represent
 * an element of the domain.  Each of these nodes is a user node
 * with as expression a call expression.
 *
 * The "before_each_for" callback is called on each for node before
 * its children have been created.
 *
 * The "after_each_for" callback is called on each for node after
 * its children have been created.
 *
 * The "before_each_mark" callback is called before we handle the subtree
 * of an isl_schedule_node_mark node.
 *
 * The "after_each_mark" callback is called after we have handled the subtree
 * of an isl_schedule_node_mark node.
 *
 * "executed" contains the inverse schedule at this point
 * of the AST generation.
 * It is currently only used in isl_ast_build_get_schedule, which is
 * in turn only used by user code from within a callback.
 * The value is set right before we may be calling such a callback.
 *
 * "single_valued" is set if the current inverse schedule (which may or may
 * not be stored in "executed") is known to be single valued, specifically
 * an inverse schedule that was not (appeared not to be) single valued
 * is extended to a single valued inverse schedule.  This is mainly used
 * to avoid an infinite recursion when we fail to detect later on that
 * the extended inverse schedule is single valued.
 *
 * "node" points to the current band node in case we are generating
 * an AST from a schedule tree.  It may be NULL if we are not generating
 * an AST from a schedule tree or if we are not inside a band node.
 *
 * "loop_type" originally contains loop AST generation types for
 * the "n" members of "node" and it is updated (along with "n") when
 * a schedule dimension is inserted.
 * It is NULL if "node" is NULL.
 *
 * "isolated" is the piece of the schedule domain isolated by the isolate
 * option on the current band.  This set may be NULL if we have not checked
 * for the isolate option yet.
 */
================================================================================

文件路径: ./isl_local.c
注释行数: 11
注释内容:
/*
 * Copyright 2011      INRIA Saclay
 * Copyright 2014      Ecole Normale Superieure
 *
 * Use of this software is governed by the MIT license
 *
 * Written by Sven Verdoolaege, INRIA Saclay - Ile-de-France,
 * Parc Club Orsay Universite, ZAC des vignes, 4 rue Jacques Monod,
 * 91893 Orsay, France
 * and Ecole Normale Superieure, 45 rue d'Ulm, 75230 Paris, France
 */
================================================================================

文件路径: ./isl_local.c
注释行数: 10
注释内容:
/* Compare two sets of local variables, defined over
 * the same space.
 *
 * Return -1 if "local1" is "smaller" than "local2", 1 if "local1" is "greater"
 * than "local2" and 0 if they are equal.
 *
 * The order is fairly arbitrary.  We do "prefer" divs that only involve
 * earlier dimensions in the sense that we consider matrices where
 * the first differing div involves earlier dimensions to be smaller.
 */
================================================================================

文件路径: ./isl_schedule_band.h
注释行数: 21
注释内容:
/* Information about a band within a schedule.
 *
 * n is the number of scheduling dimensions within the band.
 * coincident is an array of length n, indicating whether a scheduling dimension
 *	satisfies the coincidence constraints in the sense that
 *	the corresponding dependence distances are zero.
 * permutable is set if the band is permutable.
 * mupa is the partial schedule corresponding to this band.  The dimension
 *	of mupa is equal to n.
 * loop_type contains the loop AST generation types for the members
 * in the band.  It may be NULL, if all members are
 * of type isl_ast_loop_default.
 * isolate_loop_type contains the loop AST generation types for the members
 * in the band for the isolated part.  It may be NULL, if all members are
 * of type isl_ast_loop_default.
 * ast_build_options are the remaining AST build options associated
 * to the band.
 * anchored is set if the node depends on its position in the schedule tree.
 *	In particular, it is set if the AST build options include
 *	an isolate option.
 */
================================================================================

文件路径: ./isl_test_cpp.cc
注释行数: 15
注释内容:
/* Test the (unchecked) isl C++ interface
 *
 * This includes:
 *  - The isl C <-> C++ pointer interface
 *  - Object construction
 *  - Different parameter types
 *  - Different return types
 *  - Foreach functions
 *  - Exceptions
 *  - Spaces
 *  - Schedule trees
 *  - AST generation
 *  - AST expression generation
 *  - Templated interface
 */
================================================================================

文件路径: ./isl_multi_splice_templ.c
注释行数: 23
注释内容:
/* Given two multi expressions, "multi1"
 *
 *	[A1 A2] -> [B1 B2]
 *
 * where A2 starts at position "in_pos" and B2 starts at position "out_pos",
 * and "multi2"
 *
 *	[C] -> [D]
 *
 * return the multi expression
 *
 *	[A1 C A2] -> [B1 D B2]
 *
 * We first insert input dimensions to obtain
 *
 *	[A1 C A2] -> [B1 B2]
 *
 * and
 *
 *	[A1 C A2] -> [D]
 *
 * and then apply range_splice.
 */
================================================================================

文件路径: ./isl_test_cpp-checked.cc
注释行数: 12
注释内容:
/* Test that isl_bool values are returned correctly.
 *
 * We check in detail the following parts of the isl::boolean class:
 *  - The is_true, is_false, and is_error functions return true in case they
 *    are called on a true, false, or error instance of isl::boolean,
 *    respectively
 *  - Explicit conversion to 'bool'
 *  - Implicit conversion to 'bool'
 *  - The complement operator
 *  - Explicit construction from 'true' and 'false'
 *  - Explicit construction form isl_bool
 */
================================================================================

文件路径: ./isl_test_cpp-checked.cc
注释行数: 14
注释内容:
/* Test the isl checked C++ interface
 *
 * This includes:
 *  - The isl C <-> C++ pointer interface
 *  - Object construction
 *  - Different parameter types
 *  - Different return types
 *  - Foreach functions
 *  - Every functions
 *  - Spaces
 *  - Schedule trees
 *  - AST generation
 *  - AST expression generation
 */
================================================================================

文件路径: ./isl_ast_codegen.c
注释行数: 11
注释内容:
/*
 * Copyright 2012-2014 Ecole Normale Superieure
 * Copyright 2014      INRIA Rocquencourt
 *
 * Use of this software is governed by the MIT license
 *
 * Written by Sven Verdoolaege,
 * Ecole Normale Superieure, 45 rue d’Ulm, 75230 Paris, France
 * and Inria Paris - Rocquencourt, Domaine de Voluceau - Rocquencourt,
 * B.P. 105 - 78153 Le Chesnay, France
 */
================================================================================

文件路径: ./isl_ast_codegen.c
注释行数: 19
注释内容:
/* Generate an AST for a single domain based on
 * the (non single valued) inverse schedule "executed".
 *
 * We extend the schedule with the iteration domain
 * and continue generating through a call to generate_code.
 *
 * In particular, if executed has the form
 *
 *	S -> D
 *
 * then we continue generating code on
 *
 *	[S -> D] -> D
 *
 * The extended inverse schedule is clearly single valued
 * ensuring that the nested generate_code will not reach this function,
 * but will instead create calls to all elements of D that need
 * to be executed from the current schedule domain.
 */
================================================================================

文件路径: ./isl_ast_codegen.c
注释行数: 18
注释内容:
/* Generate a call expression for the single executed
 * domain element "map" and put a guard around it based its (simplified)
 * domain.  "executed" is the original inverse schedule from which "map"
 * has been derived.  In particular, "map" is either identical to "executed"
 * or it is the result of gisting "executed" with respect to the build domain.
 * "executed" is only used if there is an at_each_domain callback.
 *
 * At this stage, any pending constraints in the build can no longer
 * be simplified with respect to any enforced constraints since
 * the call node does not have any enforced constraints.
 * Since all pending constraints not covered by any enforced constraints
 * will be added as a guard to the graft in create_node_scaled,
 * even in the eliminated case, the pending constraints
 * can be considered to have been generated by outer constructs.
 *
 * If the user has set an at_each_domain callback, it is called
 * on the constructed call expression node.
 */
================================================================================

文件路径: ./isl_ast_codegen.c
注释行数: 35
注释内容:
/* Generate an AST for a single domain based on
 * the inverse schedule "executed" and add it to data->list.
 *
 * If there is more than one domain element associated to the current
 * schedule "time", then we need to continue the generation process
 * in generate_non_single_valued.
 * Note that the inverse schedule being single-valued may depend
 * on constraints that are only available in the original context
 * domain specified by the user.  We therefore first introduce
 * some of the constraints of data->build->domain.  In particular,
 * we intersect with a single-disjunct approximation of this set.
 * We perform this approximation to avoid further splitting up
 * the executed relation, possibly introducing a disjunctive guard
 * on the statement.
 *
 * On the other hand, we only perform the test after having taken the gist
 * of the domain as the resulting map is the one from which the call
 * expression is constructed.  Using this map to construct the call
 * expression usually yields simpler results in cases where the original
 * map is not obviously single-valued.
 * If the original map is obviously single-valued, then the gist
 * operation is skipped.
 *
 * Because we perform the single-valuedness test on the gisted map,
 * we may in rare cases fail to recognize that the inverse schedule
 * is single-valued.  This becomes problematic if this happens
 * from the recursive call through generate_non_single_valued
 * as we would then end up in an infinite recursion.
 * We therefore check if we are inside a call to generate_non_single_valued
 * and revert to the ungisted map if the gisted map turns out not to be
 * single-valued.
 *
 * Otherwise, call add_domain to generate a call expression (with guard) and
 * to call the at_each_domain callback, if any.
 */
================================================================================

文件路径: ./isl_ast_codegen.c
注释行数: 16
注释内容:
/* Call build->create_leaf to a create "leaf" node in the AST,
 * encapsulate the result in an isl_ast_graft and return the result
 * as a 1-element list.
 *
 * Note that the node returned by the user may be an entire tree.
 *
 * Since the node itself cannot enforce any constraints, we turn
 * all pending constraints into guards and add them to the resulting
 * graft to ensure that they will be generated.
 *
 * Before we pass control to the user, we first clear some information
 * from the build that is (presumbably) only meaningful
 * for the current code generation.
 * This includes the create_leaf callback itself, so we make a copy
 * of the build first.
 */
================================================================================

文件路径: ./isl_ast_codegen.c
注释行数: 12
注释内容:
/* Generate an AST after having handled the complete schedule
 * of this call to the code generator or the complete band
 * if we are generating an AST from a schedule tree.
 *
 * If we are inside a band node, then move on to the child of the band.
 *
 * If the user has specified a create_leaf callback, control
 * is passed to the user in call_create_leaf.
 *
 * Otherwise, we generate one or more calls for each individual
 * domain in generate_domain.
 */
================================================================================

文件路径: ./isl_ast_codegen.c
注释行数: 20
注释内容:
/* Extract a lower bound on dimension "pos" from constraint "c".
 *
 * If the constraint is of the form
 *
 *	a x + f(...) >= 0
 *
 * then we essentially return
 *
 *	l = ceil(-f(...)/a)
 *
 * However, if the current dimension is strided, then we need to make
 * sure that the lower bound we construct is of the form
 *
 *	f + s a
 *
 * with f the offset and s the stride.
 * We therefore compute
 *
 *	f + s * ceil((l - f)/s)
 */
================================================================================

文件路径: ./isl_ast_codegen.c
注释行数: 12
注释内容:
/* Return the exact lower bound (or upper bound if "upper" is set)
 * of "domain" as a piecewise affine expression.
 *
 * If we are computing a lower bound (of a strided dimension), then
 * we need to make sure it is of the form
 *
 *	f + s a
 *
 * where f is the offset and s is the stride.
 * We therefore need to include the stride constraint before computing
 * the minimum.
 */
================================================================================

文件路径: ./isl_ast_codegen.c
注释行数: 13
注释内容:
/* Given a list of lower bounds "list", remove those that are redundant
 * with respect to the other bounds in "list" and the domain of "build".
 *
 * We first sort the bounds in the same way as they would be sorted
 * by set_for_node_expressions so that we can try and remove the last
 * bounds first.
 *
 * For a lower bound to be effective, there needs to be at least
 * one domain element for which it is larger than all other lower bounds.
 * For each lower bound we therefore intersect the domain with
 * the conditions that it is larger than all other bounds and
 * check whether the result is empty.  If so, the bound can be removed.
 */
================================================================================

文件路径: ./isl_ast_codegen.c
注释行数: 11
注释内容:
/* Extract a lower bound on dimension "pos" from each constraint
 * in "constraints" and return the list of lower bounds.
 * If "constraints" has zero elements, then we extract a lower bound
 * from "domain" instead.
 *
 * If the current dimension is strided, then the lower bound
 * is adjusted by lower_bound to match the stride information.
 * This modification may make one or more lower bounds redundant
 * with respect to the other lower bounds.  We therefore check
 * for this condition and remove the redundant lower bounds.
 */
================================================================================

文件路径: ./isl_ast_codegen.c
注释行数: 11
注释内容:
/* Add guards implied by the "generated constraints",
 * but not (necessarily) enforced by the generated AST to "guard".
 * In particular, if there is any stride constraints,
 * then add the guard implied by those constraints.
 * If we have generated a degenerate loop, then add the guard
 * implied by "bounds" on the outer dimensions, i.e., the guard
 * that ensures that the single value actually exists.
 * Since there may also be guards implied by a combination
 * of these constraints, we first combine them before
 * deriving the implied constraints.
 */
================================================================================

文件路径: ./isl_ast_codegen.c
注释行数: 11
注释内容:
/* Update "graft" based on "sub_build" for the degenerate case.
 *
 * "build" is the build in which graft->node was created
 * "sub_build" contains information about the current level itself,
 * including the single value attained.
 *
 * We set the initialization part of the for loop to the single
 * value attained by the current dimension.
 * The increment and condition are not strictly needed as the are known
 * to be "1" and "iterator <= value" respectively.
 */
================================================================================

文件路径: ./isl_ast_codegen.c
注释行数: 28
注释内容:
/* Compute the constraints on the outer dimensions enforced by
 * graft->node and add those constraints to graft->enforced,
 * in case the upper bound is expressed as a set "upper".
 *
 * In particular, if l(...) is a lower bound in "lower", and
 *
 *	-a i + f(...) >= 0		or	a i <= f(...)
 *
 * is an upper bound ocnstraint on the current dimension i,
 * then the for loop enforces the constraint
 *
 *	-a l(...) + f(...) >= 0		or	a l(...) <= f(...)
 *
 * We therefore simply take each lower bound in turn, plug it into
 * the upper bounds and compute the intersection over all lower bounds.
 *
 * If a lower bound is a rational expression, then
 * isl_basic_set_preimage_multi_aff will force this rational
 * expression to have only integer values.  However, the loop
 * itself does not enforce this integrality constraint.  We therefore
 * use the ceil of the lower bounds instead of the lower bounds themselves.
 * Other constraints will make sure that the for loop is only executed
 * when each of the lower bounds attains an integral value.
 * In particular, potentially rational values only occur in
 * lower_bound if the offset is a (seemingly) rational expression,
 * but then outer conditions will make sure that this rational expression
 * only attains integer values.
 */
================================================================================

文件路径: ./isl_ast_codegen.c
注释行数: 13
注释内容:
/* Set the condition part of the for node graft->node in case
 * the upper bound is represented as a list of piecewise affine expressions.
 *
 * In particular, set the condition to
 *
 *	iterator <= min(list of upper bounds)
 *
 * If each of the upper bounds has a negative constant term, then
 * set the condition to
 *
 *	iterator < min(list of (upper bound + 1)s)
 *
 */
================================================================================

文件路径: ./isl_ast_codegen.c
注释行数: 19
注释内容:
/* Should we express the loop condition as
 *
 *	iterator <= min(list of upper bounds)
 *
 * or as a conjunction of constraints?
 *
 * The first is constructed from a list of upper bounds.
 * The second is constructed from a set.
 *
 * If there are no upper bounds in "constraints", then this could mean
 * that "domain" simply doesn't have an upper bound or that we didn't
 * pick any upper bound.  In the first case, we want to generate the
 * loop condition as a(n empty) conjunction of constraints
 * In the second case, we will compute
 * a single upper bound from "domain" and so we use the list form.
 *
 * If there are upper bounds in "constraints",
 * then we use the list form iff the atomic_upper_bound option is set.
 */
================================================================================

文件路径: ./isl_ast_codegen.c
注释行数: 31
注释内容:
/* Update "graft" based on "bounds" and "domain" for the generic,
 * non-degenerate, case.
 *
 * "c_lower" and "c_upper" contain the lower and upper bounds
 * that the loop node should express.
 * "domain" is the subset of the intersection of the constraints
 * for which some code is executed.
 *
 * There may be zero lower bounds or zero upper bounds in "constraints"
 * in case the list of constraints was created
 * based on the atomic option or based on separation with explicit bounds.
 * In that case, we use "domain" to derive lower and/or upper bounds.
 *
 * We first compute a list of one or more lower bounds.
 *
 * Then we decide if we want to express the condition as
 *
 *	iterator <= min(list of upper bounds)
 *
 * or as a conjunction of constraints.
 *
 * The set of enforced constraints is then computed either based on
 * a list of upper bounds or on a set of upper bound constraints.
 * We do not compute any enforced constraints if we were forced
 * to compute a lower or upper bound using exact_bound.  The domains
 * of the resulting expressions may imply some bounds on outer dimensions
 * that we do not want to appear in the enforced constraints since
 * they are not actually enforced by the corresponding code.
 *
 * Finally, we fill in the expressions of the for node.
 */
================================================================================

文件路径: ./isl_ast_codegen.c
注释行数: 16
注释内容:
/* Update "graft" based on "bounds" and "domain" for the generic,
 * non-degenerate, case.
 *
 * "list" respresent the list of bounds that need to be encoded by
 * the for loop.  Only the constraints that involve the iterator
 * are relevant here.  The other constraints are taken care of by
 * the caller and are included in the generated constraints of "build".
 * "domain" is the subset of the intersection of the constraints
 * for which some code is executed.
 * "build" is the build in which graft->node was created.
 *
 * We separate lower bounds, upper bounds and constraints that
 * are independent of the loop iterator.
 *
 * The actual for loop bounds are generated in refine_generic_bounds.
 */
================================================================================

文件路径: ./isl_ast_codegen.c
注释行数: 11
注释内容:
/* Update "graft" based on "bounds" and "domain" for the generic,
 * non-degenerate, case.
 *
 * "bounds" respresent the bounds that need to be encoded by
 * the for loop (or a guard around the for loop).
 * "domain" is the subset of "bounds" for which some code is executed.
 * "build" is the build in which graft->node was created.
 *
 * We break up "bounds" into a list of constraints and continue with
 * refine_generic_split.
 */
================================================================================

文件路径: ./isl_ast_codegen.c
注释行数: 72
注释内容:
/* Create an AST node for the current dimension based on
 * the schedule domain "bounds" and return the node encapsulated
 * in an isl_ast_graft.
 *
 * "executed" is the current inverse schedule, taking into account
 * the bounds in "bounds"
 * "domain" is the domain of "executed", with inner dimensions projected out.
 * It may be a strict subset of "bounds" in case "bounds" was created
 * based on the atomic option or based on separation with explicit bounds.
 *
 * "domain" may satisfy additional equalities that result
 * from intersecting "executed" with "bounds" in add_node.
 * It may also satisfy some global constraints that were dropped out because
 * we performed separation with explicit bounds.
 * The very first step is then to copy these constraints to "bounds".
 *
 * Since we may be calling before_each_for and after_each_for
 * callbacks, we record the current inverse schedule in the build.
 *
 * We consider three builds,
 * "build" is the one in which the current level is created,
 * "body_build" is the build in which the next level is created,
 * "sub_build" is essentially the same as "body_build", except that
 * the depth has not been increased yet.
 *
 * "build" already contains information (in strides and offsets)
 * about the strides at the current level, but this information is not
 * reflected in the build->domain.
 * We first add this information and the "bounds" to the sub_build->domain.
 * isl_ast_build_set_loop_bounds adds the stride information and
 * checks whether the current dimension attains
 * only a single value and whether this single value can be represented using
 * a single affine expression.
 * In the first case, the current level is considered "degenerate".
 * In the second, sub-case, the current level is considered "eliminated".
 * Eliminated levels don't need to be reflected in the AST since we can
 * simply plug in the affine expression.  For degenerate, but non-eliminated,
 * levels, we do introduce a for node, but mark is as degenerate so that
 * it can be printed as an assignment of the single value to the loop
 * "iterator".
 *
 * If the current level is eliminated, we explicitly plug in the value
 * for the current level found by isl_ast_build_set_loop_bounds in the
 * inverse schedule.  This ensures that if we are working on a slice
 * of the domain based on information available in the inverse schedule
 * and the build domain, that then this information is also reflected
 * in the inverse schedule.  This operation also eliminates the current
 * dimension from the inverse schedule making sure no inner dimensions depend
 * on the current dimension.  Otherwise, we create a for node, marking
 * it degenerate if appropriate.  The initial for node is still incomplete
 * and will be completed in either refine_degenerate or refine_generic.
 *
 * We then generate a sequence of grafts for the next level,
 * create a surrounding graft for the current level and insert
 * the for node we created (if the current level is not eliminated).
 * Before creating a graft for the current level, we first extract
 * hoistable constraints from the child guards and combine them
 * with the pending constraints in the build.  These constraints
 * are used to simplify the child guards and then added to the guard
 * of the current graft to ensure that they will be generated.
 * If the hoisted guard is a disjunction, then we use it directly
 * to gist the guards on the children before intersect it with the
 * pending constraints.  We do so because this disjunction is typically
 * identical to the guards on the children such that these guards
 * can be effectively removed completely.  After the intersection,
 * the gist operation would have a harder time figuring this out.
 *
 * Finally, we set the bounds of the for loop in either
 * refine_degenerate or refine_generic.
 * We do so in a context where the pending constraints of the build
 * have been replaced by the guard of the current graft.
 */
================================================================================

文件路径: ./isl_ast_codegen.c
注释行数: 40
注释内容:
/* Create an AST node for the current dimension based on
 * the schedule domain "bounds" and return the node encapsulated
 * in an isl_ast_graft.
 *
 * "executed" is the current inverse schedule, taking into account
 * the bounds in "bounds"
 * "domain" is the domain of "executed", with inner dimensions projected out.
 *
 *
 * Before moving on to the actual AST node construction in create_node_scaled,
 * we first check if the current dimension is strided and if we can scale
 * down this stride.  Note that we only do this if the ast_build_scale_strides
 * option is set.
 *
 * In particular, let the current dimension take on values
 *
 *	f + s a
 *
 * with a an integer.  We check if we can find an integer m that (obviously)
 * divides both f and s.
 *
 * If so, we check if the current dimension only appears in constraints
 * where the coefficients of the other variables are multiples of m.
 * We perform this extra check to avoid the risk of introducing
 * divisions by scaling down the current dimension.
 *
 * If so, we scale the current dimension down by a factor of m.
 * That is, we plug in
 *
 *	i = m i'							(1)
 *
 * Note that in principle we could always scale down strided loops
 * by plugging in
 *
 *	i = f + s i'
 *
 * but this may result in i' taking on larger values than the original i,
 * due to the shift by "f".
 * By constrast, the scaling in (1) can only reduce the (absolute) value "i".
 */
================================================================================

文件路径: ./isl_ast_codegen.c
注释行数: 14
注释内容:
/* Generate code for the schedule domain "bounds"
 * and add the result to "list".
 *
 * We mainly detect strides here and check if the bounds do not
 * conflict with the current build domain
 * and then pass over control to create_node.
 *
 * "bounds" reflects the bounds on the current dimension and possibly
 * some extra conditions on outer dimensions.
 * It does not, however, include any divs involving the current dimension,
 * so it does not capture any stride constraints.
 * We therefore need to compute that part of the schedule domain that
 * intersects with "bounds" and derive the strides from the result.
 */
================================================================================

文件路径: ./isl_ast_codegen.c
注释行数: 31
注释内容:
/* Generate code for the schedule domains in "scc"
 * and add the results to "list".
 *
 * The domains in "scc" form a strongly connected component in the ordering.
 * If the number of domains in "scc" is larger than 1, then this means
 * that we cannot determine a valid ordering for the domains in the component.
 * This should be fairly rare because the individual domains
 * have been made disjoint first.
 * The problem is that the domains may be integrally disjoint but not
 * rationally disjoint.  For example, we may have domains
 *
 *	{ [i,i] : 0 <= i <= 1 }		and	{ [i,1-i] : 0 <= i <= 1 }
 *
 * These two domains have an empty intersection, but their rational
 * relaxations do intersect.  It is impossible to order these domains
 * in the second dimension because the first should be ordered before
 * the second for outer dimension equal to 0, while it should be ordered
 * after for outer dimension equal to 1.
 *
 * This may happen in particular in case of unrolling since the domain
 * of each slice is replaced by its simple hull.
 *
 * For each basic set i in "scc" and for each of the following basic sets j,
 * we split off that part of the basic set i that shares the outer dimensions
 * with j and lies before j in the current dimension.
 * We collect all the pieces in a new list that replaces "scc".
 *
 * While the elements in "scc" should be disjoint, we double-check
 * this property to avoid running into an infinite recursion in case
 * they intersect due to some internal error.
 */
================================================================================

文件路径: ./isl_ast_codegen.c
注释行数: 13
注释内容:
/* Sort the domains in "domain_list" according to the execution order
 * at the current depth (for equal values of the outer dimensions),
 * generate code for each of them, collecting the results in a list.
 * If no code is generated (because the intersection of the inverse schedule
 * with the domains turns out to be empty), then an empty list is returned.
 *
 * The caller is responsible for ensuring that the basic sets in "domain_list"
 * are pair-wise disjoint.  It can, however, in principle happen that
 * two basic sets should be ordered one way for one value of the outer
 * dimensions and the other way for some other value of the outer dimensions.
 * We therefore play safe and look for strongly connected components.
 * The function add_nodes takes care of handling non-trivial components.
 */
================================================================================

文件路径: ./isl_ast_codegen.c
注释行数: 10
注释内容:
/* Internal data structure for generate_sorted_domains_wrap.
 *
 * "n" is the total number of basic sets
 * "executed" and "build" are extra arguments to be passed
 *	to generate_sorted_domains.
 *
 * "single" is set to 1 by generate_sorted_domains_wrap if there
 * is only a single component.
 * "list" collects the results.
 */
================================================================================

文件路径: ./isl_ast_codegen.c
注释行数: 16
注释内容:
/* Look for any (weakly connected) components in the "domain_list"
 * of domains that share some values of the outer dimensions.
 * That is, domains in different components do not share any values
 * of the outer dimensions.  This means that these components
 * can be freely reordered.
 * Within each of the components, we sort the domains according
 * to the execution order at the current depth.
 *
 * If there is more than one component, then generate_sorted_domains_wrap
 * fuses the result of each call to generate_sorted_domains
 * into a list with either zero or one graft and collects these (at most)
 * single element lists into a bigger list. This means that the elements of the
 * final list can be freely reordered.  In particular, we sort them
 * according to an arbitrary but fixed ordering to ease merging of
 * graft lists from different components.
 */
================================================================================

文件路径: ./isl_ast_codegen.c
注释行数: 16
注释内容:
/* Temporary data used during the search for a lower bound for unrolling.
 *
 * "build" is the build in which the unrolling will be performed
 * "domain" is the original set for which to find a lower bound
 * "depth" is the dimension for which to find a lower boudn
 * "expansion" is the expansion that needs to be applied to "domain"
 * in the unrolling that will be performed
 *
 * "lower" is the best lower bound found so far.  It is NULL if we have not
 * found any yet.
 * "n" is the corresponding size.  If lower is NULL, then the value of n
 * is undefined.
 * "n_div" is the maximal number of integer divisions in the first
 * unrolled iteration (after expansion).  It is set to -1 if it hasn't
 * been computed yet.
 */
================================================================================

文件路径: ./isl_ast_codegen.c
注释行数: 14
注释内容:
/* Is the lower bound "lower" with corresponding iteration count "n"
 * better than the one stored in "data"?
 * If there is no upper bound on the iteration count ("n" is infinity) or
 * if the count is too large, then we cannot use this lower bound.
 * Otherwise, if there was no previous lower bound or
 * if the iteration count of the new lower bound is smaller than
 * the iteration count of the previous lower bound, then we consider
 * the new lower bound to be better.
 * If the iteration count is the same, then compare the number
 * of integer divisions that would be needed to express
 * the iterator value at the first slice in the unrolling
 * according to the lower bound.  If we end up computing this
 * number, then store the lowest value in data->n_div.
 */
================================================================================

文件路径: ./isl_ast_codegen.c
注释行数: 26
注释内容:
/* Check if we can use "c" as a lower bound and if it is better than
 * any previously found lower bound.
 *
 * If "c" does not involve the dimension at the current depth,
 * then we cannot use it.
 * Otherwise, let "c" be of the form
 *
 *	i >= f(j)/a
 *
 * We compute the maximal value of
 *
 *	-ceil(f(j)/a)) + i + 1
 *
 * over the domain.  If there is such a value "n", then we know
 *
 *	-ceil(f(j)/a)) + i + 1 <= n
 *
 * or
 *
 *	i < ceil(f(j)/a)) + n
 *
 * meaning that we can use ceil(f(j)/a)) as a lower bound for unrolling.
 * We just need to check if we have found any lower bound before and
 * if the new lower bound is better (smaller n or fewer integer divisions)
 * than the previously found lower bounds.
 */
================================================================================

文件路径: ./isl_ast_codegen.c
注释行数: 24
注释内容:
/* Look for a lower bound l(i) on the dimension at "depth"
 * and a size n such that "domain" is a subset of
 *
 *	{ [i] : l(i) <= i_d < l(i) + n }
 *
 * where d is "depth" and l(i) depends only on earlier dimensions.
 * Furthermore, try and find a lower bound such that n is as small as possible.
 * In particular, "n" needs to be finite.
 * "build" is the build in which the unrolling will be performed.
 * "expansion" is the expansion that needs to be applied to "domain"
 * in the unrolling that will be performed.
 *
 * Inner dimensions have been eliminated from "domain" by the caller.
 *
 * We first construct a collection of lower bounds on the input set
 * by computing its simple hull.  We then iterate through them,
 * discarding those that we cannot use (either because they do not
 * involve the dimension at "depth" or because they have no corresponding
 * upper bound, meaning that "n" would be unbounded) and pick out the
 * best from the remaining ones.
 *
 * If we cannot find a suitable lower bound, then we consider that
 * to be an error.
 */
================================================================================

文件路径: ./isl_ast_codegen.c
注释行数: 33
注释内容:
/* Call "fn" on each iteration of the current dimension of "domain".
 * If "init" is not NULL, then it is called with the number of
 * iterations before any call to "fn".
 * Return -1 on failure.
 *
 * Since we are going to be iterating over the individual values,
 * we first check if there are any strides on the current dimension.
 * If there is, we rewrite the current dimension i as
 *
 *		i = stride i' + offset
 *
 * and then iterate over individual values of i' instead.
 *
 * We then look for a lower bound on i' and a size such that the domain
 * is a subset of
 *
 *	{ [j,i'] : l(j) <= i' < l(j) + n }
 *
 * and then take slices of the domain at values of i'
 * between l(j) and l(j) + n - 1.
 *
 * We compute the unshifted simple hull of each slice to ensure that
 * we have a single basic set per offset.  The slicing constraint
 * may get simplified away before the unshifted simple hull is taken
 * and may therefore in some rare cases disappear from the result.
 * We therefore explicitly add the constraint back after computing
 * the unshifted simple hull to ensure that the basic sets
 * remain disjoint.  The constraints that are dropped by taking the hull
 * will be taken into account at the next level, as in the case of the
 * atomic option.
 *
 * Finally, we map i' back to i and call "fn".
 */
================================================================================

文件路径: ./isl_ast_codegen.c
注释行数: 19
注释内容:
/* Data structure for storing the results and the intermediate objects
 * of compute_domains.
 *
 * "list" is the main result of the function and contains a list
 * of disjoint basic sets for which code should be generated.
 *
 * "executed" and "build" are inputs to compute_domains.
 * "schedule_domain" is the domain of "executed".
 *
 * "option" contains the domains at the current depth that should by
 * atomic, separated or unrolled.  These domains are as specified by
 * the user, except that inner dimensions have been eliminated and
 * that they have been made pair-wise disjoint.
 *
 * "sep_class" contains the user-specified split into separation classes
 * specialized to the current depth.
 * "done" contains the union of the separation domains that have already
 * been handled.
 */
================================================================================

文件路径: ./isl_ast_codegen.c
注释行数: 11
注释内容:
/* Extend domains->list with a list of basic sets, one for each value
 * of the current dimension in "domain" and remove the corresponding
 * sets from the class domain.  Return the updated class domain.
 * The divs that involve the current dimension have not been projected out
 * from this domain.
 *
 * We call foreach_iteration to iterate over the individual values and
 * in do_unroll_iteration we collect the individual basic sets in
 * domains->list and their union in data->unroll_domain, which is then
 * used to update the class domain.
 */
================================================================================

文件路径: ./isl_ast_codegen.c
注释行数: 16
注释内容:
/* Add domains to domains->list for each individual value of the current
 * dimension, for that part of the schedule domain that lies in the
 * intersection of the option domain and the class domain.
 * Remove the corresponding sets from the class domain and
 * return the updated class domain.
 *
 * We first break up the unroll option domain into individual pieces
 * and then handle each of them separately.  The unroll option domain
 * has been made disjoint in compute_domains_init_options,
 *
 * Note that we actively want to combine different pieces of the
 * schedule domain that have the same value at the current dimension.
 * We therefore need to break up the unroll option domain before
 * intersecting with class and schedule domain, hoping that the
 * unroll option domain specified by the user is relatively simple.
 */
================================================================================

文件路径: ./isl_ast_codegen.c
注释行数: 17
注释内容:
/* Try and construct a single basic set that includes the intersection of
 * the schedule domain, the atomic option domain and the class domain.
 * Add the resulting basic set(s) to domains->list and remove them
 * from class_domain.  Return the updated class domain.
 *
 * We construct a single domain rather than trying to combine
 * the schedule domains of individual domains because we are working
 * within a single component so that non-overlapping schedule domains
 * should already have been separated.
 * We do however need to make sure that this single domains is a subset
 * of the class domain so that it would not intersect with any other
 * class domains.  This means that we may end up splitting up the atomic
 * domain in case separation classes are being used.
 *
 * "domain" is the intersection of the schedule domain and the class domain,
 * with inner dimensions projected out.
 */
================================================================================

文件路径: ./isl_ast_codegen.c
注释行数: 12
注释内容:
/* Split up the schedule domain into uniform basic sets,
 * in the sense that each element in a basic set is associated to
 * elements of the same domains, and add the result to domains->list.
 * Do this for that part of the schedule domain that lies in the
 * intersection of "class_domain" and the separate option domain.
 *
 * "class_domain" may or may not include the constraints
 * of the schedule domain, but this does not make a difference
 * since we are going to intersect it with the domain of the inverse schedule.
 * If it includes schedule domain constraints, then they may involve
 * inner dimensions, but we will eliminate them in separation_domain.
 */
================================================================================

文件路径: ./isl_ast_codegen.c
注释行数: 37
注释内容:
/* Split up the domain at the current depth into disjoint
 * basic sets for which code should be generated separately
 * for the given separation class domain.
 *
 * If any separation classes have been defined, then "class_domain"
 * is the domain of the current class and does not refer to inner dimensions.
 * Otherwise, "class_domain" is the universe domain.
 *
 * We first make sure that the class domain is disjoint from
 * previously considered class domains.
 *
 * The separate domains can be computed directly from the "class_domain".
 *
 * The unroll, atomic and remainder domains need the constraints
 * from the schedule domain.
 *
 * For unrolling, the actual schedule domain is needed (with divs that
 * may refer to the current dimension) so that stride detection can be
 * performed.
 *
 * For atomic and remainder domains, inner dimensions and divs involving
 * the current dimensions should be eliminated.
 * In case we are working within a separation class, we need to intersect
 * the result with the current "class_domain" to ensure that the domains
 * are disjoint from those generated from other class domains.
 *
 * The domain that has been made atomic may be larger than specified
 * by the user since it needs to be representable as a single basic set.
 * This possibly larger domain is removed from class_domain by
 * compute_atomic_domain.  It is computed first so that the extended domain
 * would not overlap with any domains computed before.
 * Similary, the unrolled domains may have some constraints removed and
 * may therefore also be larger than specified by the user.
 *
 * If anything is left after handling separate, unroll and atomic,
 * we split it up into basic sets and append the basic sets to domains->list.
 */
================================================================================

文件路径: ./isl_ast_codegen.c
注释行数: 21
注释内容:
/* Split up the domain at the current depth into disjoint
 * basic sets for which code should be generated separately,
 * based on the user-specified options.
 * Return the list of disjoint basic sets.
 *
 * There are three kinds of domains that we need to keep track of.
 * - the "schedule domain" is the domain of "executed"
 * - the "class domain" is the domain corresponding to the currrent
 *	separation class
 * - the "option domain" is the domain corresponding to one of the options
 *	atomic, unroll or separate
 *
 * We first consider the individial values of the separation classes
 * and split up the domain for each of them separately.
 * Finally, we consider the remainder.  If no separation classes were
 * specified, then we call compute_partial_domains with the universe
 * "class_domain".  Otherwise, we take the "schedule_domain" as "class_domain",
 * with inner dimensions removed.  We do this because we want to
 * avoid computing the complement of the class domains (i.e., the difference
 * between the universe and domains->done).
 */
================================================================================

文件路径: ./isl_ast_codegen.c
注释行数: 32
注释内容:
/* Generate code for a single component, after shifting (if any)
 * has been applied, in case the schedule was specified as a schedule tree.
 * In particular, handle the base case where there is either no isolated
 * set or we are within the isolated set (in which case "isolated" is set)
 * or the iterations that precede or follow the isolated set.
 *
 * The schedule domain is broken up or combined into basic sets
 * according to the AST generation option specified in the current
 * schedule node, which may be either atomic, separate, unroll or
 * unspecified.  If the option is unspecified, then we currently simply
 * split the schedule domain into disjoint basic sets.
 *
 * In case the separate option is specified, the AST generation is
 * handled by generate_shifted_component_tree_separate.
 * In the other cases, we need the global schedule domain.
 * In the unroll case, the AST generation is then handled by
 * generate_shifted_component_tree_unroll which needs the actual
 * schedule domain (with divs that may refer to the current dimension)
 * so that stride detection can be performed.
 * In the atomic or unspecified case, inner dimensions and divs involving
 * the current dimensions should be eliminated.
 * The result is then either combined into a single basic set or
 * split up into disjoint basic sets.
 * Finally an AST is generated for each basic set and the results are
 * concatenated.
 *
 * If the schedule domain involves a disjunction that is purely based on
 * constraints involving only outer dimension, then it is treated as
 * if atomic was specified.  This ensures that only a single loop
 * is generated instead of a sequence of identical loops with
 * different guards.
 */
================================================================================

文件路径: ./isl_ast_codegen.c
注释行数: 28
注释内容:
/* Generate code for a single component, after shifting (if any)
 * has been applied, in case the schedule was specified as a schedule tree.
 *
 * We first check if the user has specified an isolated schedule domain
 * and that we are not already outside of this isolated schedule domain.
 * If so, we break up the schedule domain into iterations that
 * precede the isolated domain, the isolated domain itself,
 * the iterations that follow the isolated domain and
 * the remaining iterations (those that are incomparable
 * to the isolated domain).
 * We generate an AST for each piece and concatenate the results.
 *
 * If the isolated domain is not convex, then it is replaced
 * by a convex superset to ensure that the sets of preceding and
 * following iterations are properly defined and, in particular,
 * that there are no intermediate iterations that do not belong
 * to the isolated domain.
 *
 * In the special case where at least one element of the schedule
 * domain that does not belong to the isolated domain needs
 * to be scheduled after this isolated domain, but none of those
 * elements need to be scheduled before, break up the schedule domain
 * in only two parts, the isolated domain, and a part that will be
 * scheduled after the isolated domain.
 *
 * If no isolated set has been specified, then we generate an
 * AST for the entire inverse schedule.
 */
================================================================================

文件路径: ./isl_ast_codegen.c
注释行数: 18
注释内容:
/* Given an array "domain" of isl_set_map_pairs and an array "order"
 * of indices into the "domain" array,
 * find the element of "domain" (amongst those indexed by the first "n"
 * elements of "order") with the "set" field that has the smallest
 * value for the current iterator.
 *
 * Note that the domain with the smallest value may depend on the parameters
 * and/or outer loop dimension.  Since the result of this function is only
 * used as heuristic, we only make a reasonable attempt at finding the best
 * domain, one that should work in case a single domain provides the smallest
 * value for the current dimension over all values of the parameters
 * and outer dimensions.
 *
 * In particular, we compute the smallest value of the first domain
 * and replace it by that of any later domain if that later domain
 * has a smallest value that is smaller for at least some value
 * of the parameters and outer dimensions.
 */
================================================================================

文件路径: ./isl_ast_codegen.c
注释行数: 79
注释内容:
/* Construct a shifted inverse schedule based on the original inverse schedule,
 * the stride and the offset.
 *
 * The original inverse schedule is specified as the "map" fields
 * of the elements of "domain" indexed by the first "n" elements of "order".
 *
 * "stride" and "offset" are such that the difference
 * between the values of the current dimension of domain "i"
 * and the values of the current dimension for some reference domain are
 * equal to
 *
 *	stride * integer + offset[i]
 *
 * Moreover, 0 <= offset[i] < stride.
 *
 * For each domain, we create a map
 *
 *	{ [..., j, ...] -> [..., j - offset[i], offset[i], ....] }
 *
 * where j refers to the current dimension and the other dimensions are
 * unchanged, and apply this map to the original schedule domain.
 *
 * For example, for the original schedule
 *
 *	{ A[i] -> [2i]: 0 <= i < 10; B[i] -> [2i+1] : 0 <= i < 10 }
 *
 * and assuming the offset is 0 for the A domain and 1 for the B domain,
 * we apply the mapping
 *
 *	{ [j] -> [j, 0] }
 *
 * to the schedule of the "A" domain and the mapping
 *
 *	{ [j - 1] -> [j, 1] }
 *
 * to the schedule of the "B" domain.
 *
 *
 * Note that after the transformation, the differences between pairs
 * of values of the current dimension over all domains are multiples
 * of stride and that we have therefore exposed the stride.
 *
 *
 * To see that the mapping preserves the lexicographic order,
 * first note that each of the individual maps above preserves the order.
 * If the value of the current iterator is j1 in one domain and j2 in another,
 * then if j1 = j2, we know that the same map is applied to both domains
 * and the order is preserved.
 * Otherwise, let us assume, without loss of generality, that j1 < j2.
 * If c1 >= c2 (with c1 and c2 the corresponding offsets), then
 *
 *	j1 - c1 < j2 - c2
 *
 * and the order is preserved.
 * If c1 < c2, then we know
 *
 *	0 <= c2 - c1 < s
 *
 * We also have
 *
 *	j2 - j1 = n * s + r
 *
 * with n >= 0 and 0 <= r < s.
 * In other words, r = c2 - c1.
 * If n > 0, then
 *
 *	j1 - c1 < j2 - c2
 *
 * If n = 0, then
 *
 *	j1 - c1 = j2 - c2
 *
 * and so
 *
 *	(j1 - c1, c1) << (j2 - c2, c2)
 *
 * with "<<" the lexicographic order, proving that the order is preserved
 * in all cases.
 */
================================================================================

文件路径: ./isl_ast_codegen.c
注释行数: 26
注释内容:
/* Generate code for a single component, after exposing the stride,
 * given that the schedule domain is "shifted strided".
 *
 * The component inverse schedule is specified as the "map" fields
 * of the elements of "domain" indexed by the first "n" elements of "order".
 *
 * The schedule domain being "shifted strided" means that the differences
 * between the values of the current dimension of domain "i"
 * and the values of the current dimension for some reference domain are
 * equal to
 *
 *	stride * integer + offset[i]
 *
 * We first look for the domain with the "smallest" value for the current
 * dimension and adjust the offsets such that the offset of the "smallest"
 * domain is equal to zero.  The other offsets are reduced modulo stride.
 *
 * Based on this information, we construct a new inverse schedule in
 * construct_shifted_executed that exposes the stride.
 * Since this involves the introduction of a new schedule dimension,
 * the build needs to be changed accordingly.
 * After computing the AST, the newly introduced dimension needs
 * to be removed again from the list of grafts.  We do this by plugging
 * in a mapping that represents the new schedule domain in terms of the
 * old schedule domain.
 */
================================================================================

文件路径: ./isl_ast_codegen.c
注释行数: 70
注释内容:
/* Generate code for a single component.
 *
 * The component inverse schedule is specified as the "map" fields
 * of the elements of "domain" indexed by the first "n" elements of "order".
 *
 * This function may modify the "set" fields of "domain".
 *
 * Before proceeding with the actual code generation for the component,
 * we first check if there are any "shifted" strides, meaning that
 * the schedule domains of the individual domains are all strided,
 * but that they have different offsets, resulting in the union
 * of schedule domains not being strided anymore.
 *
 * The simplest example is the schedule
 *
 *	{ A[i] -> [2i]: 0 <= i < 10; B[i] -> [2i+1] : 0 <= i < 10 }
 *
 * Both schedule domains are strided, but their union is not.
 * This function detects such cases and then rewrites the schedule to
 *
 *	{ A[i] -> [2i, 0]: 0 <= i < 10; B[i] -> [2i, 1] : 0 <= i < 10 }
 *
 * In the new schedule, the schedule domains have the same offset (modulo
 * the stride), ensuring that the union of schedule domains is also strided.
 *
 *
 * If there is only a single domain in the component, then there is
 * nothing to do.   Similarly, if the current schedule dimension has
 * a fixed value for almost all domains then there is nothing to be done.
 * In particular, we need at least two domains where the current schedule
 * dimension does not have a fixed value.
 * Finally, in case of a schedule map input,
 * if any of the options refer to the current schedule dimension,
 * then we bail out as well.  It would be possible to reformulate the options
 * in terms of the new schedule domain, but that would introduce constraints
 * that separate the domains in the options and that is something we would
 * like to avoid.
 * In the case of a schedule tree input, we bail out if any of
 * the descendants of the current schedule node refer to outer
 * schedule nodes in any way.
 *
 *
 * To see if there is any shifted stride, we look at the differences
 * between the values of the current dimension in pairs of domains
 * for equal values of outer dimensions.  These differences should be
 * of the form
 *
 *	m x + r
 *
 * with "m" the stride and "r" a constant.  Note that we cannot perform
 * this analysis on individual domains as the lower bound in each domain
 * may depend on parameters or outer dimensions and so the current dimension
 * itself may not have a fixed remainder on division by the stride.
 *
 * In particular, we compare the first domain that does not have an
 * obviously fixed value for the current dimension to itself and all
 * other domains and collect the offsets and the gcd of the strides.
 * If the gcd becomes one, then we failed to find shifted strides.
 * If the gcd is zero, then the differences were all fixed, meaning
 * that some domains had non-obviously fixed values for the current dimension.
 * If all the offsets are the same (for those domains that do not have
 * an obviously fixed value for the current dimension), then we do not
 * apply the transformation.
 * If none of the domains were skipped, then there is nothing to do.
 * If some of them were skipped, then if we apply separation, the schedule
 * domain should get split in pieces with a (non-shifted) stride.
 *
 * Otherwise, we apply a shift to expose the stride in
 * generate_shift_component.
 */
================================================================================

文件路径: ./isl_ast_codegen.c
注释行数: 12
注释内容:
/* Is any domain element of "umap" scheduled after any of
 * the corresponding image elements by the tree rooted at
 * the band node "node"?
 *
 * We first check if any domain element is scheduled after any
 * of the corresponding image elements by the band node itself.
 * If not, we restrict "map" to those pairs of element that
 * are scheduled together by the band node and continue with
 * the child of the band node.
 * If there are no such pairs then the map passed to after_in_child
 * will be empty causing it to return 0.
 */
================================================================================

文件路径: ./isl_ast_codegen.c
注释行数: 10
注释内容:
/* Is any domain element of "umap" scheduled after any of
 * the corresponding image elements by the tree rooted at
 * the context node "node"?
 *
 * The context constraints apply to the schedule domain,
 * so we cannot apply them directly to "umap", which contains
 * pairs of statement instances.  Instead, we add them
 * to the range of the prefix schedule for both domain and
 * range of "umap".
 */
================================================================================

文件路径: ./isl_ast_codegen.c
注释行数: 10
注释内容:
/* Is any domain element of "umap" scheduled after any of
 * the corresponding image elements by the tree rooted at
 * the set node "node"?
 *
 * This is only the case if this condition holds in any
 * of the (filter) children of the set node.
 * In particular, if the domain and the range of "umap"
 * are contained in different children, then the condition
 * does not hold.
 */
================================================================================

文件路径: ./isl_ast_codegen.c
注释行数: 13
注释内容:
/* Is any domain element of "map1" scheduled after any domain
 * element of "map2" by the subtree underneath the current band node,
 * while at the same time being scheduled together by the current
 * band node, i.e., by "map1" and "map2?
 *
 * If the child of the current band node is a leaf, then
 * no element can be scheduled after any other element.
 *
 * Otherwise, we construct a relation between domain elements
 * of "map1" and domain elements of "map2" that are scheduled
 * together and then check if the subtree underneath the current
 * band node determines their relative order.
 */
================================================================================

文件路径: ./isl_ast_codegen.c
注释行数: 14
注释内容:
/* Is any element of domain "i" scheduled after any element of domain "j"
 * (for a common iteration of the first data->depth loops)?
 *
 * data->domain[i].set contains the domain of the inverse schedule
 * for domain "i", i.e., elements in the schedule domain.
 *
 * If we are inside a band of a schedule tree and there is a pair
 * of elements in the two domains that is schedule together by
 * the current band, then we check if any element of "i" may be schedule
 * after element of "j" by the descendants of the band node.
 *
 * If data->group_coscheduled is set, then we also return 1 if there
 * is any pair of elements in the two domains that are scheduled together.
 */
================================================================================

文件路径: ./isl_ast_codegen.c
注释行数: 20
注释内容:
/* Look for independent components at the current depth and generate code
 * for each component separately.  The resulting lists of grafts are
 * merged in an attempt to combine grafts with identical guards.
 *
 * Code for two domains can be generated separately if all the elements
 * of one domain are scheduled before (or together with) all the elements
 * of the other domain.  We therefore consider the graph with as nodes
 * the domains and an edge between two nodes if any element of the first
 * node is scheduled after any element of the second node.
 * If the ast_build_group_coscheduled is set, then we also add an edge if
 * there is any pair of elements in the two domains that are scheduled
 * together.
 * Code is then generated (by generate_component)
 * for each of the strongly connected components in this graph
 * in their topological order.
 *
 * Since the test is performed on the domain of the inverse schedules of
 * the different domains, we precompute these domains and store
 * them in data.domain.
 */
================================================================================

文件路径: ./isl_ast_codegen.c
注释行数: 14
注释内容:
/* Generate code for the next level (and all inner levels).
 *
 * If "executed" is empty, i.e., no code needs to be generated,
 * then we return an empty list.
 *
 * If we have already generated code for all loop levels, then we pass
 * control to generate_inner_level.
 *
 * If "executed" lives in a single space, i.e., if code needs to be
 * generated for a single domain, then there can only be a single
 * component and we go directly to generate_shifted_component.
 * Otherwise, we call generate_components to detect the components
 * and to call generate_component on each of them separately.
 */
================================================================================

文件路径: ./isl_ast_codegen.c
注释行数: 20
注释内容:
/* Given an inverse schedule in terms of the external build schedule, i.e.,
 *
 *	[E -> S] -> D
 *
 * with E the external build schedule and S the additional schedule "space",
 * reformulate the inverse schedule in terms of the internal schedule domain,
 * i.e., return
 *
 *	[I -> S] -> D
 *
 * We first obtain a mapping
 *
 *	I -> E
 *
 * take the inverse and the product with S -> S, resulting in
 *
 *	[I -> S] -> [E -> S]
 *
 * Applying the map to the input produces the desired result.
 */
================================================================================

文件路径: ./isl_ast_codegen.c
注释行数: 37
注释内容:
/* Generate an AST that visits the elements in the range of data->executed
 * in the relative order specified by the corresponding domain element(s)
 * for those domain elements that belong to "set".
 * Add the result to data->list.
 *
 * The caller ensures that "set" is a universe domain.
 * "space" is the space of the additional part of the schedule.
 * It is equal to the space of "set" if build->domain is parametric.
 * Otherwise, it is equal to the range of the wrapped space of "set".
 *
 * If the build space is not parametric and
 * if isl_ast_build_node_from_schedule_map
 * was called from an outside user (data->internal not set), then
 * the (inverse) schedule refers to the external build domain and needs to
 * be transformed to refer to the internal build domain.
 *
 * If the build space is parametric, then we add some of the parameter
 * constraints to the executed relation.  Adding these constraints
 * allows for an earlier detection of conflicts in some cases.
 * However, we do not want to divide the executed relation into
 * more disjuncts than necessary.  We therefore approximate
 * the constraints on the parameters by a single disjunct set.
 *
 * The build is extended to include the additional part of the schedule.
 * If the original build space was not parametric, then the options
 * in data->build refer only to the additional part of the schedule
 * and they need to be adjusted to refer to the complete AST build
 * domain.
 *
 * After having adjusted inverse schedule and build, we start generating
 * code with the outer loop of the current code generation
 * in generate_next_level.
 *
 * If the original build space was not parametric, we undo the embedding
 * on the resulting isl_ast_node_list so that it can be used within
 * the outer AST build.
 */
================================================================================

文件路径: ./isl_ast_codegen.c
注释行数: 17
注释内容:
/* Generate an AST that visits the elements in the range of data->executed
 * in the relative order specified by the corresponding domain element(s)
 * for those domain elements that belong to "set".
 * Add the result to data->list.
 *
 * The caller ensures that "set" is a universe domain.
 *
 * If the build space S is not parametric, then the space of "set"
 * need to be a wrapped relation with S as domain.  That is, it needs
 * to be of the form
 *
 *	[S -> T]
 *
 * Check this property and pass control to generate_code_in_space
 * passing along T.
 * If the build space is not parametric, then T is the space of "set".
 */
================================================================================

文件路径: ./isl_ast_codegen.c
注释行数: 23
注释内容:
/* Generate an AST that visits the elements in the range of "executed"
 * in the relative order specified by the corresponding domain element(s).
 *
 * "build" is an isl_ast_build that has either been constructed by
 * isl_ast_build_from_context or passed to a callback set by
 * isl_ast_build_set_create_leaf.
 * In the first case, the space of the isl_ast_build is typically
 * a parametric space, although this is currently not enforced.
 * In the second case, the space is never a parametric space.
 * If the space S is not parametric, then the domain space(s) of "executed"
 * need to be wrapped relations with S as domain.
 *
 * If the domain of "executed" consists of several spaces, then an AST
 * is generated for each of them (in arbitrary order) and the results
 * are concatenated.
 *
 * If "internal" is set, then the domain "S" above refers to the internal
 * schedule domain representation.  Otherwise, it refers to the external
 * representation, as returned by isl_ast_build_get_schedule_space.
 *
 * We essentially run over all the spaces in the domain of "executed"
 * and call generate_code_set on each of them.
 */
================================================================================

文件路径: ./isl_ast_codegen.c
注释行数: 25
注释内容:
/* Generate an AST that visits the elements in the domain of "schedule"
 * in the relative order specified by the corresponding image element(s).
 *
 * "build" is an isl_ast_build that has either been constructed by
 * isl_ast_build_from_context or passed to a callback set by
 * isl_ast_build_set_create_leaf.
 * In the first case, the space of the isl_ast_build is typically
 * a parametric space, although this is currently not enforced.
 * In the second case, the space is never a parametric space.
 * If the space S is not parametric, then the range space(s) of "schedule"
 * need to be wrapped relations with S as domain.
 *
 * If the range of "schedule" consists of several spaces, then an AST
 * is generated for each of them (in arbitrary order) and the results
 * are concatenated.
 *
 * We first initialize the local copies of the relevant options.
 * We do this here rather than when the isl_ast_build is created
 * because the options may have changed between the construction
 * of the isl_ast_build and the call to isl_generate_code.
 *
 * The main computation is performed on an inverse schedule (with
 * the schedule domain in the domain and the elements to be executed
 * in the range) called "executed".
 */
================================================================================

文件路径: ./isl_ast_codegen.c
注释行数: 17
注释内容:
/* Generate an AST that visits the elements in the domain of "executed"
 * in the relative order specified by the leaf node "node".
 *
 * The relation "executed" maps the outer generated loop iterators
 * to the domain elements executed by those iterations.
 *
 * Simply pass control to generate_inner_level.
 * Note that the current build does not refer to any band node, so
 * that generate_inner_level will not try to visit the child of
 * the leaf node.
 *
 * If multiple statement instances reach a leaf,
 * then they can be executed in any order.
 * Group the list of grafts based on shared guards
 * such that identical guards are only generated once
 * when the list is eventually passed on to isl_ast_graft_list_fuse.
 */
================================================================================

文件路径: ./isl_ast_codegen.c
注释行数: 14
注释内容:
/* Generate an AST that visits the elements in the domain of "executed"
 * in the relative order specified by the band node "node" and its descendants.
 *
 * The relation "executed" maps the outer generated loop iterators
 * to the domain elements executed by those iterations.
 *
 * If the band is empty, we continue with its descendants.
 * Otherwise, we extend the build and the inverse schedule with
 * the additional space/partial schedule and continue generating
 * an AST in generate_next_level.
 * As soon as we have extended the inverse schedule with the additional
 * partial schedule, we look for equalities that may exists between
 * the old and the new part.
 */
================================================================================

文件路径: ./isl_ast_codegen.c
注释行数: 32
注释内容:
/* Generate an AST that visits the elements in the domain of "executed"
 * in the relative order specified by the context node "node"
 * and its descendants.
 *
 * The relation "executed" maps the outer generated loop iterators
 * to the domain elements executed by those iterations.
 *
 * The context node may introduce additional parameters as well as
 * constraints on the outer schedule dimensions or original parameters.
 *
 * We add the extra parameters to a new build and the context
 * constraints to both the build and (as a single disjunct)
 * to the domain of "executed".  Since the context constraints
 * are specified in terms of the input schedule, we first need
 * to map them to the internal schedule domain.
 *
 * After constructing the AST from the descendants of "node",
 * we combine the list of grafts into a single graft within
 * the new build, in order to be able to exploit the additional
 * context constraints during this combination.
 *
 * Additionally, if the current node is the outermost node in
 * the schedule tree (apart from the root domain node), we generate
 * all pending guards, again to be able to exploit the additional
 * context constraints.  We currently do not do this for internal
 * context nodes since we may still want to hoist conditions
 * to outer AST nodes.
 *
 * If the context node introduced any new parameters, then they
 * are removed from the set of enforced constraints and guard
 * in hoist_out_of_context.
 */
================================================================================

文件路径: ./isl_ast_codegen.c
注释行数: 10
注释内容:
/* Generate an AST that visits the elements in the domain of "executed"
 * in the relative order specified by the expansion node "node" and
 * its descendants.
 *
 * The relation "executed" maps the outer generated loop iterators
 * to the domain elements executed by those iterations.
 *
 * We expand the domain elements by the expansion and
 * continue with the descendants of the node.
 */
================================================================================

文件路径: ./isl_ast_codegen.c
注释行数: 12
注释内容:
/* Generate an AST that visits the elements in the domain of "executed"
 * in the relative order specified by the extension node "node" and
 * its descendants.
 *
 * The relation "executed" maps the outer generated loop iterators
 * to the domain elements executed by those iterations.
 *
 * Extend the inverse schedule with the extension applied to current
 * set of generated constraints.  Since the extension if formulated
 * in terms of the input schedule, it first needs to be transformed
 * to refer to the internal schedule.
 */
================================================================================

文件路径: ./isl_ast_codegen.c
注释行数: 17
注释内容:
/* Generate an AST that visits the elements in the domain of "executed"
 * in the relative order specified by the filter node "node" and
 * its descendants.
 *
 * The relation "executed" maps the outer generated loop iterators
 * to the domain elements executed by those iterations.
 *
 * We simply intersect the iteration domain (i.e., the range of "executed")
 * with the filter and continue with the descendants of the node,
 * unless the resulting inverse schedule is empty, in which
 * case we return an empty list.
 *
 * If the result of the intersection is equal to the original "executed"
 * relation, then keep the original representation since the intersection
 * may have unnecessarily broken up the relation into a greater number
 * of disjuncts.
 */
================================================================================

文件路径: ./isl_ast_codegen.c
注释行数: 13
注释内容:
/* Generate an AST that visits the elements in the domain of "executed"
 * in the relative order specified by the guard node "node" and
 * its descendants.
 *
 * The relation "executed" maps the outer generated loop iterators
 * to the domain elements executed by those iterations.
 *
 * Ensure that the associated guard is enforced by the outer AST
 * constructs by adding it to the guard of the graft.
 * Since we know that we will enforce the guard, we can also include it
 * in the generated constraints used to construct an AST for
 * the descendant nodes.
 */
================================================================================

文件路径: ./isl_ast_codegen.c
注释行数: 13
注释内容:
/* Generate an AST that visits the elements in the domain of "executed"
 * in the relative order specified by the mark node "node" and
 * its descendants.
 *
 * The relation "executed" maps the outer generated loop iterators
 * to the domain elements executed by those iterations.

 * Since we may be calling before_each_mark and after_each_mark
 * callbacks, we record the current inverse schedule in the build.
 *
 * We generate an AST for the child of the mark node, combine
 * the graft list into a single graft and then insert the mark
 * in the AST of that single graft.
 */
================================================================================

文件路径: ./isl_ast_codegen.c
注释行数: 10
注释内容:
/* Generate an AST that visits the elements in the domain of "executed"
 * in the relative order specified by the sequence (or set) node "node" and
 * its descendants.
 *
 * The relation "executed" maps the outer generated loop iterators
 * to the domain elements executed by those iterations.
 *
 * We simply generate an AST for each of the children and concatenate
 * the results.
 */
================================================================================

文件路径: ./isl_ast_codegen.c
注释行数: 11
注释内容:
/* Generate an AST that visits the elements in the domain of "executed"
 * in the relative order specified by the node "node" and its descendants.
 *
 * The relation "executed" maps the outer generated loop iterators
 * to the domain elements executed by those iterations.
 *
 * The node types are handled in separate functions.
 * Set nodes are currently treated in the same way as sequence nodes.
 * The children of a set node may be executed in any order,
 * including the order of the children.
 */
================================================================================

文件路径: ./isl_ast_codegen.c
注释行数: 10
注释内容:
/* Generate an AST that visits the elements in the domain of "executed"
 * in the relative order specified by the (single) child of "node" and
 * its descendants.
 *
 * The relation "executed" maps the outer generated loop iterators
 * to the domain elements executed by those iterations.
 *
 * This function is never called on a leaf, set or sequence node,
 * so the node always has exactly one child.
 */
================================================================================

文件路径: ./isl_ast_codegen.c
注释行数: 15
注释内容:
/* Generate an AST that visits the elements in the domain of the domain
 * node "node" in the relative order specified by its descendants.
 *
 * An initial inverse schedule is created that maps a zero-dimensional
 * schedule space to the node domain.
 * The input "build" is assumed to have a parametric domain and
 * is replaced by the same zero-dimensional schedule space.
 *
 * We also add some of the parameter constraints in the build domain
 * to the executed relation.  Adding these constraints
 * allows for an earlier detection of conflicts in some cases.
 * However, we do not want to divide the executed relation into
 * more disjuncts than necessary.  We therefore approximate
 * the constraints on the parameters by a single disjunct set.
 */
================================================================================

文件路径: ./isl_ast_codegen.c
注释行数: 10
注释内容:
/* Generate an AST that visits the elements in the domain of "schedule"
 * in the relative order specified by the schedule tree.
 *
 * "build" is an isl_ast_build that has been created using
 * isl_ast_build_alloc or isl_ast_build_from_context based
 * on a parametric set.
 *
 * The construction starts at the root node of the schedule,
 * which is assumed to be a domain node.
 */
================================================================================

文件路径: ./isl_bernstein.c
注释行数: 14
注释内容:
/*
 * Copyright 2006-2007 Universiteit Leiden
 * Copyright 2008-2009 Katholieke Universiteit Leuven
 * Copyright 2010      INRIA Saclay
 *
 * Use of this software is governed by the MIT license
 *
 * Written by Sven Verdoolaege, Leiden Institute of Advanced Computer Science,
 * Universiteit Leiden, Niels Bohrweg 1, 2333 CA Leiden, The Netherlands
 * and K.U.Leuven, Departement Computerwetenschappen, Celestijnenlaan 200A,
 * B-3001 Leuven, Belgium
 * and INRIA Saclay - Ile-de-France, Parc Club Orsay Universite,
 * ZAC des vignes, 4 rue Jacques Monod, 91893 Orsay, France
 */
================================================================================

文件路径: ./isl_bernstein.c
注释行数: 10
注释内容:
/* Extract the coefficients of the Bernstein base polynomials and store
 * them in data->fold and data->fold_tight.
 *
 * In particular, the coefficient of each monomial
 * of multi-degree (k[0], k[1], ..., k[n-1]) is divided by the corresponding
 * multinomial coefficient d!/k[0]! k[1]! ... k[n-1]!
 *
 * c[i] contains the coefficient of the selected powers of the first i+1 vars.
 * multinom[i] contains the partial multinomial coefficient.
 */
================================================================================

文件路径: ./isl_bernstein.c
注释行数: 12
注释内容:
/* Perform bernstein expansion on the parametric vertices that are active
 * on "cell".
 *
 * data->poly has been homogenized in the calling function.
 *
 * We plug in the barycentric coordinates for the set variables
 *
 *		\vec x = \sum_i \alpha_i v_i(\vec p)
 *
 * and the constant "1 = \sum_i \alpha_i" for the homogeneous dimension.
 * Next, we extract the coefficients of the Bernstein base polynomials.
 */
================================================================================

文件路径: ./isl_bernstein.c
注释行数: 11
注释内容:
/* Base case of applying bernstein expansion.
 *
 * We compute the chamber decomposition of the parametric polytope "bset"
 * and then perform bernstein expansion on the parametric vertices
 * that are active on each chamber.
 *
 * If the polynomial does not depend on the set variables
 * (and in particular if the number of set variables is zero)
 * then the bound is equal to the polynomial and
 * no actual bernstein expansion needs to be performed.
 */
================================================================================

文件路径: ./isl_bernstein.c
注释行数: 11
注释内容:
/* Compute a bound on the polynomial defined over the parametric polytope
 * using bernstein expansion and store the result
 * in bound->pwf and bound->pwf_tight.
 *
 * If bernstein_recurse is set to ISL_BERNSTEIN_FACTORS, we check if
 * the polytope can be factorized and apply bernstein expansion recursively
 * on the factors.
 * If bernstein_recurse is set to ISL_BERNSTEIN_INTERVALS, we apply
 * bernstein expansion recursively on each dimension.
 * Otherwise, we apply bernstein expansion on the entire polytope.
 */
================================================================================

文件路径: ./isl_scheduler.c
注释行数: 16
注释内容:
/*
 * Copyright 2011      INRIA Saclay
 * Copyright 2012-2014 Ecole Normale Superieure
 * Copyright 2015-2016 Sven Verdoolaege
 * Copyright 2016      INRIA Paris
 * Copyright 2017      Sven Verdoolaege
 *
 * Use of this software is governed by the MIT license
 *
 * Written by Sven Verdoolaege, INRIA Saclay - Ile-de-France,
 * Parc Club Orsay Universite, ZAC des vignes, 4 rue Jacques Monod,
 * 91893 Orsay, France
 * and Ecole Normale Superieure, 45 rue d'Ulm, 75230 Paris, France
 * and Centre de Recherche Inria de Paris, 2 rue Simone Iff - Voie DQ12,
 * CS 42112, 75589 Paris Cedex 12, France
 */
================================================================================

文件路径: ./isl_scheduler.c
注释行数: 51
注释内容:
/* Internal information about a node that is used during the construction
 * of a schedule.
 * space represents the original space in which the domain lives;
 *	that is, the space is not affected by compression
 * sched is a matrix representation of the schedule being constructed
 *	for this node; if compressed is set, then this schedule is
 *	defined over the compressed domain space
 * sched_map is an isl_map representation of the same (partial) schedule
 *	sched_map may be NULL; if compressed is set, then this map
 *	is defined over the uncompressed domain space
 * rank is the number of linearly independent rows in the linear part
 *	of sched
 * the rows of "vmap" represent a change of basis for the node
 *	variables; the first rank rows span the linear part of
 *	the schedule rows; the remaining rows are linearly independent
 * the rows of "indep" represent linear combinations of the schedule
 * coefficients that are non-zero when the schedule coefficients are
 * linearly independent of previously computed schedule rows.
 * start is the first variable in the LP problem in the sequences that
 *	represents the schedule coefficients of this node
 * nvar is the dimension of the (compressed) domain
 * nparam is the number of parameters or 0 if we are not constructing
 *	a parametric schedule
 *
 * If compressed is set, then hull represents the constraints
 * that were used to derive the compression, while compress and
 * decompress map the original space to the compressed space and
 * vice versa.
 *
 * scc is the index of SCC (or WCC) this node belongs to
 *
 * "cluster" is only used inside extract_clusters and identifies
 * the cluster of SCCs that the node belongs to.
 *
 * coincident contains a boolean for each of the rows of the schedule,
 * indicating whether the corresponding scheduling dimension satisfies
 * the coincidence constraints in the sense that the corresponding
 * dependence distances are zero.
 *
 * If the schedule_treat_coalescing option is set, then
 * "sizes" contains the sizes of the (compressed) instance set
 * in each direction.  If there is no fixed size in a given direction,
 * then the corresponding size value is set to infinity.
 * If the schedule_treat_coalescing option or the schedule_max_coefficient
 * option is set, then "max" contains the maximal values for
 * schedule coefficients of the (compressed) variables.  If no bound
 * needs to be imposed on a particular variable, then the corresponding
 * value is negative.
 * If not NULL, then "bounds" contains a non-parametric set
 * in the compressed space that is bounded by the size in each direction.
 */
================================================================================

文件路径: ./isl_scheduler.c
注释行数: 39
注释内容:
/* An edge in the dependence graph.  An edge may be used to
 * ensure validity of the generated schedule, to minimize the dependence
 * distance or both
 *
 * map is the dependence relation, with i -> j in the map if j depends on i
 * tagged_condition and tagged_validity contain the union of all tagged
 *	condition or conditional validity dependence relations that
 *	specialize the dependence relation "map"; that is,
 *	if (i -> a) -> (j -> b) is an element of "tagged_condition"
 *	or "tagged_validity", then i -> j is an element of "map".
 *	If these fields are NULL, then they represent the empty relation.
 * src is the source node
 * dst is the sink node
 *
 * types is a bit vector containing the types of this edge.
 * validity is set if the edge is used to ensure correctness
 * coincidence is used to enforce zero dependence distances
 * proximity is set if the edge is used to minimize dependence distances
 * condition is set if the edge represents a condition
 *	for a conditional validity schedule constraint
 * local can only be set for condition edges and indicates that
 *	the dependence distance over the edge should be zero
 * conditional_validity is set if the edge is used to conditionally
 *	ensure correctness
 *
 * For validity edges, start and end mark the sequence of inequality
 * constraints in the LP problem that encode the validity constraint
 * corresponding to this edge.
 *
 * During clustering, an edge may be marked "no_merge" if it should
 * not be used to merge clusters.
 * The weight is also only used during clustering and it is
 * an indication of how many schedule dimensions on either side
 * of the schedule constraints can be aligned.
 * If the weight is negative, then this means that this edge was postponed
 * by has_bounded_distances or any_no_merge.  The original weight can
 * be retrieved by adding 1 + graph->max_weight, with "graph"
 * the graph containing this edge.
 */
================================================================================

文件路径: ./isl_scheduler.c
注释行数: 57
注释内容:
/* Internal information about the dependence graph used during
 * the construction of the schedule.
 *
 * intra_hmap is a cache, mapping dependence relations to their dual,
 *	for dependences from a node to itself, possibly without
 *	coefficients for the parameters
 * intra_hmap_param is a cache, mapping dependence relations to their dual,
 *	for dependences from a node to itself, including coefficients
 *	for the parameters
 * inter_hmap is a cache, mapping dependence relations to their dual,
 *	for dependences between distinct nodes
 * if compression is involved then the key for these maps
 * is the original, uncompressed dependence relation, while
 * the value is the dual of the compressed dependence relation.
 *
 * n is the number of nodes
 * node is the list of nodes
 * maxvar is the maximal number of variables over all nodes
 * max_row is the allocated number of rows in the schedule
 * n_row is the current (maximal) number of linearly independent
 *	rows in the node schedules
 * n_total_row is the current number of rows in the node schedules
 * band_start is the starting row in the node schedules of the current band
 * root is set to the original dependence graph from which this graph
 *	is derived through splitting.  If this graph is not the result of
 *	splitting, then the root field points to the graph itself.
 *
 * sorted contains a list of node indices sorted according to the
 *	SCC to which a node belongs
 *
 * n_edge is the number of edges
 * edge is the list of edges
 * max_edge contains the maximal number of edges of each type;
 *	in particular, it contains the number of edges in the inital graph.
 * edge_table contains pointers into the edge array, hashed on the source
 *	and sink spaces; there is one such table for each type;
 *	a given edge may be referenced from more than one table
 *	if the corresponding relation appears in more than one of the
 *	sets of dependences; however, for each type there is only
 *	a single edge between a given pair of source and sink space
 *	in the entire graph
 *
 * node_table contains pointers into the node array, hashed on the space tuples
 *
 * region contains a list of variable sequences that should be non-trivial
 *
 * lp contains the (I)LP problem used to obtain new schedule rows
 *
 * src_scc and dst_scc are the source and sink SCCs of an edge with
 *	conflicting constraints
 *
 * scc represents the number of components
 * weak is set if the components are weakly connected
 *
 * max_weight is used during clustering and represents the maximal
 * weight of the relevant proximity edges.
 */
================================================================================

文件路径: ./isl_scheduler.c
注释行数: 11
注释内容:
/* Check whether the dependence graph has a validity edge
 * between the given two nodes.
 *
 * Conditional validity edges are essentially validity edges that
 * can be ignored if the corresponding condition edges are iteration private.
 * Here, we are only checking for the presence of validity
 * edges, so we need to consider the conditional validity edges too.
 * In particular, this function is used during the detection
 * of strongly connected components and we cannot ignore
 * conditional validity edges during this detection.
 */
================================================================================

文件路径: ./isl_scheduler.c
注释行数: 15
注释内容:
/* Set the entries of node->max to the minimum of the schedule_max_coefficient
 * option (if set) and half of the minimum of the sizes in the other
 * dimensions.  Round up when computing the half such that
 * if the minimum of the sizes is one, half of the size is taken to be one
 * rather than zero.
 * If the global minimum is unbounded (i.e., if both
 * the schedule_max_coefficient is not set and the sizes in the other
 * dimensions are unbounded), then store a negative value.
 * If the schedule coefficient is close to the size of the instance set
 * in another dimension, then the schedule may represent a loop
 * coalescing transformation (especially if the coefficient
 * in that other dimension is one).  Forcing the coefficient to be
 * smaller than or equal to half the minimal size should avoid this
 * situation.
 */
================================================================================

文件路径: ./isl_scheduler.c
注释行数: 16
注释内容:
/* Compute and return the size of "set" in dimension "dim".
 * The size is taken to be the difference in values for that variable
 * for fixed values of the other variables.
 * This assumes that "set" is convex.
 * In particular, the variable is first isolated from the other variables
 * in the range of a map
 *
 *	[i_0, ..., i_dim-1, i_dim+1, ...] -> [i_dim]
 *
 * and then duplicated
 *
 *	[i_0, ..., i_dim-1, i_dim+1, ...] -> [[i_dim] -> [i_dim']]
 *
 * The shared variables are then projected out and the maximal value
 * of i_dim' - i_dim is computed.
 */
================================================================================

文件路径: ./isl_scheduler.c
注释行数: 15
注释内容:
/* Perform a compression on "node" where "hull" represents the constraints
 * that were used to derive the compression, while "compress" and
 * "decompress" map the original space to the compressed space and
 * vice versa.
 *
 * If "node" was not compressed already, then simply store
 * the compression information.
 * Otherwise the "original" space is actually the result
 * of a previous compression, which is then combined
 * with the present compression.
 *
 * The dimensionality of the compressed domain is also adjusted.
 * Other information, such as the sizes and the maximal coefficient values,
 * has not been computed yet and therefore does not need to be adjusted.
 */
================================================================================

文件路径: ./isl_scheduler.c
注释行数: 20
注释内容:
/* Given that dimension "pos" in "set" has a fixed value
 * in terms of the other dimensions, (further) compress "node"
 * by projecting out this dimension.
 * "set" may be the result of a previous compression.
 * "uncompressed" is the original domain (without compression).
 *
 * The compression function simply projects out the dimension.
 * The decompression function adds back the dimension
 * in the right position as an expression of the other dimensions
 * derived from "set".
 * As in extract_node, the compressed space has an identifier
 * that references "node" such that each compressed space is unique and
 * such that the node can be recovered from the compressed space.
 *
 * The constraint removed through the compression is added to the "hull"
 * such that only edges that relate to the original domains
 * are taken into account.
 * In particular, it is obtained by composing compression and decompression and
 * taking the relation among the variables in the range.
 */
================================================================================

文件路径: ./isl_scheduler.c
注释行数: 16
注释内容:
/* Compute the size of the compressed domain in each dimension and
 * store the results in node->sizes.
 * "uncompressed" is the original domain (without compression).
 *
 * First compress the domain if needed and then compute the size
 * in each direction.
 * If the domain is not convex, then the sizes are computed
 * on a convex superset in order to avoid picking up sizes
 * that are valid for the individual disjuncts, but not for
 * the domain as a whole.
 *
 * If any of the sizes turns out to be zero, then this means
 * that this dimension has a fixed value in terms of
 * the other dimensions.  Perform an (extra) compression
 * to remove this dimensions.
 */
================================================================================

文件路径: ./isl_scheduler.c
注释行数: 14
注释内容:
/* Compute the size of the instance set "set" of "node", after compression,
 * as well as bounds on the corresponding coefficients, if needed.
 *
 * The sizes are needed when the schedule_treat_coalescing option is set.
 * The bounds are needed when the schedule_treat_coalescing option or
 * the schedule_max_coefficient option is set.
 *
 * If the schedule_treat_coalescing option is not set, then at most
 * the bounds need to be set and this is done in set_max_coefficient.
 * Otherwise, compute the size of the compressed domain
 * in each direction and store the results in node->size.
 * Finally, set the bounds on the coefficients based on the sizes
 * and the schedule_max_coefficient option in compute_max_coefficient.
 */
================================================================================

文件路径: ./isl_scheduler.c
注释行数: 14
注释内容:
/* Add a new node to the graph representing the given instance set.
 * "nvar" is the (possibly compressed) number of variables and
 * may be smaller than then number of set variables in "set"
 * if "compressed" is set.
 * If "compressed" is set, then "hull" represents the constraints
 * that were used to derive the compression, while "compress" and
 * "decompress" map the original space to the compressed space and
 * vice versa.
 * If "compressed" is not set, then "hull", "compress" and "decompress"
 * should be NULL.
 *
 * Compute the size of the instance set and bounds on the coefficients,
 * if needed.
 */
================================================================================

文件路径: ./isl_scheduler.c
注释行数: 13
注释内容:
/* Insert dummy tags in domain and range of "map".
 *
 * In particular, if "map" is of the form
 *
 *	A -> B
 *
 * then return
 *
 *	[A -> dummy_tag] -> [B -> dummy_tag]
 *
 * where the dummy_tags are identical and equal to any dummy tags
 * introduced by any other call to this function.
 */
================================================================================

文件路径: ./isl_scheduler.c
注释行数: 23
注释内容:
/* Add a new edge to the graph based on the given map
 * and add it to data->graph->edge_table[data->type].
 * If a dependence relation of a given type happens to be identical
 * to one of the dependence relations of a type that was added before,
 * then we don't create a new edge, but instead mark the original edge
 * as also representing a dependence of the current type.
 *
 * Edges of type isl_edge_condition or isl_edge_conditional_validity
 * may be specified as "tagged" dependence relations.  That is, "map"
 * may contain elements (i -> a) -> (j -> b), where i -> j denotes
 * the dependence on iterations and a and b are tags.
 * edge->map is set to the relation containing the elements i -> j,
 * while edge->tagged_condition and edge->tagged_validity contain
 * the union of all the "map" relations
 * for which extract_edge is called that result in the same edge->map.
 *
 * If the source or the destination node is compressed, then
 * intersect both "map" and "tagged" with the constraints that
 * were used to construct the compression.
 * This ensures that there are no schedule constraints defined
 * outside of these domains, while the scheduler no longer has
 * any control over those outside parts.
 */
================================================================================

文件路径: ./isl_scheduler.c
注释行数: 10
注释内容:
/* Return a non-parametric set in the compressed space of "node" that is
 * bounded by the size in each direction
 *
 *	{ [x] : -S_i <= x_i <= S_i }
 *
 * If S_i is infinity in direction i, then there are no constraints
 * in that direction.
 *
 * Cache the result in node->bounds.
 */
================================================================================

文件路径: ./isl_scheduler.c
注释行数: 31
注释内容:
/* Given a dependence relation R from "node" to itself,
 * construct the set of coefficients of valid constraints for elements
 * in that dependence relation.
 * In particular, the result contains tuples of coefficients
 * c_0, c_n, c_x such that
 *
 *	c_0 + c_n n + c_x y - c_x x >= 0 for each (x,y) in R
 *
 * or, equivalently,
 *
 *	c_0 + c_n n + c_x d >= 0 for each d in delta R = { y - x | (x,y) in R }
 *
 * We choose here to compute the dual of delta R.
 * Alternatively, we could have computed the dual of R, resulting
 * in a set of tuples c_0, c_n, c_x, c_y, and then
 * plugged in (c_0, c_n, c_x, -c_x).
 *
 * If "need_param" is set, then the resulting coefficients effectively
 * include coefficients for the parameters c_n.  Otherwise, they may
 * have been projected out already.
 * Since the constraints may be different for these two cases,
 * they are stored in separate caches.
 * In particular, if no parameter coefficients are required and
 * the schedule_treat_coalescing option is set, then the parameters
 * are projected out and some constraints that could be exploited
 * to construct coalescing schedules are removed before the dual
 * is computed.
 *
 * If "node" has been compressed, then the dependence relation
 * is also compressed before the set of coefficients is computed.
 */
================================================================================

文件路径: ./isl_scheduler.c
注释行数: 11
注释内容:
/* Given a dependence relation R, construct the set of coefficients
 * of valid constraints for elements in that dependence relation.
 * In particular, the result contains tuples of coefficients
 * c_0, c_n, c_x, c_y such that
 *
 *	c_0 + c_n n + c_x x + c_y y >= 0 for each (x,y) in R
 *
 * If the source or destination nodes of "edge" have been compressed,
 * then the dependence relation is also compressed before
 * the set of coefficients is computed.
 */
================================================================================

文件路径: ./isl_scheduler.c
注释行数: 20
注释内容:
/* Construct an isl_dim_map for mapping constraints on coefficients
 * for "node" to the corresponding positions in graph->lp.
 * "offset" is the offset of the coefficients for the variables
 * in the input constraints.
 * "s" is the sign of the mapping.
 *
 * The input constraints are given in terms of the coefficients
 * (c_0, c_x) or (c_0, c_n, c_x).
 * The mapping produced by this function essentially plugs in
 * (0, c_i_x^+ - c_i_x^-) if s = 1 and
 * (0, -c_i_x^+ + c_i_x^-) if s = -1 or
 * (0, 0, c_i_x^+ - c_i_x^-) if s = 1 and
 * (0, 0, -c_i_x^+ + c_i_x^-) if s = -1.
 * In graph->lp, the c_i_x^- appear before their c_i_x^+ counterpart.
 * Furthermore, the order of these pairs is the opposite of that
 * of the corresponding coefficients.
 *
 * The caller can extend the mapping to also map the other coefficients
 * (and therefore not plug in 0).
 */
================================================================================

文件路径: ./isl_scheduler.c
注释行数: 20
注释内容:
/* Construct an isl_dim_map for mapping constraints on coefficients
 * for "src" (node i) and "dst" (node j) to the corresponding positions
 * in graph->lp.
 * "offset" is the offset of the coefficients for the variables of "src"
 * in the input constraints.
 * "s" is the sign of the mapping.
 *
 * The input constraints are given in terms of the coefficients
 * (c_0, c_n, c_x, c_y).
 * The mapping produced by this function essentially plugs in
 * (c_j_0 - c_i_0, c_j_n - c_i_n,
 *  -(c_i_x^+ - c_i_x^-), c_j_x^+ - c_j_x^-) if s = 1 and
 * (-c_j_0 + c_i_0, -c_j_n + c_i_n,
 *  c_i_x^+ - c_i_x^-, -(c_j_x^+ - c_j_x^-)) if s = -1.
 * In graph->lp, the c_*^- appear before their c_*^+ counterpart.
 * Furthermore, the order of these pairs is the opposite of that
 * of the corresponding coefficients.
 *
 * The caller can further extend the mapping.
 */
================================================================================

文件路径: ./isl_scheduler.c
注释行数: 15
注释内容:
/* Add constraints to graph->lp that force validity for the given
 * dependence from a node i to itself.
 * That is, add constraints that enforce
 *
 *	(c_i_0 + c_i_n n + c_i_x y) - (c_i_0 + c_i_n n + c_i_x x)
 *	= c_i_x (y - x) >= 0
 *
 * for each (x,y) in R.
 * We obtain general constraints on coefficients (c_0, c_x)
 * of valid constraints for (y - x) and then plug in (0, c_i_x^+ - c_i_x^-),
 * where c_i_x = c_i_x^+ - c_i_x^-, with c_i_x^+ and c_i_x^- non-negative.
 * In graph->lp, the c_i_x^- appear before their c_i_x^+ counterpart.
 * Note that the result of intra_coefficients may also contain
 * parameter coefficients c_n, in which case 0 is plugged in for them as well.
 */
================================================================================

文件路径: ./isl_scheduler.c
注释行数: 13
注释内容:
/* Add constraints to graph->lp that force validity for the given
 * dependence from node i to node j.
 * That is, add constraints that enforce
 *
 *	(c_j_0 + c_j_n n + c_j_x y) - (c_i_0 + c_i_n n + c_i_x x) >= 0
 *
 * for each (x,y) in R.
 * We obtain general constraints on coefficients (c_0, c_n, c_x, c_y)
 * of valid constraints for R and then plug in
 * (c_j_0 - c_i_0, c_j_n - c_i_n, -(c_i_x^+ - c_i_x^-), c_j_x^+ - c_j_x^-),
 * where c_* = c_*^+ - c_*^-, with c_*^+ and c_*^- non-negative.
 * In graph->lp, the c_*^- appear before their c_*^+ counterpart.
 */
================================================================================

文件路径: ./isl_scheduler.c
注释行数: 42
注释内容:
/* Add constraints to graph->lp that bound the dependence distance for the given
 * dependence from a node i to itself.
 * If s = 1, we add the constraint
 *
 *	c_i_x (y - x) <= m_0 + m_n n
 *
 * or
 *
 *	-c_i_x (y - x) + m_0 + m_n n >= 0
 *
 * for each (x,y) in R.
 * If s = -1, we add the constraint
 *
 *	-c_i_x (y - x) <= m_0 + m_n n
 *
 * or
 *
 *	c_i_x (y - x) + m_0 + m_n n >= 0
 *
 * for each (x,y) in R.
 * We obtain general constraints on coefficients (c_0, c_n, c_x)
 * of valid constraints for (y - x) and then plug in (m_0, m_n, -s * c_i_x),
 * with each coefficient (except m_0) represented as a pair of non-negative
 * coefficients.
 *
 *
 * If "local" is set, then we add constraints
 *
 *	c_i_x (y - x) <= 0
 *
 * or
 *
 *	-c_i_x (y - x) <= 0
 *
 * instead, forcing the dependence distance to be (less than or) equal to 0.
 * That is, we plug in (0, 0, -s * c_i_x),
 * intra_coefficients is not required to have c_n in its result when
 * "local" is set.  If they are missing, then (0, -s * c_i_x) is plugged in.
 * Note that dependences marked local are treated as validity constraints
 * by add_all_validity_constraints and therefore also have
 * their distances bounded by 0 from below.
 */
================================================================================

文件路径: ./isl_scheduler.c
注释行数: 47
注释内容:
/* Add constraints to graph->lp that bound the dependence distance for the given
 * dependence from node i to node j.
 * If s = 1, we add the constraint
 *
 *	(c_j_0 + c_j_n n + c_j_x y) - (c_i_0 + c_i_n n + c_i_x x)
 *		<= m_0 + m_n n
 *
 * or
 *
 *	-(c_j_0 + c_j_n n + c_j_x y) + (c_i_0 + c_i_n n + c_i_x x) +
 *		m_0 + m_n n >= 0
 *
 * for each (x,y) in R.
 * If s = -1, we add the constraint
 *
 *	-((c_j_0 + c_j_n n + c_j_x y) - (c_i_0 + c_i_n n + c_i_x x))
 *		<= m_0 + m_n n
 *
 * or
 *
 *	(c_j_0 + c_j_n n + c_j_x y) - (c_i_0 + c_i_n n + c_i_x x) +
 *		m_0 + m_n n >= 0
 *
 * for each (x,y) in R.
 * We obtain general constraints on coefficients (c_0, c_n, c_x, c_y)
 * of valid constraints for R and then plug in
 * (m_0 - s*c_j_0 + s*c_i_0, m_n - s*c_j_n + s*c_i_n,
 *  s*c_i_x, -s*c_j_x)
 * with each coefficient (except m_0, c_*_0 and c_*_n)
 * represented as a pair of non-negative coefficients.
 *
 *
 * If "local" is set (and s = 1), then we add constraints
 *
 *	(c_j_0 + c_j_n n + c_j_x y) - (c_i_0 + c_i_n n + c_i_x x) <= 0
 *
 * or
 *
 *	-((c_j_0 + c_j_n n + c_j_x y) + (c_i_0 + c_i_n n + c_i_x x)) >= 0
 *
 * instead, forcing the dependence distance to be (less than or) equal to 0.
 * That is, we plug in
 * (-s*c_j_0 + s*c_i_0, -s*c_j_n + s*c_i_n, s*c_i_x, -s*c_j_x).
 * Note that dependences marked local are treated as validity constraints
 * by add_all_validity_constraints and therefore also have
 * their distances bounded by 0 from below.
 */
================================================================================

文件路径: ./isl_scheduler.c
注释行数: 10
注释内容:
/* Add all validity constraints to graph->lp.
 *
 * An edge that is forced to be local needs to have its dependence
 * distances equal to zero.  We take care of bounding them by 0 from below
 * here.  add_all_proximity_constraints takes care of bounding them by 0
 * from above.
 *
 * If "use_coincidence" is set, then we treat coincidence edges as local edges.
 * Otherwise, we ignore them.
 */
================================================================================

文件路径: ./isl_scheduler.c
注释行数: 12
注释内容:
/* Add constraints to graph->lp that bound the dependence distance
 * for all dependence relations.
 * If a given proximity dependence is identical to a validity
 * dependence, then the dependence distance is already bounded
 * from below (by zero), so we only need to bound the distance
 * from above.  (This includes the case of "local" dependences
 * which are treated as validity dependence by add_all_validity_constraints.)
 * Otherwise, we need to bound the distance both from above and from below.
 *
 * If "use_coincidence" is set, then we treat coincidence edges as local edges.
 * Otherwise, we ignore them.
 */
================================================================================

文件路径: ./isl_scheduler.c
注释行数: 28
注释内容:
/* Compute a basis for the rows in the linear part of the schedule
 * and extend this basis to a full basis.  The remaining rows
 * can then be used to force linear independence from the rows
 * in the schedule.
 *
 * In particular, given the schedule rows S, we compute
 *
 *	S   = H Q
 *	S U = H
 *
 * with H the Hermite normal form of S.  That is, all but the
 * first rank columns of H are zero and so each row in S is
 * a linear combination of the first rank rows of Q.
 * The matrix Q can be used as a variable transformation
 * that isolates the directions of S in the first rank rows.
 * Transposing S U = H yields
 *
 *	U^T S^T = H^T
 *
 * with all but the first rank rows of H^T zero.
 * The last rows of U^T are therefore linear combinations
 * of schedule coefficients that are all zero on schedule
 * coefficients that are linearly dependent on the rows of S.
 * At least one of these combinations is non-zero on
 * linearly independent schedule coefficients.
 * The rows are normalized to involve as few of the last
 * coefficients as possible and to have a positive initial value.
 */
================================================================================

文件路径: ./isl_scheduler.c
注释行数: 14
注释内容:
/* How many times should we count the constraints in "edge"?
 *
 * We count as follows
 * validity		-> 1 (>= 0)
 * validity+proximity	-> 2 (>= 0 and upper bound)
 * proximity		-> 2 (lower and upper bound)
 * local(+any)		-> 2 (>= 0 and <= 0)
 *
 * If an edge is only marked conditional_validity then it counts
 * as zero since it is only checked afterwards.
 *
 * If "use_coincidence" is set, then we treat coincidence edges as local edges.
 * Otherwise, we ignore them.
 */
================================================================================

文件路径: ./isl_scheduler.c
注释行数: 11
注释内容:
/* Count the number of equality and inequality constraints
 * that will be added to the main lp problem.
 * We count as follows
 * validity		-> 1 (>= 0)
 * validity+proximity	-> 2 (>= 0 and upper bound)
 * proximity		-> 2 (lower and upper bound)
 * local(+any)		-> 2 (>= 0 and <= 0)
 *
 * If "use_coincidence" is set, then we treat coincidence edges as local edges.
 * Otherwise, we ignore them.
 */
================================================================================

文件路径: ./isl_scheduler.c
注释行数: 30
注释内容:
/* Add constraints to graph->lp that bound the values of
 * the parameter schedule coefficients of "node" to "max" and
 * the variable schedule coefficients to the corresponding entry
 * in node->max.
 * In either case, a negative value means that no bound needs to be imposed.
 *
 * For parameter coefficients, this amounts to adding a constraint
 *
 *	c_n <= max
 *
 * i.e.,
 *
 *	-c_n + max >= 0
 *
 * The variables coefficients are, however, not represented directly.
 * Instead, the variable coefficients c_x are written as differences
 * c_x = c_x^+ - c_x^-.
 * That is,
 *
 *	-max_i <= c_x_i <= max_i
 *
 * is encoded as
 *
 *	-max_i <= c_x_i^+ - c_x_i^- <= max_i
 *
 * or
 *
 *	-(c_x_i^+ - c_x_i^-) + max_i >= 0
 *	c_x_i^+ - c_x_i^- + max_i >= 0
 */
================================================================================

文件路径: ./isl_scheduler.c
注释行数: 30
注释内容:
/* Construct an ILP problem for finding schedule coefficients
 * that result in non-negative, but small dependence distances
 * over all dependences.
 * In particular, the dependence distances over proximity edges
 * are bounded by m_0 + m_n n and we compute schedule coefficients
 * with small values (preferably zero) of m_n and m_0.
 *
 * All variables of the ILP are non-negative.  The actual coefficients
 * may be negative, so each coefficient is represented as the difference
 * of two non-negative variables.  The negative part always appears
 * immediately before the positive part.
 * Other than that, the variables have the following order
 *
 *	- sum of positive and negative parts of m_n coefficients
 *	- m_0
 *	- sum of all c_n coefficients
 *		(unconstrained when computing non-parametric schedules)
 *	- sum of positive and negative parts of all c_x coefficients
 *	- positive and negative parts of m_n coefficients
 *	- for each node
 *		- positive and negative parts of c_i_x, in opposite order
 *		- c_i_n (if parametric)
 *		- c_i_0
 *
 * The constraints are those from the edges plus two or three equalities
 * to express the sums.
 *
 * If "use_coincidence" is set, then we treat coincidence edges as local edges.
 * Otherwise, we ignore them.
 */
================================================================================

文件路径: ./isl_scheduler.c
注释行数: 10
注释内容:
/* Extract the coefficients for the variables of "node" from "sol".
 *
 * Each schedule coefficient c_i_x is represented as the difference
 * between two non-negative variables c_i_x^+ - c_i_x^-.
 * The c_i_x^- appear before their c_i_x^+ counterpart.
 * Furthermore, the order of these pairs is the opposite of that
 * of the corresponding coefficients.
 *
 * Return c_i_x = c_i_x^+ - c_i_x^-
 */
================================================================================

文件路径: ./isl_scheduler.c
注释行数: 10
注释内容:
/* Update the schedules of all nodes based on the given solution
 * of the LP problem.
 * The new row is added to the current band.
 * All possibly negative coefficients are encoded as a difference
 * of two non-negative variables, so we need to perform the subtraction
 * here.
 *
 * If coincident is set, then the caller guarantees that the new
 * row satisfies the coincidence constraints.
 */
================================================================================

文件路径: ./isl_scheduler.c
注释行数: 13
注释内容:
/* Update the dependence relation of the given edge based
 * on the current schedule.
 * If the dependence is carried completely by the current schedule, then
 * it is removed from the edge_tables.  It is kept in the list of edges
 * as otherwise all edge_tables would have to be recomputed.
 *
 * If the edge is of a type that can appear multiple times
 * between the same pair of nodes, then it is added to
 * the edge table (again).  This prevents the situation
 * where none of these edges is referenced from the edge table
 * because the one that was referenced turned out to be empty and
 * was therefore removed from the table.
 */
================================================================================

文件路径: ./isl_scheduler.c
注释行数: 13
注释内容:
/* Update the dependence relations of all edges based on the current schedule
 * and enforce conditional validity constraints that are adjacent
 * to satisfied condition constraints.
 *
 * First check if any of the condition constraints are satisfied
 * (i.e., not local to the outer schedule) and keep track of
 * their domain and range.
 * Then update all dependence relations (which removes the non-local
 * constraints).
 * Finally, if any condition constraints turned out to be satisfied,
 * then turn all adjacent conditional validity constraints into
 * unconditional validity constraints.
 */
================================================================================

文件路径: ./isl_scheduler.c
注释行数: 11
注释内容:
/* Compute a schedule for a subgraph of "graph".  In particular, for
 * the graph composed of nodes that satisfy node_pred and edges that
 * that satisfy edge_pred.
 * If the subgraph is known to consist of a single component, then wcc should
 * be set and then we call compute_schedule_wcc on the constructed subgraph.
 * Otherwise, we call compute_schedule, which will check whether the subgraph
 * is connected.
 *
 * The schedule is inserted at "node" and the updated schedule node
 * is returned.
 */
================================================================================

文件路径: ./isl_scheduler.c
注释行数: 13
注释内容:
/* Split the current graph into two parts and compute a schedule for each
 * part individually.  In particular, one part consists of all SCCs up
 * to and including graph->src_scc, while the other part contains the other
 * SCCs.  The split is enforced by a sequence node inserted at position "node"
 * in the schedule tree.  Return the updated schedule node.
 * If either of these two parts consists of a sequence, then it is spliced
 * into the sequence containing the two parts.
 *
 * The current band is reset. It would be possible to reuse
 * the previously computed rows as the first rows in the next
 * band, but recomputing them may result in better rows as we are looking
 * at a smaller part of the dependence graph.
 */
================================================================================

文件路径: ./isl_scheduler.c
注释行数: 16
注释内容:
/* Add the constraints "coef" derived from an edge from "node" to itself
 * to graph->lp in order to respect the dependences and to try and carry them.
 * "pos" is the sequence number of the edge that needs to be carried.
 * "coef" represents general constraints on coefficients (c_0, c_x)
 * of valid constraints for (y - x) with x and y instances of the node.
 *
 * The constraints added to graph->lp need to enforce
 *
 *	(c_j_0 + c_j_x y) - (c_j_0 + c_j_x x)
 *	= c_j_x (y - x) >= e_i
 *
 * for each (x,y) in the dependence relation of the edge.
 * That is, (-e_i, c_j_x) needs to be plugged in for (c_0, c_x),
 * taking into account that each coefficient in c_j_x is represented
 * as a pair of non-negative coefficients.
 */
================================================================================

文件路径: ./isl_scheduler.c
注释行数: 24
注释内容:
/* Add the constraints "coef" derived from an edge from "src" to "dst"
 * to graph->lp in order to respect the dependences and to try and carry them.
 * "pos" is the sequence number of the edge that needs to be carried or
 * -1 if no attempt should be made to carry the dependences.
 * "coef" represents general constraints on coefficients (c_0, c_n, c_x, c_y)
 * of valid constraints for (x, y) with x and y instances of "src" and "dst".
 *
 * The constraints added to graph->lp need to enforce
 *
 *	(c_k_0 + c_k_n n + c_k_x y) - (c_j_0 + c_j_n n + c_j_x x) >= e_i
 *
 * for each (x,y) in the dependence relation of the edge or
 *
 *	(c_k_0 + c_k_n n + c_k_x y) - (c_j_0 + c_j_n n + c_j_x x) >= 0
 *
 * if pos is -1.
 * That is,
 * (-e_i + c_k_0 - c_j_0, c_k_n - c_j_n, -c_j_x, c_k_x)
 * or
 * (c_k_0 - c_j_0, c_k_n - c_j_n, -c_j_x, c_k_x)
 * needs to be plugged in for (c_0, c_n, c_x, c_y),
 * taking into account that each coefficient in c_j_x and c_k_x is represented
 * as a pair of non-negative coefficients.
 */
================================================================================

文件路径: ./isl_scheduler.c
注释行数: 15
注释内容:
/* Return a pointer to the node in "graph" that lives in "space".
 * If the requested node has been compressed, then "space"
 * corresponds to the compressed space.
 * The graph is assumed to have such a node.
 * Return NULL in case of error.
 *
 * First try and see if "space" is the space of an uncompressed node.
 * If so, return that node.
 * Otherwise, "space" was constructed by construct_compressed_id and
 * contains a user pointer pointing to the node in the tuple id.
 * However, this node belongs to the original dependence graph.
 * If "graph" is a subgraph of this original dependence graph,
 * then the node with the same space still needs to be looked up
 * in the current graph.
 */
================================================================================

文件路径: ./isl_scheduler.c
注释行数: 11
注释内容:
/* Add the constraints "coef" derived from an edge from a node to itself
 * to data->graph->lp in order to respect the dependences and
 * to try and carry them.
 *
 * The space of "coef" is of the form
 *
 *	coefficients[[c_cst] -> S[c_x]]
 *
 * with S[c_x] the (compressed) space of the node.
 * Extract the node from the space and call add_intra_constraints.
 */
================================================================================

文件路径: ./isl_scheduler.c
注释行数: 11
注释内容:
/* Add the constraints "coef" derived from an edge from a node j
 * to a node k to data->graph->lp in order to respect the dependences and
 * to try and carry them (provided data->carry_inter is set).
 *
 * The space of "coef" is of the form
 *
 *	coefficients[[c_cst, c_n] -> [S_j[c_x] -> S_k[c_y]]]
 *
 * with S_j[c_x] and S_k[c_y] the (compressed) spaces of the nodes.
 * Extract the nodes from the space and call add_inter_constraints.
 */
================================================================================

文件路径: ./isl_scheduler.c
注释行数: 33
注释内容:
/* Construct an LP problem for finding schedule coefficients
 * such that the schedule carries as many validity dependences as possible.
 * In particular, for each dependence i, we bound the dependence distance
 * from below by e_i, with 0 <= e_i <= 1 and then maximize the sum
 * of all e_i's.  Dependences with e_i = 0 in the solution are simply
 * respected, while those with e_i > 0 (in practice e_i = 1) are carried.
 * "intra" is the sequence of coefficient constraints for intra-node edges.
 * "inter" is the sequence of coefficient constraints for inter-node edges.
 * "n_edge" is the total number of edges.
 * "carry_inter" indicates whether inter-node edges should be carried or
 * only respected.  That is, if "carry_inter" is not set, then
 * no e_i variables are introduced for the inter-node edges.
 *
 * All variables of the LP are non-negative.  The actual coefficients
 * may be negative, so each coefficient is represented as the difference
 * of two non-negative variables.  The negative part always appears
 * immediately before the positive part.
 * Other than that, the variables have the following order
 *
 *	- sum of (1 - e_i) over all edges
 *	- sum of all c_n coefficients
 *		(unconstrained when computing non-parametric schedules)
 *	- sum of positive and negative parts of all c_x coefficients
 *	- for each edge
 *		- e_i
 *	- for each node
 *		- positive and negative parts of c_i_x, in opposite order
 *		- c_i_n (if parametric)
 *		- c_i_0
 *
 * The constraints are those from the (validity) edges plus three equalities
 * to express the sums and n_edge inequalities to express e_i <= 1.
 */
================================================================================

文件路径: ./isl_scheduler.c
注释行数: 16
注释内容:
/* If the schedule_split_scaled option is set and if the linear
 * parts of the scheduling rows for all nodes in the graphs have
 * a non-trivial common divisor, then remove this
 * common divisor from the linear part.
 * Otherwise, insert a band node directly and continue with
 * the construction of the schedule.
 *
 * If a non-trivial common divisor is found, then
 * the linear part is reduced and the remainder is ignored.
 * The pieces of the graph that are assigned different remainders
 * form (groups of) strongly connected components within
 * the scaled down band.  If needed, they can therefore
 * be ordered along this remainder in a sequence node.
 * However, this ordering is not enforced here in order to allow
 * the scheduler to combine some of the strongly connected components.
 */
================================================================================

文件路径: ./isl_scheduler.c
注释行数: 13
注释内容:
/* Is the schedule row "sol" trivial on node "node"?
 * That is, is the solution zero on the dimensions linearly independent of
 * the previously found solutions?
 * Return 1 if the solution is trivial, 0 if it is not and -1 on error.
 *
 * Each coefficient is represented as the difference between
 * two non-negative values in "sol".
 * We construct the schedule row s and check if it is linearly
 * independent of previously computed schedule rows
 * by computing T s, with T the linear combinations that are zero
 * on linearly dependent schedule rows.
 * If the result consists of all zeros, then the solution is trivial.
 */
================================================================================

文件路径: ./isl_scheduler.c
注释行数: 21
注释内容:
/* Does the solution "sol" of the LP problem constructed by setup_carry_lp
 * carry any of the "n_edge" groups of dependences?
 * The value in the first position is the sum of (1 - e_i) over all "n_edge"
 * edges, with 0 <= e_i <= 1 equal to 1 when the dependences represented
 * by the edge are carried by the solution.
 * If the sum of the (1 - e_i) is smaller than "n_edge" then at least
 * one of those is carried.
 *
 * Note that despite the fact that the problem is solved using a rational
 * solver, the solution is guaranteed to be integral.
 * Specifically, the dependence distance lower bounds e_i (and therefore
 * also their sum) are integers.  See Lemma 5 of [1].
 *
 * Any potential denominator of the sum is cleared by this function.
 * The denominator is not relevant for any of the other elements
 * in the solution.
 *
 * [1] P. Feautrier, Some Efficient Solutions to the Affine Scheduling
 *     Problem, Part II: Multi-Dimensional Time.
 *     In Intl. Journal of Parallel Programming, 1992.
 */
================================================================================

文件路径: ./isl_scheduler.c
注释行数: 32
注释内容:
/* Return the lexicographically smallest rational point in "lp",
 * assuming that all variables are non-negative and performing some
 * additional sanity checks.
 * If "want_integral" is set, then compute the lexicographically smallest
 * integer point instead.
 * In particular, "lp" should not be empty by construction.
 * Double check that this is the case.
 * If dependences are not carried for any of the "n_edge" edges,
 * then return an empty vector.
 *
 * If the schedule_treat_coalescing option is set and
 * if the computed schedule performs loop coalescing on a given node,
 * i.e., if it is of the form
 *
 *	c_i i + c_j j + ...
 *
 * with |c_j/c_i| >= size_i, then force the coefficient c_i to be zero
 * to cut out this solution.  Repeat this process until no more loop
 * coalescing occurs or until no more dependences can be carried.
 * In the latter case, revert to the previously computed solution.
 *
 * If the caller requests an integral solution and if coalescing should
 * be treated, then perform the coalescing treatment first as
 * an integral solution computed before coalescing treatment
 * would carry the same number of edges and would therefore probably
 * also be coalescing.
 *
 * To allow the coalescing treatment to be performed first,
 * the initial solution is allowed to be rational and it is only
 * cut out (if needed) in the next iteration, if no coalescing measures
 * were taken.
 */
================================================================================

文件路径: ./isl_scheduler.c
注释行数: 19
注释内容:
/* Given a non-trivial lineality space "lineality", add the corresponding
 * universe set to data->mask and add a map from elements to
 * other elements along the lines in "lineality" to data->equivalent.
 * If this is the first time this function gets called
 * (data->any_non_trivial is still false), then set data->any_non_trivial and
 * initialize data->mask and data->equivalent.
 *
 * In particular, if the lineality space is defined by equality constraints
 *
 *	E x = 0
 *
 * then construct an affine mapping
 *
 *	f : x -> E x
 *
 * and compute the equivalence relation of having the same image under f:
 *
 *	{ x -> x' : E x = E x' }
 */
================================================================================

文件路径: ./isl_scheduler.c
注释行数: 19
注释内容:
/* Check if the difference set on intra-node schedule constraints "intra"
 * has any non-trivial lineality space.
 * If so, then extend the difference set to a difference set
 * on equivalent elements.  That is, if "intra" is
 *
 *	{ y - x : (x,y) \in V }
 *
 * and elements are equivalent if they have the same image under f,
 * then return
 *
 *	{ y' - x' : (x,y) \in V and f(x) = f(x') and f(y) = f(y') }
 *
 * or, since f is linear,
 *
 *	{ y' - x' : (x,y) \in V and f(y - x) = f(y' - x') }
 *
 * The results of the search for non-trivial lineality spaces is stored
 * in "data".
 */
================================================================================

文件路径: ./isl_scheduler.c
注释行数: 36
注释内容:
/* For each dependence relation on a (conditional) validity edge
 * from a node to itself,
 * construct the set of coefficients of valid constraints for elements
 * in that dependence relation and collect the results.
 * If "coincidence" is set, then coincidence edges are considered as well.
 *
 * In particular, for each dependence relation R, constraints
 * on coefficients (c_0, c_x) are constructed such that
 *
 *	c_0 + c_x d >= 0 for each d in delta R = { y - x | (x,y) in R }
 *
 * If the schedule_treat_coalescing option is set, then some constraints
 * that could be exploited to construct coalescing schedules
 * are removed before the dual is computed, but after the parameters
 * have been projected out.
 * The entire computation is essentially the same as that performed
 * by intra_coefficients, except that it operates on multiple
 * edges together and that the parameters are always projected out.
 *
 * Additionally, exploit any non-trivial lineality space
 * in the difference set after removing coalescing constraints and
 * store the results of the non-trivial lineality space detection in "data".
 * The procedure is currently run unconditionally, but it is unlikely
 * to find any non-trivial lineality spaces if no coalescing constraints
 * have been removed.
 *
 * Note that if a dependence relation is a union of basic maps,
 * then each basic map needs to be treated individually as it may only
 * be possible to carry the dependences expressed by some of those
 * basic maps and not all of them.
 * The collected validity constraints are therefore not coalesced and
 * it is assumed that they are not coalesced automatically.
 * Duplicate basic maps can be removed, however.
 * In particular, if the same basic map appears as a disjunct
 * in multiple edges, then it only needs to be carried once.
 */
================================================================================

文件路径: ./isl_scheduler.c
注释行数: 29
注释内容:
/* For each dependence relation on a (conditional) validity edge
 * from a node to some other node,
 * construct the set of coefficients of valid constraints for elements
 * in that dependence relation and collect the results.
 * If "coincidence" is set, then coincidence edges are considered as well.
 *
 * In particular, for each dependence relation R, constraints
 * on coefficients (c_0, c_n, c_x, c_y) are constructed such that
 *
 *	c_0 + c_n n + c_x x + c_y y >= 0 for each (x,y) in R
 *
 * This computation is essentially the same as that performed
 * by inter_coefficients, except that it operates on multiple
 * edges together.
 *
 * Additionally, exploit any non-trivial lineality space
 * that may have been discovered by collect_intra_validity
 * (as stored in "data").
 *
 * Note that if a dependence relation is a union of basic maps,
 * then each basic map needs to be treated individually as it may only
 * be possible to carry the dependences expressed by some of those
 * basic maps and not all of them.
 * The collected validity constraints are therefore not coalesced and
 * it is assumed that they are not coalesced automatically.
 * Duplicate basic maps can be removed, however.
 * In particular, if the same basic map appears as a disjunct
 * in multiple edges, then it only needs to be carried once.
 */
================================================================================

文件路径: ./isl_scheduler.c
注释行数: 15
注释内容:
/* Construct an LP problem for finding schedule coefficients
 * such that the schedule carries as many of the "n_edge" groups of
 * dependences as possible based on the corresponding coefficient
 * constraints and return the lexicographically smallest non-trivial solution.
 * "intra" is the sequence of coefficient constraints for intra-node edges.
 * "inter" is the sequence of coefficient constraints for inter-node edges.
 * If "want_integral" is set, then compute an integral solution
 * for the coefficients rather than using the numerators
 * of a rational solution.
 * "carry_inter" indicates whether inter-node edges should be carried or
 * only respected.
 *
 * If none of the "n_edge" groups can be carried
 * then return an empty vector.
 */
================================================================================

文件路径: ./isl_scheduler.c
注释行数: 24
注释内容:
/* Construct an LP problem for finding schedule coefficients
 * such that the schedule carries as many of the validity dependences
 * as possible and
 * return the lexicographically smallest non-trivial solution.
 * If "fallback" is set, then the carrying is performed as a fallback
 * for the Pluto-like scheduler.
 * If "coincidence" is set, then try and carry coincidence edges as well.
 *
 * The variable "n_edge" stores the number of groups that should be carried.
 * If none of the "n_edge" groups can be carried
 * then return an empty vector.
 * If, moreover, "n_edge" is zero, then the LP problem does not even
 * need to be constructed.
 *
 * If a fallback solution is being computed, then compute an integral solution
 * for the coefficients rather than using the numerators
 * of a rational solution.
 *
 * If a fallback solution is being computed, if there are any intra-node
 * dependences, and if requested by the user, then first try
 * to only carry those intra-node dependences.
 * If this fails to carry any dependences, then try again
 * with the inter-node dependences included.
 */
================================================================================

文件路径: ./isl_scheduler.c
注释行数: 31
注释内容:
/* Construct a schedule row for each node such that as many validity dependences
 * as possible are carried and then continue with the next band.
 * If "fallback" is set, then the carrying is performed as a fallback
 * for the Pluto-like scheduler.
 * If "coincidence" is set, then try and carry coincidence edges as well.
 *
 * If there are no validity dependences, then no dependence can be carried and
 * the procedure is guaranteed to fail.  If there is more than one component,
 * then try computing a schedule on each component separately
 * to prevent or at least postpone this failure.
 *
 * If a schedule row is computed, then check that dependences are carried
 * for at least one of the edges.
 *
 * If the computed schedule row turns out to be trivial on one or
 * more nodes where it should not be trivial, then we throw it away
 * and try again on each component separately.
 *
 * If there is only one component, then we accept the schedule row anyway,
 * but we do not consider it as a complete row and therefore do not
 * increment graph->n_row.  Note that the ranks of the nodes that
 * do get a non-trivial schedule part will get updated regardless and
 * graph->maxvar is computed based on these ranks.  The test for
 * whether more schedule rows are required in compute_schedule_wcc
 * is therefore not affected.
 *
 * Insert a band corresponding to the schedule row at position "node"
 * of the schedule tree and continue with the construction of the schedule.
 * This insertion and the continued construction is performed by split_scaled
 * after optionally checking for non-trivial common divisors.
 */
================================================================================

文件路径: ./isl_scheduler.c
注释行数: 12
注释内容:
/* Topologically sort statements mapped to the same schedule iteration
 * and add insert a sequence node in front of "node"
 * corresponding to this order.
 * If "initialized" is set, then it may be assumed that compute_maxvar
 * has been called on the current band.  Otherwise, call
 * compute_maxvar if and before carry_dependences gets called.
 *
 * If it turns out to be impossible to sort the statements apart,
 * because different dependences impose different orderings
 * on the statements, then we extend the schedule such that
 * it carries at least one more dependence.
 */
================================================================================

文件路径: ./isl_scheduler.c
注释行数: 11
注释内容:
/* Compute a schedule for a connected dependence graph using Feautrier's
 * multi-dimensional scheduling algorithm and return the updated schedule node.
 *
 * The original algorithm is described in [1].
 * The main idea is to minimize the number of scheduling dimensions, by
 * trying to satisfy as many dependences as possible per scheduling dimension.
 *
 * [1] P. Feautrier, Some Efficient Solutions to the Affine Scheduling
 *     Problem, Part II: Multi-Dimensional Time.
 *     In Intl. Journal of Parallel Programming, 1992.
 */
================================================================================

文件路径: ./isl_scheduler.c
注释行数: 10
注释内容:
/* Does "graph" have any satisfied condition edges that
 * are adjacent to the conditional validity constraint with
 * domain "conditional_source" and range "conditional_sink"?
 *
 * A satisfied condition is one that is not local.
 * If a condition was forced to be local already (i.e., marked as local)
 * then there is no need to check if it is in fact local.
 *
 * Additionally, mark all adjacent condition edges found as local.
 */
================================================================================

文件路径: ./isl_scheduler.c
注释行数: 14
注释内容:
/* Are there any violated conditional validity dependences with
 * adjacent condition dependences that are not local with respect
 * to the current schedule?
 * That is, is the conditional validity constraint violated?
 *
 * Additionally, mark all those adjacent condition dependences as local.
 * We also mark those adjacent condition dependences that were not marked
 * as local before, but just happened to be local already.  This ensures
 * that they remain local if the schedule is recomputed.
 *
 * We first collect domain and range of all violated conditional validity
 * dependences and then check if there are any adjacent non-local
 * condition dependences.
 */
================================================================================

文件路径: ./isl_scheduler.c
注释行数: 32
注释内容:
/* Examine the current band (the rows between graph->band_start and
 * graph->n_total_row), deciding whether to drop it or add it to "node"
 * and then continue with the computation of the next band, if any.
 * If "initialized" is set, then it may be assumed that compute_maxvar
 * has been called on the current band.  Otherwise, call
 * compute_maxvar if and before carry_dependences gets called.
 *
 * The caller keeps looking for a new row as long as
 * graph->n_row < graph->maxvar.  If the latest attempt to find
 * such a row failed (i.e., we still have graph->n_row < graph->maxvar),
 * then we either
 * - split between SCCs and start over (assuming we found an interesting
 *	pair of SCCs between which to split)
 * - continue with the next band (assuming the current band has at least
 *	one row)
 * - if there is more than one SCC left, then split along all SCCs
 * - if outer coincidence needs to be enforced, then try to carry as many
 *	validity or coincidence dependences as possible and
 *	continue with the next band
 * - try to carry as many validity dependences as possible and
 *	continue with the next band
 * In each case, we first insert a band node in the schedule tree
 * if any rows have been computed.
 *
 * If the caller managed to complete the schedule and the current band
 * is empty, then finish off by topologically
 * sorting the statements based on the remaining dependences.
 * If, on the other hand, the current band has at least one row,
 * then continue with the next band.  Note that this next band
 * will necessarily be empty, but the graph may still be split up
 * into weakly connected components before arriving back here.
 */
================================================================================

文件路径: ./isl_scheduler.c
注释行数: 32
注释内容:
/* Construct a band of schedule rows for a connected dependence graph.
 * The caller is responsible for determining the strongly connected
 * components and calling compute_maxvar first.
 *
 * We try to find a sequence of as many schedule rows as possible that result
 * in non-negative dependence distances (independent of the previous rows
 * in the sequence, i.e., such that the sequence is tilable), with as
 * many of the initial rows as possible satisfying the coincidence constraints.
 * The computation stops if we can't find any more rows or if we have found
 * all the rows we wanted to find.
 *
 * If ctx->opt->schedule_outer_coincidence is set, then we force the
 * outermost dimension to satisfy the coincidence constraints.  If this
 * turns out to be impossible, we fall back on the general scheme above
 * and try to carry as many dependences as possible.
 *
 * If "graph" contains both condition and conditional validity dependences,
 * then we need to check that that the conditional schedule constraint
 * is satisfied, i.e., there are no violated conditional validity dependences
 * that are adjacent to any non-local condition dependences.
 * If there are, then we mark all those adjacent condition dependences
 * as local and recompute the current band.  Those dependences that
 * are marked local will then be forced to be local.
 * The initial computation is performed with no dependences marked as local.
 * If we are lucky, then there will be no violated conditional validity
 * dependences adjacent to any non-local condition dependences.
 * Otherwise, we mark some additional condition dependences as local and
 * recompute.  We continue this process until there are no violations left or
 * until we are no longer able to compute a schedule.
 * Since there are only a finite number of dependences,
 * there will only be a finite number of iterations.
 */
================================================================================

文件路径: ./isl_scheduler.c
注释行数: 21
注释内容:
/* Clustering information used by compute_schedule_wcc_clustering.
 *
 * "n" is the number of SCCs in the original dependence graph
 * "scc" is an array of "n" elements, each representing an SCC
 * of the original dependence graph.  All entries in the same cluster
 * have the same number of schedule rows.
 * "scc_cluster" maps each SCC index to the cluster to which it belongs,
 * where each cluster is represented by the index of the first SCC
 * in the cluster.  Initially, each SCC belongs to a cluster containing
 * only that SCC.
 *
 * "scc_in_merge" is used by merge_clusters_along_edge to keep
 * track of which SCCs need to be merged.
 *
 * "cluster" contains the merged clusters of SCCs after the clustering
 * has completed.
 *
 * "scc_node" is a temporary data structure used inside copy_partial.
 * For each SCC, it keeps track of the number of nodes in the SCC
 * that have already been copied.
 */
================================================================================

文件路径: ./isl_scheduler.c
注释行数: 15
注释内容:
/* Return the index of an edge in "graph" that can be used to merge
 * two clusters in "c".
 * Return graph->n_edge if no such edge can be found.
 * Return -1 on error.
 *
 * In particular, return a proximity edge between two clusters
 * that is not marked "no_merge" and such that neither of the
 * two clusters has an incomplete, empty band.
 *
 * If there are multiple such edges, then try and find the most
 * appropriate edge to use for merging.  In particular, pick the edge
 * with the greatest weight.  If there are multiple of those,
 * then pick one with the shortest distance between
 * the two cluster representatives.
 */
================================================================================

文件路径: ./isl_scheduler.c
注释行数: 22
注释内容:
/* Mark all SCCs that belong to either of the two clusters in "c"
 * connected by the edge in "graph" with index "edge", or to any
 * of the intermediate clusters.
 * The marking is recorded in c->scc_in_merge.
 *
 * The given edge has been selected for merging two clusters,
 * meaning that there is at least a proximity edge between the two nodes.
 * However, there may also be (indirect) validity dependences
 * between the two nodes.  When merging the two clusters, all clusters
 * containing one or more of the intermediate nodes along the
 * indirect validity dependences need to be merged in as well.
 *
 * First collect all such nodes by computing the strongly connected
 * component (SCC) containing the two nodes connected by the edge, where
 * the two nodes are considered to depend on each other to make
 * sure they end up in the same SCC.  Similarly, each node is considered
 * to depend on every other node in the same cluster to ensure
 * that the SCC consists of complete clusters.
 *
 * Then the original SCCs that contain any of these nodes are marked
 * in c->scc_in_merge.
 */
================================================================================

文件路径: ./isl_scheduler.c
注释行数: 13
注释内容:
/* Given a mapping "cluster_map" from the original instances to
 * the cluster instances, add schedule constraints on the clusters
 * to "sc" corresponding to the original constraints represented by "edge".
 *
 * For non-tagged dependence constraints, the cluster constraints
 * are obtained by applying "cluster_map" to the edge->map.
 *
 * For tagged dependence constraints, "cluster_map" needs to be applied
 * to the domains of the wrapped relations in domain and range
 * of the tagged dependence constraints.  Pick out the mappings
 * from these domains from "cluster_map" and construct their product.
 * This mapping can then be applied to the pair of domains.
 */
================================================================================

文件路径: ./isl_scheduler.c
注释行数: 11
注释内容:
/* Construct a dependence graph for scheduling clusters with respect
 * to each other and store the result in "merge_graph".
 * In particular, the nodes of the graph correspond to the schedule
 * dimensions of the current bands of those clusters that have been
 * marked for merging in "c".
 *
 * First construct an isl_schedule_constraints object for this domain
 * by transforming the edges in "graph" to the domain.
 * Then initialize a dependence graph for scheduling from these
 * constraints.
 */
================================================================================

文件路径: ./isl_scheduler.c
注释行数: 10
注释内容:
/* If there are any clusters where the dimension of the current band
 * (i.e., the band that is to be merged) is smaller than "maxvar" and
 * if there are any nodes in such a cluster where the number
 * of remaining schedule rows that still need to be computed
 * is greater than "max_slack", then return the smallest current band
 * dimension of all these clusters.  Otherwise return the original value
 * of "maxvar".  Return -1 in case of any error.
 * Only clusters that are about to be merged are considered.
 * "c" contains information about the clusters.
 */
================================================================================

文件路径: ./isl_scheduler.c
注释行数: 16
注释内容:
/* Adjust merge_graph->maxvar based on the number of remaining schedule rows
 * that still need to be computed.  In particular, if there is a node
 * in a cluster where the dimension of the current band is smaller
 * than merge_graph->maxvar, but the number of remaining schedule rows
 * is greater than that of any node in a cluster with the maximal
 * dimension for the current band (i.e., merge_graph->maxvar),
 * then adjust merge_graph->maxvar to the (smallest) current band dimension
 * of those clusters.  Without this adjustment, the total number of
 * schedule dimensions would be increased, resulting in a skewed view
 * of the number of coincident dimensions.
 * "c" contains information about the clusters.
 *
 * If the maximize_band_depth option is set and merge_graph->maxvar is reduced,
 * then there is no point in attempting any merge since it will be rejected
 * anyway.  Set merge_graph->maxvar to zero in such cases.
 */
================================================================================

文件路径: ./isl_scheduler.c
注释行数: 14
注释内容:
/* Return the transformation on "node" expressed by the current (and only)
 * band of "merge_graph" applied to the clusters in "c".
 *
 * First find the representation of "node" in its SCC in "c" and
 * extract the transformation expressed by the current band.
 * Then extract the transformation applied by "merge_graph"
 * to the cluster to which this SCC belongs.
 * Combine the two to obtain the complete transformation on the node.
 *
 * Note that the range of the first transformation is an anonymous space,
 * while the domain of the second is named "cluster_X".  The range
 * of the former therefore needs to be adjusted before the two
 * can be combined.
 */
================================================================================

文件路径: ./isl_scheduler.c
注释行数: 26
注释内容:
/* Does the edge "edge" from "graph" have bounded dependence distances
 * in the merged graph "merge_graph" of a selection of clusters in "c"?
 *
 * Extract the complete transformations of the source and destination
 * nodes of the edge, apply them to the edge constraints and
 * compute the differences.  Finally, check if these differences are bounded
 * in each direction.
 *
 * If the dimension of the band is greater than the number of
 * dimensions that can be expected to be optimized by the edge
 * (based on its weight), then also allow the differences to be unbounded
 * in the remaining dimensions, but only if either the source or
 * the destination has a fixed value in that direction.
 * This allows a statement that produces values that are used by
 * several instances of another statement to be merged with that
 * other statement.
 * However, merging such clusters will introduce an inherently
 * large proximity distance inside the merged cluster, meaning
 * that proximity distances will no longer be optimized in
 * subsequent merges.  These merges are therefore only allowed
 * after all other possible merges have been tried.
 * The first time such a merge is encountered, the weight of the edge
 * is replaced by a negative weight.  The second time (i.e., after
 * all merges over edges with a non-negative weight have been tried),
 * the merge is allowed.
 */
================================================================================

文件路径: ./isl_scheduler.c
注释行数: 11
注释内容:
/* Should the clusters be merged based on the cluster schedule
 * in the current (and only) band of "merge_graph"?
 * "graph" is the original dependence graph, while "c" records
 * which SCCs are involved in the latest merge.
 *
 * In particular, is there at least one proximity constraint
 * that is optimized by the merge?
 *
 * A proximity constraint is considered to be optimized
 * if the dependence distances are small.
 */
================================================================================

文件路径: ./isl_scheduler.c
注释行数: 18
注释内容:
/* Should the clusters be merged based on the cluster schedule
 * in the current (and only) band of "merge_graph"?
 * "graph" is the original dependence graph, while "c" records
 * which SCCs are involved in the latest merge.
 *
 * If the current band is empty, then the clusters should not be merged.
 *
 * If the band depth should be maximized and the merge schedule
 * is incomplete (meaning that the dimension of some of the schedule
 * bands in the original schedule will be reduced), then the clusters
 * should not be merged.
 *
 * If the schedule_maximize_coincidence option is set, then check that
 * the number of coincident schedule dimensions is not reduced.
 *
 * Finally, only allow the merge if at least one proximity
 * constraint is optimized.
 */
================================================================================

文件路径: ./isl_scheduler.c
注释行数: 10
注释内容:
/* Apply the schedule in "t_node" to the "n" rows starting at "first"
 * of the schedule in "node" and return the result.
 *
 * That is, essentially compute
 *
 *	T * N(first:first+n-1)
 *
 * taking into account the constant term and the parameter coefficients
 * in "t_node".
 */
================================================================================

文件路径: ./isl_scheduler.c
注释行数: 10
注释内容:
/* Apply the cluster schedule in "t_node" to the current band
 * schedule of the nodes in "graph".
 *
 * In particular, replace the rows starting at band_start
 * by the result of applying the cluster schedule in "t_node"
 * to the original rows.
 *
 * The coincidence of the schedule is determined by the coincidence
 * of the cluster schedule.
 */
================================================================================

文件路径: ./isl_scheduler.c
注释行数: 10
注释内容:
/* Merge the clusters marked for merging in "c" into a single
 * cluster using the cluster schedule in the current band of "merge_graph".
 * The representative SCC for the new cluster is the SCC with
 * the smallest index.
 *
 * The current band schedule of each SCC in the new cluster is obtained
 * by applying the schedule of the corresponding original cluster
 * to the original band schedule.
 * All SCCs in the new cluster have the same number of schedule rows.
 */
================================================================================

文件路径: ./isl_scheduler.c
注释行数: 31
注释内容:
/* Try and merge the clusters of SCCs marked in c->scc_in_merge
 * by scheduling the current cluster bands with respect to each other.
 *
 * Construct a dependence graph with a space for each cluster and
 * with the coordinates of each space corresponding to the schedule
 * dimensions of the current band of that cluster.
 * Construct a cluster schedule in this cluster dependence graph and
 * apply it to the current cluster bands if it is applicable
 * according to ok_to_merge.
 *
 * If the number of remaining schedule dimensions in a cluster
 * with a non-maximal current schedule dimension is greater than
 * the number of remaining schedule dimensions in clusters
 * with a maximal current schedule dimension, then restrict
 * the number of rows to be computed in the cluster schedule
 * to the minimal such non-maximal current schedule dimension.
 * Do this by adjusting merge_graph.maxvar.
 *
 * Return isl_bool_true if the clusters have effectively been merged
 * into a single cluster.
 *
 * Note that since the standard scheduling algorithm minimizes the maximal
 * distance over proximity constraints, the proximity constraints between
 * the merged clusters may not be optimized any further than what is
 * sufficient to bring the distances within the limits of the internal
 * proximity constraints inside the individual clusters.
 * It may therefore make sense to perform an additional translation step
 * to bring the clusters closer to each other, while maintaining
 * the linear part of the merging schedule found using the standard
 * scheduling algorithm.
 */
================================================================================

文件路径: ./isl_scheduler.c
注释行数: 13
注释内容:
/* Is there any edge marked "no_merge" between two SCCs that are
 * about to be merged (i.e., that are set in "scc_in_merge")?
 * "merge_edge" is the proximity edge along which the clusters of SCCs
 * are going to be merged.
 *
 * If there is any edge between two SCCs with a negative weight,
 * while the weight of "merge_edge" is non-negative, then this
 * means that the edge was postponed.  "merge_edge" should then
 * also be postponed since merging along the edge with negative weight should
 * be postponed until all edges with non-negative weight have been tried.
 * Replace the weight of "merge_edge" by a negative weight as well and
 * tell the caller not to attempt a merge.
 */
================================================================================

文件路径: ./isl_scheduler.c
注释行数: 18
注释内容:
/* Merge the two clusters in "c" connected by the edge in "graph"
 * with index "edge" into a single cluster.
 * If it turns out to be impossible to merge these two clusters,
 * then mark the edge as "no_merge" such that it will not be
 * considered again.
 *
 * First mark all SCCs that need to be merged.  This includes the SCCs
 * in the two clusters, but it may also include the SCCs
 * of intermediate clusters.
 * If there is already a no_merge edge between any pair of such SCCs,
 * then simply mark the current edge as no_merge as well.
 * Likewise, if any of those edges was postponed by has_bounded_distances,
 * then postpone the current edge as well.
 * Otherwise, try and merge the clusters and mark "edge" as "no_merge"
 * if the clusters did not end up getting merged, unless the non-merge
 * is due to the fact that the edge was postponed.  This postponement
 * can be recognized by a change in weight (from non-negative to negative).
 */
================================================================================

文件路径: ./isl_scheduler.c
注释行数: 11
注释内容:
/* Copy the current band schedule from the SCCs that form the cluster
 * with index "pos" to the actual cluster at position "pos".
 * By construction, the index of the first SCC that belongs to the cluster
 * is also "pos".
 *
 * The order of the nodes inside both the SCCs and the cluster
 * is assumed to be same as the order in the original "graph".
 *
 * Since the SCC graphs will no longer be used after this function,
 * the schedules are actually swapped rather than copied.
 */
================================================================================

文件路径: ./isl_scheduler.c
注释行数: 15
注释内容:
/* Extract the merged clusters of SCCs in "graph", sort them, and
 * store them in c->clusters.  Update c->scc_cluster accordingly.
 *
 * First keep track of the cluster containing the SCC to which a node
 * belongs in the node itself.
 * Then extract the clusters into c->clusters, copying the current
 * band schedule from the SCCs that belong to the cluster.
 * Do this only once per cluster.
 *
 * Finally, topologically sort the clusters and update c->scc_cluster
 * to match the new scc numbering.  While the SCCs were originally
 * sorted already, some SCCs that depend on some other SCCs may
 * have been merged with SCCs that appear before these other SCCs.
 * A reordering may therefore be required.
 */
================================================================================

文件路径: ./isl_scheduler.c
注释行数: 16
注释内容:
/* Compute weights on the proximity edges of "graph" that can
 * be used by find_proximity to find the most appropriate
 * proximity edge to use to merge two clusters in "c".
 * The weights are also used by has_bounded_distances to determine
 * whether the merge should be allowed.
 * Store the maximum of the computed weights in graph->max_weight.
 *
 * The computed weight is a measure for the number of remaining schedule
 * dimensions that can still be completely aligned.
 * In particular, compute the number of equalities between
 * input dimensions and output dimensions in the proximity constraints.
 * The directions that are already handled by outer schedule bands
 * are projected out prior to determining this number.
 *
 * Edges that will never be considered by find_proximity are ignored.
 */
================================================================================

文件路径: ./isl_scheduler.c
注释行数: 10
注释内容:
/* Call compute_schedule_finish_band on each of the clusters in "c"
 * in their topological order.  This order is determined by the scc
 * fields of the nodes in "graph".
 * Combine the results in a sequence expressing the topological order.
 *
 * If there is only one cluster left, then there is no need to introduce
 * a sequence node.  Also, in this case, the cluster necessarily contains
 * the SCC at position 0 in the original graph and is therefore also
 * stored in the first cluster of "c".
 */
================================================================================

文件路径: ./isl_scheduler.c
注释行数: 17
注释内容:
/* Compute a schedule for a connected dependence graph by first considering
 * each strongly connected component (SCC) in the graph separately and then
 * incrementally combining them into clusters.
 * Return the updated schedule node.
 *
 * Initially, each cluster consists of a single SCC, each with its
 * own band schedule.  The algorithm then tries to merge pairs
 * of clusters along a proximity edge until no more suitable
 * proximity edges can be found.  During this merging, the schedule
 * is maintained in the individual SCCs.
 * After the merging is completed, the full resulting clusters
 * are extracted and in finish_bands_clustering,
 * compute_schedule_finish_band is called on each of them to integrate
 * the band into "node" and to continue the computation.
 *
 * compute_weights initializes the weights that are used by find_proximity.
 */
================================================================================

文件路径: ./isl_scheduler.c
注释行数: 15
注释内容:
/* Compute a schedule for a connected dependence graph and return
 * the updated schedule node.
 *
 * If Feautrier's algorithm is selected, we first recursively try to satisfy
 * as many validity dependences as possible. When all validity dependences
 * are satisfied we extend the schedule to a full-dimensional schedule.
 *
 * Call compute_schedule_wcc_whole or compute_schedule_wcc_clustering
 * depending on whether the user has selected the option to try and
 * compute a schedule for the entire (weakly connected) component first.
 * If there is only a single strongly connected component (SCC), then
 * there is no point in trying to combine SCCs
 * in compute_schedule_wcc_clustering, so compute_schedule_wcc_whole
 * is called instead.
 */
================================================================================

文件路径: ./isl_scheduler.c
注释行数: 18
注释内容:
/* Compute a schedule for each group of nodes identified by node->scc
 * separately and then combine them in a sequence node (or as set node
 * if graph->weak is set) inserted at position "node" of the schedule tree.
 * Return the updated schedule node.
 *
 * If "wcc" is set then each of the groups belongs to a single
 * weakly connected component in the dependence graph so that
 * there is no need for compute_sub_schedule to look for weakly
 * connected components.
 *
 * If a set node would be introduced and if the number of components
 * is equal to the number of nodes, then check if the schedule
 * is already complete.  If so, a redundant set node would be introduced
 * (without any further descendants) stating that the statements
 * can be executed in arbitrary order, which is also expressed
 * by the absence of any node.  Refrain from inserting any nodes
 * in this case and simply return.
 */
================================================================================

文件路径: ./isl_scheduler.c
注释行数: 10
注释内容:
/* Compute a schedule for the given dependence graph and insert it at "node".
 * Return the updated schedule node.
 *
 * We first check if the graph is connected (through validity and conditional
 * validity dependences) and, if not, compute a schedule
 * for each component separately.
 * If the schedule_serialize_sccs option is set, then we check for strongly
 * connected components instead and compute a separate schedule for
 * each such strongly connected component.
 */
================================================================================

文件路径: ./isl_scheduler.c
注释行数: 15
注释内容:
/* Compute a schedule on sc->domain that respects the given schedule
 * constraints.
 *
 * In particular, the schedule respects all the validity dependences.
 * If the default isl scheduling algorithm is used, it tries to minimize
 * the dependence distances over the proximity dependences.
 * If Feautrier's scheduling algorithm is used, the proximity dependence
 * distances are only minimized during the extension to a full-dimensional
 * schedule.
 *
 * If there are any condition and conditional validity dependences,
 * then the conditional validity dependences may be violated inside
 * a tilable band, provided they have no adjacent non-local
 * condition dependences.
 */
================================================================================

文件路径: ./isl_output_private.h
注释行数: 11
注释内容:
/* Internal data structure for isl_print_space.
 *
 * latex is set if that is the output format.
 * print_dim (if not NULL) is called on each dimension.
 * user is set by the caller of print_space and may be used inside print_dim.
 *
 * space is the global space that is being printed.  This field is set by
 *	print_space.
 * type is the tuple of the global space that is currently being printed.
 *	This field is set by print_space.
 */
================================================================================

文件路径: ./isl_tab_pip.c
注释行数: 12
注释内容:
/*
 * Copyright 2008-2009 Katholieke Universiteit Leuven
 * Copyright 2010      INRIA Saclay
 * Copyright 2016-2017 Sven Verdoolaege
 *
 * Use of this software is governed by the MIT license
 *
 * Written by Sven Verdoolaege, K.U.Leuven, Departement
 * Computerwetenschappen, Celestijnenlaan 200A, B-3001 Leuven, Belgium
 * and INRIA Saclay - Ile-de-France, Parc Club Orsay Universite,
 * ZAC des vignes, 4 rue Jacques Monod, 91893 Orsay, France 
 */
================================================================================

文件路径: ./isl_tab_pip.c
注释行数: 38
注释内容:
/*
 * The implementation of parametric integer linear programming in this file
 * was inspired by the paper "Parametric Integer Programming" and the
 * report "Solving systems of affine (in)equalities" by Paul Feautrier
 * (and others).
 *
 * The strategy used for obtaining a feasible solution is different
 * from the one used in isl_tab.c.  In particular, in isl_tab.c,
 * upon finding a constraint that is not yet satisfied, we pivot
 * in a row that increases the constant term of the row holding the
 * constraint, making sure the sample solution remains feasible
 * for all the constraints it already satisfied.
 * Here, we always pivot in the row holding the constraint,
 * choosing a column that induces the lexicographically smallest
 * increment to the sample solution.
 *
 * By starting out from a sample value that is lexicographically
 * smaller than any integer point in the problem space, the first
 * feasible integer sample point we find will also be the lexicographically
 * smallest.  If all variables can be assumed to be non-negative,
 * then the initial sample value may be chosen equal to zero.
 * However, we will not make this assumption.  Instead, we apply
 * the "big parameter" trick.  Any variable x is then not directly
 * used in the tableau, but instead it is represented by another
 * variable x' = M + x, where M is an arbitrarily large (positive)
 * value.  x' is therefore always non-negative, whatever the value of x.
 * Taking as initial sample value x' = 0 corresponds to x = -M,
 * which is always smaller than any possible value of x.
 *
 * The big parameter trick is used in the main tableau and
 * also in the context tableau if isl_context_lex is used.
 * In this case, each tableaus has its own big parameter.
 * Before doing any real work, we check if all the parameters
 * happen to be non-negative.  If so, we drop the column corresponding
 * to M from the initial context tableau.
 * If isl_context_gbr is used, then the big parameter trick is only
 * used in the main tableau.
 */
================================================================================

文件路径: ./isl_tab_pip.c
注释行数: 27
注释内容:
/* isl_sol is an interface for constructing a solution to
 * a parametric integer linear programming problem.
 * Every time the algorithm reaches a state where a solution
 * can be read off from the tableau, the function "add" is called
 * on the isl_sol passed to find_solutions_main.  In a state where
 * the tableau is empty, "add_empty" is called instead.
 * "free" is called to free the implementation specific fields, if any.
 *
 * "error" is set if some error has occurred.  This flag invalidates
 * the remainder of the data structure.
 * If "rational" is set, then a rational optimization is being performed.
 * "level" is the current level in the tree with nodes for each
 * split in the context.
 * If "max" is set, then a maximization problem is being solved, rather than
 * a minimization problem, which means that the variables in the
 * tableau have value "M - x" rather than "M + x".
 * "n_out" is the number of output dimensions in the input.
 * "space" is the space in which the solution (and also the input) lives.
 *
 * The context tableau is owned by isl_sol and is updated incrementally.
 *
 * There are currently two implementations of this interface,
 * isl_sol_map, which simply collects the solutions in an isl_map
 * and (optionally) the parts of the context where there is no solution
 * in an isl_set, and
 * isl_sol_pma, which collects an isl_pw_multi_aff instead.
 */
================================================================================

文件路径: ./isl_tab_pip.c
注释行数: 20
注释内容:
/* Push a partial solution represented by a domain and mapping M
 * onto the stack of partial solutions.
 *
 * The affine matrix "M" maps the dimensions of the context
 * to the output variables.  Convert it into an isl_multi_aff and
 * then call sol_push_sol.
 *
 * Note that the description of the initial context may have involved
 * existentially quantified variables, in which case they also appear
 * in "dom".  These need to be removed before creating the affine
 * expression because an affine expression cannot be defined in terms
 * of existentially quantified variables without a known representation.
 * Since newly added integer divisions are inserted before these
 * existentially quantified variables, they are still in the final
 * positions and the corresponding final columns of "M" are zero
 * because align_context_divs adds the existentially quantified
 * variables of the context to the main tableau without any constraints and
 * any equality constraints that are added later on can only serve
 * to eliminate these existentially quantified variables.
 */
================================================================================

文件路径: ./isl_tab_pip.c
注释行数: 10
注释内容:
/* Swap the initial two partial solutions in "sol".
 *
 * That is, go from
 *
 *	sol->partial = p1; p1->next = p2; p2->next = p3
 *
 * to
 *
 *	sol->partial = p2; p2->next = p1; p1->next = p3
 */
================================================================================

文件路径: ./isl_tab_pip.c
注释行数: 10
注释内容:
/* Combine the initial two partial solution of "sol" into
 * a partial solution with the current context domain of "sol" and
 * the function description of the second partial solution in the list.
 * The level of the new partial solution is set to the current level.
 *
 * That is, the first two partial solutions (D1,M1) and (D2,M2) are
 * replaced by (D,M2), where D is the domain of "sol", which is assumed
 * to be the union of D1 and D2, while M1 is assumed to be equal to M2
 * (at least on D1).
 */
================================================================================

文件路径: ./isl_tab_pip.c
注释行数: 15
注释内容:
/* The initial two partial solutions of "sol" are known to be at
 * the same level.
 * If they represent the same solution (on different parts of the domain),
 * then combine them into a single solution at the current level.
 * Otherwise, pop them both.
 *
 * Even if the two partial solution are not obviously the same,
 * one may still be a simplification of the other over its own domain.
 * Also check if the two sets of affine functions are equal when
 * restricted to one of the domains.  If so, combine the two
 * using the set of affine functions on the other domain.
 * That is, for two partial solutions (D1,M1) and (D2,M2),
 * if M1 = M2 on D1, then the pair of partial solutions can
 * be replaced by (D1+D2,M2) and similarly when M1 = M2 on D2.
 */
================================================================================

文件路径: ./isl_tab_pip.c
注释行数: 49
注释内容:
/* Add the solution identified by the tableau and the context tableau.
 *
 * The layout of the variables is as follows.
 *	tab->n_var is equal to the total number of variables in the input
 *			map (including divs that were copied from the context)
 *			+ the number of extra divs constructed
 *      Of these, the first tab->n_param and the last tab->n_div variables
 *	correspond to the variables in the context, i.e.,
 *		tab->n_param + tab->n_div = context_tab->n_var
 *	tab->n_param is equal to the number of parameters and input
 *			dimensions in the input map
 *	tab->n_div is equal to the number of divs in the context
 *
 * If there is no solution, then call add_empty with a basic set
 * that corresponds to the context tableau.  (If add_empty is NULL,
 * then do nothing).
 *
 * If there is a solution, then first construct a matrix that maps
 * all dimensions of the context to the output variables, i.e.,
 * the output dimensions in the input map.
 * The divs in the input map (if any) that do not correspond to any
 * div in the context do not appear in the solution.
 * The algorithm will make sure that they have an integer value,
 * but these values themselves are of no interest.
 * We have to be careful not to drop or rearrange any divs in the
 * context because that would change the meaning of the matrix.
 *
 * To extract the value of the output variables, it should be noted
 * that we always use a big parameter M in the main tableau and so
 * the variable stored in this tableau is not an output variable x itself, but
 *	x' = M + x (in case of minimization)
 * or
 *	x' = M - x (in case of maximization)
 * If x' appears in a column, then its optimal value is zero,
 * which means that the optimal value of x is an unbounded number
 * (-M for minimization and M for maximization).
 * We currently assume that the output dimensions in the original map
 * are bounded, so this cannot occur.
 * Similarly, when x' appears in a row, then the coefficient of M in that
 * row is necessarily 1.
 * If the row in the tableau represents
 *	d x' = c + d M + e(y)
 * then, in case of minimization, the corresponding row in the matrix
 * will be
 *	a c + a e(y)
 * with a d = m, the (updated) common denominator of the matrix.
 * In case of maximization, the row will be
 *	-a c - a e(y)
 */
================================================================================

文件路径: ./isl_tab_pip.c
注释行数: 11
注释内容:
/* Return an integer division for use in a parametric cut based
 * on the given row.
 * In particular, let the parametric constant of the row be
 *
 *		\sum_i a_i y_i
 *
 * where y_0 = 1, but none of the y_i corresponds to the big parameter M.
 * The div returned is equal to
 *
 *		floor(\sum_i {-a_i} y_i) = floor((\sum_i (-a_i mod d) y_i)/d)
 */
================================================================================

文件路径: ./isl_tab_pip.c
注释行数: 11
注释内容:
/* Return an integer division for use in transferring an integrality constraint
 * to the context.
 * In particular, let the parametric constant of the row be
 *
 *		\sum_i a_i y_i
 *
 * where y_0 = 1, but none of the y_i corresponds to the big parameter M.
 * The the returned div is equal to
 *
 *		floor(\sum_i {a_i} y_i) = floor((\sum_i (a_i mod d) y_i)/d)
 */
================================================================================

文件路径: ./isl_tab_pip.c
注释行数: 10
注释内容:
/* Construct and return an inequality that expresses an upper bound
 * on the given div.
 * In particular, if the div is given by
 *
 *	d = floor(e/m)
 *
 * then the inequality expresses
 *
 *	m d <= e
 */
================================================================================

文件路径: ./isl_tab_pip.c
注释行数: 13
注释内容:
/* Given a row in the tableau and a div that was created
 * using get_row_split_div and that has been constrained to equality, i.e.,
 *
 *		d = floor(\sum_i {a_i} y_i) = \sum_i {a_i} y_i
 *
 * replace the expression "\sum_i {a_i} y_i" in the row by d,
 * i.e., we subtract "\sum_i {a_i} y_i" and add 1 d.
 * The coefficients of the non-parameters in the tableau have been
 * verified to be integral.  We can therefore simply replace coefficient b
 * by floor(b).  For the coefficients of the parameters we have
 * floor(a_i) = a_i - {a_i}, while for the other coefficients, we have
 * floor(b) = b.
 */
================================================================================

文件路径: ./isl_tab_pip.c
注释行数: 16
注释内容:
/* Given a row r and two columns, return the column that would
 * lead to the lexicographically smallest increment in the sample
 * solution when leaving the basis in favor of the row.
 * Pivoting with column c will increment the sample value by a non-negative
 * constant times a_{V,c}/a_{r,c}, with a_{V,c} the elements of column c
 * corresponding to the non-parametric variables.
 * If variable v appears in a column c_v, then a_{v,c} = 1 iff c = c_v,
 * with all other entries in this virtual row equal to zero.
 * If variable v appears in a row, then a_{v,c} is the element in column c
 * of that row.
 *
 * Let v be the first variable with a_{v,c1}/a_{r,c1} != a_{v,c2}/a_{r,c2}.
 * Then if a_{v,c1}/a_{r,c1} < a_{v,c2}/a_{r,c2}, i.e.,
 * a_{v,c2} a_{r,c1} - a_{v,c1} a_{r,c2} > 0, c1 results in the minimal
 * increment.  Otherwise, it's c2.
 */
================================================================================

文件路径: ./isl_tab_pip.c
注释行数: 21
注释内容:
/* Given a row that represents an equality, look for an appropriate
 * pivoting column.
 * In particular, if there are any non-zero coefficients among
 * the non-parameter variables, then we take the last of these
 * variables.  Eliminating this variable in terms of the other
 * variables and/or parameters does not influence the property
 * that all column in the initial tableau are lexicographically
 * positive.  The row corresponding to the eliminated variable
 * will only have non-zero entries below the diagonal of the
 * initial tableau.  That is, we transform
 *
 *		I				I
 *		  1		into		a
 *		    I				  I
 *
 * If there is no such non-parameter variable, then we are dealing with
 * pure parameter equality and we pick any parameter with coefficient 1 or -1
 * for elimination.  This will ensure that the eliminated parameter
 * always has an integer value whenever all the other parameters are integral.
 * If there is no such parameter then we return -1.
 */
================================================================================

文件路径: ./isl_tab_pip.c
注释行数: 12
注释内容:
/* Add an equality that may or may not be valid to the tableau.
 * If the resulting row is a pure constant, then it must be zero.
 * Otherwise, the resulting tableau is empty.
 *
 * If the row is not a pure constant, then we add two inequalities,
 * each time checking that they can be satisfied.
 * In the end we try to use one of the two constraints to eliminate
 * a column.
 *
 * This function assumes that at least two more rows and at least
 * two more elements in the constraint array are available in the tableau.
 */
================================================================================

文件路径: ./isl_tab_pip.c
注释行数: 11
注释内容:
/* Check for next (non-parameter) variable after "var" (first if var == -1)
 * that is non-integer and therefore requires a cut and return
 * the index of the variable.
 * For parametric tableaus, there are three parts in a row,
 * the constant, the coefficients of the parameters and the rest.
 * For each part, we check whether the coefficients in that part
 * are all integral and if so, set the corresponding flag in *f.
 * If the constant and the parameter part are integral, then the
 * current sample value is integral and no cut is required
 * (irrespective of whether the variable part is integral).
 */
================================================================================

文件路径: ./isl_tab_pip.c
注释行数: 10
注释内容:
/* Check for first (non-parameter) variable that is non-integer and
 * therefore requires a cut and return the corresponding row.
 * For parametric tableaus, there are three parts in a row,
 * the constant, the coefficients of the parameters and the rest.
 * For each part, we check whether the coefficients in that part
 * are all integral and if so, set the corresponding flag in *f.
 * If the constant and the parameter part are integral, then the
 * current sample value is integral and no cut is required
 * (irrespective of whether the variable part is integral).
 */
================================================================================

文件路径: ./isl_tab_pip.c
注释行数: 22
注释内容:
/* Add a (non-parametric) cut to cut away the non-integral sample
 * value of the given row.
 *
 * If the row is given by
 *
 *	m r = f + \sum_i a_i y_i
 *
 * then the cut is
 *
 *	c = - {-f/m} + \sum_i {a_i/m} y_i >= 0
 *
 * The big parameter, if any, is ignored, since it is assumed to be big
 * enough to be divisible by any integer.
 * If the tableau is actually a parametric tableau, then this function
 * is only called when all coefficients of the parameters are integral.
 * The cut therefore has zero coefficients for the parameters.
 *
 * The current value is known to be negative, so row_sign, if it
 * exists, is set accordingly.
 *
 * Return the row of the cut or -1.
 */
================================================================================

文件路径: ./isl_tab_pip.c
注释行数: 15
注释内容:
/* Given a non-parametric tableau, add cuts until an integer
 * sample point is obtained or until the tableau is determined
 * to be integer infeasible.
 * As long as there is any non-integer value in the sample point,
 * we add appropriate cuts, if possible, for each of these
 * non-integer values and then resolve the violated
 * cut constraints using restore_lexmin.
 * If one of the corresponding rows is equal to an integral
 * combination of variables/constraints plus a non-integral constant,
 * then there is no way to obtain an integer point and we return
 * a tableau that is marked empty.
 * The parameter cutting_strategy controls the strategy used when adding cuts
 * to remove non-integer points. CUT_ALL adds all possible cuts
 * before continuing the search. CUT_ONE adds only one cut at a time.
 */
================================================================================

文件路径: ./isl_tab_pip.c
注释行数: 11
注释内容:
/* Add a div specified by "div" to both the main tableau and
 * the context tableau.  In case of the main tableau, we only
 * need to add an extra div.  In the context tableau, we also
 * need to express the meaning of the div.
 * Return the index of the div or -1 if anything went wrong.
 *
 * The new integer division is added before any unknown integer
 * divisions in the context to ensure that it does not get
 * equated to some linear combination involving unknown integer
 * divisions.
 */
================================================================================

文件路径: ./isl_tab_pip.c
注释行数: 23
注释内容:
/* Add a parametric cut to cut away the non-integral sample value
 * of the given row.
 * Let a_i be the coefficients of the constant term and the parameters
 * and let b_i be the coefficients of the variables or constraints
 * in basis of the tableau.
 * Let q be the div q = floor(\sum_i {-a_i} y_i).
 *
 * The cut is expressed as
 *
 *	c = \sum_i -{-a_i} y_i + \sum_i {b_i} x_i + q >= 0
 *
 * If q did not already exist in the context tableau, then it is added first.
 * If q is in a column of the main tableau then the "+ q" can be accomplished
 * by setting the corresponding entry to the denominator of the constraint.
 * If q happens to be in a row of the main tableau, then the corresponding
 * row needs to be added instead (taking care of the denominators).
 * Note that this is very unlikely, but perhaps not entirely impossible.
 *
 * The current value of the cut is known to be negative (or at least
 * non-positive), so row_sign is set accordingly.
 *
 * Return the row of the cut or -1.
 */
================================================================================

文件路径: ./isl_tab_pip.c
注释行数: 12
注释内容:
/* Construct a tableau for bmap that can be used for computing
 * the lexicographic minimum (or maximum) of bmap.
 * If not NULL, then dom is the domain where the minimum
 * should be computed.  In this case, we set up a parametric
 * tableau with row signs (initialized to "unknown").
 * If M is set, then the tableau will use a big parameter.
 * If max is set, then a maximum should be computed instead of a minimum.
 * This means that for each variable x, the tableau will contain the variable
 * x' = M - x, rather than x' = M + x.  This in turn means that the coefficient
 * of the variables in all constraints are negated prior to adding them
 * to the tableau.
 */
================================================================================

文件路径: ./isl_tab_pip.c
注释行数: 29
注释内容:
/* Given a main tableau where more than one row requires a split,
 * determine and return the "best" row to split on.
 *
 * If any of the rows requiring a split only involves
 * variables that also appear in the context tableau,
 * then the negative part is guaranteed not to have a solution.
 * It is therefore best to split on any of these rows first.
 *
 * Otherwise,
 * given two rows in the main tableau, if the inequality corresponding
 * to the first row is redundant with respect to that of the second row
 * in the current tableau, then it is better to split on the second row,
 * since in the positive part, both rows will be positive.
 * (In the negative part a pivot will have to be performed and just about
 * anything can happen to the sign of the other row.)
 *
 * As a simple heuristic, we therefore select the row that makes the most
 * of the other rows redundant.
 *
 * Perhaps it would also be useful to look at the number of constraints
 * that conflict with any given constraint.
 *
 * best is the best row so far (-1 when we have not found any row yet).
 * best_r is the number of other rows made redundant by row best.
 * When best is still -1, bset_r is meaningless, but it is initialized
 * to some arbitrary value (0) anyway.  Without this redundant initialization
 * valgrind may warn about uninitialized memory accesses when isl
 * is compiled with some versions of gcc.
 */
================================================================================

文件路径: ./isl_tab_pip.c
注释行数: 17
注释内容:
/* Look through all the recently added equalities in the context
 * to see if we can propagate any of them to the main tableau.
 *
 * The newly added equalities in the context are encoded as pairs
 * of inequalities starting at inequality "first".
 *
 * We tentatively add each of these equalities to the main tableau
 * and if this happens to result in a row with a final coefficient
 * that is one or negative one, we use it to kill a column
 * in the main tableau.  Otherwise, we discard the tentatively
 * added row.
 * This tentative addition of equality constraints turns
 * on the undo facility of the tableau.  Turn it off again
 * at the end, assuming it was turned off to begin with.
 *
 * Return 0 on success and -1 on failure.
 */
================================================================================

文件路径: ./isl_tab_pip.c
注释行数: 56
注释内容:
/* Determine the sign of the given row of the main tableau.
 * The result is one of
 *	isl_tab_row_pos: always non-negative; no pivot needed
 *	isl_tab_row_neg: always non-positive; pivot
 *	isl_tab_row_any: can be both positive and negative; split
 *
 * We first handle some simple cases
 *	- the row sign may be known already
 *	- the row may be obviously non-negative
 *	- the parametric constant may be equal to that of another row
 *	  for which we know the sign.  This sign will be either "pos" or
 *	  "any".  If it had been "neg" then we would have pivoted before.
 *
 * If none of these cases hold, we check the value of the row for each
 * of the currently active samples.  Based on the signs of these values
 * we make an initial determination of the sign of the row.
 *
 *	all zero			->	unk(nown)
 *	all non-negative		->	pos
 *	all non-positive		->	neg
 *	both negative and positive	->	all
 *
 * If we end up with "all", we are done.
 * Otherwise, we perform a check for positive and/or negative
 * values as follows.
 *
 *	samples	       neg	       unk	       pos
 *	<0 ?			    Y        N	    Y        N
 *					    pos    any      pos
 *	>0 ?	     Y      N	 Y     N
 *		    any    neg  any   neg
 *
 * There is no special sign for "zero", because we can usually treat zero
 * as either non-negative or non-positive, whatever works out best.
 * However, if the row is "critical", meaning that pivoting is impossible
 * then we don't want to limp zero with the non-positive case, because
 * then we we would lose the solution for those values of the parameters
 * where the value of the row is zero.  Instead, we treat 0 as non-negative
 * ensuring a split if the row can attain both zero and negative values.
 * The same happens when the original constraint was one that could not
 * be satisfied with equality by any integer values of the parameters.
 * In this case, we normalize the constraint, but then a value of zero
 * for the normalized constraint is actually a positive value for the
 * original constraint, so again we need to treat zero as non-negative.
 * In both these cases, we have the following decision tree instead:
 *
 *	all non-negative		->	pos
 *	all negative			->	neg
 *	both negative and non-negative	->	all
 *
 *	samples	       neg	          	       pos
 *	<0 ?			             	    Y        N
 *					           any      pos
 *	>=0 ?	     Y      N
 *		    any    neg
 */
================================================================================

文件路径: ./isl_tab_pip.c
注释行数: 14
注释内容:
/* Find solutions for values of the parameters that satisfy the given
 * inequality.
 *
 * We currently take a snapshot of the context tableau that is reset
 * when we return from this function, while we make a copy of the main
 * tableau, leaving the original main tableau untouched.
 * These are fairly arbitrary choices.  Making a copy also of the context
 * tableau would obviate the need to undo any changes made to it later,
 * while taking a snapshot of the main tableau could reduce memory usage.
 * If we were to switch to taking a snapshot of the main tableau,
 * we would have to keep in mind that we need to save the row signs
 * and that we need to do this before saving the current basis
 * such that the basis has been restore before we restore the row signs.
 */
================================================================================

文件路径: ./isl_tab_pip.c
注释行数: 94
注释内容:
/* Compute the lexicographic minimum of the set represented by the main
 * tableau "tab" within the context "sol->context_tab".
 * On entry the sample value of the main tableau is lexicographically
 * less than or equal to this lexicographic minimum.
 * Pivots are performed until a feasible point is found, which is then
 * necessarily equal to the minimum, or until the tableau is found to
 * be infeasible.  Some pivots may need to be performed for only some
 * feasible values of the context tableau.  If so, the context tableau
 * is split into a part where the pivot is needed and a part where it is not.
 *
 * Whenever we enter the main loop, the main tableau is such that no
 * "obvious" pivots need to be performed on it, where "obvious" means
 * that the given row can be seen to be negative without looking at
 * the context tableau.  In particular, for non-parametric problems,
 * no pivots need to be performed on the main tableau.
 * The caller of find_solutions is responsible for making this property
 * hold prior to the first iteration of the loop, while restore_lexmin
 * is called before every other iteration.
 *
 * Inside the main loop, we first examine the signs of the rows of
 * the main tableau within the context of the context tableau.
 * If we find a row that is always non-positive for all values of
 * the parameters satisfying the context tableau and negative for at
 * least one value of the parameters, we perform the appropriate pivot
 * and start over.  An exception is the case where no pivot can be
 * performed on the row.  In this case, we require that the sign of
 * the row is negative for all values of the parameters (rather than just
 * non-positive).  This special case is handled inside row_sign, which
 * will say that the row can have any sign if it determines that it can
 * attain both negative and zero values.
 *
 * If we can't find a row that always requires a pivot, but we can find
 * one or more rows that require a pivot for some values of the parameters
 * (i.e., the row can attain both positive and negative signs), then we split
 * the context tableau into two parts, one where we force the sign to be
 * non-negative and one where we force is to be negative.
 * The non-negative part is handled by a recursive call (through find_in_pos).
 * Upon returning from this call, we continue with the negative part and
 * perform the required pivot.
 *
 * If no such rows can be found, all rows are non-negative and we have
 * found a (rational) feasible point.  If we only wanted a rational point
 * then we are done.
 * Otherwise, we check if all values of the sample point of the tableau
 * are integral for the variables.  If so, we have found the minimal
 * integral point and we are done.
 * If the sample point is not integral, then we need to make a distinction
 * based on whether the constant term is non-integral or the coefficients
 * of the parameters.  Furthermore, in order to decide how to handle
 * the non-integrality, we also need to know whether the coefficients
 * of the other columns in the tableau are integral.  This leads
 * to the following table.  The first two rows do not correspond
 * to a non-integral sample point and are only mentioned for completeness.
 *
 *	constant	parameters	other
 *
 *	int		int		int	|
 *	int		int		rat	| -> no problem
 *
 *	rat		int		int	  -> fail
 *
 *	rat		int		rat	  -> cut
 *
 *	int		rat		rat	|
 *	rat		rat		rat	| -> parametric cut
 *
 *	int		rat		int	|
 *	rat		rat		int	| -> split context
 *
 * If the parametric constant is completely integral, then there is nothing
 * to be done.  If the constant term is non-integral, but all the other
 * coefficient are integral, then there is nothing that can be done
 * and the tableau has no integral solution.
 * If, on the other hand, one or more of the other columns have rational
 * coefficients, but the parameter coefficients are all integral, then
 * we can perform a regular (non-parametric) cut.
 * Finally, if there is any parameter coefficient that is non-integral,
 * then we need to involve the context tableau.  There are two cases here.
 * If at least one other column has a rational coefficient, then we
 * can perform a parametric cut in the main tableau by adding a new
 * integer division in the context tableau.
 * If all other columns have integral coefficients, then we need to
 * enforce that the rational combination of parameters (c + \sum a_i y_i)/m
 * is always integral.  We do this by introducing an integer division
 * q = floor((c + \sum a_i y_i)/m) and stipulating that its argument should
 * always be integral in the context tableau, i.e., m q = c + \sum a_i y_i.
 * Since q is expressed in the tableau as
 *	c + \sum a_i y_i - m q >= 0
 *	-c - \sum a_i y_i + m q + m - 1 >= 0
 * it is sufficient to add the inequality
 *	-c - \sum a_i y_i + m q >= 0
 * In the part of the context where this inequality does not hold, the
 * main tableau is marked as being empty.
 */
================================================================================

文件路径: ./isl_tab_pip.c
注释行数: 20
注释内容:
/* Compute the lexicographic minimum of the set represented by the main
 * tableau "tab" within the context "sol->context_tab".
 *
 * As a preprocessing step, we first transfer all the purely parametric
 * equalities from the main tableau to the context tableau, i.e.,
 * parameters that have been pivoted to a row.
 * These equalities are ignored by the main algorithm, because the
 * corresponding rows may not be marked as being non-negative.
 * In parts of the context where the added equality does not hold,
 * the main tableau is marked as being empty.
 *
 * Before we embark on the actual computation, we save a copy
 * of the context.  When we return, we check if there are any
 * partial solutions that can potentially be merged.  If so,
 * we perform a rollback to the initial state of the context.
 * The merging of partial solutions happens inside calls to
 * sol_dec_level that are pushed onto the undo stack of the context.
 * If there are no partial solutions that can potentially be merged
 * then the rollback is skipped as it would just be wasted effort.
 */
================================================================================

文件路径: ./isl_tab_pip.c
注释行数: 14
注释内容:
/* The correspondence between the variables in the main tableau,
 * the context tableau, and the input map and domain is as follows.
 * The first n_param and the last n_div variables of the main tableau
 * form the variables of the context tableau.
 * In the basic map, these n_param variables correspond to the
 * parameters and the input dimensions.  In the domain, they correspond
 * to the parameters and the set dimensions.
 * The n_div variables correspond to the integer divisions in the domain.
 * To ensure that everything lines up, we may need to copy some of the
 * integer divisions of the domain to the map.  These have to be placed
 * in the same order as those in the context and they have to be placed
 * after any other integer divisions that the map may have.
 * This function performs the required reordering.
 */
================================================================================

文件路径: ./isl_tab_pip.c
注释行数: 12
注释内容:
/* Base case of isl_tab_basic_map_partial_lexopt, after removing
 * some obvious symmetries.
 *
 * We make sure the divs in the domain are properly ordered,
 * because they will be added one by one in the given order
 * during the construction of the solution map.
 * Furthermore, make sure that the known integer divisions
 * appear before any unknown integer division because the solution
 * may depend on the known integer divisions, while anything that
 * depends on any variable starting from the first unknown integer
 * division is ignored in sol_pma_add.
 */
================================================================================

文件路径: ./isl_tab_pip.c
注释行数: 10
注释内容:
/* Check whether "bmap" has a pair of constraints that have
 * the same coefficients for the output variables.
 * Note that the coefficients of the existentially quantified
 * variables need to be zero since the existentially quantified
 * of the result are usually not the same as those of the input.
 * Furthermore, check that each of the input variables that occur
 * in those constraints does not occur in any other constraint.
 * If so, return true and return the row indices of the two constraints
 * in *first and *second.
 */
================================================================================

文件路径: ./isl_tab_pip.c
注释行数: 13
注释内容:
/* Given a set of upper bounds on the last "input" variable m,
 * construct a set that assigns the minimal upper bound to m, i.e.,
 * construct a set that divides the space into cells where one
 * of the upper bounds is smaller than all the others and assign
 * this upper bound to m.
 *
 * In particular, if there are n bounds b_i, then the result
 * consists of n basic sets, each one of the form
 *
 *	m = b_i
 *	b_i <= b_j	for j > i
 *	b_i <  b_j	for j < i
 */
================================================================================

文件路径: ./isl_tab_pip.c
注释行数: 13
注释内容:
/* Given a map of which the last input variable is the minimum
 * of the bounds in "cst", split each basic set in the set
 * in pieces where one of the bounds is (strictly) smaller than the others.
 * This subdivision is given in "min_expr".
 * The variable is subsequently projected out.
 *
 * We only do the split when it is needed.
 * For example if the last input variable m = min(a,b) and the only
 * constraints in the given basic set are lower bounds on m,
 * i.e., l <= m = min(a,b), then we can simply project out m
 * to obtain l <= a and l <= b, without having to split on whether
 * m is equal to a or b.
 */
================================================================================

文件路径: ./isl_tab_pip.c
注释行数: 22
注释内容:
/* Extract a domain from "bmap" for the purpose of computing
 * a lexicographic optimum.
 *
 * This function is only called when the caller wants to compute a full
 * lexicographic optimum, i.e., without specifying a domain.  In this case,
 * the caller is not interested in the part of the domain space where
 * there is no solution and the domain can be initialized to those constraints
 * of "bmap" that only involve the parameters and the input dimensions.
 * This relieves the parametric programming engine from detecting those
 * inequalities and transferring them to the context.  More importantly,
 * it ensures that those inequalities are transferred first and not
 * intermixed with inequalities that actually split the domain.
 *
 * If the caller does not require the absence of existentially quantified
 * variables in the result (i.e., if ISL_OPT_QE is not set in "flags"),
 * then the actual domain of "bmap" can be used.  This ensures that
 * the domain does not need to be split at all just to separate out
 * pieces of the domain that do not have a solution from piece that do.
 * This domain cannot be used in general because it may involve
 * (unknown) existentially quantified variables which will then also
 * appear in the solution.
 */
================================================================================

文件路径: ./isl_tab_pip.c
注释行数: 17
注释内容:
/* Global internal data for isl_tab_basic_set_non_trivial_lexmin.
 *
 * "n_op" is the number of initial coordinates to optimize,
 * as passed to isl_tab_basic_set_non_trivial_lexmin.
 * "region" is the "n_region"-sized array of regions passed
 * to isl_tab_basic_set_non_trivial_lexmin.
 *
 * "tab" is the tableau that corresponds to the ILP problem.
 * "local" is an array of local data structure, one for each
 * (potential) level of the backtracking procedure of
 * isl_tab_basic_set_non_trivial_lexmin.
 * "v" is a pre-allocated vector that can be used for adding
 * constraints to the tableau.
 *
 * "sol" contains the best solution found so far.
 * It is initialized to a vector of size zero.
 */
================================================================================

文件路径: ./isl_tab_pip.c
注释行数: 14
注释内容:
/* Add constraints to "tab" that ensure that any solution is significantly
 * better than that represented by "sol".  That is, find the first
 * relevant (within first n_op) non-zero coefficient and force it (along
 * with all previous coefficients) to be zero.
 * If the solution is already optimal (all relevant coefficients are zero),
 * then just mark the table as empty.
 * "n_zero" is the number of coefficients that have been forced zero
 * by previous calls to this function at the same level.
 * Return the updated number of forced zero coefficients or -1 on error.
 *
 * This function assumes that at least 2 * (n_op - n_zero) more rows and
 * at least 2 * (n_op - n_zero) more elements in the constraint array
 * are available in the tableau.
 */
================================================================================

文件路径: ./isl_tab_pip.c
注释行数: 14
注释内容:
/* Local data at each level of the backtracking procedure of
 * isl_tab_basic_set_non_trivial_lexmin.
 *
 * "update" is set if a solution has been found in the current case
 * of this level, such that a better solution needs to be enforced
 * in the next case.
 * "n_zero" is the number of initial coordinates that have already
 * been forced to be zero at this level.
 * "region" is the non-triviality region considered at this level.
 * "side" is the index of the current case at this level.
 * "n" is the number of triviality directions.
 * "snap" is a snapshot of the tableau holding a state that needs
 * to be satisfied by all subsequent cases.
 */
================================================================================

文件路径: ./isl_tab_pip.c
注释行数: 19
注释内容:
/* Enter level "level" of the backtracking search and figure out
 * what to do next.  "init" is set if the level was entered
 * from a higher level and needs to be initialized.
 * Otherwise, the level is entered as a result of backtracking and
 * the tableau needs to be restored to a position that can
 * be used for the next case at this level.
 * The snapshot is assumed to have been saved in the previous case,
 * before the constraints specific to that case were added.
 *
 * In the initialization case, the local region is initialized
 * to point to the first violated region.
 * If the constraints of all regions are satisfied by the current
 * sample of the tableau, then tell the caller to continue looking
 * for a better solution or to stop searching if an optimal solution
 * has been found.
 *
 * If the tableau is empty or if all cases at the current level
 * have been considered, then the caller needs to backtrack as well.
 */
================================================================================

文件路径: ./isl_tab_pip.c
注释行数: 17
注释内容:
/* Add constraints to data->tab that select the current case (local->side)
 * at the current level.
 *
 * If the linear combinations v should not be zero, then the cases are
 *	v_0 >= 1
 *	v_0 <= -1
 *	v_0 = 0 and v_1 >= 1
 *	v_0 = 0 and v_1 <= -1
 *	v_0 = 0 and v_1 = 0 and v_2 >= 1
 *	v_0 = 0 and v_1 = 0 and v_2 <= -1
 *	...
 * in this order.
 *
 * A snapshot is taken after the equality constraint (if any) has been added
 * such that the next case can start off from this position.
 * The rollback to this position is performed in enter_level.
 */
================================================================================

文件路径: ./isl_tab_pip.c
注释行数: 36
注释内容:
/* Return the lexicographically smallest non-trivial solution of the
 * given ILP problem.
 *
 * All variables are assumed to be non-negative.
 *
 * n_op is the number of initial coordinates to optimize.
 * That is, once a solution has been found, we will only continue looking
 * for solutions that result in significantly better values for those
 * initial coordinates.  That is, we only continue looking for solutions
 * that increase the number of initial zeros in this sequence.
 *
 * A solution is non-trivial, if it is non-trivial on each of the
 * specified regions.  Each region represents a sequence of
 * triviality directions on a sequence of variables that starts
 * at a given position.  A solution is non-trivial on such a region if
 * at least one of the triviality directions is non-zero
 * on that sequence of variables.
 *
 * Whenever a conflict is encountered, all constraints involved are
 * reported to the caller through a call to "conflict".
 *
 * We perform a simple branch-and-bound backtracking search.
 * Each level in the search represents an initially trivial region
 * that is forced to be non-trivial.
 * At each level we consider 2 * n cases, where n
 * is the number of triviality directions.
 * In terms of those n directions v_i, we consider the cases
 *	v_0 >= 1
 *	v_0 <= -1
 *	v_0 = 0 and v_1 >= 1
 *	v_0 = 0 and v_1 <= -1
 *	v_0 = 0 and v_1 = 0 and v_2 >= 1
 *	v_0 = 0 and v_1 = 0 and v_2 <= -1
 *	...
 * in this order.
 */
================================================================================

文件路径: ./isl_tab_pip.c
注释行数: 17
注释内容:
/* Given a set of upper bounds on the last "input" variable m,
 * construct a piecewise affine expression that selects
 * the minimal upper bound to m, i.e.,
 * divide the space into cells where one
 * of the upper bounds is smaller than all the others and select
 * this upper bound on that cell.
 *
 * In particular, if there are n bounds b_i, then the result
 * consists of n cell, each one of the form
 *
 *	b_i <= b_j	for j > i
 *	b_i <  b_j	for j < i
 *
 * The affine expression on this cell is
 *
 *	b_i
 */
================================================================================

文件路径: ./isl_tab_pip.c
注释行数: 12
注释内容:
/* Given a piecewise multi-affine expression of which the last input variable
 * is the minimum of the bounds in "cst", plug in the value of the minimum.
 * This minimum expression is given in "min_expr_pa".
 * The set "min_expr" contains the same information, but in the form of a set.
 * The variable is subsequently projected out.
 *
 * The implementation is similar to those of "split" and "split_domain".
 * If the variable appears in a given expression, then minimum expression
 * is plugged in.  Otherwise, if the variable appears in the constraints
 * and a split is required, then the domain is split.  Otherwise, no split
 * is performed.
 */
================================================================================

文件路径: ./isl_convex_hull.c
注释行数: 11
注释内容:
/*
 * Copyright 2008-2009 Katholieke Universiteit Leuven
 * Copyright 2014      INRIA Rocquencourt
 *
 * Use of this software is governed by the MIT license
 *
 * Written by Sven Verdoolaege, K.U.Leuven, Departement
 * Computerwetenschappen, Celestijnenlaan 200A, B-3001 Leuven, Belgium
 * and Inria Paris - Rocquencourt, Domaine de Voluceau - Rocquencourt,
 * B.P. 105 - 78153 Le Chesnay, France
 */
================================================================================

文件路径: ./isl_convex_hull.c
注释行数: 18
注释内容:
/* Remove redundant
 * constraints.  If the minimal value along the normal of a constraint
 * is the same if the constraint is removed, then the constraint is redundant.
 *
 * Since some constraints may be mutually redundant, sort the constraints
 * first such that constraints that involve existentially quantified
 * variables are considered for removal before those that do not.
 * The sorting is also needed for the use in map_simple_hull.
 *
 * Note that isl_tab_detect_implicit_equalities may also end up
 * marking some constraints as redundant.  Make sure the constraints
 * are preserved and undo those marking such that isl_tab_detect_redundant
 * can consider the constraints in the sorted order.
 *
 * Alternatively, we could have intersected the basic map with the
 * corresponding equality and then checked if the dimension was that
 * of a facet.
 */
================================================================================

文件路径: ./isl_convex_hull.c
注释行数: 17
注释内容:
/* Given a union of basic sets, construct the constraints for wrapping
 * a facet around one of its ridges.
 * In particular, if each of n the d-dimensional basic sets i in "set"
 * contains the origin, satisfies the constraints x_1 >= 0 and x_2 >= 0
 * and is defined by the constraints
 *				    [ 1 ]
 *				A_i [ x ]  >= 0
 *
 * then the resulting set is of dimension n*(1+d) and has as constraints
 *
 *				    [ a_i ]
 *				A_i [ x_i ] >= 0
 *
 *				      a_i   >= 0
 *
 *			\sum_i x_{i,1} = 1
 */
================================================================================

文件路径: ./isl_convex_hull.c
注释行数: 57
注释内容:
/* Given a facet "facet" of the convex hull of "set" and a facet "ridge"
 * of that facet, compute the other facet of the convex hull that contains
 * the ridge.
 *
 * We first transform the set such that the facet constraint becomes
 *
 *			x_1 >= 0
 *
 * I.e., the facet lies in
 *
 *			x_1 = 0
 *
 * and on that facet, the constraint that defines the ridge is
 *
 *			x_2 >= 0
 *
 * (This transformation is not strictly needed, all that is needed is
 * that the ridge contains the origin.)
 *
 * Since the ridge contains the origin, the cone of the convex hull
 * will be of the form
 *
 *			x_1 >= 0
 *			x_2 >= a x_1
 *
 * with this second constraint defining the new facet.
 * The constant a is obtained by settting x_1 in the cone of the
 * convex hull to 1 and minimizing x_2.
 * Now, each element in the cone of the convex hull is the sum
 * of elements in the cones of the basic sets.
 * If a_i is the dilation factor of basic set i, then the problem
 * we need to solve is
 *
 *			min \sum_i x_{i,2}
 *			st
 *				\sum_i x_{i,1} = 1
 *				    a_i   >= 0
 *				  [ a_i ]
 *				A [ x_i ] >= 0
 *
 * with
 *				    [  1  ]
 *				A_i [ x_i ] >= 0
 *
 * the constraints of each (transformed) basic set.
 * If a = n/d, then the constraint defining the new facet (in the transformed
 * space) is
 *
 *			-n x_1 + d x_2 >= 0
 *
 * In the original space, we need to take the same combination of the
 * corresponding constraints "facet" and "ridge".
 *
 * If a = -infty = "-1/0", then we just return the original facet constraint.
 * This means that the facet is unbounded, but has a bounded intersection
 * with the union of sets.
 */
================================================================================

文件路径: ./isl_convex_hull.c
注释行数: 13
注释内容:
/* Compute the constraint of a facet of "set".
 *
 * We first compute the intersection with a bounding constraint
 * that is orthogonal to one of the coordinate axes.
 * If the affine hull of this intersection has only one equality,
 * we have found a facet.
 * Otherwise, we wrap the current bounding constraint around
 * one of the equalities of the face (one that is not equal to
 * the current bounding constraint).
 * This process continues until we have found a facet.
 * The dimension of the intersection increases by at least
 * one on each iteration, so termination is guaranteed.
 */
================================================================================

文件路径: ./isl_convex_hull.c
注释行数: 39
注释内容:
/* Given the bounding constraint "c" of a facet of the convex hull of "set",
 * compute a hyperplane description of the facet, i.e., compute the facets
 * of the facet.
 *
 * We compute an affine transformation that transforms the constraint
 *
 *			  [ 1 ]
 *			c [ x ] = 0
 *
 * to the constraint
 *
 *			   z_1  = 0
 *
 * by computing the right inverse U of a matrix that starts with the rows
 *
 *			[ 1 0 ]
 *			[  c  ]
 *
 * Then
 *			[ 1 ]     [ 1 ]
 *			[ x ] = U [ z ]
 * and
 *			[ 1 ]     [ 1 ]
 *			[ z ] = Q [ x ]
 *
 * with Q = U^{-1}
 * Since z_1 is zero, we can drop this variable as well as the corresponding
 * column of U to obtain
 *
 *			[ 1 ]      [ 1  ]
 *			[ x ] = U' [ z' ]
 * and
 *			[ 1  ]      [ 1 ]
 *			[ z' ] = Q' [ x ]
 *
 * with Q' equal to Q, but without the corresponding row.
 * After computing the facets of the facet in the z' space,
 * we convert them back to the x space through Q.
 */
================================================================================

文件路径: ./isl_convex_hull.c
注释行数: 21
注释内容:
/* Given an initial facet constraint, compute the remaining facets.
 * We do this by running through all facets found so far and computing
 * the adjacent facets through wrapping, adding those facets that we
 * hadn't already found before.
 *
 * For each facet we have found so far, we first compute its facets
 * in the resulting convex hull.  That is, we compute the ridges
 * of the resulting convex hull contained in the facet.
 * We also compute the corresponding facet in the current approximation
 * of the convex hull.  There is no need to wrap around the ridges
 * in this facet since that would result in a facet that is already
 * present in the current approximation.
 *
 * This function can still be significantly optimized by checking which of
 * the facets of the basic sets are also facets of the convex hull and
 * using all the facets so far to help in constructing the facets of the
 * facets
 * and/or
 * using the technique in section "3.1 Ridge Generation" of
 * "Extended Convex Hull" by Fukuda et al.
 */
================================================================================

文件路径: ./isl_convex_hull.c
注释行数: 20
注释内容:
/* Given a set and a linear space "lin" of dimension n > 0,
 * project the linear space from the set, compute the convex hull
 * and then map the set back to the original space.
 *
 * Let
 *
 *	M x = 0
 *
 * describe the linear space.  We first compute the Hermite normal
 * form H = M U of M = H Q, to obtain
 *
 *	H Q x = 0
 *
 * The last n rows of H will be zero, so the last n variables of x' = Q x
 * are the one we want to project out.  We do this by transforming each
 * basic set A x >= b to A U x' >= b and then removing the last n dimensions.
 * After computing the convex hull in x'_1, i.e., A' x'_1 >= b',
 * we transform the hull back to the original space as A' Q_1 x >= b',
 * with Q_1 all but the last n rows of Q.
 */
================================================================================

文件路径: ./isl_convex_hull.c
注释行数: 20
注释内容:
/* Compute a vector s in the homogeneous space such that <s, r> > 0
 * for all rays in the homogeneous space of the two cones that correspond
 * to the input polyhedra bset1 and bset2.
 *
 * We compute s as a vector that satisfies
 *
 *	s = \sum_j \alpha_{ij} h_{ij}	for i = 1,2			(*)
 *
 * with h_{ij} the normals of the facets of polyhedron i
 * (including the "positivity constraint" 1 >= 0) and \alpha_{ij}
 * strictly positive numbers.  For simplicity we impose \alpha_{ij} >= 1.
 * We first set up an LP with as variables the \alpha{ij}.
 * In this formulation, for each polyhedron i,
 * the first constraint is the positivity constraint, followed by pairs
 * of variables for the equalities, followed by variables for the inequalities.
 * We then simply pick a feasible solution and compute s using (*).
 *
 * Note that we simply pick any valid direction and make no attempt
 * to pick a "good" or even the "best" valid direction.
 */
================================================================================

文件路径: ./isl_convex_hull.c
注释行数: 59
注释内容:
/* Compute the convex hull of a pair of basic sets without any parameters or
 * integer divisions, where the convex hull is known to be pointed,
 * but the basic sets may be unbounded.
 *
 * We turn this problem into the computation of a convex hull of a pair
 * _bounded_ polyhedra by "changing the direction of the homogeneous
 * dimension".  This idea is due to Matthias Koeppe.
 *
 * Consider the cones in homogeneous space that correspond to the
 * input polyhedra.  The rays of these cones are also rays of the
 * polyhedra if the coordinate that corresponds to the homogeneous
 * dimension is zero.  That is, if the inner product of the rays
 * with the homogeneous direction is zero.
 * The cones in the homogeneous space can also be considered to
 * correspond to other pairs of polyhedra by chosing a different
 * homogeneous direction.  To ensure that both of these polyhedra
 * are bounded, we need to make sure that all rays of the cones
 * correspond to vertices and not to rays.
 * Let s be a direction such that <s, r> > 0 for all rays r of both cones.
 * Then using s as a homogeneous direction, we obtain a pair of polytopes.
 * The vector s is computed in valid_direction.
 *
 * Note that we need to consider _all_ rays of the cones and not just
 * the rays that correspond to rays in the polyhedra.  If we were to
 * only consider those rays and turn them into vertices, then we
 * may inadvertently turn some vertices into rays.
 *
 * The standard homogeneous direction is the unit vector in the 0th coordinate.
 * We therefore transform the two polyhedra such that the selected
 * direction is mapped onto this standard direction and then proceed
 * with the normal computation.
 * Let S be a non-singular square matrix with s as its first row,
 * then we want to map the polyhedra to the space
 *
 *	[ y' ]     [ y ]		[ y ]          [ y' ]
 *	[ x' ] = S [ x ]	i.e.,	[ x ] = S^{-1} [ x' ]
 *
 * We take S to be the unimodular completion of s to limit the growth
 * of the coefficients in the following computations.
 *
 * Let b_i + A_i x >= 0 be the constraints of polyhedron i.
 * We first move to the homogeneous dimension
 *
 *	b_i y + A_i x >= 0		[ b_i A_i ] [ y ]    [ 0 ]
 *	    y         >= 0	or	[  1   0  ] [ x ] >= [ 0 ]
 *
 * Then we change directoin
 *
 *	[ b_i A_i ]        [ y' ]		              [ y' ]
 *	[  1   0  ] S^{-1} [ x' ] >= 0	or	[ b_i' A_i' ] [ x' ] >= 0
 *
 * Then we compute the convex hull of the polytopes b_i' + A_i' x' >= 0
 * resulting in b' + A' x' >= 0, which we then convert back
 *
 *	            [ y ]		        [ y ]
 *	[ b' A' ] S [ x ] >= 0	or	[ b A ] [ x ] >= 0
 *
 * The polyhedron b + A x >= 0 is then the convex hull of the input polyhedra.
 */
================================================================================

文件路径: ./isl_convex_hull.c
注释行数: 13
注释内容:
/* Compute the convex hull of a pair of basic sets without any parameters or
 * integer divisions.
 *
 * This function is called from uset_convex_hull_unbounded, which
 * means that the complete convex hull is unbounded.  Some pairs
 * of basic sets may still be bounded, though.
 * They may even lie inside a lower dimensional space, in which
 * case they need to be handled inside their affine hull since
 * the main algorithm assumes that the result is full-dimensional.
 *
 * If the convex hull of the two basic sets would have a non-trivial
 * lineality space, we first project out this lineality space.
 */
================================================================================

文件路径: ./isl_convex_hull.c
注释行数: 11
注释内容:
/* Check for inequality constraints of a basic set without equalities
 * or redundant constraints
 * such that the same or more stringent copies of the constraint appear
 * in all of the basic sets.  Such constraints are necessarily facet
 * constraints of the convex hull.
 *
 * If the resulting basic set is by chance identical to one of
 * the basic sets in "set", then we know that this basic set contains
 * all other basic sets and is therefore the convex hull of set.
 * In this case we set *is_hull to 1.
 */
================================================================================

文件路径: ./isl_convex_hull.c
注释行数: 10
注释内容:
/* Check if inequality "ineq" is a bound for basic set "j" or if
 * it can be relaxed (by increasing the constant term) to become
 * a bound for that basic set.  In the latter case, the constant
 * term is updated.
 * Relaxation of the constant term is only allowed if "shift" is set.
 *
 * Return 1 if "ineq" is a bound
 *	  0 if "ineq" may attain arbitrarily small values on basic set "j"
 *	 -1 if some error occurred
 */
================================================================================

文件路径: ./isl_convex_hull.c
注释行数: 13
注释内容:
/* Set the constant term of "ineq" to the maximum of those of the constraints
 * in the basic sets of "set" following "i" that are parallel to "ineq".
 * That is, if any of the basic sets of "set" following "i" have a more
 * relaxed copy of "ineq", then replace "ineq" by the most relaxed copy.
 * "c_hash" is the hash value of the linear part of "ineq".
 * "v" has been set up for use by has_ineq.
 *
 * Note that the two inequality constraints corresponding to an equality are
 * represented by the same inequality constraint in data->p[j].table
 * (but with different hash values).  This means the constraint (or at
 * least its constant term) may need to be temporarily negated to get
 * the actually hashed constraint.
 */
================================================================================

文件路径: ./isl_convex_hull.c
注释行数: 21
注释内容:
/* Check if inequality "ineq" from basic set "i" is or can be relaxed to
 * become a bound on the whole set.  If so, add the (relaxed) inequality
 * to "hull".  Relaxation is only allowed if "shift" is set.
 *
 * We first check if "hull" already contains a translate of the inequality.
 * If so, we are done.
 * Then, we check if any of the previous basic sets contains a translate
 * of the inequality.  If so, then we have already considered this
 * inequality and we are done.
 * Otherwise, for each basic set other than "i", we check if the inequality
 * is a bound on the basic set, but first replace the constant term
 * by the maximal value of any translate of the inequality in any
 * of the following basic sets.
 * For previous basic sets, we know that they do not contain a translate
 * of the inequality, so we directly call is_bound.
 * For following basic sets, we first check if a translate of the
 * inequality appears in its description.  If so, the constant term
 * of the inequality has already been updated with respect to this
 * translate and the inequality is therefore known to be a bound
 * of this basic set.
 */
================================================================================

文件路径: ./isl_convex_hull.c
注释行数: 19
注释内容:
/* Compute a superset of the convex hull of map that is described
 * by only (translates of) the constraints in the constituents of map.
 * Translation is only allowed if "shift" is set.
 *
 * The constraints are sorted while removing redundant constraints
 * in order to indicate a preference of which constraints should
 * be preserved.  In particular, pairs of constraints that are
 * sorted together are preferred to either both be preserved
 * or both be removed.  The sorting is performed inside
 * isl_basic_map_remove_redundancies.
 *
 * The result of the computation is stored in map->cached_simple_hull[shift]
 * such that it can be reused in subsequent calls.  The cache is cleared
 * whenever the map is modified (in isl_map_cow).
 * Note that the results need to be stored in the input map for there
 * to be any chance that they may get reused.  In particular, they
 * are stored in a copy of the input map that is saved before
 * the integer division alignment.
 */
================================================================================

文件路径: ./isl_convex_hull.c
注释行数: 16
注释内容:
/* Drop all inequalities from "bmap1" that do not also appear in "bmap2".
 * A constraint that appears with different constant terms
 * in "bmap1" and "bmap2" is also kept, with the least restrictive
 * (i.e., greatest) constant term.
 * "bmap1" and "bmap2" are assumed to have the same (known)
 * integer divisions.
 * The constraints of both "bmap1" and "bmap2" are assumed
 * to have been sorted using isl_basic_map_sort_constraints.
 *
 * Run through the inequality constraints of "bmap1" and "bmap2"
 * in sorted order.
 * Each constraint of "bmap1" without a matching constraint in "bmap2"
 * is removed.
 * If a match is found, the constraint is kept.  If needed, the constant
 * term of the constraint is adjusted.
 */
================================================================================

文件路径: ./isl_convex_hull.c
注释行数: 10
注释内容:
/* Compute a superset of "bmap1" and "bmap2" that is described
 * by only the constraints that appear in both "bmap1" and "bmap2".
 *
 * First drop constraints that involve unknown integer divisions
 * since it is not trivial to check whether two such integer divisions
 * in different basic maps are the same.
 * Then align the remaining (known) divs and sort the constraints.
 * Finally drop all inequalities and equalities from "bmap1" that
 * do not also appear in "bmap2".
 */
================================================================================

文件路径: ./isl_convex_hull.c
注释行数: 12
注释内容:
/* Compute a superset of the convex hull of "map" that is described
 * by only the constraints in the constituents of "map".
 * In particular, the result is composed of constraints that appear
 * in each of the basic maps of "map"
 *
 * Constraints that involve unknown integer divisions are dropped
 * since it is not trivial to check whether two such integer divisions
 * in different basic maps are the same.
 *
 * The hull is initialized from the first basic map and then
 * updated with respect to the other basic maps in turn.
 */
================================================================================

文件路径: ./isl_convex_hull.c
注释行数: 18
注释内容:
/* Compute a superset of the convex hull of "set" that is described
 * by only some of the "n_ineq" constraints in the list "ineq", where "set"
 * has no parameters or integer divisions.
 *
 * The inequalities in "ineq" are assumed to have been sorted such
 * that constraints with the same linear part appear together and
 * that among constraints with the same linear part, those with
 * smaller constant term appear first.
 *
 * We reuse the same data structure that is used by uset_simple_hull,
 * but we do not need the hull table since we will not consider the
 * same constraint more than once.  We therefore allocate it with zero size.
 *
 * We run through the constraints and try to add them one by one,
 * skipping identical constraints.  If we have added a constraint and
 * the next constraint is a more relaxed translate, then we skip this
 * next constraint as well.
 */
================================================================================

文件路径: ./isl_convex_hull.c
注释行数: 11
注释内容:
/* Compute a superset of the convex hull of "map" that is described
 * by only constraints in the elements of "list".
 *
 * If the list is empty, then we can only describe the universe set.
 * If the input map is empty, then all constraints are valid, so
 * we return the intersection of the elements in "list".
 *
 * Otherwise, we align all divs and temporarily treat them
 * as regular variables, computing the unshifted simple hull in
 * uset_unshifted_simple_hull_from_basic_set_list.
 */
================================================================================
